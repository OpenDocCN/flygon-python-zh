- en: Networking with QtNetwork
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QtNetwork进行网络连接
- en: Humans are social creatures and, increasingly, so are the software systems we
    create. As useful as computers are on their own, they are far more useful when
    connected to other computers. Whether on a small local switch or the global internet,
    engaging with other systems over a network is crucial functionality for much modern
    software. In this chapter, we're going to explore the networking capabilities
    offered by Qt and how to use them within PyQt5.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人类是社会性动物，越来越多的软件系统也是如此。尽管计算机本身很有用，但与其他计算机连接后，它们的用途要大得多。无论是在小型本地交换机还是全球互联网上，通过网络与其他系统进行交互对于大多数现代软件来说都是至关重要的功能。在本章中，我们将探讨Qt提供的网络功能以及如何在PyQt5中使用它们。
- en: 'In particular, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Low-level networking with sockets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用套接字进行低级网络连接
- en: HTTP communications with `QNetworkAccessManager`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QNetworkAccessManager`进行HTTP通信
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will, as in other chapters, need a basic Python and PyQt5 setup as described
    in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started with
    PyQt*, and you will benefit from downloading the example code from our GitHub
    repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter08).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节一样，您需要一个基本的Python和PyQt5设置，如[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中所述，并且您将受益于从我们的GitHub存储库下载示例代码[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter08)。
- en: In addition, you will want access to at least one other Python-equipped computer
    on the same local area network.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将希望至少有另一台装有Python的计算机连接到同一局域网。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xqid](http://bit.ly/2M5xqid)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[http://bit.ly/2M5xqid](http://bit.ly/2M5xqid)
- en: Low-level networking with sockets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字进行低级网络连接
- en: Nearly every modern network uses the **internet protocol suite**, also known
    as **TCP/IP**, to facilitate connections between computers or other devices. TCP/IP
    is a set of protocols that manage the transmission of raw data over the network.
    The most common way to work with TCP/IP directly in code is with a **socket API**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个现代网络都使用**互联网协议套件**，也称为**TCP/IP**，来促进计算机或其他设备之间的连接。TCP/IP是一组管理网络上原始数据传输的协议。直接在代码中使用TCP/IP最常见的方法是使用**套接字API**。
- en: A socket is a file-like object that represents a single point of network connectivity
    for the system. Every socket has a **host address**, **network port**, and **transmission
    protocol**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是一个类似文件的对象，代表系统的网络连接点。每个套接字都有一个**主机地址**，**网络端口**和**传输协议**。
- en: 'The host address, also known as an **IP address**, is a set of numbers used
    to identify a single network host on a network. Although backbone systems rely
    on the IPv6 protocol, most personal computers still use the older IPv4 address,
    which consists of four numbers between `0` and `255` separated by a dot. You can
    find the address of your system using GUI tools, or by typing one of the following
    commands into a command-line terminal:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主机地址，也称为**IP地址**，是用于在网络上标识单个网络主机的一组数字。尽管骨干系统依赖IPv6协议，但大多数个人计算机仍使用较旧的IPv4地址，该地址由点分隔的四个介于`0`和`255`之间的数字组成。您可以使用GUI工具找到系统的地址，或者通过在命令行终端中键入以下命令之一来找到地址：
- en: '| OS | Command |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| OS | Command |'
- en: '| --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Windows | `ipconfig` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Windows | `ipconfig` | '
- en: '| macOS | `ifconfig` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| macOS | `ifconfig` |'
- en: '| Linux | `ip address` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Linux | `ip address` | '
- en: Port is simply a number from `0` to `65535`. Although you can create a socket
    with any port number, certain port numbers are assigned to common services; these
    are called **well-known ports**. For example, HTTP servers are typically assigned
    to port `80`, and SSH is typically on port `22`. On many operating systems, administrative
    or root privileges are required to create a socket on ports less than `1024`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 端口只是一个从`0`到`65535`的数字。虽然您可以使用任何端口号创建套接字，但某些端口号分配给常见服务；这些被称为**众所周知的端口**。例如，HTTP服务器通常分配到端口`80`，SSH通常在端口`22`上。在许多操作系统上，需要管理或根权限才能在小于`1024`的端口上创建套接字。
- en: An official list of well-known ports can be found at [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)找到官方的众所周知的端口列表。
- en: Transmission protocols include **Transmission Control Protocol** (**TCP**) and
    **User Datagram Protocol** (**UDP**). TCP is a stateful connection between two
    systems. You can think of it as a phone call—a connection is established, information
    is exchanged, and at some definite point the connection is disconnected. Because
    of its statefulness, TCP ensures that all transmitted packets are received. UDP,
    on the other hand, is a stateless protocol. Think of it like using a walkie-talkie—users
    transmit a message, which receivers may or may not receive in whole or in part,
    and an explicit connection is never established. UDP is comparatively lightweight
    and often used for broadcast messages since it doesn't require a connection to
    a specific host.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 传输协议包括**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。TCP是两个系统之间的有状态连接。您可以将其视为电话呼叫
    - 建立连接，交换信息，并在某个明确的点断开连接。由于其有状态性，TCP确保接收所有传输的数据包。另一方面，UDP是一种无状态协议。将其视为使用对讲机 -
    用户传输消息，接收者可能完整或部分接收，且不会建立明确的连接。UDP相对轻量级，通常用于广播消息，因为它不需要与特定主机建立连接。
- en: The `QtNetwork` module provides us with classes to establish TCP and UDP socket
    connections. To understand how they work, we're going to construct two chat systems—one
    using UDP, the other using TCP.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtNetwork`模块为我们提供了建立TCP和UDP套接字连接的类。为了理解它们的工作原理，我们将构建两个聊天系统 - 一个使用UDP，另一个使用TCP。'
- en: Building a chat GUI
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天 GUI
- en: 'Let''s begin by creating a basic GUI form that we can use for both versions
    of the chat application. Start with the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, and add this class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个基本的 GUI 表单，我们可以在聊天应用的两个版本中使用。从[第 4 章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)的应用程序模板开始，*使用
    QMainWindow 构建应用程序*，然后添加这个类：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The GUI is pretty simple, just a text edit to display the conversation, a line
    edit to enter a message, and a button to send. We've also implemented a signal
    we can emit whenever the user submits a new message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 很简单，只有一个文本编辑器来显示对话，一个行编辑器来输入消息，以及一个发送按钮。我们还实现了一个信号，每当用户提交新消息时就可以发出。
- en: 'The GUI will also have two methods:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 还将有两个方法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `send()` method, triggered by the `send_btn` button, emits our `submitted`
    signal containing the text in the line edit, and the `write_message()` method
    which receives a `username` and `message` and writes it to the text edit using
    some simple formatting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 方法由 `send_btn` 按钮触发，发出包含行编辑中文本的 `submitted` 信号，以及 `write_message()`
    方法，该方法接收 `username` 和 `message` 并使用一些简单的格式将其写入文本编辑器。'
- en: 'Down in the `MainWindow.__init__()` method, add in this code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainWindow.__init__()` 方法中，添加以下代码：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, before we can do any networking code, we need to add an `import` for
    `QtNetwork`. Add it to the top of the file, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们可以进行任何网络编码之前，我们需要为 `QtNetwork` 添加一个 `import`。像这样将其添加到文件的顶部：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code will be the base code for both our UDP and TCP chat applications,
    so save one copy of this file as `udp_chat.py` and another as `tcp_chat.py`. We'll
    complete each application by creating a backend object for the form.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将是我们的 UDP 和 TCP 聊天应用程序的基础代码，所以将这个文件保存为 `udp_chat.py` 的一个副本，另一个副本保存为 `tcp_chat.py`。我们将通过为表单创建一个后端对象来完成每个应用程序。
- en: Building a UDP chat client
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 UDP 聊天客户端
- en: UDP is most commonly used in broadcast applications on local networks, so to
    demonstrate this, we're going to make our UDP chat a local-network-only broadcast
    chat. That means that any computer on a local network running a copy of this application
    will be able to view and participate in the conversation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 最常用于本地网络上的广播应用程序，因此为了演示这一点，我们将使我们的 UDP 聊天成为一个仅限本地网络的广播聊天。这意味着在运行此应用程序副本的本地网络上的任何计算机都将能够查看并参与对话。
- en: 'We''ll start by creating our backend class, which we''ll call `UdpChatInterface`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的后端类，我们将其称为 `UdpChatInterface`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our backend inherits `QObject` so that we can use Qt signals, of which we've
    defined two—a `received` signal that we'll emit when a message is received, and
    an `error` signal that we'll emit when an error happens. We've also defined a
    port number to use, and a `delimiter` string. The `delimiter` string will be used
    to separate the username and message when we serialize our message for transmission;
    so, when the user `alanm` sends the message `Hello World`, our interface will
    send the string `alanm||Hello World` out on the wire.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端继承自 `QObject`，以便我们可以使用 Qt 信号，我们定义了两个信号——一个 `received` 信号，当接收到消息时我们将发出它，一个
    `error` 信号，当发生错误时我们将发出它。我们还定义了一个要使用的端口号和一个 `delimiter` 字符串。当我们序列化消息进行传输时，`delimiter`
    字符串将用于分隔用户名和消息；因此，当用户 `alanm` 发送消息 `Hello World` 时，我们的接口将在网络上发送字符串 `alanm||Hello
    World`。
- en: Only one application can be bound to a port at one time; if you already have
    an application using port `7777`, you should change this number to something else
    between `1024` and `65535`. On Windows, macOS, and older Linux systems, the `netstat`
    command can be used to show which ports are in use. On newer Linux systems, the
    `ss` command can be used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一次只能将一个应用程序绑定到一个端口；如果您已经有一个使用端口 `7777` 的应用程序，您应该将这个数字更改为 `1024` 到 `65535` 之间的其他数字。在
    Windows、macOS 和旧版 Linux 系统上，可以使用 `netstat` 命令来显示正在使用哪些端口。在较新的 Linux 系统上，可以使用 `ss`
    命令。
- en: 'Now start an `__init__()` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个 `__init__()` 方法：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After calling `super()` and storing the `username` variable, our first order
    of business is to create and configure a `QUdpSocket` object. Before we can use
    the socket, it must be **bound** to a localhost address and a port number. `QtNetwork.QHostAddress.Any`
    represents all addresses on the local system so our socket will be listening and
    sending on port `7777` on all local interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `super()` 并存储 `username` 变量后，我们的首要任务是创建和配置一个 `QUdpSocket` 对象。在我们可以使用套接字之前，它必须**绑定**到本地主机地址和端口号。`QtNetwork.QHostAddress.Any`
    表示本地系统上的所有地址，因此我们的套接字将在所有本地接口上监听和发送端口 `7777` 上的数据。
- en: 'To use the socket, we have to handle its signals:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用套接字，我们必须处理它的信号：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Socket objects have two signals that we're interested in watching. The first
    is `readyRead`, and it's emitted whenever data is received by the socket. We're
    going to handle that signal in a method called `process_datagrams()`, which we'll
    write in a moment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Socket 对象有两个我们感兴趣的信号。第一个是 `readyRead`，每当套接字接收到数据时就会发出该信号。我们将在一个名为 `process_datagrams()`
    的方法中处理该信号，我们马上就会写这个方法。
- en: The `error` signal is emitted when there is an error of any kind, which we'll
    handle in an instance method called `on_error()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 信号在发生任何错误时发出，我们将在一个名为 `on_error()` 的实例方法中处理它。'
- en: 'Let''s start with that error handler since it''s relatively simple:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从错误处理程序开始，因为它相对简单：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method has a little bit of Qt magic in it. Network errors are defined in
    the `SocketError` enum of the `QAbstractSocket` class (the parent class of `UdpSocket`).
    Unfortunately, if we just try to print the error, we get the integer value of
    the constant. To actually get a meaningful string, we're going to dig into the
    `staticMetaObject` associated with `QAbstractSocket`. We first get the index of
    the enum class containing the error constants, then use `valueToKey()` to convert
    our socket error integer into its constant name. This trick can be used with any
    Qt enum to retrieve a meaningful name rather than just its integer value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在其中有一点Qt的魔力。网络错误在`QAbstractSocket`类（`UdpSocket`的父类）的`SocketError`枚举中定义。不幸的是，如果我们只是尝试打印错误，我们会得到常量的整数值。要实际获得有意义的字符串，我们将深入与`QAbstractSocket`关联的`staticMetaObject`。我们首先获取包含错误常量的枚举类的索引，然后使用`valueToKey()`将我们的套接字错误整数转换为其常量名称。这个技巧可以用于任何Qt枚举，以检索有意义的名称而不仅仅是它的整数值。
- en: One that's been retrieved, we simply format the error in a message and emit
    it in our `error` signal.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦被检索，我们只需将错误格式化为消息并在我们的`error`信号中发出。
- en: 'Now let''s tackle `process_datagrams()`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来解决`process_datagrams()`：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A single UDP transmission is known as a **datagram**. When a datagram is received
    by our socket, it is stored in a buffer and the `readyRead` signal is emitted.
    As long as that buffer has datagrams waiting, the socket's `hasPendingDatagrams()`
    will return `True`. Thus, we loop continually while there are pending datagrams,
    calling the socket's `receiveDatagram()` method, which returns and removes the
    next datagram waiting in the buffer until all the datagrams are retrieved.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单个UDP传输被称为**数据报**。当我们的套接字接收到数据报时，它被存储在缓冲区中，并发出`readyRead`信号。只要该缓冲区有等待的数据报，套接字的`hasPendingDatagrams()`将返回`True`。因此，只要有待处理的数据报，我们就会循环调用套接字的`receiveDatagram()`方法，该方法返回并移除缓冲区中等待的下一个数据报，直到检索到所有数据报为止。
- en: The datagram object returned by `receiveDatagram()` is a `QByteArray`, the Qt
    equivalent of a Python `bytes` object. Since our program is transmitting strings,
    rather than binary objects, we can just convert the `QByteArray` to a Unicode
    string. The fastest way to do this is to first cast it to a `bytes` object, then
    use the `decode()` method to convert it to UTF-8 Unicode text.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiveDatagram()`返回的数据报对象是`QByteArray`，相当于Python的`bytes`对象。由于我们的程序传输的是字符串，而不是二进制对象，我们可以将`QByteArray`直接转换为Unicode字符串。这样做的最快方法是首先将其转换为`bytes`对象，然后使用`decode()`方法将其转换为UTF-8
    Unicode文本。'
- en: 'Now that we have our raw string, we need to check it to make sure it came from
    another instance of `udp_chat.py`, then split it out into its `username` and `message`
    components:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了原始字符串，我们需要检查它以确保它来自`udp_chat.py`的另一个实例，然后将其拆分成`username`和`message`组件：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the raw text received by the socket doesn't contain our `delimiter` string,
    it's most likely from some other program or a corrupt packet, and we'll just skip
    it. Otherwise, we'll split it at the first instance of the `delimiter` into the
    `username` and `message` strings, then emit those strings with the `received`
    signal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字接收到的原始文本不包含我们的`delimiter`字符串，那么它很可能来自其他程序或损坏的数据包，我们将跳过它。否则，我们将在第一个`delimiter`的实例处将其拆分为`username`和`message`字符串，然后发出这些字符串与`received`信号。
- en: 'The final thing our chat client needs is a method to send a message, which
    we''ll implement in the `send_message()` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天客户端需要的最后一件事是发送消息的方法，我们将在`send_message()`方法中实现：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method starts by formatting the passed message with our configured username
    using the `delimiter` string, then encodes the formatted string as a `bytes` object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法首先通过使用`delimiter`字符串格式化传递的消息与我们配置的用户名，然后将格式化的字符串编码为`bytes`对象。
- en: Next, we write the datagram to our socket object using the `writeDatagram()`
    method. This method takes a `QByteArray` (to which we have cast our `bytes` object)
    and a destination address and port. Our destination is specified as `QHostAddress.Broadcast`,
    which indicates that we want to use the broadcast address, and the port is, of
    course, the one we defined in our class variable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`writeDatagram()`方法将数据报写入我们的套接字对象。这个方法接受一个`QByteArray`（我们已经将我们的`bytes`对象转换为它）和一个目标地址和端口。我们的目的地被指定为`QHostAddress.Broadcast`，这表示我们要使用广播地址，端口当然是我们在类变量中定义的端口。
- en: The **broadcast address** is a reserved address on a TCP/IP network which, when
    used, indicates that the transmission should be received by all hosts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播地址**是TCP/IP网络上的保留地址，当使用时，表示传输应该被所有主机接收。'
- en: 'Let''s summarize what we''ve done in this backend:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们在这个后端中所做的事情：
- en: When a message is sent, it is prefixed with the username and broadcast as a
    byte array to all hosts on the network on port `7777`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送消息时，消息将以用户名为前缀，并作为字节数组广播到网络上的所有主机的端口`7777`。
- en: When a message is received on port `7777`, it is converted from a byte array
    to a string. The message and username are split and emitted in a signal.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在端口`7777`上接收到消息时，它将从字节数组转换为字符串。消息和用户名被拆分并发出信号。
- en: When an error occurs, the error number is converted to an error string and emitted
    with an error signal.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生错误时，错误号将被转换为错误字符串，并与错误信号一起发出。
- en: Now we just need to hook our backend into the frontend form.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将我们的后端连接到前端表单。
- en: Connecting signals
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接信号
- en: 'Back in our `MainWindow` constructor, we need to finish up our application
    by creating a `UdpChatInterface` object and connecting its signals:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`MainWindow`构造函数，我们需要通过创建一个`UdpChatInterface`对象并连接其信号来完成我们的应用程序：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before creating the interface, we're determining the `username` by grabbing
    the name of the current user's home directory. This is a bit of a hack, but it
    works well enough for our purposes here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建界面之前，我们通过获取当前用户的主目录名称来确定`username`。这有点像黑客，但对我们的目的来说足够好了。
- en: Next, we create our interface object and connect the chat window `submitted`
    signal to its `send_message()` slot.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的接口对象，并将聊天窗口的`submitted`信号连接到其`send_message()`槽。
- en: We then connect the interface's `received` signal to the chat window's `write_message()`
    method, and the `error` signal to a lambda function that shows the error in a
    `QMessageBox`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将接口的`received`信号连接到聊天窗口的`write_message()`方法，将`error`信号连接到一个lambda函数，用于在`QMessageBox`中显示错误。
- en: With everything wired up, we're ready to test.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都连接好了，我们准备好测试了。
- en: Testing the chat
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试聊天
- en: To test this chat system, you'll need two computers with Python and PyQt5 installed
    running on the same local area network. You may need to disable the systems' firewalls
    or open UPD port `7777` before proceeding.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个聊天系统，您需要两台安装了Python和PyQt5的计算机，运行在同一个局域网上。在继续之前，您可能需要禁用系统的防火墙或打开UDP端口`7777`。
- en: 'Once you''ve done that, copy `udp_chat.py` to both machines and launch it.
    Type a message on one machine; it should show up in the chat window on both machines,
    looking something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将`udp_chat.py`复制到两台计算机上并启动它。在一台计算机上输入一条消息；它应该会显示在两台计算机的聊天窗口中，看起来像这样：
- en: '![](assets/152c38db-31b6-4c6a-b19e-beea931a4787.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/152c38db-31b6-4c6a-b19e-beea931a4787.png)'
- en: Notice that the systems also pick up and react to their own broadcast messages,
    so we don't need to worry about echoing our own messages in the text area.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，系统也会接收并对自己的广播消息做出反应，因此我们不需要担心在文本区域中回显自己的消息。
- en: UDP is certainly simple to work with, but it has many limitations. For example,
    UDP broadcasts cannot usually be routed outside a local network, and the lack
    of stateful connection means that there is no way to know whether a transmission
    was received or lost. In the *Building a TCP chat client* section, we'll build
    a TCP version of our chat that doesn't have these issues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: UDP确实很容易使用，但它有许多限制。例如，UDP广播通常无法路由到本地网络之外，而且无状态连接的缺失意味着无法知道传输是否已接收或丢失。在*构建TCP聊天客户端*部分，我们将构建一个没有这些问题的聊天TCP版本。
- en: Building a TCP chat client
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建TCP聊天客户端
- en: TCP is a stateful transmission protocol, meaning that a connection is established
    and maintained until the transmission is complete. TCP is also primarily a one-to-one
    connection between hosts, which we generally implement using a **client-server**
    design. Our TCP chat application will make a direct connection between two network
    hosts and will contain both a client component that will connect to other instances
    of the app and a server component that will handle incoming client connections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是一种有状态的传输协议，这意味着建立并维护连接直到传输完成。TCP也主要是一对一的主机连接，我们通常使用**客户端-服务器**设计来实现。我们的TCP聊天应用程序将在两个网络主机之间建立直接连接，并包含一个客户端组件，用于连接应用程序的其他实例，以及一个服务器组件，用于处理传入的客户端连接。
- en: 'In the `tcp_chat.py` file you created earlier, start a TCP chat interface class
    like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在您之前创建的`tcp_chat.py`文件中，像这样启动一个TCP聊天接口类：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So far, this is identical to the UDP interface apart from the name. Now let''s
    create the constructor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这与UDP接口完全相同，除了名称。现在让我们创建构造函数：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As before, the interface object takes a `username`, but we've added a `recipient`
    argument as well. Since TCP requires a direct connection to another host, we need
    to specify which remote host we want to connect to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，接口对象需要一个`username`，但我们还添加了一个`recipient`参数。由于TCP需要与另一个主机建立直接连接，我们需要指定要连接的远程主机。
- en: 'Now we need to create the server component that will listen for incoming connections:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建服务器组件，用于监听传入的连接：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`listener` is a `QTcpServer` object. `QTcpServer` enables our interface to
    receive incoming connections from TCP clients on the given interface and port,
    which in this case we''ve set to any local interface on port `7777`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`listener`是一个`QTcpServer`对象。`QTcpServer`使我们的接口能够在给定接口和端口上接收来自TCP客户端的传入连接，这里我们将其设置为端口`7777`上的任何本地接口。'
- en: When there is an error with an incoming connection, the server object emits
    an `acceptError` signal, which we connect to an `on_error()` method. These are
    the same kind of errors that `UdpSocket` emits, so we can copy the `on_error()`
    method from `udp_chat.py` and handle them identically.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当有传入连接出现错误时，服务器对象会发出一个`acceptError`信号，我们将其连接到一个`on_error()`方法。这些是`UdpSocket`发出的相同类型的错误，因此我们可以从`udp_chat.py`中复制`on_error()`方法并以相同的方式处理它们。
- en: 'The `newConnection` signal is emitted whenever a new connection comes into
    the server; we''re going to handle that in a method called `on_connection()`,
    which looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有新连接进入服务器时，都会发出`newConnection`信号；我们将在一个名为`on_connection()`的方法中处理这个信号，它看起来像这样：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The server's `nextPendingConnection()` method returns the next waiting connection
    as a `QTcpSocket` object. Like `QUdpSocket`, `QTcpSocket` emits a `readyRead`
    signal when it receives data. We'll connect this signal to a `process_datastream()`
    method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的`nextPendingConnection()`方法返回一个`QTcpSocket`对象作为下一个等待连接。像`QUdpSocket`一样，`QTcpSocket`在接收数据时会发出`readyRead`信号。我们将把这个信号连接到一个`process_datastream()`方法。
- en: Finally, we'll save a reference to our new connection in the `self.connections`
    list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`self.connections`列表中保存对新连接的引用。
- en: Working with data streams
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据流
- en: While UDP sockets work with datagrams, TCP sockets work with **data streams**.
    As the name implies, data streams involve a flow of data rather than discrete
    units. TCP transmissions are sent as a stream of network packets that may or may
    not arrive in the correct order, and it's up to the receiver to correctly reassemble
    the data received. To make this process easier, we can wrap our socket in a `QtCore.QDataStream`
    object, which provides a generic interface for reading and writing data from file-like
    sources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UDP套接字使用数据报，但TCP套接字使用**数据流**。顾名思义，数据流涉及数据的流动而不是离散的单元。TCP传输被发送为一系列网络数据包，这些数据包可能按照正确的顺序到达，也可能不会，接收方需要正确地重新组装接收到的数据。为了使这个过程更容易，我们可以将套接字包装在一个`QtCore.QDataStream`对象中，它提供了一个从类似文件的源读取和写入数据的通用接口。
- en: 'Let''s begin our method like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像这样开始我们的方法：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We're iterating through the connected sockets and passing each to a `QDataStream`
    object. The `socket` object has a `bytesAvailable()` method that tells us how
    many bytes of data are queued up to be read. If this number is zero, we're going
    to continue to the next connection in the list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遍历连接的套接字，并将每个传递给`QDataStream`对象。`socket`对象有一个`bytesAvailable()`方法，告诉我们有多少字节的数据排队等待读取。如果这个数字为零，我们将继续到列表中的下一个连接。
- en: 'If not, we''ll read from the data stream:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，我们将从数据流中读取：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`QDataStream.readQString()` attempts to pull a string from the data stream
    and return it. Despite the name, in PyQt5 this method actually returns a Python
    Unicode string, not a `QString`. It''s important to understand that this method
    *only* works if a `QString` was sent with the original packet. If some other object
    was sent (a raw byte string, an integer, and so on), `readQString()` will return
    `None`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream.readQString()`尝试从数据流中提取一个字符串并返回它。尽管名称如此，在PyQt5中，这个方法实际上返回一个Python
    Unicode字符串，而不是`QString`。重要的是要理解，这个方法*只有*在原始数据包中发送了`QString`时才起作用。如果发送了其他对象（原始字节字符串、整数等），`readQString()`将返回`None`。'
- en: The `QDataStream` has methods for writing and reading a variety of data types.
    See its documentation at [https://doc.qt.io/qt-5/qdatastream.html](https://doc.qt.io/qt-5/qdatastream.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream`有用于写入和读取各种数据类型的方法。请参阅其文档[https://doc.qt.io/qt-5/qdatastream.html](https://doc.qt.io/qt-5/qdatastream.html)。'
- en: Once we have the transmission as a string, we check for the `delimiter` string
    in the raw message and, if found, split the raw message and emit the `received`
    signal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将传输作为字符串，我们将检查原始消息中的`delimiter`字符串，并且如果找到，拆分原始消息并发出`received`信号。
- en: Sending data over TCP
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过TCP发送数据
- en: '`QTcpServer` has handled the reception of messages; now we need to implement
    sending messages. To do this, we first need to create a `QTcpSocket` object to
    be our client socket.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTcpServer`已经处理了消息的接收；现在我们需要实现发送消息。为此，我们首先需要创建一个`QTcpSocket`对象作为我们的客户端套接字。'
- en: 'Let''s add this to the end of `__init__()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到`__init__()`的末尾：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've created a default `QTcpSocket` object and connected its `error` signal
    to our error handling method. Note that we don't need to bind this socket because
    it won't be listening.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个默认的`QTcpSocket`对象，并将其`error`信号连接到我们的错误处理方法。请注意，我们不需要绑定此套接字，因为它不会监听。
- en: 'To use the client socket, we''ll create a `send_message()` method; just as
    with our UDP chat, this method will start by formatting the message it into the
    raw transmission string:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用客户端套接字，我们将创建一个`send_message()`方法；就像我们的UDP聊天一样，这个方法将首先将消息格式化为原始传输字符串：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we need to connect to the remote host with which we''re going to communicate:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要连接到要通信的远程主机：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The socket's `state` property can tell us whether our socket is connected to
    a remote host. The `QAbstractSocket.ConnectedState` state indicates that our client
    is connected to a server. If it's not, we call the socket's `connectToHost()`
    method to establish the connection to our recipient host.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字的`state`属性可以告诉我们套接字是否连接到远程主机。`QAbstractSocket.ConnectedState`状态表示我们的客户端已连接到服务器。如果没有，我们调用套接字的`connectToHost()`方法来建立与接收主机的连接。
- en: Now that we can be fairly certain we've connected, let's send the message. To
    do this, we once again turn to the `QDataStream` object to handle the delicate
    aspects of communicating with our TCP socket.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以相当肯定我们已经连接了，让我们发送消息。为了做到这一点，我们再次转向`QDataStream`对象来处理与我们的TCP套接字通信的细节。
- en: 'Begin by creating a new data stream attached to the client socket:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个附加到客户端套接字的新数据流：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can write a string to the data stream using its `writeQString()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`writeQString()`方法向数据流写入字符串：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It''s important to understand that objects can be pulled from the data stream
    only in the order we sent them. For instance, if we wanted to prefix the string
    with its length so that the recipient can check it for corruption, we might do
    this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，对象只能按照我们发送它们的顺序从数据流中提取。例如，如果我们想要在字符串前面加上它的长度，以便接收方可以检查它是否损坏，我们可以这样做：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `process_datastream()` method would then have to be adjusted accordingly:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的`process_datastream()`方法需要相应地进行调整：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last thing we need to do in `send_message()` is emit our message locally
    so that the local display can show it. Since this isn't a broadcast message, our
    local TCP server won't hear the messages being sent out.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`send_message()`中我们需要做的最后一件事是本地发出我们的消息，以便本地显示可以显示它。由于这不是广播消息，我们的本地TCP服务器不会听到发送出去的消息。
- en: 'Add this at the end of `send_message()`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`send_message()`的末尾添加这个：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s summarize how this backend operates:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下这个后端的操作方式：
- en: 'We have a TCP server component:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个TCP服务器组件：
- en: The TCP server object listens for connections from remote hosts on port `7777`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP服务器对象在端口`7777`上监听来自远程主机的连接
- en: When one is received, it stores the connection as a socket and waits for data
    from that socket
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到连接时，它将连接存储为套接字，并等待来自该套接字的数据
- en: When data is received, it is read from the socket using a data stream, interpreted,
    and emitted
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当接收到数据时，它将从套接字中读取数据流，解释并发出
- en: 'We have a TCP client component:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个TCP客户端组件：
- en: When a message needs to be sent, it is first formatted
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要发送消息时，首先对其进行格式化
- en: Then the connection state is checked, and one is established if necessary
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后检查连接状态，如果需要建立连接
- en: Once the connection state is ensured, the message is written to the socket using
    a data stream
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦确保连接状态，消息将被写入套接字使用数据流
- en: Connecting our backend and testing
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接我们的后端并进行测试
- en: 'Back in `MainWindow.__init__()`, we need to add the relevant code to create
    our interface and connect the signals:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`，我们需要添加相关的代码来创建我们的接口并连接信号：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since we need a recipient, we'll ask the user using a `QInputDialog`. This dialog
    class allows you to easily query a user for a single value. In this case, we're
    asking for the IP address or hostname of the other system. This value we pass
    to the `TcpChatInterface` constructor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个接收者，我们将使用`QInputDialog`询问用户。这个对话框类允许您轻松地查询用户的单个值。在这种情况下，我们要求输入另一个系统的IP地址或主机名。这个值我们传递给`TcpChatInterface`构造函数。
- en: The rest of the code is essentially the same as the UDP chat client.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分基本上与UDP聊天客户端相同。
- en: To test this chat client, you'll need to run one copy on another computer on
    the same network or on an address you can reach from your own network. When you
    launch the client, specify the IP or hostname of the other machine. Once both
    clients are running, you should be able to send messages back and forth. If you
    launch the client on a third machine, note that you won't see the messages, since
    they are being directed to a single machine only.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个聊天客户端，您需要在同一网络上的另一台计算机上运行一个副本，或者在您自己的网络中可以访问的地址上运行。当您启动客户端时，请指定另一台计算机的IP或主机名。一旦两个客户端都在运行，您应该能够互发消息。如果您在第三台计算机上启动客户端，请注意您将看不到消息，因为它们只被发送到单台计算机。
- en: HTTP communications with QNetworkAccessManager
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QNetworkAccessManager`进行HTTP通信
- en: '**HyperText Transfer Protocol** (**HTTP**) is the protocol on which the World
    Wide Web is built, and arguably the most important communications protocol of
    our time. We could certainly implement our own HTTP communications on top of sockets,
    but Qt has already done the work for us. The `QNetworkAccessManager` class implements
    an object that can transmit HTTP requests and receive HTTP replies. We can use
    this class to create applications that communicate with web services and APIs.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是构建万维网的协议，也可以说是我们这个时代最重要的通信协议。我们当然可以在套接字上实现自己的HTTP通信，但Qt已经为我们完成了这项工作。`QNetworkAccessManager`类实现了一个可以传输HTTP请求和接收HTTP回复的对象。我们可以使用这个类来创建与Web服务和API通信的应用程序。'
- en: Simple downloading
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单下载
- en: 'To demonstrate the basic use of `QNetworkAccessManager`, we''re going to build
    a simple command-line HTTP download tool. Open a blank file called `downloader.py`
    and let''s start with some imports:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`QNetworkAccessManager`的基本用法，我们将构建一个简单的命令行HTTP下载工具。打开一个名为`downloader.py`的空文件，让我们从一些导入开始：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since we aren't doing a GUI here, we don't need `QtWidgets` or `QtGui`, just
    `QtNetwork`, and `QtCore`. We'll also use the standard library `path` module for
    some filesystem-based operations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们这里不需要`QtWidgets`或`QtGui`，只需要`QtNetwork`和`QtCore`。我们还将使用标准库`path`模块进行一些基于文件系统的操作。
- en: 'Let''s create a `QObject` subclass for our download engine:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的下载引擎创建一个`QObject`子类：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside our download engine, we're creating a `QNetworkAccessManager` and connecting
    its `finished` signal to a callback called `on_finish()`. The `finished` signal
    is emitted when the manager completes a network transaction and has a reply ready
    to process, which it includes with the signal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下载引擎中，我们创建了一个`QNetworkAccessManager`，并将其`finished`信号连接到一个名为`on_finish()`的回调函数。当管理器完成网络事务并准备好处理回复时，它会发出`finished`信号，并将回复包含在信号中。
- en: Next, we create a `QNetworkRequest` object. `QNetworkRequest` represents the
    HTTP request that we're sending to the remote server and contains all the information
    we're going to send. In this case, we just need the URL that has been passed into
    the constructor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`QNetworkRequest`对象。`QNetworkRequest`代表我们发送到远程服务器的HTTP请求，并包含我们要发送的所有信息。在这种情况下，我们只需要构造函数中传入的URL。
- en: Finally, we tell our network manager to execute the request using `get()`. The
    `get()` method sends our request using the HTTP `GET` method, which is typically
    used for requesting information for download. The manager will send this request
    and await a reply.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们告诉我们的网络管理器使用`get()`执行请求。`get()`方法使用HTTP `GET`方法发送我们的请求，通常用于请求下载的信息。管理器将发送这个请求并等待回复。
- en: 'When the reply comes, it will be sent to our `on_finished()` callback:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当回复到来时，它将被发送到我们的`on_finished()`回调函数：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `reply` object here is a `QNetworkReply` instance, which contains the data
    and metadata received from the remote server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`reply`对象是一个`QNetworkReply`实例，其中包含从远程服务器接收的数据和元数据。
- en: We first try to determine a filename, which we'll use for saving the file. The
    reply's `url` property contains the URL to which the original request was made,
    and we can query the URL's `fileName` property. Sometimes this is empty, though,
    so we'll fall back to the `'download'` string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试确定一个文件名，我们将用它来保存文件。回复的`url`属性包含原始请求所发出的URL，我们可以查询URL的`fileName`属性。有时这是空的，所以我们将退而求其次使用`'download'`字符串。
- en: Next, we'll check whether the filename already exists on our system. For safety,
    we exit if it does, so that you don't destroy important files on your system testing
    this demo.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查文件名是否已经存在于我们的系统上。出于安全考虑，如果存在，我们将退出，这样您就不会在测试这个演示时破坏重要文件。
- en: Finally, we extract the data from the reply using its `readAll()` method, writing
    this data to a local file. Notice that we open the file in `wb` mode (write-binary)
    since `readAll()` returns binary data in the form of a `QByteAarray` object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用它的`readAll()`方法从回复中提取数据，并将这些数据写入本地文件。请注意，我们以`wb`模式（写入二进制）打开文件，因为`readAll()`以`QByteAarray`对象的形式返回二进制数据。
- en: 'The main execution code for our `Downloader` class comes last:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Downloader`类的主要执行代码最后出现：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we're just getting the first argument from the command line and passing
    it into our `Downloader` object. Notice that we use `QCoreApplication` rather
    than `QApplication`; this class is used when you want to create a command-line
    Qt application. It's otherwise the same as `QApplication`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是从命令行中获取第一个参数，并将其传递给我们的`Downloader`对象。请注意，我们使用的是`QCoreApplication`而不是`QApplication`；当您想要创建一个命令行Qt应用程序时，可以使用这个类。否则，它与`QApplication`是一样的。
- en: 'In a nutshell, using `QNetworkAccessManager` is as simple as this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用`QNetworkAccessManager`就是这么简单：
- en: Create a `QNetworkAccessManager` object
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`QNetworkAccessManager`对象
- en: Create a `QNetworkRequest` object
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`QNetworkRequest`对象
- en: Pass the request to the manager's `get()` method
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求传递给管理器的`get()`方法
- en: Handle the reply in a callback connected to the manager's `finished` signal
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与管理器的`finished`信号连接的回调中处理回复
- en: Posting data and files
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布数据和文件
- en: Retrieving data with a `GET` request is fairly simple HTTP; for a deeper exploration
    of HTTP communications with PyQt5, we're going to build a utility that will allow
    us to send `POST` requests with arbitrary key-value and file data to a remote
    URL. This utility might be useful for testing web APIs, for example.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`请求检索数据是相当简单的HTTP；为了更深入地探索PyQt5的HTTP通信，我们将构建一个实用程序，允许我们向远程URL发送带有任意键值和文件数据的`POST`请求。例如，这个实用程序可能对测试Web
    API很有用。
- en: Building the GUI
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建GUI
- en: 'Starting with a copy of your Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, let''s add our main GUI code into the
    `MainWindow.__init__()` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)的Qt应用程序模板的副本开始，*使用QMainWindow构建应用程序*，让我们将主要的GUI代码添加到`MainWindow.__init__()`方法中：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is a simple form built on a `QWidget` object. There is a line input for
    the URL, a table widget for entering key-value pairs, and a button that will be
    used to trigger a file dialog and store the selected filename.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个建立在`QWidget`对象上的简单表单。有一个用于URL的输入行，一个用于输入键值对的表格小部件，以及一个用于触发文件对话框并存储所选文件名的按钮。
- en: After that, we have a `submit` button for sending the request and a read-only
    text edit that will display the returned results.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一个用于发送请求的`submit`按钮和一个只读文本编辑框，用于显示返回的结果。
- en: 'The `fname` button calls `on_file_btn()` when clicked, which looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`fname`按钮在单击时调用`on_file_btn()`，其代码如下：'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method simply calls a `QFileDialog` function to retrieve a filename to
    open. In order to keep things simple, we're taking the slightly unorthodox approach
    of storing the filename as our `QPushButton` text.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是调用`QFileDialog`函数来检索要打开的文件名。为了保持简单，我们采取了略微不正统的方法，将文件名存储为我们的`QPushButton`文本。
- en: The final `MainWindow` method is `submit()`, which is called when the `submit`
    button is clicked. We'll come back to that method after writing our web backend
    since its operation depends on how we define that backend.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`MainWindow`方法是`submit()`，当单击`submit`按钮时将调用该方法。在编写我们的Web后端之后，我们将回到该方法，因为它的操作取决于我们如何定义该后端。
- en: The POSTing backend
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST后端
- en: Our web posting backend will be based on a `QObject` simply so that we can use
    signals and slots.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web发布后端将基于`QObject`，这样我们就可以使用信号和槽。
- en: 'Begin by subclassing `QObject` and creating a signal:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过子类化`QObject`并创建一个信号：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `replyReceived` will be emitted when we receive a reply from the server
    to which we're posting and will carry with it the body of the reply as a string.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从服务器接收到我们正在发布的回复时，`replyReceived`信号将被发出，并携带回复的主体作为字符串。
- en: 'Now let''s create the constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建构造函数：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we're creating our `QNetworkAccessManager` object and connecting its `finished`
    signal to a local method called `on_reply()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建我们的`QNetworkAccessManager`对象，并将其`finished`信号连接到名为`on_reply()`的本地方法。
- en: 'The `on_reply()` method will look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_reply()`方法将如下所示：'
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Recall that the `finished` signal carries with it a `QNetworkReply` object.
    We can call its `readAll()` method to get the body of the reply as a `QByteArray`.
    Just as we did with our raw socket data, we first cast this to a `bytes` object,
    then use the `decode()` method to convert it to UTF-8 Unicode data. Finally, we'll
    emit our `replyReceived` signal with the string from the server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`finished`信号携带一个`QNetworkReply`对象。我们可以调用它的`readAll()`方法来获取回复的主体作为`QByteArray`。就像我们对原始套接字数据所做的那样，我们首先将其转换为`bytes`对象，然后使用`decode()`方法将其转换为UTF-8
    Unicode数据。最后，我们将使用来自服务器的字符串发出我们的`replyReceived`信号。
- en: 'Now we need a method that will actually post our key-value data and file to
    a URL. We''ll call it `make_request()`, and it begins as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个方法，实际上会将我们的键值数据和文件发布到URL。我们将其称为`make_request()`，并从以下位置开始：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Just as with a `GET` request, we start by creating a `QNetworkRequest` object
    from the provided URL. Unlike the `GET` request, however, our `POST` request carries
    a data payload. To carry this payload, we need to create a special object that
    we can send with the request.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与`GET`请求一样，我们首先从提供的URL创建一个`QNetworkRequest`对象。但与`GET`请求不同，我们的`POST`请求携带数据负载。为了携带这个负载，我们需要创建一个特殊的对象，可以与请求一起发送。
- en: There are a few ways that an HTTP request can format a data payload, but the
    most common way to transmit a file over HTTP is to use a **Multipart Form** request.
    This kind of request contains both key-value data and byte-encoded file data and
    is what you would get from submitting an HTML form containing a mix of input widgets
    and file widgets.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求可以以几种方式格式化数据负载，但通过HTTP传输文件的最常见方式是使用**多部分表单**请求。这种请求包含键值数据和字节编码的文件数据，是通过提交包含输入小部件和文件小部件混合的HTML表单获得的。
- en: 'To perform this kind of request in PyQt, we will begin by creating a `QtNetwork.QHttpMultiPart`
    object, like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要在PyQt中执行这种请求，我们将首先创建一个`QtNetwork.QHttpMultiPart`对象，如下所示：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are different types of multipart HTTP messages, and we define which type
    we want by passing a `QtNetwork.QHttpMultiPart.ContentType` enum constant to the
    constructor. The type we need for transmitting file and form data together is
    `FormDataType`, which we've used here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的多部分HTTP消息，我们通过将`QtNetwork.QHttpMultiPart.ContentType`枚举常量传递给构造函数来定义我们想要的类型。我们在这里使用的是用于一起传输文件和表单数据的`FormDataType`类型。
- en: The HTTP multipart object is a container for `QHttpPart` objects, each of which
    represents a component of our data payload. We need to create these parts from
    the data passed into this method and add them to our multipart object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP多部分对象是一个包含`QHttpPart`对象的容器，每个对象代表我们数据负载的一个组件。我们需要从传入此方法的数据创建这些部分，并将它们添加到我们的多部分对象中。
- en: 'Let''s start with our key-value pairs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的键值对开始：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each HTTP part has a header and a body. The header contains metadata about the
    part, including its **Content-Disposition**—in other words, what it contains.
    In the case of form data, that would be `form-data`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP部分都有一个标头和一个主体。标头包含有关部分的元数据，包括其**Content-Disposition**—也就是它包含的内容。对于表单数据，那将是`form-data`。
- en: So, for each key-value pair in the `data` dictionary, we're creating a single
    `QHttpPart` object, setting the Content-Disposition header to `form-data` with
    a `name` argument set to the key. Finally, we set the body of the HTTP part to
    our value (encoded as a byte string) and add the HTTP part to our multipart object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`data`字典中的每个键值对，我们正在创建一个单独的`QHttpPart`对象，将Content-Disposition标头设置为`form-data`，并将`name`参数设置为键。最后，我们将HTTP部分的主体设置为我们的值（编码为字节字符串），并将HTTP部分添加到我们的多部分对象中。
- en: 'To include our file, we need to do something similar:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含我们的文件，我们需要做类似的事情：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, our Content-Disposition header is still set to `form-data`, but also
    includes a `filename` argument set to the name of our file. The body of the HTTP
    part is set to the contents of the file. Note that we open the file in `rb` mode,
    meaning that its binary contents will be read as a `bytes` object rather than
    interpreting it as plaintext. This is important as `setBody()` expects bytes rather
    than Unicode.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们的Content-Disposition标头仍然设置为`form-data`，但也包括一个`filename`参数，设置为我们文件的名称。HTTP部分的主体设置为文件的内容。请注意，我们以`rb`模式打开文件，这意味着它的二进制内容将被读取为`bytes`对象，而不是将其解释为纯文本。这很重要，因为`setBody()`期望的是bytes而不是Unicode。
- en: 'Now that our multipart object is built, we can call the `post()` method of
    our `QNetworkAccessManager` object to send the request with the multipart data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的多部分对象已经构建好了，我们可以调用`QNetworkAccessManager`对象的`post()`方法来发送带有多部分数据的请求：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Back in `MainWindow.__init__()`, let''s create a `Poster` object to work with:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`，让我们创建一个`Poster`对象来使用：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since `replyReceived` emits the reply body as a string, we can connect it directly
    to `setText` in our response widget to view the server's response.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`replyReceived`将回复主体作为字符串发出，我们可以直接将其连接到响应小部件的`setText`上，以查看服务器的响应。
- en: 'Finally, it''s time to create our `submit()` callback:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候创建我们的`submit()`回调了：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remember that `make_request()` wants `QUrl`, a `dict` of the key-value pairs,
    and a filename string; so, this method simply goes through each widget, extracting
    and formatting the data, then passes it to `make_request()`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`make_request()`需要`QUrl`、键值对的`dict`和文件名字符串；因此，这个方法只是遍历每个小部件，提取和格式化数据，然后将其传递给`make_request()`。
- en: Testing the utility
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试实用程序
- en: If you have access to a server that accepts POST requests and file uploads,
    you can certainly use that to test your script; if not, you can also use the `sample_http_server.py`
    script included with the example code for this chapter. This script requires only
    Python 3 and the standard library and will echo back your POST request to you.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以访问接受POST请求和文件上传的服务器，您可以使用它来测试您的脚本；如果没有，您也可以使用本章示例代码中包含的`sample_http_server.py`脚本。这个脚本只需要Python
    3和标准库，它会将您的POST请求回显给您。
- en: 'Launch the server script in a console window, then in a second console run
    your `poster.py` script and do the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台窗口中启动服务器脚本，然后在第二个控制台中运行您的`poster.py`脚本，并执行以下操作：
- en: Enter `http://localhost:8000` for the URL
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入URL为`http://localhost:8000`
- en: Add a few arbitrary key-value pairs to the table
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向表中添加一些任意的键值对
- en: Select a file (probably a not-very-large text file, such as one of your Python
    scripts) to upload
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择要上传的文件（可能是一个不太大的文本文件，比如您的Python脚本之一）
- en: Click Submit Post
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击提交帖子
- en: 'You should see a printout of your request in both the server console window
    and in the response text edit on the GUI. It should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在服务器控制台窗口和GUI上的响应文本编辑中看到您请求的打印输出。它应该是这样的：
- en: '![](assets/fbc5b22b-9a2f-4e97-8897-c328187ecffd.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fbc5b22b-9a2f-4e97-8897-c328187ecffd.png)'
- en: 'To summarize, handling a `POST` request with `QNetworkAccessManager` involves
    the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用`QNetworkAccessManager`处理`POST`请求涉及以下步骤：
- en: Creating a `QNetworkAccessManager` and connecting its `finished` signal to a
    method that will process a `QNetworkReply`
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`QNetworkAccessManager`并将其`finished`信号连接到将处理`QNetworkReply`的方法
- en: Creating a `QNetworkRequest` pointed to the target URL
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建指向目标URL的`QNetworkRequest`
- en: Creating a data payload object, such as a `QHttpMultiPart` object
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据有效负载对象，比如`QHttpMultiPart`对象
- en: Passing the request and data payload to the `QNetworkAccessManager` object's
    `post()` method
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求和数据有效负载传递给`QNetworkAccessManager`对象的`post()`方法
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored connecting our PyQt applications to the network.
    You learned how to do low-level programming with sockets, including both a UDP
    broadcast application and TCP client-server application. You also learned how
    to interact with HTTP services using `QNetworkAccessManager`, beginning with simple
    downloading and ending with the uploading of complex multi-part form and file
    data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将我们的PyQt应用程序连接到网络。您学会了如何使用套接字进行低级编程，包括UDP广播应用程序和TCP客户端-服务器应用程序。您还学会了如何使用`QNetworkAccessManager`与HTTP服务进行交互，从简单的下载到复杂的多部分表单和文件数据上传。
- en: The next chapter will explore the use of SQL databases to store and retrieve
    data. You will learn how to build and query a SQL database, how to integrate SQL
    commands into your applications using the `QtSQL` module, and how to use SQL model-view
    components to quickly build data-driven GUI applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨使用SQL数据库存储和检索数据。您将学习如何构建和查询SQL数据库，如何使用`QtSQL`模块将SQL命令集成到您的应用程序中，以及如何使用SQL模型视图组件快速构建数据驱动的GUI应用程序。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您从本章中学到的知识：
- en: You are designing an application that will emit a status message to the local
    network, which you will monitor with administrator tools. What kind of socket
    object would be a good choice?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在设计一个应用程序，该应用程序将向本地网络发出状态消息，您将使用管理员工具进行监视。哪种类型的套接字对象是一个不错的选择？
- en: Your GUI class has a `QTcpSocket` object called `self.socket`. You've connected
    its `readyRead` signal to the following method, but it's not working. What's happening,
    and how can you fix it?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的GUI类有一个名为`self.socket`的`QTcpSocket`对象。你已经将它的`readyRead`信号连接到以下方法，但它不起作用。发生了什么，你该如何修复它？
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Use `QTcpServer` to implement a simple service that listens on port `8080` and
    prints any requests received. Make it reply to the client with a byte string of
    your choice.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QTcpServer`来实现一个简单的服务，监听端口`8080`，并打印接收到的任何请求。让它用你选择的字节字符串回复客户端。
- en: 'You''re creating a download function for your application to retrieve a large
    data file for import into your application. The code does not work. Read the code
    and decide what you''re doing wrong:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在为你的应用程序创建一个下载函数，用于获取一个大数据文件以导入到你的应用程序中。代码不起作用。阅读代码并决定你做错了什么：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Modify your `poster.py` script so that it sends the key-value data as JSON rather
    than HTTP form data.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`poster.py`脚本，以便将键值数据发送为JSON，而不是HTTP表单数据。
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参考以下内容：
- en: More information on the datagram packet structure can be found at [https://en.wikipedia.org/wiki/Datagram](https://en.wikipedia.org/wiki/Datagram).
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关数据报包结构的更多信息，请参阅[https://en.wikipedia.org/wiki/Datagram](https://en.wikipedia.org/wiki/Datagram)。
- en: With the ever-increasing focus on security and privacy in network communications,
    it's important to know how to work with SSL. See [https://doc.qt.io/qt-5/ssl.html](https://doc.qt.io/qt-5/ssl.html)
    for an overview of the `QtNetwork` facilities for working with SSL.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着对网络通信中安全和隐私的关注不断增加，了解如何使用SSL是很重要的。请参阅[https://doc.qt.io/qt-5/ssl.html](https://doc.qt.io/qt-5/ssl.html)
    了解使用SSL的`QtNetwork`工具的概述。
- en: The **Mozilla Developer Network** has a large number of resources for understanding
    HTTP and its various standards and protocols at [https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mozilla开发者网络**在[https://developer.mozilla.org/en-US/docs/Web/HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP)上有大量资源，用于理解HTTP及其各种标准和协议。'
