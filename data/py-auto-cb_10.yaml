- en: Debugging Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试技术
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Learning Python interpreter basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Python解释器基础知识
- en: Debugging through logging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过日志调试
- en: Debugging with breakpoints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断点调试
- en: Improving your debugging skills
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高你的调试技能
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Writing code is not easy. Actually, it is very hard. Even the best programmer
    in the world can't foresee any possible alternative and flow of the code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码并不容易。实际上，它非常困难。即使是世界上最好的程序员也无法预见代码的任何可能的替代方案和流程。
- en: This means that executing our code will always produce surprises and unexpected
    behavior. Some will be very evident and others will be very subtle, but the ability
    to identify and remove these defects in the code is critical to building solid
    software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着执行我们的代码将总是产生惊喜和意外的行为。有些会非常明显，而其他的则会非常微妙，但是识别和消除代码中的这些缺陷的能力对于构建稳固的软件至关重要。
- en: These defects in software are known as **bugs**, and therefore removing them
    is called **debugging**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些软件中的缺陷被称为**bug**，因此消除它们被称为**调试**。
- en: Inspecting the code just by reading it is not great. There are always surprises,
    and complex code is difficult to follow. That's why the ability to debug by stopping
    execution and taking a look at the current state of things is important.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过阅读来检查代码并不好。总会有意外，复杂的代码很难跟踪。这就是为什么通过停止执行并查看当前状态的能力是重要的。
- en: Everyone, EVERYONE introduces bugs in the code, normally to be surprised by
    them later. Some people have described debugging as *being the detective in a
    crime movie where you are also the murderer*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人，每个人都会在代码中引入bug，通常稍后会对此感到惊讶。有些人将调试描述为*在一部犯罪电影中扮演侦探，而你也是凶手*。
- en: 'Any debugging process roughly follows this path:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何调试过程大致遵循以下路径：
- en: You realize there's a problem
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你意识到有一个问题
- en: You understand what the correct behavior should be
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你了解正确的行为应该是什么
- en: You discover why the current code produces the bug
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你发现了当前代码产生bug的原因
- en: You change the code to produce the proper result
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你改变代码以产生正确的结果
- en: 95% of the time, everything but step 3 is trivial, which is the bulk of the
    debugging process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这95%的时间里，除了步骤3之外的所有事情都是微不足道的，这是调试过程的主要部分。
- en: 'Realizing the why of a bug, at its core, uses the scientific method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到bug的原因，本质上使用了科学方法：
- en: Measure and observe what the code is doing
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测量和观察代码的行为
- en: Produce a hypothesis on why that is
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对为什么会这样产生假设
- en: Validate or disprove that's correct, maybe through an experiment
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证或证明是否正确，也许通过实验
- en: Use the resulting information to iterate the process
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用得到的信息来迭代这个过程
- en: 'Debugging is an ability, and as such, it will improve over time. Practice plays
    an important role in developing intuition on what paths look promising to identify
    an error, but there are some general ideas that may help you:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一种能力，因此随着时间的推移会得到改善。实践在培养对哪些路径看起来有希望识别错误的直觉方面起着重要作用，但也有一些一般的想法可能会帮助你：
- en: '**Divide and conquer: **Isolate small parts of the code, so that it is possible
    to understand the code. Simplify the problem as much as possible.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之：**隔离代码的小部分，以便理解代码。尽可能简化问题。'
- en: 'There''s a format of this called the **Wolf fence algorithm**, described by
    Eduard Gauss:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个称为**狼围栏算法**的格式，由爱德华·高斯描述：
- en: '"There''s one wolf in Alaska; how do you find it? First build a fence down
    the middle of the state, wait for the wolf to howl, determine which side of the
    fence it is on. Repeat process on that side only, until you get to the point where
    you can see the wolf."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"阿拉斯加有一只狼；你怎么找到它？首先在州的中间建造一道围栏，等待狼嚎叫，确定它在围栏的哪一边。然后只在那一边重复这个过程，直到你能看到狼为止。"'
- en: '**Move backwards from the error: **If there''s a clear error at a specific
    point, the bug is likely located in the surroundings. Move progressively backwards
    from the error, following the track until the source of the error is found.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从错误处向后移动：**如果在特定点有明显的错误，那么bug可能位于周围。从错误处逐渐向后移动，沿着轨迹直到找到错误的源头。'
- en: '**You can assume anything you want, as long as you prove your assumption:** Code
    is very complex to keep in your head all at once. You need to validate small assumptions
    that, when combined, will provide solid ground to move forward with detecting
    and fixing the problem. Make small experiments, which will allow you to remove
    from your mind parts of the code that actually work and focus on untested ones.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只要你证明了你的假设，你可以假设任何东西：**代码非常复杂，无法一次性记住所有内容。您需要验证小的假设，这些假设结合起来将为检测和修复问题提供坚实的基础。进行小实验，这将允许您从头脑中删除实际工作的代码部分，并专注于未经测试的代码部分。'
- en: 'Or in the words of Sherlock Holmes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或用福尔摩斯的话说：
- en: '"Once you eliminate the impossible, whatever remains, no matter how improbable,
    must be the truth."'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"一旦你排除了不可能的，无论多么不可能，剩下的，必定是真相。"'
- en: But remember to prove it. Avoid untested assumptions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但记住要证明它。避免未经测试的假设。
- en: All of this sounds a bit scary, but actually most of the bugs are pretty evident.
    Maybe a typo, or a piece of code not ready for a particular value. Try to keep
    things simple. Simple code is easier to analyze and debug.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来有点可怕，但实际上大多数bug都是相当明显的。也许是拼写错误，或者一段代码还没有准备好接受特定的值。尽量保持简单。简单的代码更容易分析和调试。
- en: In this chapter, we will see some of the tools and techniques for debugging,
    and apply them specifically to Python scripts. The scripts will have some bugs
    that we will fix as part of the recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一些调试工具和技术，并将它们特别应用于Python脚本。这些脚本将有一些bug，我们将作为配方的一部分来修复它们。
- en: Learning Python interpreter basics
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Python解释器基础知识
- en: In this recipe, we'll cover some of Python's built-in capabilities to examine
    code, to investigate what's going on, and to detect when things are not behaving
    properly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将介绍一些Python内置的功能，以检查代码，调查发生了什么事情，并检测当事情不正常时。
- en: We can also verify when things are working as expected. Remember that being
    able to discard part of the code as the source of a bug is incredibly important.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以验证事情是否按预期进行。记住，能够排除代码的一部分作为错误源是非常重要的。
- en: While debugging, we typically need to analyze unknown elements and objects that
    come from an external module or service. Given the dynamic nature of Python, the
    code is highly discoverable at any point in the execution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，我们通常需要分析来自外部模块或服务的未知元素和对象。鉴于Python的动态特性，代码在执行的任何时刻都是高度可发现的。
- en: Everything in this recipe is included by default in Python's interpreter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法中的所有内容都是Python解释器的默认内容。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Import `pprint`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pprint`：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new dictionary called `dictionary`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dictionary`的新字典：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Display `globals` into this environment:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`globals`显示到此环境中：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Print the `globals` dictionary in a readable format with `pprint`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以可读格式使用`pprint`打印`globals`字典：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Display all of the attributes of the `dictionary`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示`dictionary`的所有属性：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Show the help for the `dictionary` object:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示`dictionary`对象的帮助：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After the import of `pprint` (pretty print) in step 1, we create a new dictionary
    to work as the example in step 2.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步导入`pprint`（漂亮打印）之后，我们创建一个新的字典作为第2步中的示例。
- en: Step 3 shows how the global namespace contains, among other things, the defined
    dictionary and the module. `globals()` displays all imported modules an other
    global variables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步显示了全局命名空间包含已定义的字典和模块等内容。`globals()`显示所有导入的模块和其他全局变量。
- en: There's an equivalent `locals()` for local namespaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本地命名空间有一个等效的`locals()`。
- en: '`pprint` helps to display the `globals` in a more readable format in step 4,
    adding more space and separating the elements by line.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`pprint`有助于以第4步中更可读的格式显示`globals`，增加更多空间并将元素分隔成行。'
- en: Step 5 shows how to use `dir()` to obtain all the attributes of a Python object.
    Note this includes all the double underscore values, such as `__len__`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步显示了如何使用`dir()`获取Python对象的所有属性。请注意，这包括所有双下划线值，如`__len__`。
- en: The use of the built-in `help()` function will display relevant information
    for objects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`help()`函数将显示对象的相关信息。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`dir()` in particular is extremely useful for inspecting unknown objects, modules,
    or classes. If you need to filter out the default attributes, and clarify the
    output, you can filter the output this way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir()`特别适用于检查未知对象、模块或类。如果需要过滤默认属性并澄清输出，可以通过以下方式过滤输出：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the same way, if you're searching for a particular method (such as something
    that starts with `set`), you can filter in the same way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要搜索特定方法（例如以`set`开头的方法），也可以以相同的方式进行过滤。
- en: '`help()` will display the `docstring` of a function or class. `docstring` is
    the string defined just after the definition to document the function or class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`help()`将显示函数或类的`docstring`。`docstring`是在定义之后定义的字符串，用于记录函数或类的信息：'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how in the next example, the  *This is help for something* string is
    defined just after the definition of the function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在下一个示例中，*这是某物的帮助*字符串是在函数定义之后定义的。
- en: '`docstring` is normally enclosed in triple quotes to allow writing string with
    multiple lines. Python will treat everything inside triple-quotes as a big string,
    even if there are newlines. You can use either `''` or `"` characters,  as long
    as you use three of them. You can find more information about `docstrings` at [https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`docstring`通常用三引号括起来，以允许编写多行字符串。Python将三引号内的所有内容视为一个大字符串，即使有换行符也是如此。您可以使用`''`或`"`字符，只要使用三个即可。您可以在[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)找到有关`docstrings`的更多信息。'
- en: The documentation for the built-in functions can be found at [https://docs.python.org/3/library/functions.html#built-in-functions](https://docs.python.org/3/library/functions.html#built-in-functions),
    and the full documentation for `pprint` can be found at [https://docs.python.org/3/library/pprint.html#](https://docs.python.org/3/library/pprint.html#).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数的文档可以在[https://docs.python.org/3/library/functions.html#built-in-functions](https://docs.python.org/3/library/functions.html#built-in-functions)找到，`pprint`的完整文档可以在[https://docs.python.org/3/library/pprint.html#](https://docs.python.org/3/library/pprint.html#)找到。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Improving your debugging skills* recipe
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高调试技能*的方法'
- en: The *Debugging through logging* recipe
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过日志进行调试*的方法'
- en: Debugging through logging
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过日志进行调试
- en: Debugging is, after all, detecting what's going on inside our program and what
    unexpected or incorrect effects may be happening. A simple, yet very effective,
    approach is to output variables and other information at strategic parts of your
    code to follow the flow of the program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，调试就是检测程序内部发生了什么以及可能发生的意外或不正确的影响。一个简单但非常有效的方法是在代码的战略部分输出变量和其他信息，以跟踪程序的流程。
- en: The simplest form of this approach is called **print debugging**, or inserting
    print statements at certain points to print the value of variables or points while
    debugging.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最简单形式称为**打印调试**，或者在调试时在某些点插入打印语句以打印变量或点的值。
- en: But taking this technique a little bit further and combining it with the logging
    techniques presented in [Chapter 2](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml), *Automating
    Tasks Made Easy* allows us to create a semi-permanent trace of the execution of
    the program, which can be really useful when detecting issues in a running program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，稍微深入了解这种技术，并将其与[第2章](6b1d9f13-f2de-41f1-a87b-6896ceb7b280.xhtml)中介绍的日志技术相结合，*轻松实现自动化任务*使我们能够创建程序执行的半永久跟踪，这在检测运行中的程序中的问题时非常有用。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the `debug_logging.py` file from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_logging.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_logging.py).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GitHub 下载 `debug_logging.py` 文件：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_logging.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_logging.py)。
- en: It contains an implementation of the bubble sort algorithm ([https://www.studytonight.com/data-structures/bubble-sort](https://www.studytonight.com/data-structures/bubble-sort)),
    which is the simplest way to sort a list of elements. It iterates several times
    over the list, and on each iteration, two adjacent values are checked and interchanged,
    so the bigger one is after the smaller. This makes the bigger values ascend like
    bubbles in the list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了冒泡排序算法的实现（[https://www.studytonight.com/data-structures/bubble-sort](https://www.studytonight.com/data-structures/bubble-sort)），这是对元素列表进行排序的最简单方式。它在列表上进行多次迭代，每次迭代都会检查并交换两个相邻的值，使得较大的值在较小的值之后。这样就使得较大的值像气泡一样在列表中上升。
- en: Bubble sort is a simple but naive way of implementing a sort, and there are
    better alternatives. Unless you have an extremely good reason not to, rely on
    the standard `.sort` method in lists.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是一种简单但天真的排序实现方式，有更好的替代方案。除非你有极好的理由，否则依赖列表中的标准 `.sort` 方法。
- en: 'When run, it checks the following list to verify that it is correct:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，它检查以下列表以验证其正确性：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have a bug in this implementation, so we can fix it as part of the recipe!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个实现中有一个 bug，所以我们可以将其作为修复的一部分来修复！
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Run the `debug_logging.py` script and check whether it fails:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `debug_logging.py` 脚本并检查是否失败：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Enable the dubug logging, changing the second line of the `debug_logging.py`
    script:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用调试日志，更改`debug_logging.py`脚本的第二行：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Change the preceding line to the following one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一行改为以下一行：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the different `level`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的 `level`。
- en: 'Run the script again, with more information inside:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行脚本，增加更多信息：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After analyzing the output, we realize that the last element of the list is
    not sorted. We analyze the code and discover an off-by-one error in line 7\. Do
    you see it? Let''s fix it by changing the following line:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析输出后，我们意识到列表的最后一个元素没有排序。我们分析代码并发现第 7 行有一个 off-by-one 错误。你看到了吗？让我们通过更改以下一行来修复它：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Change the preceding line to the following one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将前一行改为以下一行：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: (Notice the removal of the `-1` operation.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: （注意移除了 `-1` 操作。）
- en: 'Run it again and you will see that it works as expected. The debug logs are
    not displayed here:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行它，你会发现它按预期工作。调试日志不会显示在这里：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Step 1 presents the script and shows that the code is faulty, as it's not properly
    sorting the list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 步介绍了脚本，并显示代码有错误，因为它没有正确地对列表进行排序。
- en: The script already has some logs to show the start and end result, as well as
    some debug logs that show each intermediate step. In step 2, we activate the display
    of the `DEBUG` logs, as in step 1 only the `INFO` ones were shown.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本已经有一些日志来显示开始和结束结果，以及一些调试日志来显示每个中间步骤。在第 2 步中，我们激活了显示 `DEBUG` 日志的显示，因为在第 1 步中只显示了
    `INFO`。
- en: Note that the logs are displayed by default in the standard error output. This
    is displayed by default in the Terminal. If you need to direct the logs somewhere
    else, such as a file, see how to configure a different handler. See the logging
    configuration in Python for more details: [https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下日志会显示在标准错误输出中。这在终端中是默认显示的。如果你需要将日志重定向到其他地方，比如文件中，可以查看如何配置不同的处理程序。查看
    Python 中的日志配置以获取更多详细信息：[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)。
- en: Step 3 runs the script again, this time displaying extra information, showing
    that the last element in the list is not sorted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 步再次运行脚本，这次显示额外信息，显示列表中的最后一个元素没有排序。
- en: The bug is an off-by-one error, a very common kind of error, as it should iterate
    to the whole size of the list. This is fixed in step 4.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 bug 是一个 off-by-one 错误，这是一种非常常见的错误，因为它应该迭代整个列表的大小。这在第 4 步中得到修复。
- en: Check the code to understand why there's an error. The whole list should be
    compared, but we made the mistake of reducing the size by one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码以了解为什么会出现错误。整个列表应该被比较，但我们错误地减少了一个大小。
- en: Step 5 shows that the fixed script runs correctly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 步显示修复后的脚本运行正确。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we have strategically located the debug logs beforehand, but
    that may not be the case in a real-life debugging exercise. You may need to add
    more or change the location as part of the bug investigation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们已经有策略地放置了调试日志，但在实际的调试练习中可能不是这样。你可能需要添加更多或更改位置作为 bug 调查的一部分。
- en: The biggest advantage of this technique is that we're able to see the flow of
    the program, being able to inspect one moment of the code execution to another,
    and make sense of the flow. But the disadvantage is that we can end with a wall
    of text that doesn't provide specific information about our problem. You need
    to find a balance between too much and too little information.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的最大优势是我们能够看到程序的流程，能够检查代码执行的一个时刻到另一个时刻，并理解流程。但缺点是我们可能会得到一大堆不提供关于问题的具体信息的文本。你需要在提供太多和太少信息之间找到平衡。
- en: For the same reason, try to limit very long variables unless they're necessary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，除非必要，尽量限制非常长的变量。
- en: Remember to turn down the logging level after fixing the bug. It is likely that
    some logs that you discover to be irrelevant may need to be deleted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在修复 bug 后降低日志级别。很可能你发现一些不相关的日志需要被删除。
- en: The quick and dirty version of this technique is to add print statements instead
    of debug logs. While some people are resistant to this, it is actually a valuable
    technique to use for debug purposes. But remember to clean them up when you're
    done.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的快速而粗糙的版本是添加打印语句而不是调试日志。虽然有些人对此持反对意见，但实际上这是一种用于调试目的的有价值的技术。但记得在完成后清理它们。
- en: 'All the introspection elements are available, so you can create logs that display,
    for example, all the attributes of a `dir(object)` object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的内省元素都可用，因此可以创建显示例如`dir(object)`对象的所有属性的日志：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Anything that can be displayed as a string is able to be presented in a log,
    including any text manipulation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以显示为字符串的内容都可以在日志中呈现，包括任何文本操作。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning Python interpreter basics* recipe
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Python解释器基础*食谱'
- en: The *Improving your debugging skills* recipe
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高调试技能*食谱'
- en: Debugging with breakpoints
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断点进行调试
- en: Python has a ready-to-go debugger called `pdb`. Given that Python code is interpreted,
    this means that stopping the execution of the code at any point is possible by
    setting a breakpoint, which will jump into a command line where any code can be
    used to analyze the situation and execute any number of instructions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个现成的调试器叫做`pdb`。鉴于Python代码是解释性的，这意味着可以通过设置断点来在任何时候停止代码的执行，这将跳转到一个命令行，可以在其中使用任何代码来分析情况并执行任意数量的指令。
- en: Let's see how to do it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the `debug_algorithm.py` script, available from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_algorithm.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_algorithm.py).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`debug_algorithm.py`脚本，可从GitHub获取：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_algorithm.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_algorithm.py)。
- en: 'In the next section, we will analyze the execution of the code in detail. The code checks
    whether numbers follow certain properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细分析代码的执行。代码检查数字是否符合某些属性：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is possible that you recognize what the code is doing, but bear with me so
    that we can analyze it interactively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你已经认识到代码在做什么，但请跟着我一起交互分析它。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Run the code to see all the assertions are valid:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看所有断言是否有效：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add  `breakpoint()`, after the `while` loop, just before line 7, resulting
    in the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环之后添加`breakpoint()`，就在第7行之前，结果如下：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Execute the code again, and see that it stops at the breakpoint, entering into
    the interactive `Pdb` mode:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行代码，看到它在断点处停止，进入交互式`Pdb`模式：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check the value of the candidate and the two operations. This line is checking
    whether the dividing of `candidate` by `lower` is an integer (the float and integer
    division is the same):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查候选值和两个操作的值。这一行是在检查`candidate`除以`lower`是否为整数（浮点数和整数除法是相同的）：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Continue to the next instruction with `n`. See that it ends the while loop
    and returns `True`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`n`继续到下一条指令。看到它结束了while循环并返回`True`：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Continue the execution until another breakpoint is found with `c`. Note that
    this is the next call to `valid()`, which has 15 as an input:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续执行，直到找到另一个断点，使用`c`。请注意，这是对`valid()`的下一个调用，输入为15：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Continue running and inspecting the numbers until what the `valid` function
    is doing makes sense. Are you able to find out what the code does? (If you can''t,
    don''t worry and check the next section.) When you''re done, exit with `q`. This
    stops the execution:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行和检查数字，直到`valid`函数的操作有意义。你能找出代码在做什么吗？（如果你不能，不要担心，查看下一节。）完成后，使用`q`退出。这将停止执行：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The code is, as you probably know already, checking whether a number is a prime
    number. It tries to divide the number by all integers lower than it. If at any
    point is divisible, it returns a `False` result, because it's not a prime.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正在检查一个数字是否是质数，这点你可能已经知道。它试图将数字除以比它小的所有整数。如果在任何时候可以被整除，它将返回`False`结果，因为它不是质数。
- en: This is actually a very inefficient way of checking for a prime number, as it
    will take a very long time to deal with big numbers. It is fast enough for our
    teaching purposes, though. If you're interested in finding primes, you can take
    a look at math packages such as SymPy ([https://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#sympy.ntheory.primetest.isprime](https://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#sympy.ntheory.primetest.isprime)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个检查质数的非常低效的方法，因为处理大数字将需要很长时间。不过，对于我们的教学目的来说，它足够快。如果你有兴趣找质数，可以查看SymPy等数学包（[https://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#sympy.ntheory.primetest.isprime](https://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#sympy.ntheory.primetest.isprime)）。
- en: After checking the general execution in step 1, in step 2, we introduced a `breakpoint`
    in the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中检查了一般的执行，在步骤2中，在代码中引入了一个`breakpoint`。
- en: When the code is executed in step 3, it stops at the `breakpoint` position,
    entering into an interactive mode.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当在步骤3中执行代码时，它会在`breakpoint`位置停止，进入交互模式。
- en: In the interactive mode, we can inspect the values of any variable as well as
    perform any kind of operation. As demonstrated in step 4, sometimes, a line of
    code can be better analyzed by reproducing its parts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互模式下，我们可以检查任何变量的值，以及执行任何类型的操作。如步骤4所示，有时，通过重现其部分，可以更好地分析一行代码。
- en: The code can be inspected and regular operations can be executed in the command
    line. The next line of code can be executed by calling `n(ext)`, as done in step
    5 several times, to see the flow of the code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检查代码并在命令行中执行常规操作。可以通过调用`n(ext)`来执行下一行代码，就像步骤5中多次执行一样，以查看代码的流程。
- en: Step 6 shows how to resume the execution with the `c(ontinue)` command in order,
    to stop in the next breakpoint. All these operations can be iterated to see the
    flow and values, and to understand what the code is doing at any point.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤6显示了如何使用`c(ontinue)`命令恢复执行，以便在下一个断点处停止。所有这些操作都可以迭代以查看流程和值，并了解代码在任何时候正在做什么。
- en: The execution can be stopped with `q(uit)`, as demonstrated in step 7.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`q(uit)`停止执行，如步骤7所示。
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To see all the available operations, you can call `h(elp)` at any point.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的操作，可以在任何时候调用`h(elp)`。
- en: 'You can check the surrounding code at any point using the `l(ist)` command.
    For example, in step 4:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`l(ist)`命令在任何时候检查周围的代码。例如，在步骤4中：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The other two main debugger commands are `s(tep)`, which will execute the next
    step, including entering a new call, and `r(eturn)`, which will return from the
    current function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个主要的调试器命令是`s(tep)`，它将执行下一步，包括进入新的调用，以及`r(eturn)`，它将从当前函数返回。
- en: You can set up (and disable) more breakpoints using the `pdb` command `b(reak)`.
    You need to specify the file and line for the breakpoint, but it's actually more
    straightforward and less error-prone to just change the code and run it again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pdb`命令`b(reak)`设置（和禁用）更多断点。您需要为断点指定文件和行，但实际上更直接，更不容易出错的方法是改变代码并再次运行它。
- en: You can overwrite variables as well as read them. Or create new variables. Or
    make extra calls. Or anything else you can imagine. The full power of the Python
    interpreter is at your service! Use it to check how something works or verify whether
    something is happening.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以覆盖变量以及读取它们。或者创建新变量。或进行额外的调用。或者您能想象到的其他任何事情。Python解释器的全部功能都在您的服务中！用它来检查某些东西是如何工作的，或者验证某些事情是否发生。
- en: Avoid creating variables with names that are reserved for the debugger, such
    as calling a list `l`. It will make things confusing and interfere when trying
    to debug, sometimes in non-obvious ways.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用调试器保留的名称创建变量，例如将列表称为`l`。这将使事情变得混乱，并在尝试调试时干扰，有时以非明显的方式。
- en: 'The `breakpoint()` function is new in Python 3.7, but it''s highly recommended
    if you''re using that version. In previous versions, you need to replace it with the
    following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`breakpoint()`函数是Python 3.7中的新功能，但如果您使用该版本，强烈推荐使用它。在以前的版本中，您需要用以下内容替换它：'
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: They work in exactly the same way. Note the two statements in the same line,
    which is not recommended in Python in general, but it's a great way of keeping
    the breakpoint in a single line.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的工作方式完全相同。请注意同一行中的两个语句，这在Python中通常是不推荐的，但这是保持断点在单行中的一个很好的方法。
- en: Remember to remove any `breakpoints` once `debugging` is done! Especially when
    committing to a version-control system such as Git.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在调试完成后删除任何`breakpoints`！特别是在提交到Git等版本控制系统时。
- en: You can read more about the new `breakpoint` call in the official PEP describing
    its usage at: [https://www.python.org/dev/peps/pep-0553/](https://www.python.org/dev/peps/pep-0553/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方PEP中阅读有关新的`breakpoint`调用的更多信息，该PEP描述了其用法：[https://www.python.org/dev/peps/pep-0553/](https://www.python.org/dev/peps/pep-0553/)。
- en: The full `pdb` documentation can be found here: [https://docs.python.org/3.7/library/pdb.html#module-pdb](https://docs.python.org/3.7/library/pdb.html#module-pdb).
    It includes all the debug commands.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`pdb`文档可以在这里找到：[https://docs.python.org/3.7/library/pdb.html#module-pdb](https://docs.python.org/3.7/library/pdb.html#module-pdb)。它包括所有的调试命令。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning Python interpreter basics* recipe
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Python解释器基础*食谱'
- en: The *Improving your debugging skills* recipe
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*改进您的调试技能*食谱'
- en: Improving your debugging skills
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进您的调试技能
- en: In this recipe, we will analyze a small script that replicates a call to an external
    service, analyzing it and fixing some bugs. We will show different techniques
    to improve the debugging.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将分析一个小脚本，它复制了对外部服务的调用，分析并修复了一些错误。我们将展示不同的技术来改进调试。
- en: The script will ping some personal names to an internet server (`httpbin.org`,
    a test site) to get them back, simulating its retrieval from an external server.
    It will then split them into first and last name and prepare them to be sorted
    by surname. Finally, it will sort them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将一些个人姓名ping到互联网服务器（`httpbin.org`，一个测试站点）以获取它们，模拟从外部服务器检索它们。然后将它们分成名和姓，并准备按姓氏排序。最后，它将对它们进行排序。
- en: The script contains several bugs that we will detect and fix.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包含了几个我们将检测和修复的错误。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will use the `requests` and `parse` modules and include
    them in our virtual environment:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用`requests`和`parse`模块，并将它们包含在我们的虚拟环境中：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `debug_skills.py` script is available from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills.py).
    Note that it contains bugs that we will fix as part of this recipe.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug_skills.py`脚本可以从GitHub获取：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills.py)。请注意，它包含我们将在本食谱中修复的错误。'
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Run the script, which will generate an error:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本，将生成错误：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Analyze the status code. We get 405, which means that the method we sent is
    not allowed. We inspect the code and realize that for the call in line 24, we
    used `GET`, when the proper one is `POST` (as described in the URL). Replace the
    code with the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析状态码。我们得到了405，这意味着我们发送的方法不被允许。我们检查代码并意识到，在第24行的调用中，我们使用了`GET`，而正确的方法是`POST`（如URL中所述）。用以下内容替换代码：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We keep the old buggy code commented with `(old)` for clarity of changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旧的错误代码用`(old)`进行了注释，以便更清楚地进行更改。
- en: 'Run the code again, which will produce a different error:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，将产生不同的错误：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Insert a breakpoint in line 33, one preceding the error. Run it again and enter
    into debugging mode:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第33行插入一个断点，一个在错误之前。再次运行它并进入调试模式：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Running `n` does not produce an error, meaning that it's not the first value.
    After a few runs on ` c`, we realize that this is not the correct approach, as
    we don't know what input is the one generating the error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`n`不会产生错误，这意味着它不是第一个值。在`c`上运行几次后，我们意识到这不是正确的方法，因为我们不知道哪个输入是产生错误的。
- en: 'Instead, we wrap the line with a `try...except` block and produce a breakpoint
    at that point:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，我们用`try...except`块包装该行，并在那一点产生一个`breakpoint`：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We run the code again. This time the code stops at the moment the data produced
    an error:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次运行代码。这次代码在数据产生错误的时候停止：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The cause is now clear, line 35 only allows us to split two words, but raises
    an error if a middle name is added. After some testing, we settle into this line
    to fix it:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在原因很明显，第35行只允许我们分割两个单词，但如果添加中间名就会引发错误。经过一些测试，我们确定了这行来修复它：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We run the script again. Be sure to remove the `breakpoint` and `try..except`
    block. This time, it generates a list of names! And they are sorted alphabetically
    by surname. However, a few of the names look incorrect:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次运行脚本。确保移除`breakpoint`和`try..except`块。这次，它生成了一个名字列表！并且它们按姓氏字母顺序排序。然而，一些名字看起来不正确：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Who's called `O'Carroll, S\\u00e9amus` ?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 谁叫`O'Carroll, S\\u00e9amus`？
- en: 'To analyse this particular case, but skip the rest, we must create an `if`
    condition to break only for that name in line 33\. Notice the `in` to avoid having
    to be totally correct:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了分析这个特殊情况，但跳过其余部分，我们必须创建一个`if`条件，只在第33行为那个名字中断。注意`in`，以避免必须完全正确：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the script once more. The breakpoint stops at the proper moment:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行脚本。`breakpoint`在正确的时刻停止了：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Move upward in the code and check the different variables:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向上移动代码，检查不同的变量：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `result.json()` dictionary, there''s actually a different field that
    seems to be rendering the name properly, which is called `''json''`. Let''s look
    at it in detail; we can see that it''s a dictionary:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`result.json()`字典中，实际上有一个不同的字段，似乎正确地呈现了名字，这个字段叫做`'json'`。让我们仔细看一下；我们可以看到它是一个字典：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Change the code, instead of parsing the raw value in `'data'`, use directly
    the `'json'` field from the result. This  simplifies the code, which is great!
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变代码，不要解析`'data'`中的原始值，直接使用结果中的`'json'`字段。这简化了代码，非常棒！
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the code again. Remember to remove the `breakpoint`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码。记得移除`breakpoint`：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This time, it's all correct! You have successfully debugged the program!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，一切都正确了！您已成功调试了程序！
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The structure of the recipe is divided into three different problems. Let''s
    analyze it in small blocks:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱的结构分为三个不同的问题。让我们分块分析它：
- en: '**First error—Wrong call to the external service**:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个错误-对外部服务的错误调用**：'
- en: After showing the first error in step 1, we read with care the resulting error,
    saying that the server is returning a 405 status code. This corresponds to a method
    not allowed, indicating that our calling method is not correct.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中显示第一个错误后，我们仔细阅读了产生的错误，说服务器返回了405状态码。这对应于不允许的方法，表明我们的调用方法不正确。
- en: 'Inspect the following line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下行：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It gives us the indication that we are using a `GET` call to one URL that's
    defined for `POST`, so we make the change in step 2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们，我们正在使用`GET`调用一个为`POST`定义的URL，所以我们在步骤2中进行了更改。
- en: Notice that there has been no extra debugging steps as such in this error, but
    a careful reading of the error message and the code. Remember to pay attention
    to error messages and logs. Often, this is enough to discover the issue.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个错误中并没有额外的调试步骤，而是仔细阅读错误消息和代码。记住要注意错误消息和日志。通常，这已经足够发现问题了。
- en: We run the code in step 3 to find the next problem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在步骤3中运行代码，找到下一个问题。
- en: '**Second error—Wrong handling of middle names**:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个错误-中间名处理错误**：'
- en: In step 3, we get an error of too many values to unpack. We create a `breakpoint`
    to analyze the data in step 4 at this point, but discover that not all the data
    produces this error. The analysis done in step 4 shows that it may be very confusing
    to stop the execution when an error is not produced, having to continue until
    it does. We know that the error is produced at this point, but only for certain
    kind of data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤3中，我们得到了一个值过多的错误。我们在步骤4中创建一个`breakpoint`来分析这一点的数据，但发现并非所有数据都会产生这个错误。在步骤4中进行的分析表明，当错误没有产生时停止执行可能会非常令人困惑，必须继续直到产生错误。我们知道错误是在这一点产生的，但只对某种类型的数据产生错误。
- en: As we know that the error is being produced at some point, we capture it in
    a `try..except` block in step 5\. When the exception is produced, we trigger the
    `breakpoint`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道错误是在某个时候产生的，我们在步骤5中用`try..except`块捕获它。当异常产生时，我们触发`breakpoint`。
- en: This makes step 6 execution of the script to stop when the `full_name` is `'John
    Paul Smith'`. This produces an error as the `split` expects two elements, not
    three.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得步骤6执行脚本时停止，当`full_name`是`'John Paul Smith'`时。这会产生一个错误，因为`split`期望返回两个元素，而不是三个。
- en: This is fixed in step 7, allowing everything except the last word to be part
    of the first name, grouping any middle name(s) into the first element. This fits
    our purpose for this program, to sort by last name.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这在步骤7中得到了修复，允许除了最后一个单词之外的所有内容都成为名字的一部分，将任何中间名归为第一个元素。这符合我们这个程序的目的，按姓氏排序。
- en: Names are actually quite complex to handle. Check out this article if you want
    to be delighted with the great amount of wrong assumptions one can make regarding
    names: [https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，名字处理起来相当复杂。如果您想对关于名字的错误假设感到惊讶，请查看这篇文章：[https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/](https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/)。
- en: 'The following line does that with `rsplit`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用`rsplit`：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It divides the text by words, starting from the right and making a maximum of
    one split, guaranteeing that only two elements will be returned.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过单词从右边开始分割文本，最多分割一次，确保只返回两个元素。
- en: When the code is changed, step 8 runs the code again to discover the next error.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码更改时，第8步再次运行代码以发现下一个错误。
- en: '**Third error—Using a wrong returned value by the external service**:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三个错误——使用外部服务返回的错误值**：'
- en: Running the code in step 8 displays the list and does not produce any errors.
    But, examining the results, we can see that some of the names are incorrectly
    processed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步运行代码会显示列表，并且不会产生任何错误。 但是，检查结果，我们可以看到一些名称被错误处理了。
- en: We pick one of the examples in step 9 and create a conditional breakpoint. We
    only activate the `breakpoint` if the data fulfills the `if` condition.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择第9步中的一个示例，并创建一个条件断点。 只有在数据满足`if`条件时才激活`breakpoint`。
- en: The `if` condition in this case stops at any time the `"O'Carroll"` string appears,
    not having to make it stricter with an equal statement. Be pragmatic about this
    code, as you'll need to remove it after the bug is fixed anyway.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`if`条件在任何时候停止`"O'Carroll"`字符串出现，而不必使用等号语句使其更严格。 对于这段代码要实用主义，因为在修复错误后，您将需要将其删除。
- en: The code is run again in step 10\. From there, once validated that the data
    is as expected, we worked *backward* to find the root of the problem. Step 11
    analyzes previous values and the code up to that point, trying to find out what
    lead to the incorrect value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在第10步再次运行。 从那里，一旦验证数据符合预期，我们就开始*向后*寻找问题的根源。 第11步分析先前的值和到目前为止的代码，试图找出导致不正确值的原因。
- en: We then discover that we used the wrong field in the returned value from the
    `result` from the server. The value in the `json` field is better for this task
    and it's already parsed for us. Step 12 checks the value and sees how it should
    be used.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们发现我们在从服务器的`result`返回值中使用了错误的字段。 `json`字段的值更适合这个任务，而且它已经为我们解析了。 第12步检查该值并查看应该如何使用它。
- en: In step 13, we change the code to adjust. Notice that the `parse` module is
    no longer needed and that the code is actually cleaner using the `json` field.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13步，我们更改代码进行调整。 请注意，不再需要`parse`模块，而且使用`json`字段的代码实际上更清晰。
- en: This result is actually more common than it looks, especially when dealing with
    external interfaces. We may use it in a way that works, but maybe it's not the
    best. Take a little bit of time to read the documentation and keep an eye on improvements
    and learn how to better use the tools.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果实际上比看起来更常见，特别是在处理外部接口时。 我们可能会以一种有效的方式使用它，但也许这并不是最好的。 花点时间阅读文档，并密切关注改进并学习如何更好地使用工具。
- en: Once this is fixed, the code is run again in step 14\. Finally, the code is
    doing what's expected, sorting the names alphabetically by surname. Notice that
    the other name that contained strange characters is fixed as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个问题解决了，代码在第14步再次运行。 最后，代码按姓氏按字母顺序排列。 请注意，包含奇怪字符的其他名称也已修复。
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The fixed script is available from GitHub: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills_fixed.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills_fixed.py).
    You can download it and see the differences.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 修复后的脚本可以从GitHub获取：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills_fixed.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter10/debug_skills_fixed.py)。
    您可以下载并查看其中的差异。
- en: There are other ways of creating conditional breakpoints. There's actually support
    from the debugger to create breakpoints that stop, but only if some conditions
    are met. When possible, we find it easier to work directly with code, as it is
    persistent between runs and easier to remember and operate. You can check how
    to create it in the Python `pdb` documentation: [https://docs.python.org/3/library/pdb.html#pdbcommand-break](https://docs.python.org/3/library/pdb.html#pdbcommand-break).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他创建条件断点的方法。 实际上，调试器支持创建断点，但仅当满足某些条件时才停止。 可以在Python `pdb`文档中查看如何创建它：[https://docs.python.org/3/library/pdb.html#pdbcommand-break](https://docs.python.org/3/library/pdb.html#pdbcommand-break)。
- en: The kind of breakpoint catching an exception shown in the first error is a demonstration
    of how making conditions in code is straightforward. Just be careful to remove
    them afterwards!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个错误中显示的捕获异常的断点类型演示了在代码中制作条件是多么简单。 只是要小心在之后删除它们！
- en: 'There are other debuggers available that have an increased set of features.
    For example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可用的调试器具有更多功能。 例如：
- en: '`ipdb` ([https://github.com/gotcha/ipdb](https://github.com/gotcha/ipdb)):
    Adds tab completion and syntax highlights'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipdb` ([https://github.com/gotcha/ipdb](https://github.com/gotcha/ipdb))：添加制表符补全和语法高亮显示'
- en: '`pudb` ([https://documen.tician.de/pudb/](https://documen.tician.de/pudb/)):
    Displays an old-style, semi-graphical, text-based interface, in the style of early
    90s tools that display the environment variables automatically'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pudb` ([https://documen.tician.de/pudb/](https://documen.tician.de/pudb/))：显示旧式的半图形文本界面，以自动显示环境变量的方式显示90年代早期工具的风格'
- en: '`web-pdb` ([https://pypi.org/project/web-pdb/](https://pypi.org/project/web-pdb/)):
    Opens a web server to access a graphic interface with the debugger'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web-pdb` ([https://pypi.org/project/web-pdb/](https://pypi.org/project/web-pdb/))：打开一个Web服务器以访问带有调试器的图形界面'
- en: Check their documentations to know how to install them and run them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 查看它们的文档以了解如何安装和运行它们。
- en: There are more debuggers available, a search on the internet will give you more
    options, including Python IDEs. In any case, be aware of adding dependencies.
    It is always good to be able to use the default debugger.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多可用的调试器，通过互联网搜索将为您提供更多选项，包括Python IDE。 无论如何，要注意添加依赖项。 能够使用默认调试器总是很好的。
- en: 'The new breakpoint commands in Python 3.7 allow us to change easily between
    debuggers using the `PYTHONBREAKPOINT` environment variable. For example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.7中的新断点命令允许我们使用`PYTHONBREAKPOINT`环境变量轻松地在调试器之间切换。 例如：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This starts `ipdb` on any breakpoint in the code. You can see more about this
    in the `breakpoint()` documentation can be found: [https://www.python.org/dev/peps/pep-0553/#environment-variable](https://www.python.org/dev/peps/pep-0553/#environment-variable).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在代码中的任何断点上启动`ipdb`。您可以在`breakpoint()`文档中了解更多信息：[https://www.python.org/dev/peps/pep-0553/#environment-variable](https://www.python.org/dev/peps/pep-0553/#environment-variable)。
- en: An important effect on this is to disable all breakpoints by setting `PYTHONBREAKPOINT=0`,
    which is a great tool to ensure that code in production is never interrupted by
    a `breakpoint()` left by mistake.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的一个重要影响是通过设置`PYTHONBREAKPOINT=0`来禁用所有断点，这是一个很好的工具，可以确保生产中的代码永远不会因为错误留下的`breakpoint()`而中断。
- en: The Python `pdb` documentation can be found here: [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)
    The whole documentation of the `parse` module can be found at [https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse) and
    the whole `requests` documentation at [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python `pdb`文档可以在这里找到：[https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)
    `parse`模块的完整文档可以在[https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse)找到，`requests`的完整文档可以在[http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master)找到。
- en: See also
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning Python interpreter basics* recipe
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Python解释器基础*配方'
- en: The *Debugging with breakpoints* recipe
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用断点进行调试*配方'
