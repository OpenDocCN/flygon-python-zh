- en: Numerical Methods for Pricing Options
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权定价的数值方法
- en: A derivative is a contract whose payoff depends on the value of some underlying
    asset. In cases where closed-form derivative pricing may be complex or even impossible,
    numerical procedures excel. A numerical procedure is the use of iterative computational
    methods in attempting to converge to a solution. One such basic implementation
    is a binomial tree. In a binomial tree, a node represents the state of an asset
    at a certain point of time associated with a price. Each node leads to two other
    nodes in the next time step. Similarly, in a trinomial tree, each node leads to
    three other nodes in the next time step. However, as the number of nodes or the
    time steps of trees increase, so do the computational resources that are consumed.
    Lattice pricing attempts to solve this problem by storing only the new information
    at each time step, while reusing values where possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 衍生品是一种合同，其回报取决于某些基础资产的价值。在封闭形式衍生品定价可能复杂甚至不可能的情况下，数值程序表现出色。数值程序是使用迭代计算方法试图收敛到解的方法。其中一个基本实现是二项树。在二项树中，一个节点代表某一时间点的资产状态，与价格相关。每个节点在下一个时间步骤导致另外两个节点。同样，在三项树中，每个节点在下一个时间步骤导致另外三个节点。然而，随着树的节点数量或时间步骤的增加，消耗的计算资源也会增加。栅格定价试图通过仅在每个时间步骤存储新信息，同时在可能的情况下重复使用价值来解决这个问题。
- en: In finite difference pricing, the nodes of the tree can also be represented
    as a grid. The terminal values on the grid consist of terminal conditions, while
    the edges of the grid represent boundary conditions in asset pricing. We will
    discuss the explicit method, implicit method, and the Crank-Nicolson method of
    the finite difference schemes to determine the price of an asset.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限差分定价中，树的节点也可以表示为网格。网格上的终端值包括终端条件，而网格的边缘代表资产定价中的边界条件。我们将讨论有限差分方案的显式方法、隐式方法和Crank-Nicolson方法，以确定资产的价格。
- en: Although vanilla options and certain exotics such as European barrier options
    and lookback options can be found to have a closed-form solution, other exotic
    products such as Asian options do not contain a closed-form solution. In these
    cases, the pricing of options can be used with numerical procedures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管香草期权和某些奇异期权，如欧式障碍期权和回望期权，可能具有封闭形式解，但其他奇异产品，如亚洲期权，没有封闭形式解。在这些情况下，可以使用数值程序来定价期权。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Pricing European and American options using a binomial tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二项树定价欧式和美式期权
- en: Using a Cox-Ross-Rubinstein binomial tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cox-Ross-Rubinstein二项树
- en: Pricing options using a Leisen-Reimer tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Leisen-Reimer树定价期权
- en: Pricing options using a trinomial tree
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三项树定价期权
- en: Deriving Greeks from a tree for free
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从树中推导希腊字母
- en: Pricing options using a binomial and trinomial lattice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二项和三项栅格定价期权
- en: Finite differences with the explicit, implicit, and Crank-Nicolson method
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显式、隐式和Crank-Nicolson方法的有限差分
- en: Implied volatility modeling using an LR tree and the bisection method
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LR树和二分法的隐含波动率建模
- en: Introduction to options
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权介绍
- en: An **option** is a derivative of an asset that gives an owner the right but
    not the obligation to transact the underlying asset at a certain date for a certain
    price, known as the maturity date and strike price, respectively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**期权**是资产的衍生品，它赋予所有者在特定日期以特定价格交易基础资产的权利，称为到期日和行权价格。'
- en: A **call option** gives the buyer the right to buy an asset by a certain date
    for a certain price. A seller or writer of a call option is obligated to sell
    the underlying security to the buyer at the agreed price, should the buyer exercise
    his/her rights on the agreed date.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**认购期权**赋予买方在特定日期以特定价格购买资产的权利。认购期权的卖方或写方有义务在约定日期以约定价格向买方出售基础证券，如果买方行使其权利。'
- en: A **put option** gives the buyer the right to sell the underlying asset by a
    certain date for a certain price. A seller or writer of a put option is obligated
    to buy the underlying security from the buyer at the agreed price, should the
    buyer exercise his/her rights on the agreed date.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**认沽期权**赋予买方在特定日期以特定价格出售基础资产的权利。认沽期权的卖方或写方有义务在约定日期以约定价格从买方购买基础证券，如果买方行使其权利。'
- en: The most common options that are available are the European options and American
    options. Other exotic options include Bermudan options and Asian options. This
    chapter will deal mainly with European and American options. A European option
    can only be exercised on the maturity date. An American option, on the other hand,
    may be exercised at any time throughout the lifetime of the option.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的期权包括欧式期权和美式期权。其他奇异期权包括百慕大期权和亚洲期权。本章主要涉及欧式期权和美式期权。欧式期权只能在到期日行使。而美式期权则可以在期权的整个生命周期内的任何时间行使。
- en: Binomial trees in option pricing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权定价中的二项树
- en: In the binomial option pricing model, the underlying security at one time period,
    represented as a node with a given price, is assumed to traverse to two other
    nodes in the next time step, representing an up state and a down state. Since
    options are derivatives of the underlying asset, the binomial pricing model tracks
    the underlying conditions on a discrete-time basis. Binomial option pricing can
    be used to value European options, American options, as well as Bermudan options.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在二项期权定价模型中，假设在一个时间段内，代表具有给定价格的节点的基础证券在下一个时间步骤中遍历到另外两个节点，代表上升状态和下降状态。由于期权是基础资产的衍生品，二项定价模型以离散时间为基础跟踪基础条件。二项期权定价可用于估值欧式期权、美式期权以及百慕大期权。
- en: The initial value of the root node is the spot price *S[0]* of the underlying
    security with a risk-neutral probability of increase *q*, and a risk-neutral probability
    of loss *1-q*, at the next time step. Based on these probabilities, the expected
    values of the security are calculated for each state of price increase or decrease
    for every time step. The terminal nodes represent every value of the expected
    security prices for every combination of up states and down states. We can then
    calculate the value of the option at every node, traverse the tree by risk-neutral
    expectations, and after discounting from the forward interest rates, we can derive
    the value of the call or put option.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点的初始值是基础证券的现货价格*S[0]*，具有风险中性概率的上涨*q*和下跌的风险中性概率*1-q*，在下一个时间步骤。基于这些概率，为每个价格上涨或下跌的状态计算了证券的预期值。终端节点代表了每个预期证券价格的值，对应于上涨状态和下跌状态的每种组合。然后我们可以计算每个节点的期权价值，通过风险中性期望遍历树状图，并在从远期利率贴现后，我们可以推导出看涨期权或看跌期权的价值。
- en: Pricing European options
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价欧式期权
- en: 'Consider a two-step binomial tree. A non-dividend paying stock price starts
    at $50, and, in each of the two time steps, the stock may go up by 20 percent
    or go down by 20 percent. Suppose that the risk-free rate is five percent per
    annum and that the time to maturity, *T*, is two years. We would like to find
    the value of a European put option with a strike price *K* of $52\. The following
    diagram shows the pricing of the stock and the payoffs at the terminal nodes using
    a binomial tree:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个两步二叉树。不支付股息的股票价格从50美元开始，在两个时间步骤中，股票可能上涨20%，也可能下跌20%。假设无风险利率为每年5%，到期时间*T*为两年。我们想要找到行权价*K*为52美元的欧式看跌期权的价值。以下图表显示了使用二叉树定价股票和终端节点的回报：
- en: '![](Images/ebfbaecf-a7a2-4763-bb3d-cf9673e98c4d.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ebfbaecf-a7a2-4763-bb3d-cf9673e98c4d.png)'
- en: 'Here, the nodes are calculated as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，节点的计算如下：
- en: '![](Images/56cb6902-2c50-4589-8d03-71981ff9cd15.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/56cb6902-2c50-4589-8d03-71981ff9cd15.png)'
- en: '![](Images/6c899404-b04e-4695-be22-8f1f4a46fac0.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6c899404-b04e-4695-be22-8f1f4a46fac0.png)'
- en: '![](Images/70e15ac6-f601-410d-9371-32cfb0dbe24e.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/70e15ac6-f601-410d-9371-32cfb0dbe24e.png)'
- en: '![](Images/6eda97f5-8781-4acf-9a3a-a88c41375fd5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6eda97f5-8781-4acf-9a3a-a88c41375fd5.png)'
- en: '![](Images/a959a1cf-4af3-4fba-904a-3e316030ad56.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a959a1cf-4af3-4fba-904a-3e316030ad56.png)'
- en: '![](Images/98ee5ef1-3fa8-47fd-afd2-5fecdbe22756.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/98ee5ef1-3fa8-47fd-afd2-5fecdbe22756.png)'
- en: '![](Images/c7579cd4-bc65-439b-9657-25691097682c.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c7579cd4-bc65-439b-9657-25691097682c.png)'
- en: '![](Images/82886492-9cb6-4ebe-b4fc-40d5b97d7da3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/82886492-9cb6-4ebe-b4fc-40d5b97d7da3.png)'
- en: 'At the terminal nodes, the payoff from exercising a European call option is
    given as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端节点，行使欧式看涨期权的回报如下：
- en: '![](Images/401d00a1-d6b5-4980-9cad-d589da05a7cf.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/401d00a1-d6b5-4980-9cad-d589da05a7cf.png)'
- en: 'In the case of a European put option, the payoff is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在欧式看跌期权的情况下，回报如下：
- en: '![](Images/91b879ad-9ac4-4540-b9a2-a9a9dbf3b42d.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/91b879ad-9ac4-4540-b9a2-a9a9dbf3b42d.png)'
- en: European call and put options are usually denoted by lowercase letters, *c*
    and *p*, while American call and put options are usually denoted by uppercase
    letters, *C* and *P*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 欧式看涨期权和看跌期权通常用小写字母*c*和*p*表示，而美式看涨期权和看跌期权通常用大写字母*C*和*P*表示。
- en: From the option payoff values, we can then traverse the binomial tree backward
    to the current time, and after discounting from the risk-free rate we will obtain
    our present value of the option. Traversing the tree backward takes into account
    the risk-neutral probabilities of the option's up states and down states.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从期权回报值中，我们可以向后遍历二叉树到当前时间，并在从无风险利率贴现后，我们将获得期权的现值。向后遍历树状图考虑了期权上涨状态和下跌状态的风险中性概率。
- en: 'We may assume that investors are indifferent to risk and that expected returns
    on all assets are equal. In the case of investing in stocks by risk-neutral probability,
    the payoff from holding the stock and taking into account the up and down state
    possibilities would be equal to the continuously compounded risk-free rate expected
    in the next time step, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设投资者对风险不感兴趣，并且所有资产的预期回报相等。在通过风险中性概率投资股票的情况下，持有股票的回报并考虑上涨和下跌状态的可能性将等于在下一个时间步骤中预期的连续复利无风险利率，如下所示：
- en: '![](Images/59bc58a4-3aa6-47d1-b491-e305786a3925.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/59bc58a4-3aa6-47d1-b491-e305786a3925.png)'
- en: 'The risk-neutral probability *q* of investing in the stock can be rewritten
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 投资股票的风险中性概率*q*可以重写如下：
- en: '![](Images/8996391c-6994-421f-99a1-116ac1e83498.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8996391c-6994-421f-99a1-116ac1e83498.png)'
- en: '**Are these formulas relevant to stocks? What about futures?**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公式与股票相关吗？期货呢？
- en: 'Unlike investing in stocks, investors do not have to make an upfront payment
    to take a position in a futures contract. In a risk-neutral sense, the expected
    growth rate from holding a futures contract is zero, and the risk-neutral probability
    *q* of investing in futures can be rewritten as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与投资股票不同，投资者无需提前付款来持有期货合约。在风险中性意义上，持有期货合约的预期增长率为零，投资期货的风险中性概率*q*可以重写如下：
- en: '![](Images/83f95aed-08c9-447c-aa1d-e5f5a372d01b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/83f95aed-08c9-447c-aa1d-e5f5a372d01b.png)'
- en: 'Let''s calculate the risk-neutral probability *q* of the stock given in the
    preceding example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算前面示例中给出的股票的风险中性概率*q*：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The payoffs of exercising the European put option at the terminal nodes are
    $0, $4, and $20 at the respective states. The present value of the put option
    can be priced as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端节点行使欧式看跌期权的回报分别为0美元、4美元和20美元。看跌期权的现值可以定价如下：
- en: '![](Images/748f9fd6-e9de-4b9b-946a-1719ace53d65.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/748f9fd6-e9de-4b9b-946a-1719ace53d65.png)'
- en: 'This gives us the put option price as $4.19\. The two-step binomial tree to
    value a European put option with payoffs at each node is illustrated in the following
    graph:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了看跌期权价格为4.19美元。使用二叉树估算每个节点的欧式看跌期权的价值如下图所示：
- en: '![](Images/66ef05f5-a024-498b-9228-720be29e4ef9.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/66ef05f5-a024-498b-9228-720be29e4ef9.png)'
- en: Writing the StockOption base class
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写StockOption基类
- en: 'Before going any further and implementing the various pricing models that we
    are about to discuss, let''s create a `StockOption` class to store and calculate
    the common attributes of the stock option that will be reused throughout this
    chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步实现我们将要讨论的各种定价模型之前，让我们创建一个`StockOption`类，用于存储和计算股票期权的共同属性，这些属性将在本章中被重复使用：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The current underlying price, strike price, risk-free rate, time to maturity,
    and number of time steps are compulsory common attributes for pricing options.
    The delta of the time step `dt` and the discount factor `df` are computed as properties
    of the class and may be overwritten by implementing classes if needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的标的价格、行权价格、无风险利率、到期时间和时间步数是定价期权的强制共同属性。时间步长`dt`和折现因子`df`的增量作为类的属性计算，并且如果需要，可以被实现类覆盖。
- en: A class for European options using a binomial tree
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二项式树的欧式期权类
- en: 'The Python implementation of the binomial option pricing model of a European
    option is given as the `BinomialEuropeanOption` class, inheriting the common attributes
    of the option from the `StockOption` class. The implementations of the methods
    in this class are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 欧式期权的Python实现是`BinomialEuropeanOption`类，它继承自`StockOption`类的共同属性。该类中方法的实现如下：
- en: The `price()` method of the `BinomialEuropeanOption` class is the entry point
    for all the instances of this class
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BinomialEuropeanOption`类的`price()`方法是该类所有实例的入口'
- en: It invokes the `setup_parameters()` method to set up the required model parameters,
    and then calls the `init_stock_price_tree()` method to simulate the expected values
    of the stock prices for the period up until *T*
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它调用`setup_parameters()`方法来设置所需的模型参数，然后调用`init_stock_price_tree()`方法来模拟期间内股票价格的预期值直到*T*
- en: Finally, the `begin_tree_traversal()` method is called to initialize the payoff
    array and store the discounted payoff values, as it traverses the binomial tree
    back to the present time
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`begin_tree_traversal()`方法来初始化支付数组并存储折现支付值，因为它遍历二项式树回到现在的时间
- en: The payoff tree nodes are returned as a NumPy array object, where the present
    value of the European option is found at the initial node
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 支付树节点作为NumPy数组对象返回，其中欧式期权的现值在初始节点处找到
- en: 'The class implementation of `BinomialEuropeanOption` is given in the following
    Python code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinomialEuropeanOption`的类实现如下Python代码：'
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s take the values from the two-step binomial tree example we discussed
    earlier to price the European put option:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们之前讨论的两步二项式树示例中的值来定价欧式看跌期权：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the binomial option pricing model gives us a present value of $4.19 for
    the European put option.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二项式期权定价模型，我们得到了欧式看跌期权的现值为4.19美元。
- en: A class for American options using a binomial tree
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二项式树的美式期权类
- en: Unlike European options, which can only be exercised at maturity, American options
    can be exercised at any time during their lifetime.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与只能在到期时行使的欧式期权不同，美式期权可以在其寿命内的任何时候行使。
- en: To implement the pricing of American options in Python, in the same way we did
    with the `BinomialEuropeanOption` class, create a class named `BinomialTreeOption`
    that inherits the `Stockoption` class. The parameters that are used in the `setup_parameters()`
    method remain the same, except for the removal of an unused `M` parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中实现美式期权的定价，我们可以像`BinomialEuropeanOption`类一样创建一个名为`BinomialTreeOption`的类，该类继承自`Stockoption`类。`setup_parameters()`方法中使用的参数保持不变，只是删除了一个未使用的`M`参数。
- en: 'The methods that are used in American options are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 美式期权中使用的方法如下：
- en: '`init_stock_price_tree`: Uses a two-dimensional NumPy array to store the expected
    returns of the stock prices for all time steps. This information is used to calculate
    the payoff values from exercising the option at each period. This method is written
    as follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_stock_price_tree`：使用二维NumPy数组存储所有时间步的股票价格的预期回报。这些信息用于计算在每个期间行使期权时的支付值。该方法编写如下：'
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`init_payoffs_tree`: Creates the payoff tree as a two-dimensional NumPy array,
    starting with the intrinsic values of the option at maturity. This method is written
    as follows:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_payoffs_tree`：创建支付树作为二维NumPy数组，从期满时期的期权内在价值开始。该方法编写如下：'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`check_early_exercise`: Returns the maximum payoff values between exercising
    the American option early and not exercising the option at all. This method is
    written as follows:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_early_exercise`：返回在提前行使美式期权和根本不行使期权之间的最大支付值。该方法编写如下：'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`traverse_tree`: This also includes the invocation of the `check_early_exercise()`
    method to check whether it is optimal to exercise an American option early at
    every time step. This method is written as follows:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traverse_tree`：这还包括调用`check_early_exercise()`方法，以检查是否在每个时间步提前行使美式期权是最优的。该方法编写如下：'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The implementation of the `begin_tree_traversal()` and the `price()` methods
    remains the same.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin_tree_traversal()`和`price()`方法的实现保持不变。'
- en: The `BinomialTreeOption` class can price both European and American options
    when the `is_put` keyword argument is set to `False` or `True` during instantiation
    of the class, respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类的实例化期间将`is_put`关键字参数设置为`False`或`True`时，`BinomialTreeOption`类可以定价欧式和美式期权。
- en: 'The following code is for pricing the American option:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是用于定价美式期权的：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The American put option is priced at $5.0896\. Since American options can be
    exercised at any time and European options can only be exercised at maturity,
    this added flexibility of American options increases their value over European
    options in certain circumstances.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 美式看跌期权的价格为5.0896美元。由于美式期权可以在任何时候行使，而欧式期权只能在到期时行使，因此美式期权的这种灵活性在某些情况下增加了其价值。
- en: For American call options on an underlying asset that does not pay dividends,
    there might not be an extra value over its European call option counterpart. Because
    of the time value of money, it costs more to exercise the American call option
    today before the expiration at the strike price than at a future time with the
    same strike price. For an in-the-money American call option, exercising the option
    early loses the benefit of protection against adverse price movement below the
    strike price, as well as its intrinsic time value. With no entitlement of dividend
    payments, there are no incentives to exercise American call options early.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支付股息的基础资产的美式看涨期权，可能没有超过其欧式看涨期权对应的额外价值。由于时间价值的原因，今天在行权价上行使美式看涨期权的成本比在未来以相同行权价行使更高。对于实值的美式看涨期权，提前行使期权会失去对抗行权价以下不利价格波动的保护，以及其内在时间价值。没有股息支付的权利，没有动机提前行使美式看涨期权。
- en: The Cox–Ross–Rubinstein model
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cox–Ross–Rubinstein模型
- en: 'In the preceding examples, we assumed that the underlying stock price would
    increase by 20 percent and decrease by 20 percent in the respective *u* up state
    and *d* down state. The **Cox-Ross-Rubinstein** (**CRR)** model proposes that,
    over a short period of time in the risk-neutral world, the binomial model matches
    the mean and variance of the underlying stock. The volatility of the underlying
    stock, or the standard deviation of returns of the stock, is taken into account
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们假设基础股价在相应的*u*上升状态和*d*下降状态分别增加20％和减少20％。**Cox-Ross-Rubinstein**（**CRR**）模型提出，在风险中性世界的短时间内，二项式模型与基础股票的均值和方差相匹配。基础股票的波动性，或者股票回报的标准差，如下所示：
- en: '![](Images/8a91adde-554a-429b-96bb-180e991f1ce2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a91adde-554a-429b-96bb-180e991f1ce2.png)'
- en: '![](Images/55fa99b2-ac5a-40bf-8adb-d09102cf749c.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/55fa99b2-ac5a-40bf-8adb-d09102cf749c.png)'
- en: A class for the CRR binomial tree option pricing model
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRR二项式树期权定价模型的类
- en: The implementation of the binomial CRR model remains the same as the binomial
    tree we discussed earlier, with the exception of the `u` and `d` model parameters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 二项式CRR模型的实现与我们之前讨论的二项式树相同，唯一的区别在于`u`和`d`模型参数。
- en: In Python, let's create a class named `BinomialCRROption` and simply inherit
    the `BinomialTreeOption` class. Then, all that we need to do is override the `setup_parameters()`
    method with values from the CRR model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，让我们创建一个名为`BinomialCRROption`的类，并简单地继承`BinomialTreeOption`类。然后，我们只需要覆盖`setup_parameters()`方法，使用CRR模型中的值。
- en: 'Instances of the `BinomialCRROption` object will invoke the `price()` method,
    which invokes all other methods of the parent `BinomialTreeOption` class, except
    the overwritten `setup_parameters()` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinomialCRROption`对象的实例将调用`price()`方法，该方法调用父类`BinomialTreeOption`的所有其他方法，除了被覆盖的`setup_parameters()`方法：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, consider the two-step binomial tree. The non-dividend paying stock has
    a current price of $50 and a volatility of 30 percent. Suppose that the risk-free
    rate is five percent per annum and the time to maturity *T* is two years. We would
    like to find the value of a European put option with a strike price *K* of $52
    by the CRR model:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑两步二项式树。不支付股息的股票当前价格为50美元，波动率为30％。假设无风险利率为年利率5％，到期时间*T*为两年。我们想要找到CRR模型下的行权价为52美元的欧式看跌期权的价值：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By using the CRR two-step binomial tree model, the price of the European put
    option and the American put option are $6.2457 and $7.4284, respectively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用CRR两步二项式树模型，欧式看跌期权和美式看跌期权的价格分别为6.2457美元和7.4284美元。
- en: Using a Leisen-Reimer tree
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Leisen-Reimer树
- en: In the binomial models we discussed earlier, we made several assumptions about
    the probability of up and down states, as well as the resulting risk-neutral probabilities.
    Besides the binomial model with CRR parameters that we discussed, other forms
    of parameterization that are discussed widely in mathematical finance include
    the Jarrow-Rudd parameterization, Tian parameterization, and Leisen-Reimer parameterization.
    Let's take a look at the Leisen-Reimer model in detail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前讨论的二项式模型中，我们对上升和下降状态的概率以及由此产生的风险中性概率做出了几个假设。除了我们讨论的具有CRR参数的二项式模型之外，在数学金融中广泛讨论的其他形式的参数化包括Jarrow-Rudd参数化、Tian参数化和Leisen-Reimer参数化。让我们详细看看Leisen-Reimer模型。
- en: Dr. Dietmar Leisen and Matthias Reimer proposed a binomial tree model with the
    purpose of approximating to the Black-Scholes solution as the number of step increases.
    It is known as the **Leisen-Reimer** (**LR**) tree, and the nodes do not recombine
    at every alternate step. It uses an inversion formula to achieve better accuracy
    during tree traversal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Dietmar Leisen博士和Matthias Reimer提出了一个二项式树模型，旨在在步数增加时逼近Black-Scholes解。它被称为**Leisen-Reimer**（**LR**）树，节点不会在每个交替步骤重新组合。它使用反演公式在树遍历期间实现更好的准确性。
- en: 'A detailed explanation of the formula is given in the paper *Binomial Models
    For Option Valuation - Examining And Improving Convergence*, March 1995, which
    is available at [http://papers.ssrn.com/sol3/papers.cfm?abstract_id=5976](http://papers.ssrn.com/sol3/papers.cfm?abstract_id=5976).
    We will be using method two of the Peizer and Pratt inversion function *f* with
    the following characteristic parameters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有关该公式的详细解释可在1995年3月的论文*Binomial Models For Option Valuation - Examining And
    Improving Convergence*中找到，网址为[http://papers.ssrn.com/sol3/papers.cfm?abstract_id=5976](http://papers.ssrn.com/sol3/papers.cfm?abstract_id=5976)。我们将使用Peizer和Pratt反演函数*f*的第二种方法，具有以下特征参数：
- en: '![](Images/9de89a37-6682-434b-b36a-c2397fa9ed49.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9de89a37-6682-434b-b36a-c2397fa9ed49.png)'
- en: '![](Images/ec38b5a2-90e5-4563-b006-bb1b848c4512.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ec38b5a2-90e5-4563-b006-bb1b848c4512.png)'
- en: '![](Images/b8910449-3784-4f4e-a9d1-3ae2d5cc8834.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b8910449-3784-4f4e-a9d1-3ae2d5cc8834.png)'
- en: '![](Images/b38b80b9-8653-42e5-8463-ff6f3922b8eb.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b38b80b9-8653-42e5-8463-ff6f3922b8eb.png)'
- en: '![](Images/07c34467-3bfb-468c-aab2-edc83990fdba.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07c34467-3bfb-468c-aab2-edc83990fdba.png)'
- en: '![](Images/648c1914-ac35-48f2-aec2-14d91b432121.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/648c1914-ac35-48f2-aec2-14d91b432121.png)'
- en: '![](Images/7e22357f-3cfd-4a3b-a57c-5bfad34f8b60.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7e22357f-3cfd-4a3b-a57c-5bfad34f8b60.png)'
- en: '![](Images/2cf66a09-cded-4bac-88dc-c66e4a75b10e.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2cf66a09-cded-4bac-88dc-c66e4a75b10e.png)'
- en: The *S[0]* parameter is the current stock price, *K* is the strike price of
    the option, σ is the annualized volatility of the underlying stock, *T* is the
    time to maturity of the option, *r* is the annualized risk-free rate, *y* is the
    dividend yield, and *Δt* is the time interval between each tree step.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*S[0]*参数是当前股票价格，*K*是期权的行权价格，σ是基础股票的年化波动率，*T*是期权的到期时间，*r*是年化无风险利率，*y*是股息收益，*Δt*是每个树步之间的时间间隔。'
- en: A class for the LR binomial tree option pricing model
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LR二项树期权定价模型的一个类
- en: 'The Python implementation of the LR tree is given in the following `BinomialLROption`
    class. Similar to the `BinomialCRROption` class, we simply inherit the `BinomialTreeOption`
    class and override the variables in the `setup_parameters` method with those of
    the LR tree model:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: LR树的Python实现在以下`BinomialLROption`类中给出。与`BinomialCRROption`类类似，我们只需继承`BinomialTreeOption`类，并用LR树模型的变量覆盖`setup_parameters`方法中的变量：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the same examples that we used previously, we can price the options using
    an LR tree:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前使用的相同示例，我们可以使用LR树定价期权：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By using the LR binomial tree model with four time steps, the price of the European
    put option and the American put option are $5.87865 and $6.7636, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用具有四个时间步长的LR二项树模型，欧式看跌期权的价格和美式看跌期权的价格分别为$5.87865和$6.7636。
- en: The Greeks for free
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 希腊字母免费
- en: In the binomial tree pricing models that we have covered so far, we traversed
    up and down the tree at each point in time to determine the node values. From
    the information at each node, we can reuse these computed values easily. One such
    use is the computation of Greeks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止涵盖的二项树定价模型中，我们在每个时间点上上下遍历树来确定节点值。根据每个节点的信息，我们可以轻松地重用这些计算出的值。其中一种用途是计算希腊字母。
- en: The Greeks measure the sensitivities of the price of derivatives, such as options
    with respect to changes in the parameters of the underlying asset, often represented
    by Greek letters. In mathematical finance, the common names associated with Greeks
    include alpha, beta, delta, gamma, vega, theta, and rho.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 希腊字母衡量衍生品价格对基础资产参数变化的敏感性，例如期权，通常用希腊字母表示。在数学金融中，与希腊字母相关的常见名称包括alpha、beta、delta、gamma、vega、theta和rho。
- en: Two particularly useful Greeks for options are delta and gamma. Delta measures
    the sensitivity of the option price with respect to the underlying asset price.
    Gamma measures the rate of change in delta with respect to the underlying price.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 期权的两个特别有用的希腊字母是delta和gamma。Delta衡量期权价格对基础资产价格的敏感性。Gamma衡量delta相对于基础价格的变化率。
- en: 'As shown in the following diagram, an additional layer of nodes is added around
    our original two-step tree to make it a four-step tree, which extends two steps
    backward in time. Even with additional terminal payoff nodes, all nodes will contain
    the same information as our original two-step tree. Our option value of interest
    is now located in the middle of the tree at **t=0**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，在我们原始的两步树周围添加了额外的节点层，使其成为一个四步树，向时间向后延伸了两步。即使有额外的期末支付节点，所有节点将包含与我们原始的两步树相同的信息。我们感兴趣的期权价值现在位于树的中间，即**t=0**：
- en: '![](Images/f93d5207-b1b0-4c63-b4be-ecc0bd5e3324.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f93d5207-b1b0-4c63-b4be-ecc0bd5e3324.png)'
- en: 'Notice that at **t=0** there exists two additional nodes'' worth of information
    that we can use to compute the delta formula, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在**t=0**处存在两个额外节点的信息，我们可以使用它们来计算delta公式，如下所示：
- en: '![](Images/da8a6f89-51c5-4052-8f68-cc0eb611150a.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/da8a6f89-51c5-4052-8f68-cc0eb611150a.png)'
- en: The delta formula states that the difference in the option prices in the up
    and down state is represented as a unit of the difference between the respective
    stock prices at time **t=0**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 三角洲公式规定，期权价格在上涨和下跌状态之间的差异表示为时间**t=0**时各自股票价格之间的差异的单位。
- en: 'Conversely, the gamma formula can be computed as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，gamma公式可以计算如下：
- en: '![](Images/6838f01f-47b1-4485-b121-1a222efddc4a.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6838f01f-47b1-4485-b121-1a222efddc4a.png)'
- en: The gamma formula states that the difference of deltas between the option prices
    in the up node and the down node against the initial node value are computed as
    a unit of the differences in price of the stock at the respective states.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 伽玛公式规定，上节点和下节点中期权价格的delta之间的差异与初始节点值相对于各自状态下股票价格的差异的单位进行计算。
- en: A class for Greeks with the LR binomial tree
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LR二项树的希腊字母类
- en: To illustrate the computation of Greeks with the LR tree, let's create a new
    class named `BinomialLRWithGreeks` that inherits the `BinomialLROption` class
    with our own implementation of the `price` method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在LR树中计算希腊字母的过程，让我们创建一个名为`BinomialLRWithGreeks`的新类，该类继承了`BinomialLROption`类，并使用我们自己的`price`方法的实现。
- en: In the `price` method, we will start by calling the `setup_parameters()` method
    of the parent class to initialize all variables required by the LR tree. However,
    this time, we will also call the `new_stock_price_tree()` method, which is a new
    method that's used to create an extra layer of nodes around the original tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`price`方法中，我们将首先调用父类的`setup_parameters()`方法来初始化LR树所需的所有变量。然而，这一次，我们还将调用`new_stock_price_tree()`方法，这是一个用于在原始树周围创建额外节点层的新方法。
- en: The `begin_tree_traversal()` method is called to perform the usual LR tree implementation
    in the parent class. The returned NumPy array object now contains information
    on the three nodes at **t=0**, where the middle node is the option price. The
    payoffs in the up and down states at **t=0** are in the first and last index of
    the array, respectively.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`begin_tree_traversal()`方法执行父类中的通常LR树实现。返回的NumPy数组对象现在包含**t=0**处三个节点的信息，其中中间节点是期权价格。在数组的第一个和最后一个索引处是**t=0**处上升和下降状态的支付。
- en: 'With this information, the `price()` method computes and returns the option
    price, the delta, and the gamma values together:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，`price()`方法计算并返回期权价格、delta和gamma值：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using the same example from the LR tree, we can compute the option values and
    Greeks for a European call and put option with 300 time steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LR树的相同示例，我们可以计算具有300个时间步的欧式看涨期权和看跌期权的期权价值和希腊值：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see from the `price()` method and results, we managed to obtain additional
    information on Greeks from the modified binomial tree without any extra overhead
    in computational complexity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从`price()`方法和结果中可以看出，我们成功地从修改后的二项树中获得了希腊附加信息，而没有增加计算复杂性。
- en: Trinomial trees in option pricing
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权定价中的三项树
- en: In the binomial tree, each node leads to two other nodes in the next time step.
    Similarly, in a trinomial tree, each node leads to three other nodes in the next
    time step. Besides having up and down states, the middle node of the trinomial
    tree indicates no change in state. When extended over more than two time steps,
    the trinomial tree can be thought of as a recombining tree, where the middle nodes
    always retain the same values as the previous time step.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在二项树中，每个节点导致下一个时间步中的两个其他节点。同样，在三项树中，每个节点导致下一个时间步中的三个其他节点。除了具有上升和下降状态外，三项树的中间节点表示状态不变。当扩展到两个以上的时间步时，三项树可以被视为重新组合树，其中中间节点始终保留与上一个时间步相同的值。
- en: 'Let''s consider the Boyle trinomial tree, where the tree is calibrated so that
    the probability of up, down, and flat movements, *u*, *d*, and *m* with risk-neutral
    probabilities *q[u]*, *q[d]*, and *q[m]* are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑Boyle三项树，其中树被校准，使得上升、下降和平稳移动的概率*u*、*d*和*m*与风险中性概率*q[u]*、*q[d]*和*q[m]*如下：
- en: '![](Images/6bccf093-15d1-474a-aa19-2bbb3b5b4669.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6bccf093-15d1-474a-aa19-2bbb3b5b4669.png)'
- en: '![](Images/548f26bc-063d-49c1-b5a5-c5b88cf07150.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/548f26bc-063d-49c1-b5a5-c5b88cf07150.png)'
- en: '![](Images/b6f6844b-4f98-41ca-bc2d-277b5d155c6b.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b6f6844b-4f98-41ca-bc2d-277b5d155c6b.png)'
- en: '![](Images/5f592c17-82bd-4348-be54-2fe893501558.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5f592c17-82bd-4348-be54-2fe893501558.png)'
- en: '![](Images/3331afe8-85f2-4160-9e74-aadfe9e7253f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3331afe8-85f2-4160-9e74-aadfe9e7253f.png)'
- en: '![](Images/d6514bfb-2bfa-457a-8a95-eac1f6ec2e1a.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d6514bfb-2bfa-457a-8a95-eac1f6ec2e1a.png)'
- en: We can see that ![](Images/368560b2-b79d-4f65-adb1-50cf118f29dc.png) recombines
    to *m =1*. With calibration, the no state movement *m* grows at a flat rate of
    1 instead of at the risk-free rate. The variable *v* is the annualized dividend
    yield, and *σ* is the annualized volatility of the underlying stock.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 ![](Images/368560b2-b79d-4f65-adb1-50cf118f29dc.png) 重新组合为 *m =1*。通过校准，无状态移动
    *m* 以1的固定利率增长，而不是以无风险利率增长。变量 *v* 是年化股息收益，*σ* 是基础股票的年化波动率。
- en: 'In general, with an increased number of nodes to process, a trinomial tree
    gives better accuracy than the binomial tree when fewer time steps are modeled,
    saving on computation speed and resources. The following diagram illustrates the
    stock price movements of a trinomial tree with two time steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，处理更多节点时，三项树在建模较少时间步时比二项树具有更好的精度，可以节省计算速度和资源。下图说明了具有两个时间步的三项树的股价变动：
- en: '![](Images/ebfc055a-39ea-418c-a865-425c697b4255.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ebfc055a-39ea-418c-a865-425c697b4255.png)'
- en: A class for the trinomial tree option pricing model
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三项树期权定价模型的类
- en: Let's create a `TrinomialTreeOption` class, inheriting from the `BinomialTreeOption`
    class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`TrinomialTreeOption`类，继承自`BinomialTreeOption`类。
- en: 'The methods for the `TrinomialTreeOption` are provided as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrinomialTreeOption`的方法如下所示：'
- en: 'The `setup_parameters()` method implements the model parameters of the trinomial
    tree. This method is written as follows:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_parameters()`方法实现了三项树的模型参数。该方法编写如下：'
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `init_stock_price_tree()` method sets up the trinomial tree to include
    the flat movement of stock prices. This method is written as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_stock_price_tree()`方法设置了三项树，包括股价的平稳移动。该方法编写如下：'
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `traverse_tree()` method takes into account the middle node after discounting
    the payoff:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traverse_tree()`方法在打折后考虑中间节点的收益：'
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the same example of the binomial tree, we get the following result:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二项树的相同示例，我们得到以下结果：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By the trinomial tree model, we obtain prices of $6.57 and $7.16 for the European
    and American put options, respectively.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过三项树模型，我们得到了欧式看跌期权和美式看跌期权的价格分别为$6.57和$7.16。
- en: Lattices in option pricing
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权定价中的栅格
- en: In binomial trees, each node recombines at every alternative node. In trinomial
    trees, each node recombines at every other node. This property of recombining
    trees can also be represented as lattices to save memory without recomputing and
    storing recombined nodes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在二项树中，每个节点在每个交替节点处重新组合。在三项树中，每个节点在每个其他节点处重新组合。重新组合树的这种属性也可以表示为栅格，以节省内存而无需重新计算和存储重新组合的节点。
- en: Using a binomial lattice
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二项栅格
- en: 'We will create a binomial lattice from the binomial CRR tree since at every
    alternate up and down nodes, the prices recombine to the same probability of *ud=1*.
    In the following diagram, **S[u]** and **S[d]** recombine with **S[du]** = **S[ud]**
    = **S*[0]***. The tree can now be represented as a single list:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从二项CRR树创建一个二项栅格，因为在每个交替的上升和下降节点处，价格重新组合为相同的*ud=1*概率。在下图中，**S[u]**和**S[d]**与**S[du]**
    = **S[ud]** = **S*[0]***重新组合。现在可以将树表示为单个列表：
- en: '![](Images/1d131a2a-96bb-4663-9199-e84c4a8cbe84.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1d131a2a-96bb-4663-9199-e84c4a8cbe84.png)'
- en: For a *N*-step binomial tree, a list of size *2N +1* is required to contain
    the information on the underlying stock prices. For European option pricing, the
    odd nodes of payoffs from the list represent the option value upon maturity. The
    tree traverses backward to obtain the option value. For American option pricing,
    as the tree traverses backward, both ends of the list shrink, and the odd nodes
    represent the associated stock prices for any time step. Payoffs from the earlier
    exercise can then be taken into account.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*N*步二项式树，需要一个大小为*2N +1*的列表来包含关于基础股票价格的信息。对于欧式期权定价，列表的奇数节点代表到期时的期权价值。树向后遍历以获得期权价值。对于美式期权定价，随着树向后遍历，列表的两端收缩，奇数节点代表任何时间步的相关股票价格。然后可以考虑早期行权的回报。
- en: A class for the CRR binomial lattice option pricing model
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRR二项式栅格期权定价模型的类
- en: 'Let''s convert the binomial tree pricing into a lattice by CRR. We can inherit
    from the `BinomialCRROption` class (which in turn inherits the `BinomialTreeOption`
    class) and create a new class named `BinomialCRRLattice`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过CRR将二项式树定价转换为栅格。我们可以继承`BinomialCRROption`类（该类又继承自`BinomialTreeOption`类），并创建一个名为`BinomialCRRLattice`的新类，如下所示：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following methods are overwritten with the implementation of the lattice
    while retaining the behavior of all the other pricing functions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法被覆盖，同时保留所有其他定价函数的行为：
- en: '`setup_parameters`: Overrides the parent method to initialize the CRR parameters
    of the parent class, as well as declaring the new variable `M` as the list size'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_parameters`：覆盖父类方法以初始化父类的CRR参数，并声明新变量`M`为列表大小'
- en: '`init_stock_price_tree`: Overrides the parent method to set up a one-dimensional
    NumPy array as the lattice with the `M` size'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_stock_price_tree`：覆盖父类方法，设置一个一维NumPy数组作为具有`M`大小的栅格'
- en: '`init_payoffs_tree` and `check_early_exercise`: Overrides the parent methods
    to take into account the payoffs at odd nodes only'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_payoffs_tree`和`check_early_exercise`：覆盖父类方法，只考虑奇数节点的回报'
- en: 'Using the same stock information from our binomial CRR model example, we can
    price a European and American put option using the binomial lattice pricing:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们二项式CRR模型示例中的相同股票信息，我们可以使用二项式栅格定价来定价欧式和美式看跌期权：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By using the CRR binomial tree lattice pricing model, we obtain prices of $6.2457
    and $7.428 for the European and American put options, respectively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用CRR二项式树格定价模型，我们得到了欧式和美式看跌期权的价格分别为$6.2457和$7.428。
- en: Using the trinomial lattice
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用三项式栅格
- en: 'The trinomial lattice works in very much the same way as the binomial lattice.
    Since each node recombines at every other node instead of alternate nodes, extracting
    odd nodes from the list is not necessary. Since the size of the list is the same
    as the one in the binomial lattice, there are no extra storage requirements in
    trinomial lattice pricing, as explained in the following diagram:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 三项式栅格与二项式栅格的工作方式基本相同。由于每个节点在每个其他节点重新组合，而不是交替节点，因此不需要从列表中提取奇数节点。由于列表的大小与二项式栅格中的大小相同，在三项式栅格定价中没有额外的存储要求，如下图所示：
- en: '![](Images/ac536179-2cd2-4ee1-ba53-e3debaa9e4e6.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ac536179-2cd2-4ee1-ba53-e3debaa9e4e6.png)'
- en: A class for the trinomial lattice option pricing model
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三项式栅格期权定价模型的类
- en: In Python, let's create a class named `TrinomialLattice` for the trinomial lattice
    implementation that inherits from the `TrinomialTreeOption` class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，让我们创建一个名为`TrinomialLattice`的类，用于继承`TrinomialTreeOption`类的三项式栅格实现。
- en: 'Just as we did for the `BinomialCRRLattice` class, the `setup_parameters`,
    `init_stock_price_tree`, `init_payoffs_tree`, and `check_early_exercise` methods
    are overwritten, without having to take into account the payoffs at odd nodes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为`BinomialCRRLattice`类所做的那样，覆盖了`setup_parameters`、`init_stock_price_tree`、`init_payoffs_tree`和`check_early_exercise`方法，而不必考虑奇数节点的回报：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the same examples as before, we can price the European and American options
    using the trinomial lattice model:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的示例，我们可以使用三项式栅格模型定价欧式和美式期权：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output agrees with the results that were obtained from the trinomial tree
    option pricing model.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与从三项式树期权定价模型获得的结果一致。
- en: Finite differences in option pricing
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期权定价中的有限差分
- en: 'Finite difference schemes are very much similar to trinomial tree option pricing,
    where each node is dependent on three other nodes with an up movement, a down
    movement, and a flat movement. The motivation behind the finite differencing is
    the application of the Black-Scholes **Partial Differential Equation** (**PDE**)
    framework (involving functions and their partial derivatives), where price *S(t)*
    is a function of *f(S,t)*, with *r* as the risk-free rate, *t* as the time to
    maturity, and *σ* as the volatility of the underlying security:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分方案与三项式树期权定价非常相似，其中每个节点依赖于另外三个节点，即上升、下降和平移。有限差分的动机是应用Black-Scholes**偏微分方程**（**PDE**）框架（涉及函数及其偏导数），其中价格*S(t)*是*f(S,t)*的函数，*r*是无风险利率，*t*是到期时间，*σ*是基础证券的波动率：
- en: '![](Images/95125917-f109-4f59-82dd-44ff66ff99dc.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/95125917-f109-4f59-82dd-44ff66ff99dc.png)'
- en: The finite difference technique tends to converge faster than lattices and approximates
    complex exotic options very well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分技术往往比栅格更快地收敛，并且很好地逼近复杂的异国期权。
- en: 'To solve a PDE by finite differences working backward in time, a discrete-time
    grid of size *M* by *N* is set up to reflect asset prices over a course of time,
    so that *S* and *t* take on the following values at each point on the grid:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有限差分向后工作来解决PDE，建立大小为*M*乘以*N*的离散时间网格，以反映一段时间内的资产价格，使得*S*和*t*在网格上的每个点上取以下值：
- en: It follows that by grid notation, *f[i,j]=f( idS, j dt)*. *S[max]* is a suitably
    large asset price that cannot be reached by the maturity time, *T*. Thus *dS*
    and *dt* are intervals between each node in the grid, incremented by price and
    time, respectively. The terminal condition at expiration time *T* for every value
    of *S* is *max(S − K, 0)* for a call option with strike *K* and *max(K − S, 0)*
    for a put option. The grid traverses backward from the terminal conditions, complying
    with the PDE while adhering to the boundary conditions of the grid, such as the
    payoff from an earlier exercise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由网格符号表示，*f[i,j]=f( idS, j dt)*。*S[max]*是一个适当大的资产价格，无法在到期时间*T*到达。因此*dS*和*dt*是网格中每个节点之间的间隔，分别由价格和时间递增。到期时间*T*的终端条件对于每个*S*的值是一个具有行权价*K*的看涨期权的*max(S
    − K, 0)*和一个具有行权价*K*的看跌期权的*max(K − S, 0)*。网格从终端条件向后遍历，遵守PDE，同时遵守网格的边界条件，例如早期行权的支付。
- en: The boundary conditions are defined values at the extreme ends of the nodes,
    where *i=0* and *i=N* for every time at *t*. Values at the boundaries are used
    to calculate the values of all other lattice nodes iteratively using the PDE.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 边界条件是节点的两端的定义值，其中*i=0*和*i=N*对于每个时间*t*。边界处的值用于使用PDE迭代计算所有其他格点的值。
- en: 'A visual representation of the grid is given in the following diagram. As *i*
    and *j* increase from the top-left corner of the grid, the price *S* tends toward
    *S[max]* (the maximum price possible) at the bottom-right corner of the grid:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的可视化表示如下图所示。当*i*和*j*从网格的左上角增加时，价格*S*趋向于网格的右下角的*S[max]*（可能的最高价格）：
- en: '![](Images/d8d7bd1b-8af0-4d25-bcdc-5ea644964aa5.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d8d7bd1b-8af0-4d25-bcdc-5ea644964aa5.png)'
- en: 'A number of ways to approximate the PDE are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 近似PDE的一些方法如下：
- en: 'Forward difference:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向差分：
- en: '![](Images/967661cb-b539-45f5-8a7f-999297c8d67d.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/967661cb-b539-45f5-8a7f-999297c8d67d.png)'
- en: 'Backward difference:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后向差分：
- en: '![](Images/1208b133-921f-4777-992a-5dbfa9349a1a.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1208b133-921f-4777-992a-5dbfa9349a1a.png)'
- en: 'Central or symmetric difference:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中心或对称差分：
- en: '![](Images/63ff2ce0-6167-479e-a73b-92aadde910b7.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/63ff2ce0-6167-479e-a73b-92aadde910b7.png)'
- en: 'The second derivative:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二阶导数：
- en: '![](Images/5886183c-bf2c-4320-8bbe-0ffbcc29da77.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5886183c-bf2c-4320-8bbe-0ffbcc29da77.png)'
- en: Once we have the boundary conditions set up, we can now apply an iterative approach
    using the explicit, implicit, or Crank-Nicolson method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们设置好边界条件，现在可以使用显式、隐式或Crank-Nicolson方法进行迭代处理。 '
- en: The explicit method
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式方法
- en: 'The explicit method for approximating *f[i,j]* is given by the following equation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 用于近似*f[i,j]*的显式方法由以下方程给出：
- en: '![](Images/cd4d03e8-dab2-4445-bfbe-4f353e2b5985.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cd4d03e8-dab2-4445-bfbe-4f353e2b5985.png)'
- en: 'Here, we can see that the first difference is the backward difference with
    respect to *t*, the second difference is the central difference with respect to
    *S*, and the third difference is the second-order difference with respect to *S*.
    When we rearrange the terms, we get the following equation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到第一个差分是关于*t*的后向差分，第二个差分是关于*S*的中心差分，第三个差分是关于*S*的二阶差分。当我们重新排列项时，我们得到以下方程：
- en: '![](Images/1c511137-07bc-420c-a905-b4084a60e3e4.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1c511137-07bc-420c-a905-b4084a60e3e4.png)'
- en: 'Where:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '![](Images/2f7a5ad4-5e48-42af-9366-c1d7818baf68.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2f7a5ad4-5e48-42af-9366-c1d7818baf68.png)'
- en: '![](Images/c5f4f25e-9d7a-484f-b8e5-336f01d49559.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5f4f25e-9d7a-484f-b8e5-336f01d49559.png)'
- en: 'Then:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '![](Images/0db97616-b3a6-44c4-92c8-9f97fb0af73b.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0db97616-b3a6-44c4-92c8-9f97fb0af73b.png)'
- en: '![](Images/496c44aa-5985-4a78-8cec-0e4111dbfcf2.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/496c44aa-5985-4a78-8cec-0e4111dbfcf2.png)'
- en: '![](Images/e3caf1b2-b486-4785-a6d9-40e6531a77ed.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e3caf1b2-b486-4785-a6d9-40e6531a77ed.png)'
- en: 'The iterative approach of the explicit method can be visually represented by
    the following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 显式方法的迭代方法可以通过以下图表进行可视化表示：
- en: '![](Images/2b4772e0-cba3-4545-b93f-c264c4f564a0.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2b4772e0-cba3-4545-b93f-c264c4f564a0.png)'
- en: Writing the finite difference base class
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有限差分基类
- en: Since we will be writing the explicit, implicit, and Crank-Nicolson methods
    of finite differences in Python, let's write a base class that inherits the common
    properties and functions of all three methods.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在Python中编写有限差分的显式、隐式和Crank-Nicolson方法，让我们编写一个基类，该基类继承了所有三种方法的共同属性和函数。
- en: 'We will create a class called `FiniteDifferences` that accepts and assigns
    all the required parameters in the `__init__` constructor method. The `price()`
    method is the entry point for invoking the specific finite difference scheme implementation,
    and will invoke these methods in the following order: `setup_boundary_conditions()`,
    `setup_coefficients()`, `traverse_grid()`, and `interpolate()`. These methods
    are explained as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`FiniteDifferences`的类，该类在`__init__`构造方法中接受并分配所有必需的参数。`price()`方法是调用特定有限差分方案实现的入口点，并将按以下顺序调用这些方法：`setup_boundary_conditions()`、`setup_coefficients()`、`traverse_grid()`和`interpolate()`。这些方法的解释如下：
- en: '`setup_boundary_conditions`: Sets up the boundary conditions of the grid structure
    as a NumPy two-dimensional array'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_boundary_conditions`：设置网格结构的边界条件为NumPy二维数组'
- en: '`setup_coefficients`: Sets up the necessary coefficients that are used for
    traversing the grid structure'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_coefficients`：设置用于遍历网格结构的必要系数'
- en: '`traverse_grid`: Iterates the grid structure backward in time, storing the
    calculated values toward the first column of the grid'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traverse_grid`：向后迭代网格结构，将计算值存储到网格的第一列'
- en: '`interpolate`: Using the final calculated values on the first column of the
    grid, this method will interpolate these values to find the option price that
    closely infers the initial stock price, `S0`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpolate`：使用网格第一列上的最终计算值，这种方法将插值这些值以找到最接近初始股价`S0`的期权价格'
- en: All of these methods are abstract methods that can be implemented by the derived
    classes. An exception type of `NotImplementedError` will be thrown should we forget
    to implement these methods.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都是可以由派生类实现的抽象方法。如果我们忘记实现这些方法，将抛出`NotImplementedError`异常类型。
- en: 'The base class with the mandatory methods should look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 基类应该包含以下强制方法：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Abstract base classes** (**ABCs**) provide a way to define interfaces for
    a class. The `@abstractmethod()` decorator declares abstract methods that child
    classes should implement. Unlike Java''s abstract methods, these methods may have
    an implementation and may be called via the `super()` mechanism from the class
    that overrides it.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象基类**（**ABCs**）提供了定义类接口的方法。`@abstractmethod()`装饰器声明了子类应该实现的抽象方法。与Java的抽象方法不同，这些方法可能有一个实现，并且可以通过`super()`机制从覆盖它的类中调用。'
- en: 'In addition to these methods, we would need to define `dS` and `dt`, the change
    in `S` per unit time, and the change in `T` per iteration, respectively. We can
    write these as class properties:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方法，我们还需要定义`dS`和`dt`，即每单位时间内`S`的变化和每次迭代中`T`的变化。我们可以将这些定义为类属性：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, add the `price()` method as the entry point that shows the steps in
    calling our discussed abstract methods:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`price()`方法添加为入口点，显示调用我们讨论的抽象方法的步骤：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A class for pricing European options using the explicit method of finite differences
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限差分的显式方法对欧式期权进行定价的类
- en: 'The Python implementation of finite differences by using the explicit method
    is given in the following `FDExplicitEu` class, which inherits from the `FiniteDifferences`
    class and overrides the required implementation methods:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式方法的有限差分的Python实现如下`FDExplicitEu`类，它继承自`FiniteDifferences`类并覆盖了所需的实现方法：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On completion of traversing the grid structure, the first column contains the
    present value of the initial asset prices at **t=0**. The `interp` function of
    NumPy is used to perform a linear interpolation to approximate the option value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 完成网格结构的遍历后，第一列包含**t=0**时刻的初始资产价格的现值。NumPy的`interp`函数用于执行线性插值以近似期权价值。
- en: Besides using linear interpolation as the most common choice for the interpolation
    method, the other methods such as the spline or cubic may be used to approximate
    the option value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线性插值作为插值方法的最常见选择外，还可以使用其他方法，如样条或三次插值来近似期权价值。
- en: Consider the example of a European put option. The underlying stock price is
    $50 with a volatility of 40 percent. The strike price of the put option is $50
    with an expiration time of five months. The risk-free rate is 10 percent.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个欧式看跌期权的例子。标的股票价格为50美元，波动率为40%。看跌期权的行权价为50美元，到期时间为五个月。无风险利率为10%。
- en: 'We can price this option using the explicit method with a `Smax` value of `100`,
    an `M` value of `100`, and an `N` value of `1000`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用显式方法对该期权进行定价，`Smax`值为`100`，`M`值为`100`，`N`值为`1000`：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What happens when other values of `M` and `N` are chosen improperly?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择其他不合适的`M`和`N`值时会发生什么？
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It appears that the explicit method of the finite difference scheme suffers
    from instability problems.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有限差分方案的显式方法存在不稳定性问题。
- en: The implicit method
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式方法
- en: 'The instability problem of the explicit method can be overcome using the forward
    difference with respect to time. The implicit method for approximating *f[i,j]*
    is given by the following equation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 显式方法的不稳定问题可以通过对时间的前向差分来克服。用于近似*f[i,j]*的隐式方法由以下方程给出：
- en: '![](Images/2b6e9a19-c56e-4d89-9da4-4fec358a90b3.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2b6e9a19-c56e-4d89-9da4-4fec358a90b3.png)'
- en: 'Here, it can be seen that the only difference between the implicit and explicit
    approximating scheme lies in the first difference, where the forward difference
    with respect to *t* is used in the implicit scheme. When we rearrange the terms,
    we get the following expression:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可以看到隐式和显式近似方案之间唯一的区别在于第一个差分，隐式方案中使用了对*t*的前向差分。当我们重新排列项时，我们得到以下表达式：
- en: '![](Images/2d290bf9-5f31-463a-819c-8efaed57c26b.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2d290bf9-5f31-463a-819c-8efaed57c26b.png)'
- en: 'Where:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '![](Images/1cd1639f-1740-4616-b9f7-9e45fb885cda.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1cd1639f-1740-4616-b9f7-9e45fb885cda.png)'
- en: '![](Images/7d83d409-627f-4267-b857-f714a158fad8.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7d83d409-627f-4267-b857-f714a158fad8.png)'
- en: 'Here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里：
- en: '![](Images/193c6822-3155-41e6-b4b8-110a15e4354d.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/193c6822-3155-41e6-b4b8-110a15e4354d.png)'
- en: '![](Images/3a7cd64e-4488-47fb-a3eb-588da2b9c77f.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3a7cd64e-4488-47fb-a3eb-588da2b9c77f.png)'
- en: '![](Images/42dc58ea-64de-49be-947b-5b397c2ada52.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/42dc58ea-64de-49be-947b-5b397c2ada52.png)'
- en: 'The iterative approach of the implicit scheme can be visually represented with
    the following diagram:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式方案的迭代方法可以用以下图表进行可视化表示：
- en: '![](Images/b760a196-4c5e-48a6-a6d3-67799d0a657b.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b760a196-4c5e-48a6-a6d3-67799d0a657b.png)'
- en: 'From the preceding diagram, we can note that values of *j+1* need to be computed
    before they can be used in the next iterative step, as the grid traverses backward.
    In the implicit scheme, the grid can be thought of as representing a system of
    linear equations at each iteration, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以注意到需要在下一次迭代步骤中计算出*j+1*的值，因为网格是向后遍历的。在隐式方案中，网格可以被认为在每次迭代中代表一个线性方程组，如下所示：
- en: '![](Images/8978c0d4-f8ef-421c-89e0-713504b1dcd4.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8978c0d4-f8ef-421c-89e0-713504b1dcd4.png)'
- en: 'By rearranging the terms, we get the following equation:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新排列项，我们得到以下方程：
- en: '![](Images/f23e2337-d4f1-458d-8409-1f55a40b9b69.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f23e2337-d4f1-458d-8409-1f55a40b9b69.png)'
- en: The linear system of equations can be represented in the form of *Ax = B*, where
    we want to solve values of *x* in each iteration. Since the matrix *A* is tri-diagonal,
    we can use the LU factorization, where *A=LU*, for faster computation. Remember
    that we solved the linear system of equations using LU decomposition in [Chapter
    2](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)*, The Importance of Linearity in
    Finance*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程组可以表示为*Ax = B*的形式，我们希望在每次迭代中解出*x*的值。由于矩阵*A*是三对角的，我们可以使用LU分解，其中*A=LU*，以加快计算速度。请记住，我们在[第2章](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)中使用LU分解解出了线性方程组，该章节名为《金融中的线性关系的重要性》。
- en: A class for pricing European options using the implicit method of finite differences
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限差分的隐式方法对欧式期权进行定价的类
- en: 'The Python implementation of the implicit scheme is given in the following
    `FDImplicitEu` class. We can inherit the implementation of the explicit method
    from the `FDExplicitEu` class we discussed earlier and override the necessary
    methods of interest, namely, the `setup_coefficients` and `traverse_grid` methods:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式方案的Python实现在以下`FDImplicitEu`类中给出。我们可以从之前讨论的`FDExplicitEu`类中继承显式方法的实现，并覆盖感兴趣的必要方法，即`setup_coefficients`和`traverse_grid`方法：
- en: '[PRE29]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using the same example as the explicit scheme, we can price the European put
    options using the implicit scheme:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与显式方案相同的示例，我们可以使用隐式方案定价欧式看跌期权：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Given the current parameters and input data, we can see that there are no stability
    issues with the implicit scheme.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于当前参数和输入数据，我们可以看到隐式方案没有稳定性问题。
- en: The Crank-Nicolson method
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crank-Nicolson方法
- en: 'Another way of avoiding the instability issue, as seen in the explicit method,
    is to use the Crank-Nicolson method. The Crank-Nicolson method converges much
    more quickly using a combination of the explicit and implicit methods, taking
    the average of both. This leads us to the following equation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免稳定性问题的方法，如显式方法中所见，是使用Crank-Nicolson方法。Crank-Nicolson方法通过使用显式和隐式方法的组合更快地收敛，取两者的平均值。这导致以下方程：
- en: '![](Images/a8840a9a-b4a3-408f-a0ba-a82b85b3767e.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a8840a9a-b4a3-408f-a0ba-a82b85b3767e.png)'
- en: 'This equation can also be rewritten as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程也可以重写如下：
- en: '![](Images/f847380f-ae9d-46f6-bfa1-2b17617b7e49.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f847380f-ae9d-46f6-bfa1-2b17617b7e49.png)'
- en: 'Where:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '![](Images/58d5e72d-41d6-4dad-bd00-d0cee25e8b34.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/58d5e72d-41d6-4dad-bd00-d0cee25e8b34.png)'
- en: 'The iterative approach of the implicit scheme can be visually represented with
    the following diagram:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式方案的迭代方法可以用以下图表形式表示：
- en: '![](Images/25895799-5f87-4158-970c-988563cc595c.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/25895799-5f87-4158-970c-988563cc595c.png)'
- en: 'We can treat the equations as a system of linear equations in a matrix form:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将方程视为矩阵形式的线性方程组：
- en: '![](Images/08f3b87b-e8dc-4d42-8a72-87b0e990a26f.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08f3b87b-e8dc-4d42-8a72-87b0e990a26f.png)'
- en: 'Where:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '![](Images/0955b807-c75c-47ac-8abd-2256d570b329.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0955b807-c75c-47ac-8abd-2256d570b329.png)'
- en: '![](Images/d26eccb2-880e-41b4-9ddd-302affc103b1.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d26eccb2-880e-41b4-9ddd-302affc103b1.png)'
- en: '![](Images/a92e8ca5-5361-478b-9cbf-85edad31fa45.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a92e8ca5-5361-478b-9cbf-85edad31fa45.png)'
- en: We can solve for the matrix *M* on every iterative procedure.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每个迭代过程中解出矩阵*M*。
- en: A class for pricing European options using the Crank-Nicolson method of finite
    differences
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限差分的Crank-Nicolson方法定价欧式期权的类
- en: 'The Python implementation of the Crank-Nicolson method is given in the following
    `FDCnEu` class, which inherits from the `FDExplicitEu` class and overrides only
    the `setup_coefficients` and `traverse_grid` methods:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Crank-Nicolson方法的Python实现在以下`FDCnEu`类中给出，该类继承自`FDExplicitEu`类，并仅覆盖`setup_coefficients`和`traverse_grid`方法：
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the same examples that we used with the explicit and implicit methods,
    we can price a European put option using the Crank-Nicolson method for different
    time point intervals:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与显式和隐式方法相同的示例，我们可以使用Crank-Nicolson方法为不同的时间点间隔定价欧式看跌期权：
- en: '[PRE32]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: From the observed values, the Crank-Nicolson method not only avoids the instability
    issue we saw in the explicit scheme, but also converges faster than both the explicit
    and implicit methods. The implicit method requires more iterations, or bigger
    values of *N*, to produce values close to those of the Crank-Nicolson method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从观察到的值来看，Crank-Nicolson方法不仅避免了我们在显式方案中看到的不稳定性问题，而且比显式和隐式方法都更快地收敛。隐式方法需要更多的迭代，或者更大的*N*值，才能产生接近Crank-Nicolson方法的值。
- en: Pricing exotic barrier options
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定价异国情调的障碍期权
- en: Finite differences are especially useful in pricing exotic options. The nature
    of the option will dictate the specifications of the boundary conditions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分在定价异国情调期权方面特别有用。期权的性质将决定边界条件的规格。
- en: In this section, we will take a look at an example of pricing a down-and-out
    barrier option with the Crank-Nicolson method of finite differences. Due to its
    relative complexity, other analytical methods, such as Monte Carlo methods, are
    usually employed in favor of finite difference schemes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个使用有限差分的Crank-Nicolson方法定价低迷障碍期权的例子。由于其相对复杂性，通常会使用其他分析方法，如蒙特卡罗方法，而不是有限差分方案。
- en: A down-and-out option
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种低迷的选择
- en: 'Let''s take a look at an example of a down-and-out option. At any time during
    the life of the option, should the underlying asset price fall below an *S[barrier]*
    barrier price, the option is considered worthless. Since, in the grid, the finite
    difference scheme represents all the possible price points, we only need to consider
    nodes with the following price range:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个低迷期权的例子。在期权的任何生命周期中，如果标的资产价格低于*S[barrier]*障碍价格，则认为该期权毫无价值。由于在网格中，有限差分方案代表所有可能的价格点，我们只需要考虑以下价格范围的节点：
- en: '![](Images/7aa99c36-a86a-45d1-b1d4-0b6f30bd9371.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7aa99c36-a86a-45d1-b1d4-0b6f30bd9371.png)'
- en: 'We can then set up the boundary conditions as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以设置边界条件如下：
- en: '![](Images/843cd7f2-7cec-4c82-b4bd-dc3debce8798.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/843cd7f2-7cec-4c82-b4bd-dc3debce8798.png)'
- en: A class for pricing down-and-out-options using the Crank-Nicolson method of
    finite differences
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限差分的Crank-Nicolson方法定价低迷期权的类
- en: 'Let''s create a class named `FDCnDo` that inherits from the `FDCnEu` class
    we discussed earlier. We will take into account the barrier price in the constructor
    method, while leaving the rest of the Crank-Nicolson implementation in the `FDCnEu`
    class unchanged:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`FDCnDo`的类，它继承自之前讨论的`FDCnEu`类。我们将在构造方法中考虑障碍价格，而将`FDCnEu`类中的Crank-Nicolson实现的其余部分保持不变：
- en: '[PRE33]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's consider an example of a down-and-out option. The underlying stock price
    is $50 with a volatility of 40 percent. The strike price of the option is $50
    with an expiration time of five months. The risk-free rate is 10 percent. The
    barrier price is $40.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个敲出期权的例子。标的股票价格为 50 美元，波动率为 40%。期权的行权价为 50 美元，到期时间为五个月。无风险利率为 10%。敲出价格为
    40 美元。
- en: 'We can price a call option and a put down-and-out option with `Smax` as `100`,
    `M` as `120`, and `N` as `500`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Smax` 为 `100`，`M` 为 `120`，`N` 为 `500` 来定价看涨期权和敲出看跌期权：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The prices of the down-and-out call and put options are $5.4916 and $0.5414,
    respectively.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 敲出看涨期权和敲出看跌期权的价格分别为 5.4916 美元和 0.5414 美元。
- en: Pricing American options with finite differences
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限差分定价美式期权
- en: So far, we have priced European options and exotic options. Due to the probability
    of an early exercise nature in American options, pricing such options is less
    straightforward. An iterative procedure is required in the implicit Crank-Nicolson
    method, where the payoffs from earlier exercises in the current period take into
    account the payoffs of an earlier exercise in the prior period. The Gauss-Siedel
    iterative method is proposed in the pricing of American options in the Crank-
    Nicolson method.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定价了欧式期权和奇异期权。由于美式期权中存在提前行权的可能性，因此定价此类期权并不那么直接。在隐式 Crank-Nicolson 方法中需要迭代过程，当前期内的提前行权收益要考虑先前期内的提前行权收益。在
    Crank-Nicolson 方法中，建议使用高斯-西德尔迭代方法定价美式期权。
- en: 'Recall that in [Chapter 2](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)*, The
    Importance of Linearity in Finance*, we covered the Gauss-Siedel method of solving
    systems of linear equations in the form of *Ax=B*. Here, the matrix *A* is decomposed
    into *A=L+U*, where *L* is a lower triangular matrix and *U* is an upper triangular
    matrix. Let''s take a look at an example of a 4 x 4 matrix, *A*:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，在[第2章](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)中，我们讨论了在金融中线性性的重要性，我们介绍了解决线性方程组的高斯-西德尔方法，形式为
    *Ax=B*。在这里，矩阵 *A* 被分解为 *A=L+U*，其中 *L* 是下三角矩阵，*U* 是上三角矩阵。让我们看一个 4 x 4 矩阵 *A* 的例子：
- en: '![](Images/6437c715-0e2b-426c-b17f-cbefd8a42c2b.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6437c715-0e2b-426c-b17f-cbefd8a42c2b.png)'
- en: 'The solution is then obtained iteratively, as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过迭代方式获得解决方案，如下所示：
- en: '![](Images/c141f535-da24-4178-a6a0-8500d7d7bd5a.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c141f535-da24-4178-a6a0-8500d7d7bd5a.png)'
- en: 'We can adapt the Gauss-Siedel method to our Crank-Nicolson implementation as
    follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将高斯-西德尔方法调整到我们的 Crank-Nicolson 实现中，如下所示：
- en: '![](Images/11cd3627-b98b-407a-b244-cc620283ca3c.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11cd3627-b98b-407a-b244-cc620283ca3c.png)'
- en: 'This equation satisfies the early exercise privilege equation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程满足提前行权特权方程：
- en: '![](Images/596908ed-7de4-4a12-ba73-f3b28424570a.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/596908ed-7de4-4a12-ba73-f3b28424570a.png)'
- en: A class for pricing American options using the Crank-Nicolson method of finite
    differences
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有限差分的 Crank-Nicolson 方法定价美式期权的类
- en: Let's create a class named `FDCnAm` that inherits from the `FDCnEu` class, which
    is the Crank-Nicolson method's counterpart for pricing European options. The `setup_coefficients`
    method may be reused, while overriding all other methods for the inclusion of
    payoffs from an earlier exercise, if any.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `FDCnAm` 的类，该类继承自 `FDCnEu` 类，后者是定价欧式期权的 Crank-Nicolson 方法的对应物。`setup_coefficients`
    方法可以被重用，同时覆盖所有其他方法，以包括先前行权的收益，如果有的话。
- en: 'The constructor `__init__()` and the `setup_boundary_conditions()` methods
    are given in the `FDCnAm` class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 构造函数和 `setup_boundary_conditions()` 方法在 `FDCnAm` 类中给出：'
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, implement the `traverse_grid()` method in the same class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在同一类中实现 `traverse_grid()` 方法：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In each iterative procedure of the `while` loop, the payoffs are calculated
    while taking into account the start and end boundaries. Furthermore, `new_values`
    are constantly replaced with new payoff calculations based on existing and previous
    values.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环的每个迭代过程中，计算收益时要考虑开始和结束边界。此外，`new_values` 不断根据现有和先前的值进行新的收益计算替换。
- en: 'At the start boundaries where the index is 0,the payoffs are calculated with
    the alpha values omitted. Implement the `calculate_payoff_start_boundary()` method
    inside the class:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始边界处，索引为 0 时，通过省略 alpha 值来计算收益。在类内实现 `calculate_payoff_start_boundary()` 方法：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the end boundary where the last index is, the payoffs are calculated with
    the gamma values omitted. Implement the `calculate_payoff_end_boundary()` method
    inside the class:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束边界处，最后一个索引时，通过省略 gamma 值来计算收益。在类内实现 `calculate_payoff_end_boundary()` 方法：
- en: '[PRE38]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For payoffs that are not at the boundaries, the payoffs are calculated by taking
    into account the alpha and gamma values. Implement the `calculate_payoff()` method
    inside the class:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不在边界的收益，通过考虑 alpha 和 gamma 值来计算收益。在类内实现 `calculate_payoff()` 方法：
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since the new variable, `values`, contains our terminal payoff values as a
    one-dimensional array, override the parent `interpolate` method to account for
    this change with the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新变量 `values` 包含我们的终端收益值作为一维数组，因此重写父类的 `interpolate` 方法以考虑这一变化，使用以下代码：
- en: '[PRE40]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The tolerance parameter is used in the Gauss-Siedel method as the convergence
    criterion. The `omega` variable is the over-relaxation parameter. Higher `omega`
    values provide faster convergence, but this also comes with higher possibilities
    of the algorithm not converging.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 容差参数用于高斯-西德尔方法的收敛标准。`omega` 变量是过度松弛参数。更高的 `omega` 值提供更快的收敛速度，但这也伴随着算法不收敛的可能性更高。
- en: 'Let''s price an American call-and-put option with an underlying asset price
    of 50 and volatility of 40 percent, a strike price of 50, a risk-free rate of
    10 percent, and an expiration date of five months. We choose a `Smax` value of
    `100`, `M` as `100`, `N` as `42`, an `omega` parameter value of `1.2`, and a tolerance
    value of `0.001`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定价一个标的资产价格为 50，波动率为 40%，行权价为 50，无风险利率为 10%，到期日为五个月的美式看涨期权和看跌期权。我们选择 `Smax`
    值为 `100`，`M` 为 `100`，`N` 为 `42`，`omega` 参数值为 `1.2`，容差值为 `0.001`：
- en: '[PRE41]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The prices of the call and put American stock options by using the Crank-Nicolson
    method are $6.109 and $4.2778, respectively.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Crank-Nicolson方法计算美式看涨和看跌期权的价格分别为6.109美元和4.2778美元。
- en: Putting it all together – implied volatility modeling
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起-隐含波动率建模
- en: 'In the option pricing methods we have learned so far, a number of parameters
    are assumed to be constant: interest rates, strike prices, dividends, and volatility.
    Here, the parameter of interest is volatility. In quantitative research, the volatility
    ratio is used to forecast price trends.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学到的期权定价方法中，有一些参数被假定为常数：利率、行权价、股息和波动率。在这里，感兴趣的参数是波动率。在定量研究中，波动率比率被用来预测价格趋势。
- en: To derive implied volatilities, we need to refer to [Chapter 3](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*,
    Nonlinearity in Finance*, where we discussed the root-finding methods of nonlinear
    functions. We will use the bisection method of numerical procedures in our next
    example to create an implied volatility curve.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要得出隐含波动率，我们需要参考[第3章](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*金融中的非线性*，在那里我们讨论了非线性函数的根查找方法。在我们的下一个示例中，我们将使用数值程序的二分法来创建一个隐含波动率曲线。
- en: Implied volatilities of the AAPL American put option
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AAPL美式看跌期权的隐含波动率
- en: 'Let''s consider the option data of the stock **Apple** (**AAPL**), which was
    gathered at the end of the day on October 3, 2014\. These details are provided
    in the following table. The option expires on December 20, 2014\. The prices listed
    are the mid-points of the bid and ask prices:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑股票**苹果**（**AAPL**）的期权数据，这些数据是在2014年10月3日收集的。以下表格提供了这些细节。期权到期日为2014年12月20日。所列价格为买入价和卖出价的中间价：
- en: '| **Strike price** | **Call price** | **Put price** |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| **行权价** | **看涨期权价格** | **看跌期权价格** |'
- en: '| 75 | 30 | 0.16 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 75 | 30 | 0.16 |'
- en: '| 80 | 24.55 | 0.32 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 80 | 24.55 | 0.32 |'
- en: '| 85 | 20.1 | 0.6 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 85 | 20.1 | 0.6 |'
- en: '| 90 | 15.37 | 1.22 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 90 | 15.37 | 1.22 |'
- en: '| 92.5 | 10.7 | 1.77 |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 92.5 | 10.7 | 1.77 |'
- en: '| 95 | 8.9 | 2.54 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 95 | 8.9 | 2.54 |'
- en: '| 97.5 | 6.95 | 3.55 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 97.5 | 6.95 | 3.55 |'
- en: '| 100 | 5.4 | 4.8 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 5.4 | 4.8 |'
- en: '| 105 | 4.1 | 7.75 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 105 | 4.1 | 7.75 |'
- en: '| 110 | 2.18 | 11.8 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 2.18 | 11.8 |'
- en: '| 115 | 1.05 | 15.96 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 115 | 1.05 | 15.96 |'
- en: '| 120 | 0.5 | 20.75 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 120 | 0.5 | 20.75 |'
- en: '| 125 | 0.26 | 25.8 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 125 | 0.26 | 25.8 |'
- en: The last traded price of AAPL was 99.62, with an interest rate of 2.48 percent
    and a dividend yield of 1.82 percent. The American options expire in 78 days.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: AAPL的最后交易价格为99.62美元，利率为2.48%，股息率为1.82%。美式期权在78天后到期。
- en: Using this information, let's create a new class named `ImpliedVolatilityModel`
    that accepts the stock option's parameters in the constructor. If required, import
    the `BinomialLROption` class that we created for the LR binomial tree we covered
    in the earlier section of this chapter, *A class for the LR binomial tree option
    pricing model*. The `bisection` function we covered in [Chapter 3](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*,
    Nonlinearity in Finance*, is also required.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些信息，让我们创建一个名为`ImpliedVolatilityModel`的新类，它在构造函数中接受股票期权的参数。如果需要，导入我们在本章前面部分介绍的用于LR二项树的`BinomialLROption`类。还需要导入我们在[第3章](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*金融中的非线性*中介绍的`bisection`函数。
- en: The `option_valuation()` method accepts the `K` strike price and the `sigma`
    volatility value to compute the value of the option. In this example, we are using
    the `BinomialLROption` pricing method.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`option_valuation()`方法接受`K`行权价和`sigma`波动率值，计算期权的价值。在这个例子中，我们使用`BinomialLROption`定价方法。'
- en: The `get_implied_volatilities()` method accepts a list of strike and option
    prices to compute the implied volatilities by the `bisection` method for every
    price available. Therefore, the length of the two lists must be the same.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_implied_volatilities()`方法接受一个行权价和期权价格的列表，通过`bisection`方法计算每个价格的隐含波动率。因此，这两个列表的长度必须相同。'
- en: 'The Python code for the `ImpliedVolatilityModel` class is given as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImpliedVolatilityModel`类的Python代码如下所示：'
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Import the `bisection` function we discussed in the previous chapter:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 导入我们在上一章讨论过的`bisection`函数：
- en: '[PRE43]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using this model, let''s find out the implied volatilities of the American
    put options using this particular set of data:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个模型，让我们使用这组特定数据找出美式看跌期权的隐含波动率：
- en: '[PRE44]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The implied volatility values are now stored in the `impvols_put` variable
    as a `list` object. Let''s plot these values against the strike prices to obtain
    an implied volatility curve:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 隐含波动率值现在以`list`对象的形式存储在`impvols_put`变量中。让我们将这些值绘制成隐含波动率曲线：
- en: '[PRE45]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This would give us the volatility smile, as shown in the following diagram.
    Here, we have modeled an LR tree with 77 steps, with each step representing one
    day:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们提供波动率微笑，如下图所示。在这里，我们建立了一个包含77个步骤的LR树，每一步代表一天：
- en: '![](Images/f5e906bf-b5cc-4c74-bc7a-1881acfd58e2.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f5e906bf-b5cc-4c74-bc7a-1881acfd58e2.png)'
- en: Of course, pricing an option daily may not be ideal since markets change by
    fractions of a millisecond. We used the bisection method to solve the implied
    volatility as implied by the binomial tree, as opposed to the realized volatility
    values directly observed from market prices.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每天定价一个期权可能并不理想，因为市场变化是以毫秒为单位的。我们使用了二分法来解决隐含波动率，这是由二项树隐含的，而不是直接从市场价格观察到的实现波动率值。
- en: Should we fit this curve against a polynomial curve to identify potential arbitrage
    opportunities? Or extrapolate the curve to derive further insights on potential
    opportunities from implied volatilities of far out-of-the-money and in-the-money
    options? Well, these questions are for option traders like yourself to find out!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该将这条曲线与多项式曲线拟合，以确定潜在的套利机会？或者推断曲线，以从远离实值和虚值期权的隐含波动率中获得更多见解？好吧，这些问题是供像你这样的期权交易员去发现的！
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a number of numerical procedures in derivative
    pricing, the most common being options. One such procedure is the use of trees,
    with binomial trees being the simplest structure to model asset information, where
    one node extends to two other nodes in each time step, representing an up state
    and a down state, respectively. In trinomial trees, each node extends to three
    other nodes in each time step, representing an up state, a down state, and a state
    with no movement, respectively. As the tree traverses upwards, the underlying
    asset is computed and represented at each node. The option then takes on the structure
    of this tree and, starting from the terminal payoffs, the tree traverses backward
    and toward the root, which converges to the current discounted option price. Besides
    binomial and trinomial trees, trees can take on the form of the CRR, Jarrow-Rudd,
    Tian, or LR parameters.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了衍生品定价中的一些数值程序，最常见的是期权。其中一种程序是使用树，二叉树是最简单的结构来建模资产信息，其中一个节点在每个时间步长延伸到另外两个节点，分别代表上升状态和下降状态。在三叉树中，每个节点在每个时间步长延伸到另外三个节点，分别代表上升状态、下降状态和无移动状态。随着树向上遍历，基础资产在每个节点处被计算和表示。然后期权采用这棵树的结构，并从期末回溯并向根部遍历，收敛到当前折现期权价格。除了二叉树和三叉树，树还可以采用CRR、Jarrow-Rudd、Tian或LR参数的形式。
- en: By adding another layer of nodes around our tree, we introduced additional information
    from which we can derive the Greeks, such as the delta and gamma, without incurring
    additional computational costs.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的树周围添加另一层节点，我们引入了额外的信息，从中我们可以推导出希腊字母，如delta和gamma，而不会产生额外的计算成本。
- en: Lattices were introduced as a way of saving storage costs over binomial and
    trinomial trees. In lattice pricing, nodes with new information are saved only
    once and reused later on nodes that require no change in the information.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格被引入是为了节省存储成本，相比二叉树和三叉树。在晶格定价中，只保存具有新信息的节点一次，并在以后需要不改变信息的节点上重复使用。
- en: We also discussed the finite difference schemes in option pricing, consisting
    of terminal and boundary conditions. From the terminal conditions, the grid traverses
    backward in time using the explicit method, implicit method, and the Crank- Nicolson
    method. Besides pricing European and American options, finite difference pricing
    schemes can be used to price exotic options, where we looked at an example of
    pricing a down-and-out barrier option.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了期权定价中的有限差分方案，包括期末和边界条件。从期末条件开始，网格使用显式方法、隐式方法和Crank-Nicolson方法向后遍历时间。除了定价欧式和美式期权，有限差分定价方案还可以用于定价异国期权，我们看了一个定价下触及障碍期权的例子。
- en: By importing the bisection root-finding method learned about in [Chapter 3](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)*,
    Nonlinearity in Finance*, and the binomial LR tree model in this chapter, we used
    market prices of an American option to create an implied volatility curve for
    further studies.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入在[第3章](ae0a23e9-876c-43b3-9f48-d1d810f1fb97.xhtml)中学到的二分根查找方法，以及本章中的二叉LR树模型，我们使用美式期权的市场价格来创建隐含波动率曲线以进行进一步研究。
- en: In the next chapter, we will take a look at modeling interest rates and derivatives.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究利率和衍生品建模。
