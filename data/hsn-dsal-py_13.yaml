- en: Design Techniques and Strategies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计技术和策略
- en: In this chapter, we take a step back and look at broader topics in computer
    algorithm design. As your experience with programming grows, certain patterns
    start to become apparent. The world of algorithms contains a plethora of techniques
    and design principles. A mastery of these techniques is required to tackle harder
    problems in the field.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们退一步，关注计算机算法设计中更广泛的主题。随着编程经验的增长，某些模式开始变得明显。算法的世界包含了大量的技术和设计原则。掌握这些技术是解决该领域更难问题所必需的。
- en: In this chapter, we will discuss the ways in which different kinds of algorithms
    can be categorized. Design techniques will be described and illustrated. We will
    also further discuss the analysis of algorithms. Finally, we will provide detailed
    implementations for a few very important algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论不同类型算法的分类方式。将描述和说明设计技术。我们还将进一步讨论算法分析。最后，我们将提供一些非常重要算法的详细实现。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The classification of algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的分类
- en: Various algorithm design methodologies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种算法设计方法
- en: The implementation and explanation of various important algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种重要算法的实现和解释
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code used in this chapter is available at the following GitHub link:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的源代码可在以下GitHub链接中找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.7-Second-Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.7-Second-Edition/tree/master/Chapter13).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.7-Second-Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.7-Second-Edition/tree/master/Chapter13)。'
- en: Classification of algorithms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法的分类
- en: 'There are a number of classification schemes, based on what the algorithm is
    designed to achieve. In previous chapters, we implemented various algorithms.
    The question to ask is: do these algorithms share the same form or any similarities? If
    the answer is yes, then ask: what are the similarities and characteristics being
    used as the basis for comparison? If the answer is no, then can the algorithms
    be grouped into classes?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于算法设计的目标，有许多分类方案。在之前的章节中，我们实现了各种算法。要问的问题是：这些算法是否具有相同的形式或相似之处？如果答案是肯定的，那么问：作为比较基础使用的相似之处和特征是什么？如果答案是否定的，那么这些算法能否被分成类别？
- en: These are the questions that we will discuss in the subsequent subsections.
    Here we present the major methods for classifying algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在随后的小节中讨论的问题。这里我们介绍了分类算法的主要方法。
- en: Classification by implementation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按实现分类
- en: When translating a series of steps or processes into a working algorithm, there
    are a number of forms that it may take. The heart of the algorithm may employ
    one or more of the following assets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列步骤或流程翻译成工作算法时，可能采用多种形式。算法的核心可能使用以下一个或多个资产。
- en: Recursion
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Recursive algorithms are the ones that call themselves to repeatedly execute
    code until a certain condition is satisfied. Some problems are more easily expressed
    by implementing their solution through recursion. One classic example is the Towers
    of Hanoi.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法是指调用自身以重复执行代码直到满足某个条件的算法。有些问题通过递归实现它们的解决方案更容易表达。一个经典的例子是汉诺塔。
- en: In simple terms, an iterative function is one that loops to repeat some part
    of the code, and a recursive function is one that calls itself to repeat the code.
    An iterative algorithm, on the other hand, uses a series of steps or a repetitive
    construct to formulate a solution; it iteratively executes a part of the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，迭代函数是循环执行代码的一部分，而递归函数是调用自身来重复执行代码的函数。另一方面，迭代算法使用一系列步骤或重复结构来制定解决方案；它迭代执行代码的一部分。
- en: This repetitive construct could be a simple `while` loop, or any other kind
    of loop. Iterative solutions also come to mind more easily than their recursive
    implementations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复结构可以是一个简单的`while`循环，或者任何其他类型的循环。迭代解决方案也比递归实现更容易想到。
- en: Logic
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑
- en: One implementation of an algorithm is expressing it as a controlled logical
    deduction. This logic component is comprised of the axioms that will be used in
    the computation. The control component determines the manner in which deduction
    is applied to the axioms. This is expressed in the form a*lgorithm = logic + control*.
    This forms the basis of the logic programming paradigm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的一种实现是将其表达为受控逻辑推导。这个逻辑组件由将在计算中使用的公理组成。控制组件确定了推导应用到公理的方式。这表达为形式a*lgorithm =
    logic + control*。这构成了逻辑编程范式的基础。
- en: The logic component determines the meaning of the algorithm. The control component
    only affects its efficiency. Without modifying the logic, the efficiency can be
    improved by improving the control component.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑组件决定了算法的含义。控制组件只影响其效率。在不修改逻辑的情况下，可以通过改进控制组件来提高效率。
- en: Serial or parallel algorithms
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行或并行算法
- en: The RAM model of most computers allows for the assumption that computing is
    carried out one instruction at a time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机的RAM模型允许假设计算是一次执行一条指令的。
- en: Serial algorithms, also known as **sequential algorithms**, are algorithms that
    are executed sequentially. Execution commences from start to finish without any
    other execution procedure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 串行算法，也称为**顺序算法**，是按顺序执行的算法。执行从开始到结束进行，没有其他执行过程。
- en: To be able to process several instructions at once, a different model or computing
    technique is required. Parallel algorithms perform more than one operation at
    a time. In the PRAM model, there are serial processors that share a global memory.
    The processors can also perform various arithmetic and logical operations in parallel.
    This enables the execution of several instructions at one time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够同时处理多条指令，需要不同的模型或计算技术。并行算法可以同时执行多个操作。在PRAM模型中，有共享全局内存的串行处理器。处理器还可以并行执行各种算术和逻辑操作。这使得可以同时执行多条指令。
- en: Parallel/distributed algorithms divide a problem into subproblems among its
    processors to collect the results. Some sorting algorithms can be efficiently
    parallelized, while iterative algorithms are generally parallelizable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 并行/分布式算法将问题分解成子问题，分配给处理器来收集结果。一些排序算法可以有效地并行化，而迭代算法通常是可并行化的。
- en: Deterministic versus nondeterministic algorithms
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定性与非确定性算法
- en: Deterministic algorithms produce the same output without fail every time the
    algorithm is run with the same input. There are some sets of problems that are
    so complex in the design of their solutions that expressing their solution in
    a deterministic way can be a challenge.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性算法每次以相同的输入运行时都会产生相同的输出。有一些问题的解决方案设计非常复杂，以至于以确定性的方式表达它们的解决方案可能是一个挑战。
- en: Nondeterministic algorithms can change the order of execution or some internal
    subprocess, leading to a change in the final result each time the algorithm is
    run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性算法可以改变执行顺序或某些内部子过程，导致每次运行算法时最终结果都会发生变化。
- en: As such, with every run of a nondeterministic algorithm, the output of the algorithm
    will be different. For instance, an algorithm that makes use of a probabilistic
    value will yield different outputs on successive executions, depending on the
    value of the random number generated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次运行非确定性算法时，算法的输出都会不同。例如，使用概率值的算法将根据生成的随机数的值，在连续执行时产生不同的输出。
- en: Classification by complexity
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按复杂度分类
- en: To determine the complexity of an algorithm is to estimate how much space (memory)
    and time is needed during computation or program execution. Generally, the performance
    of the two algorithms is compared with their complexity. The lower complexity
    algorithm—that is, the one requiring less space and time to perform a given task—is
    preferred.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确定算法的复杂度是为了估计在计算或程序执行期间需要多少空间（内存）和时间。通常，通过它们的复杂度来比较两个算法的性能。较低复杂度的算法，即执行给定任务所需的空间和时间较少的算法，更受青睐。
- en: Chapter 3, *Principles of Algorithm Design*, presents more comprehensive coverage
    of complexity. We will summarize what we have learned here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章《算法设计原理》更全面地介绍了复杂性。我们将在这里总结我们所学到的内容。
- en: Complexity curves
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度曲线
- en: Let's consider a problem of magnitude *n*. To determine the time complexity
    of an algorithm, we denote it with **T**(n). The value may fall under **O**(*1*),
    **O**(*log n*), **O**(*n*), **O**(*n log(n)*), **O**(*n²*), **O**(*n³*), or **O**(*2^n*).
    Depending on the steps an algorithm performs, the time complexity may or may not
    be affected. The notation **O**(*n*) captures the growth rate of an algorithm.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个规模为n的问题。为了确定算法的时间复杂度，我们用T(n)表示。该值可能属于O(1)、O(log n)、O(n)、O(n log(n))、O(n²)、O(n³)或O(2^n)。根据算法执行的步骤，时间复杂度可能会受到影响。符号O(n)捕捉了算法的增长率。
- en: Let's now examine a practical scenario, to determine which algorithm is better
    for solving a given problem. How do we come to the conclusion that the bubble
    sort algorithm is slower than the quick sort algorithm? Or, in general, how do
    we measure the efficiency of one algorithm against the other?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来考虑一个实际的场景，来确定哪种算法更适合解决给定的问题。我们如何得出冒泡排序算法比快速排序算法慢的结论？或者，一般来说，我们如何衡量一个算法相对于另一个算法的效率？
- en: Well, we can compare the Big **O** of any number of algorithms to determine
    their efficiency. This approach gives us a time measure or growth rate, which
    charts the behavior of the algorithm as *n* gets bigger.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以比较任意数量的算法的大O来确定它们的效率。这种方法给我们提供了一个时间度量或增长率，它描述了算法在n变大时的行为。
- en: 'Here is a graph of the different runtimes that an algorithm''s performance
    may fall under:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个图表，显示了算法性能可能属于的不同运行时间：
- en: '![](Images/92ff52c1-8d4d-4f7a-901f-117345b34c1d.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/92ff52c1-8d4d-4f7a-901f-117345b34c1d.png)'
- en: In ascending order, the list of runtimes from best to worst is **O(1)**, **O(log
    n)**, **O(*n*)**, **O(*n log n*)**, **O(*n²*)**, **O(*n³*)**, and **O(*2^n*)**.
    Therefore, if an algorithm has a time complexity of **O****(1)**, and another
    algorithm for the same task has the complexity **O(log n),** the first algorithm
    should be preferred.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按照从最好到最差的顺序，运行时间的列表为O(1)、O(log n)、O(n)、O(n log n)、O(n²)、O(n³)和O(2^n)。因此，如果一个算法的时间复杂度为O(1)，而另一个算法的复杂度为O(log
    n)，应该选择第一个算法。
- en: Classification by design
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按设计分类
- en: In this section, we present categories of algorithms based on their design.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们根据它们的设计提出了算法的分类。
- en: A given problem may have a number of solutions. When these solutions are analyzed,
    it is observed that each one follows a certain pattern or technique. We can categorize
    the algorithms based on how they solve the problem, as in the following subsections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给定的问题可能有多种解决方案。当分析这些解决方案时，可以观察到每个解决方案都遵循某种模式或技术。我们可以根据它们解决问题的方式对算法进行分类，如下面的小节所示。
- en: Divide and conquer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之
- en: This approach to problem-solving is just as its name suggests. To solve (conquer)
    a certain problem, the algorithm divides it into subproblems that can easily be
    solved. Further, the solutions to each of these subproblems are combined in such
    a way that the final solution is the solution of the original problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题解决方法正如其名称所示。为了解决（征服）某个问题，算法将其分解为可以轻松解决的子问题。此外，这些子问题的解决方案被组合在一起，以便最终解决方案是原始问题的解决方案。
- en: The way in which the problems are broken down into smaller subproblems is mostly
    done by recursion. We will examine this technique in detail in the subsequent
    subsections. Some algorithms that use this technique include merge sort, quick
    sort, and binary search.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题被分解为更小的子问题的方式大多是通过递归完成的。我们将在随后的小节中详细讨论这种技术。使用这种技术的一些算法包括归并排序、快速排序和二分查找。
- en: Dynamic programming
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划
- en: This technique is similar to divide and conquer, in that a problem is broken
    down into smaller problems. However, in divide and conquer, each subproblem has
    to be solved before its results can be used to solve bigger problems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与分而治之类似，即将问题分解为更小的问题。然而，在分而治之中，必须先解决每个子问题，然后才能用其结果来解决更大的问题。
- en: By contrast, dynamic programming does not compute the solution to an already
    encountered subproblem. Rather, it uses a remembering technique to avoid the recomputation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，动态规划不会计算已经遇到的子问题的解决方案。相反，它使用一种记忆技术来避免重新计算。
- en: Dynamic programming problems have two characteristics—**optimal substructure**,
    and **overlapping subproblem**. We will discuss this further in the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划问题具有两个特征——**最优子结构**和**重叠子问题**。我们将在下一节进一步讨论这一点。
- en: Greedy algorithms
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: It may be quite difficult to determine the best solution for a certain problem.
    To overcome this, we resort to an approach where we select the most promising
    choice from multiple available options or choices.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确定某个问题的最佳解决方案可能会非常困难。为了克服这一点，我们采用一种方法，从多个可用选项或选择中选择最有前途的选择。
- en: With greedy algorithms, the guiding rule is to always select the option that
    yields the most beneficial results and to continue doing that, hoping to reach
    a perfect solution. This technique aims to find a global optimal final solution
    by making a series of local optimal choices. The local optimal choice seems to
    lead to the solution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贪婪算法，指导规则是始终选择产生最有利的结果的选项，并继续这样做，希望达到完美的解决方案。这种技术旨在通过一系列局部最优选择找到全局最优的最终解决方案。局部最优选择似乎导致解决方案。
- en: Technical implementation
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术实现
- en: Let's dig into the implementation of some of the theoretical programming techniques
    we have discussed. We start with dynamic programming.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入讨论一些我们讨论过的理论编程技术的实现。我们从动态规划开始。
- en: Implementation using dynamic programming
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态规划进行实现
- en: As we have already described, in this approach, we divide a given problem into
    smaller subproblems. In finding the solution, care is taken not to recompute any
    of the previously encountered subproblems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经描述的，在这种方法中，我们将给定的问题分解为更小的子问题。在找到解决方案时，要注意不要重新计算任何先前遇到的子问题。
- en: This sounds a bit like recursion, but things are a little different here. A
    problem may lend itself to being solved by using dynamic programming, but will
    not necessarily take the form of making recursive calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点像递归，但这里有些不同。一个问题可能适合使用动态规划来解决，但不一定需要形成递归调用的形式。
- en: One property that makes a problem an ideal candidate for being solved with dynamic
    programming is that it has an **overlapping set of subproblems**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使问题成为动态规划的理想候选者的一个特性是它具有**重叠的子问题集**。
- en: Once we realize that the form of subproblems has repeated itself during computation,
    we need not compute it again. Instead, we return a pre-computed result for that previously
    encountered subproblem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们意识到在计算过程中子问题的形式已经重复，我们就不需要再次计算它。相反，我们返回先前遇到的子问题的预先计算结果。
- en: To ensure that we never have to re-evaluate a subproblem, we need an efficient
    way to store the results of each subproblem. The following two techniques are
    readily available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们永远不必重新评估子问题，我们需要一种有效的方法来存储每个子问题的结果。以下两种技术是readily available。
- en: Memoization
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: This technique starts from the initial problem set, and divides it into small
    subproblems. After the solution to a subprogram has been determined, we store
    the result to that particular subproblem. In the future, when this subproblem
    is encountered, we only return its pre-computed result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术从初始问题集开始，将其分解为小的子问题。在确定了子程序的解决方案之后，我们将结果存储到该特定子问题中。将来，当遇到这个子问题时，我们只返回其预先计算的结果。
- en: Tabulation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制表
- en: In tabulation, we fill a table with solutions to subproblems, and then combine
    them to solve bigger problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在制表中，我们填充一个表格，其中包含子问题的解决方案，然后将它们组合起来解决更大的问题。
- en: The Fibonacci series
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斐波那契数列
- en: Let's consider an example to understand how dynamic programming works. We use
    the Fibonacci series to illustrate both the memoization and tabulation techniques.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子来理解动态规划的工作原理。我们使用斐波那契数列来说明记忆化和制表技术。
- en: 'The Fibonacci series can be demonstrated using a recurrence relation. Recurrence
    relations are recursive functions that are used to define mathematical functions
    or sequences. For example, the following recurrence relation defines the Fibonacci
    sequence [1, 1, 2, 3, 5, 8 ...]:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列可以使用递推关系来演示。递推关系是用来定义数学函数或序列的递归函数。例如，以下递推关系定义了斐波那契数列[1, 1, 2, 3, 5, 8
    ...]：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the Fibonacci sequence can be generated by putting the values of *n*
    in sequence [1, 2, 3, 4, ...].
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，斐波那契数列可以通过将*n*的值放入序列[1, 2, 3, 4, ...]来生成。
- en: The memoization technique
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化技术
- en: 'Let''s generate the Fibonacci series to the fifth term:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成斐波那契数列的前五项：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A recursive-style program to generate the sequence would be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 生成序列的递归式程序如下：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code is very simple, but a little tricky to read because of the recursive
    calls being made that end up solving the problem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，但由于递归调用的存在，读起来有点棘手，因为最终解决了问题。
- en: When the base case is met, the `fib()` function returns 1\. If *n* is equal
    to or less than 2, the base case is met.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足基本情况时，`fib()`函数返回1。如果*n*等于或小于2，则满足基本情况。
- en: 'If the base case is not met, we will call the `fib()` function again, and this
    time supply the first call with `n-1`, and the second with `n-2`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未满足基本情况，我们将再次调用`fib()`函数，并这次将第一个调用提供`n-1`，第二个提供`n-2`：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The layout of the strategy to solve the `i^(th)` term in the Fibonacci sequence
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解决斐波那契数列中的第`i^(th)`项的策略布局如下：
- en: '![](Images/d80891b2-a57d-4b44-9630-76fafc37a303.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d80891b2-a57d-4b44-9630-76fafc37a303.png)'
- en: Careful observation of the tree diagram shows some interesting patterns. The
    call to **fib(1)** happens twice. The call to **fib(2)** happens thrice. Also,
    the call to **fib(3)** happens twice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对树状图的仔细观察显示了一些有趣的模式。对**fib(1)**的调用发生了两次。对**fib(2)**的调用发生了三次。此外，对**fib(3)**的调用发生了两次。
- en: The return values of the same function call never change; for example, the return
    value for **fib(2)** will always be the same whenever we call it. It will also
    be the same for **fib(1)** and **fib(3)**. Thus, computational time will be wasted
    if we compute again whenever we encounter the same function, since the same result
    is returned.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 相同函数调用的返回值永远不会改变；例如，每当我们调用**fib(2)**时，其返回值始终相同。**fib(1)**和**fib(3)**也是如此。因此，如果我们每次遇到相同的函数时都重新计算，将浪费计算时间，因为返回的结果相同。
- en: These repeated calls to a function with the same parameters and output suggest
    that there is an overlap. Certain computations reoccur down in the smaller subproblems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对具有相同参数和输出的函数的重复调用表明存在重叠。某些计算在较小的子问题中重复出现。
- en: A better approach is to store the results of the computation of **fib(1)** the
    first time it is encountered. Similarly, we should store return values for **fib(2)**
    and **fib(3)**. Later, anytime we encounter a call to **fib(1)**, **fib(2)**,
    or **fib(3)**, we simply return their respective results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是在首次遇到**fib(1)**时存储计算结果。同样，我们应该存储**fib(2)**和**fib(3)**的返回值。稍后，每当我们遇到对**fib(1)**、**fib(2)**或**fib(3)**的调用时，我们只需返回它们各自的结果。
- en: 'The diagram of our `fib` calls will now look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fib`调用的图现在看起来像这样：
- en: '![](Images/f7165fe9-182b-46e1-9d5d-e83ea6187486.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f7165fe9-182b-46e1-9d5d-e83ea6187486.png)'
- en: We have eliminated the need to compute **fib(3)**, fib(2), and **fib(1)** if
    they are encountered multiple times. This typifies the memoization technique,
    wherein there is no recomputation of overlapping calls to functions when breaking
    a problem into its subproblems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多次遇到，我们已经消除了计算**fib(3)**，fib(2)和**fib(1)**的需要。这是备忘录技术的典型，其中在将问题分解为子问题时，不会重新计算重叠调用函数。
- en: 'The overlapping function calls in our Fibonacci example are **fib(1)**, **fib(2)**,
    and **fib(3)**:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们斐波那契示例中的重叠函数调用是**fib(1)**、**fib(2)**和**fib(3)**：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To create a list of 1,000 elements, we do the following and pass it to the
    lookup parameter of the `dyna_fib` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含1,000个元素的列表，我们执行以下操作，并将其传递给`dyna_fib`函数的lookup参数：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This list will store the value of the computation of the various calls to the `dyna_fib()`
    function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表将存储对`dyna_fib()`函数的各种调用的计算值：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any call to the `dyna_fib()` function with *n* being less than or equal to 2
    will return 1\. When `dyna_fib(1)` is evaluated, we store the value at index 1
    of `map_set`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dyna_fib()`函数的任何小于或等于2的*n*的调用都将返回1。当评估`dyna_fib(1)`时，我们将值存储在`map_set`的索引1处。
- en: 'Write the condition for `lookup[n]` as the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将`lookup[n]`的条件写为以下内容：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We pass lookup so that it can be referenced when evaluating the subproblems.
    The calls to `dyna_fib(n-1, lookup)` and `dyna_fib(n-2, lookup)` are stored in
    `lookup[n]`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递lookup，以便在评估子问题时可以引用它。对`dyna_fib(n-1, lookup)`和`dyna_fib(n-2, lookup)`的调用存储在`lookup[n]`中。
- en: When we run our updated implementation of the function to find the `*i*^(th)`
    term of the Fibonacci series, we can see a considerable improvement. This implementation
    runs much faster than our initial implementation. Supply the value 20 to both
    implementations, and witness the difference in the execution speed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行函数的更新实现以找到斐波那契数列的第`*i*^(th)`项时，我们可以看到显着的改进。这个实现比我们最初的实现运行得快得多。将值20提供给这两个实现，并观察执行速度的差异。
- en: However, the updated algorithm has sacrificed space complexity to achieve this,
    because of the use of additional memory in storing the results of the function
    calls.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于使用额外的内存存储函数调用的结果，更新后的算法牺牲了空间复杂度。
- en: The tabulation technique
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格法
- en: A second technique in dynamic programming involves the use of a table of results,
    or matrix in some cases, to store the results of computations for later use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划中的第二种技术涉及使用结果表或在某些情况下使用矩阵来存储计算结果以供以后使用。
- en: 'This approach solves the bigger problem by first working out a route to the
    final solution. In the case of the `fib()` function, we develop a table with the
    values of `fib(1)` and `fib(2)` predetermined. Based on these two values, we will
    work our way up to `fib(n)`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过首先解决最终解决方案的路径来解决更大的问题。对于`fib()`函数，我们开发了一个表，其中预先确定了`fib(1)`和`fib(2)`的值。基于这两个值，我们将逐步计算`fib(n)`：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `results` variable stores the values 1 and 1 at indices 0 and 1\. This represents
    the return values of `fib(1)` and `fib(2)`. To calculate the values of the `fib()`
    function for values higher than 2, we simply call the `for` loop, which appends
    the sum of the `results[i-1] + results[i-2]` to the list of results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`results`变量在索引0和1处存储值1和1。这代表`fib(1)`和`fib(2)`的返回值。要计算大于2的值的`fib()`函数的值，我们只需调用`for`循环，将`results[i-1]
    + results[i-2]`的和附加到结果列表中。'
- en: Implementation using divide and conquer
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分治法实现
- en: This programming approach to problem-solving emphasizes the need to break down
    a problem into smaller subproblems of the same type or form of the original problem.
    These subproblems are solved and combined to obtain the solution of the original
    problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程方法强调将问题分解为与原始问题相同类型或形式的较小子问题的需要。这些子问题被解决并组合以获得原始问题的解决方案。
- en: The following three steps are associated with this kind of programming.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个步骤与这种编程相关。
- en: Divide
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 划分
- en: To divide means to break down an entity or problem. Here, we devise the means
    to break down the original problem into subproblems. We can achieve this through
    iterative or recursive calls.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 划分意味着分解实体或问题。在这里，我们设计手段将原始问题分解为子问题。我们可以通过迭代或递归调用来实现这一点。
- en: Conquer
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 征服
- en: It is impossible to continue breaking the problems into subproblems indefinitely.
    At some point, the smallest indivisible problem will return a solution. Once this
    happens, we can reverse our thought process and say that if we know the solution
    to the smallest subproblem, we can obtain the final solution to the original problem.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无法无限地继续将问题分解为子问题。在某个时候，最小的不可分割问题将返回一个解决方案。一旦这种情况发生，我们可以扭转我们的思维过程，并说如果我们知道最小子问题的解决方案，我们就可以获得原始问题的最终解决方案。
- en: Merge
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并
- en: To obtain the final solution, we need to combine the solutions to the smaller
    problems in order to solve the bigger problem.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到最终解决方案，我们需要结合较小问题的解决方案来解决更大的问题。
- en: There are other variants to the divide and conquer algorithms, such as merge
    and combine, and conquer and solve. Many algorithms make use of the divide and
    conquer principle, such as merge sorting, quick sort, and Strassen's matrix multiplication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他变体的分而治之算法，例如合并和组合，征服和解决。许多算法使用分而治之原则，例如归并排序、快速排序和Strassen矩阵乘法。
- en: We will now describe implementation of a merge sort algorithm, as we saw earlier
    in Chapter 3, *Principles of Algorithm Design*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将描述归并排序算法的实现，就像我们在第3章“算法设计原理”中看到的那样。
- en: Merge sort
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: Merge sort algorithms are based on the divide and conquer rule. Given a list
    of unsorted elements, we split the list into two approximate halves. We continue
    to divide the list into two halves recursively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法基于分而治之的原则。给定一列未排序的元素，我们将列表分成两个近似的部分。我们继续递归地将列表分成两半。
- en: 'After a while, the sublists created as a result of the recursive call will
    contain only one element. At that point, we begin to merge the solutions in the
    conquer or merge step:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间，由于递归调用而创建的子列表将只包含一个元素。在那时，我们开始在征服或合并步骤中合并解决方案：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our implementation starts by accepting the list of unsorted elements into the
    `merge_sort` function. The `if` statement is used to establish the base case,
    where, if there is only one element in the `unsorted_list`, we simply return that
    list again. If there is more than one element in the list, we find the approximate
    middle using `mid_point = int((len(unsorted_list)) // 2)`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现从将未排序的元素列表传递到`merge_sort`函数开始。`if`语句用于建立基本情况，即如果`unsorted_list`中只有一个元素，我们只需再次返回该列表。如果列表中有多于一个元素，我们使用`mid_point
    = int((len(unsorted_list)) // 2)`找到近似中间位置。
- en: 'Using this `mid_point`, we divide the list into two sublists, namely, `first_half`
    and `second_half`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`mid_point`，我们将列表分成两个子列表，即`first_half`和`second_half`：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A recursive call is made by passing the two sublists to the `merge_sort` function
    again:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这两个子列表再次传递给`merge_sort`函数来进行递归调用：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now for the merge step. When `half_a` and `half_b` have been passed their values,
    we call the `merge` function, which will merge or combine the two solutions stored
    in `half_a` and `half_b`, which are lists:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是合并步骤。当`half_a`和`half_b`传递了它们的值后，我们调用`merge`函数，该函数将合并或组合存储在`half_a`和`half_b`中的两个解决方案，即列表：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `merge` function takes the two lists we want to merge together, `first_sublist`
    and `second_sublist`. The `i` and `j` variables are initialized to 0, and are
    used as pointers to tell us where we are in the two lists with respect to the
    merging process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`函数接受我们要合并的两个列表`first_sublist`和`second_sublist`。`i`和`j`变量被初始化为0，并用作指针，告诉我们在合并过程中两个列表的位置。'
- en: 'The final `merged_list` will contain the merged list:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`merged_list`将包含合并后的列表：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `while` loop starts comparing the elements in `first_sublist` and `second_sublist`.
    The `if` statement selects the smaller of the two, `first_sublist[i]` or `second_sublist[j]`,
    and appends it to `merged_list`. The `i` or `j` index is incremented to reflect
    where we are with the merging step. The `while` loop stops when either sublist is
    empty.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环开始比较`first_sublist`和`second_sublist`中的元素。`if`语句选择两者中较小的一个，`first_sublist[i]`或`second_sublist[j]`，并将其附加到`merged_list`。`i`或`j`索引递增以反映我们在合并步骤中的位置。当任一子列表为空时，`while`循环停止。'
- en: There may be elements left behind in either `first_sublist` or `second_sublist`.
    The last two `while` loops make sure that those elements are added to `merged_list`
    before it is returned.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有元素留在`first_sublist`或`second_sublist`中。最后两个`while`循环确保这些元素在返回`merged_list`之前被添加。
- en: The last call to `merge(half_a, half_b)` will return the sorted list.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对`merge(half_a, half_b)`的最后调用将返回排序后的列表。
- en: 'Let''s give the algorithm a dry run by merging the two sublists `[4, 6, 8]`
    and `[5, 7, 11, 40]`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过合并两个子列表`[4, 6, 8]`和`[5, 7, 11, 40]`来对算法进行干扰运行：
- en: '| **Step** | `first_sublist` | `second_sublist` | `merged_list` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | `first_sublist` | `second_sublist` | `merged_list` |'
- en: '| Step 0 | `[4 6 8]` | `[5 7 11 40]` | `[]` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 步骤0 | `[4 6 8]` | `[5 7 11 40]` | `[]` |'
- en: '| Step 1 | `[ 6 8]` | `[5 7 11 40]` | `[4]` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 步骤1 | `[ 6 8]` | `[5 7 11 40]` | `[4]` |'
- en: '| Step 2 | `[ 6 8]` | `[ 7 11 40]` | `[4 5]` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 步骤2 | `[ 6 8]` | `[ 7 11 40]` | `[4 5]` |'
- en: '| Step 3 | `[ 8]` | `[ 7 11 40]` | `[4 5 6]` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 步骤3 | `[ 8]` | `[ 7 11 40]` | `[4 5 6]` |'
- en: '| Step 4 | `[ 8]` | `[ 11 40]` | `[4 5 6 7]` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 步骤4 | `[ 8]` | `[ 11 40]` | `[4 5 6 7]` |'
- en: '| Step 5 | `[ ]` | `[ 11 40]` | `[4 5 6 7 8]` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 步骤5 | `[ ]` | `[ 11 40]` | `[4 5 6 7 8]` |'
- en: '| Step 6 | `[]` | `[ ]` | `[4 5 6 7 8 11 40]` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 步骤6 | `[]` | `[ ]` | `[4 5 6 7 8 11 40]` |'
- en: Note that the text in bold represents the current item referenced in the loops
    `first_sublist` (which uses the `i` *index*) and `second_sublist` (which uses
    the `j` index).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意粗体文本代表循环中当前项的引用，`first_sublist`（使用`i`索引）和`second_sublist`（使用`j`索引）。
- en: At this point in the execution, the third `while` loop in the merge function
    kicks in to move 11 and 40 into `merged_list`. The returned `merged_list` will
    contain the fully sorted list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行的这一点上，合并函数中的第三个`while`循环开始将11和40移入`merged_list`。返回的`merged_list`将包含完全排序的列表。
- en: Note that while the merge algorithm takes `O(n)` time, the merge sort algorithm
    has a running time complexity of `O(log n) T(n) = O(n)*O(log n) = O(n log n)`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，合并算法需要`O(n)`的时间，而合并排序算法的运行时间复杂度为`O(log n) T(n) = O(n)*O(log n) = O(n log
    n)`。
- en: Implementation using greedy algorithms
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用贪婪算法的实现
- en: As we discussed earlier, greedy algorithms make decisions to yield the best
    possible local solution, which in turn provides the optimal solution. It is the
    hope of this technique that by making the best possible choices at each step,
    the total path will lead to an overall optimal solution or end.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，贪婪算法做出决策以产生最佳的局部解决方案，从而提供最佳解决方案。这种技术的希望是，通过在每一步做出最佳选择，总路径将导致整体最优解决方案或结束。
- en: Examples of greedy algorithms include **Prim's algorithm** for finding a minimum
    spanning tree, the **Knapsack problem**, and the **Traveling Salesman problem**,
    to mention just a few.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法的例子包括用于查找最小生成树的**Prim算法**、**背包问题**和**旅行推销员问题**。
- en: Coin-counting problem
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬币计数问题
- en: To demonstrate how the greedy technique works, let's look at an example. Consider
    a problem in which we wish to compute the minimum number of coin required to make
    a given amount A, where we have an infinite supply of the given coins' values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示贪婪技术的工作原理，让我们看一个例子。考虑一个问题，我们希望计算使给定金额A所需的最小硬币数量，其中我们有给定硬币值的无限供应。
- en: 'For example, in some arbitrary country, we have the following coin denominations:
    1, 5, and 8 GHC. Given an amount (for example, 12 GHC), we want to find the smallest
    possible number of coins needed to provide this amount.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在某个任意国家，我们有以下硬币面额：1、5和8 GHC。给定一个金额（例如12 GHC），我们想要找到提供这个金额所需的最少硬币数量。
- en: 'The algorithm to obtain the minimum number of coins to provide a given amount
    *A* using denominations `{a[1],a[2],a[3]...a[n]}` is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面额`{a[1],a[2],a[3]...a[n]}`来提供给定金额A的最小硬币数量的算法如下：
- en: We sort the list of denominations `{a[1], a[2], a[3] ...a[n]}`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对面额列表`{a[1], a[2], a[3] ...a[n]}`进行排序。
- en: We get the largest denomination in `{a[1], a[2], a[3]...a[n]}` which is smaller
    than A.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到小于A的`{a[1], a[2], a[3]...a[n]}`中的最大面额。
- en: We obtain the division by dividing A by the largest denomination.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将A除以最大面额来获得商。
- en: We get the remaining amount A by getting the remainder using (A % largest denominator).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用（A % 最大面额）来获得剩余金额A。
- en: If the value of A becomes 0, then we return the result.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果A的值变为0，则返回结果。
- en: Else If the value of A is greater than 0, we append the largest denominator
    and division variable in the result variable. And repeat the steps 2-5.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果A的值大于0，我们将最大面额和商变量附加到结果变量中。并重复步骤2-5。
- en: Using the greedy approach, we first pick the largest value from the available
    denominations—which is 8—to divide into 12\. The remainder, 4, cannot be divided
    by either 8 or the next lowest denomination, 5\. So, we try the 1 GHC denomination
    coin, of which we need four. In the end, using this greedy algorithm, we return
    an answer of one 8 GHC coin and four 1 GHC coins.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用贪婪方法，我们首先选择可用面额中的最大值——8——来除以12。余数4既不能被8整除，也不能被比8更小的面额5整除。所以，我们尝试1 GHC面额的硬币，需要四个。最终，使用这种贪婪算法，我们返回了一个8
    GHC硬币和四个1 GHC硬币的答案。
- en: 'So far, our greedy algorithm seems to be doing pretty well. A function that
    returns the respective denominations is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的贪婪算法似乎表现得相当不错。返回相应面额的函数如下：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This greedy algorithm always starts by using the largest denomination possible.
    Note that `denom` is a list of denominations, and that `sorted(denom, reverse=True)`
    will sort the list in reverse so that we can obtain the largest denomination at
    index *`0`*. Now, starting from index `*0*` of the sorted list of denominations,
    `sorted_denominations`, we iterate and apply the greedy technique:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种贪婪算法总是从可能的最大面额开始。注意`denom`是一个面额列表，`sorted(denom, reverse=True)`会将列表按照相反的顺序排序，这样我们就可以在索引`0`处获得最大面额。现在，从排序后的面额列表`sorted_denominations`的索引`0`开始，我们迭代并应用贪婪技术：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The loop will run through the list of denominations. Each time the loop runs,
    it obtains the quotient, `div`, by dividing the `total_amount` by the current
    denomination, *i*. The `total_amount` variable is updated to store the remainder
    for further processing. If the quotient is greater than 0, we store it in `number_of_denoms`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将遍历面额列表。每次循环运行时，它通过将`total_amount`除以当前面额*i*来获得商`div`。`total_amount`变量被更新以存储余数以供进一步处理。如果商大于0，我们将其存储在`number_of_denoms`中。
- en: However, there are some possible instances where this algorithm may fail. For
    instance, when passed 12 GHC, our algorithm returned one 8 GHC and four 1 GHC
    coins. This output is, however, not the optimal solution. The best solution is
    to use two 5 GHC and two 1 GHC coins.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些可能的情况下这种算法可能会失败。例如，当传入12 GHC时，我们的算法返回了一个8 GHC和四个1 GHC硬币。然而，这个输出并不是最优解。最佳解是使用两个5
    GHC和两个1 GHC硬币。
- en: 'A better greedy algorithm is presented here. This time, the function returns
    a list of tuples that allow us to investigate the best results:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出了一个更好的贪婪算法。这次，函数返回一个允许我们调查最佳结果的元组列表：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The outer `for` loop enables us to limit the denominations from which we find
    our solution:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 外部`for`循环使我们能够限制我们找到解决方案的面额：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Assuming that we have the list [5, 4, 3] in `sorted_denominations`, slicing
    it with `[j:]` helps us obtain the sublists [5, 4, 3], [4, 3], and [3], from which
    we try to find the right combination.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有列表[5, 4, 3]，在`sorted_denominations`中对其进行切片`[j:]`有助于我们获得子列表[5, 4, 3]，[4,
    3]和[3]，从中我们尝试找到正确的组合。
- en: Shortest path algorithm
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最短路径算法
- en: The shortest path problem requires us to find out the shortest possible route
    between nodes in a graph. It has important applications for mapping and route
    planning, when plotting the most efficient way to get from point **A** to point
    **B**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径问题要求我们找出图中节点之间最短可能的路径。在制定从点A到点B的最有效路径时，这对于地图和路径规划具有重要应用。
- en: Dijkstra's algorithm is a very popular method of solving this problem. This
    algorithm is used to find the shortest distance from a source to all other nodes
    or vertices in a graph. Here we explain how we can use the greedy approach to
    solve this problem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 迪杰斯特拉算法是解决这个问题的一种非常流行的方法。该算法用于在图中找到从源到所有其他节点或顶点的最短距离。在这里，我们解释了如何使用贪婪方法来解决这个问题。
- en: 'Dijkstra''s algorithm works for weighted directed and undirected graphs. The
    algorithm produces the output of a list of the shortest path from a given source
    node A in a weighted graph. The algorithm works as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 迪杰斯特拉算法适用于加权有向和无向图。该算法产生了从加权图中给定源节点A到最短路径的列表的输出。算法的工作原理如下：
- en: Initially, mark all the nodes as unvisited, and set their distance from the
    given source node to infinity (the source node is set to zero).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，将所有节点标记为未访问，并将它们从给定源节点的距离设置为无穷大（源节点设置为零）。
- en: Set the source node as current.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源节点设置为当前节点。
- en: For the current node, look for all the unvisited adjacent nodes; compute the
    distance to that node from the source node through the current node. Compare the
    newly computed distance to the currently assigned distance, and if it is smaller,
    set this as the new value.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于当前节点，查找所有未访问的相邻节点；计算从源节点通过当前节点到该节点的距离。将新计算的距离与当前分配的距离进行比较，如果更小，则将其设置为新值。
- en: Once we have considered all the unvisited adjacent nodes of the current node,
    we mark it as visited.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们考虑了当前节点的所有未访问的相邻节点，我们将其标记为已访问。
- en: We next consider the next unvisited node which has the shortest distance from
    the source node. Repeat steps 2 to 4.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，考虑下一个未访问的节点，该节点距离源节点最近。重复步骤2到4。
- en: We stop when the list of unvisited nodes is empty, meaning we have considered
    all the unvisited nodes.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当未访问节点的列表为空时，我们停止，这意味着我们已经考虑了所有未访问的节点。
- en: 'Consider the following example of a weighted graph with six nodes [A, B, C,
    D, E, F] to understand how Dijkstra''s algorithm works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下带有六个节点[A，B，C，D，E，F]的加权图的示例，以了解迪杰斯特拉算法的工作原理：
- en: '![](Images/30207f74-106b-4b35-8d06-0cf1a2377a4f.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/30207f74-106b-4b35-8d06-0cf1a2377a4f.png)'
- en: By manual inspection, the shortest path between node **A** and node **D** at
    first glance seems to be the direct line with a distance of 9\. However, the shortest
    route means the lowest total distance, even if this comprises several parts. By
    comparison, traveling from node **A** to node **E** to node **F** and finally
    to node **D **will incur a total distance of 7, making it a shorter route.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手动检查，最初看起来节点A和节点D之间的最短路径似乎是距离为9的直线。然而，最短路径意味着最低总距离，即使这包括几个部分。相比之下，从节点A到节点E，然后到节点F，最后到节点D的旅行将产生总距离为7，这使得它成为更短的路径。
- en: We would implement the shortest path algorithm with a single source. It would determine
    the shortest path from the origin, which in this case is **A**, to any other node
    in the graph.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用单源最短路径算法。它将确定从原点（在本例中为A）到图中任何其他节点的最短路径。
- en: In [Chapter 8](7223bbb5-9af3-4c48-88d0-fe2ebeb6900b.xhtml), *Graphs and Other
    Algorithms*, we discussed how to represent a graph with an adjacency list. We
    use an adjacency list along with the weight/cost/distance on every edge to represent
    the graph, as shown in the following Python code. A table is used to keep track
    of the shortest distance from the source in the graph to any other node. A Python
    dictionary will be used to implement this table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](7223bbb5-9af3-4c48-88d0-fe2ebeb6900b.xhtml)中，*图和其他算法*，我们讨论了如何用邻接列表表示图。我们使用邻接列表以及每条边上的权重/成本/距离来表示图，如下面的Python代码所示。表用于跟踪从图中源到任何其他节点的最短距离。Python字典将用于实现此表。
- en: 'Here is the starting table:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是起始表：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **距离源的最短距离** | **前一个节点** |'
- en: '| **A** | 0 | None |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **A** | 0 | None |'
- en: '| **B** | ∞ | None |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **B** | ∞ | None |'
- en: '| **C** | ∞ | None |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **C** | ∞ | None |'
- en: '| **D** | ∞ | None |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **D** | ∞ | None |'
- en: '| **E** | ∞ | None |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **E** | ∞ | None |'
- en: '| **F** | ∞ | None |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **F** | ∞ | None |'
- en: 'The adjacency list for the diagram and table is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图和表的邻接列表如下：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The nested dictionary holds the distance and adjacent nodes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套字典保存了距离和相邻节点。
- en: When the algorithm starts, the shortest distance from the given source node
    (**A**) to any of the nodes is unknown. Thus, we initially set the distance to
    all other nodes to infinity, with the exception of node **A** , as the distance
    from node **A** to node **A** is 0.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法开始时，给定源节点（A）到任何节点的最短距离是未知的。因此，我们最初将所有其他节点的距离设置为无穷大，除了节点A，因为从节点A到节点A的距离为0。
- en: No prior nodes have been visited when the algorithm begins. Therefore, we mark
    the previous node column of the node **A** as None.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法开始时，没有先前的节点被访问。因此，我们将节点A的前一个节点列标记为None。
- en: 'In step 1 of the algorithm, we start by examining the adjacent nodes to node
    **A**. To find the shortest distance from node **A** to node **B**, we need to
    find the distance from the start node to the previous node of node B, which happens
    to be node **A**, and add it to the distance from node **A** to node **B**. We
    do this for other adjacent nodes of **A**, which are **B**, **E**, and **D**.
    This is shown in the following diagram:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的第一步中，我们开始检查节点A的相邻节点。要找到从节点A到节点B的最短距离，我们需要找到从起始节点到节点B的前一个节点的距离，这恰好是节点A，并将其添加到从节点A到节点B的距离。我们对A的其他相邻节点（B、E和D）也是这样做的。这在下图中显示：
- en: '![](Images/9745d5ee-f528-4bd2-b67b-181e3655f5c4.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9745d5ee-f528-4bd2-b67b-181e3655f5c4.png)'
- en: We take the adjacent node **B** as its distance from node **A** is minimum; the
    distance from the start node (**A**) to the previous node (None) is 0, and the
    distance from the previous node to the current node (**B**) is **5**. This sum
    is compared with the data in the shortest distance column of node **B**. Since
    **5** is less than infinity(**∞**), we replace **∞** with the smaller of the two,
    which is **5**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将相邻节点B作为其从节点A的距离最小；从起始节点（A）到前一个节点（None）的距离为0，从前一个节点到当前节点（B）的距离为5。这个和与节点B的最短距离列中的数据进行比较。由于5小于无穷大（∞），我们用两者中较小的5替换∞。
- en: 'Any time the shortest distance of a node is replaced by a smaller value, we
    need to update the previous node column too for all the adjacent nodes of the
    current node. After this, we mark node **A** as visited:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个节点的最短距离被较小的值替换时，我们需要为当前节点的所有相邻节点更新前一个节点列。之后，我们将节点A标记为已访问：
- en: '![](Images/220248fc-eec9-4d42-9d69-1ac4a8ca26a2.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/220248fc-eec9-4d42-9d69-1ac4a8ca26a2.png)'
- en: 'At the end of the first step, our table looks as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步结束时，我们的表如下所示：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **源的最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| B | 5 | A |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| B | 5 | A |'
- en: '| C | ∞ | None |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| C | ∞ | None |'
- en: '| D | 9 | A |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| D | 9 | A |'
- en: '| E | 2 | A |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| E | 2 | A |'
- en: '| F | ∞ | None |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| F | ∞ | None |'
- en: At this point, node **A** is considered visited. As such, we add node **A** to
    the list of visited nodes. In the table, we show that node **A** has been visited
    by making the text bold and appending an asterisk sign to it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，节点A被视为已访问。因此，我们将节点A添加到已访问节点的列表中。在表中，我们通过将文本加粗并在其后附加星号来显示节点A已被访问。
- en: In the second step, we find the node with the shortest distance using our table
    as a guide. Node **E**, with its value of 2, has the shortest distance. This is
    what we can infer from the table about node **E**. To get to node **E**, we must
    visit node **A** and cover a distance of **2.** From node A, we cover a distance
    of 0 to get to the starting node, which is node **A** itself.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用我们的表找到最短距离的节点作为指南。节点E的值为2，具有最短距离。这是我们从节点E的表中可以推断出来的。要到达节点E，我们必须访问节点A并覆盖距离2。从节点A，我们覆盖0的距离到达起始节点，即节点A本身。
- en: The adjacent nodes to node **E** are **A** and **F**. But node **A** has already
    been visited, so we will only consider node **F**. To find the shortest route
    or distance to node **F**, we must find the distance from the starting node to
    node **E** and add it to the distance between node **E** and **F**. We can find
    the distance from the starting node to node **E** by looking at the shortest distance
    column of node **E**, which has the value **2**. The distance from node **E**
    to **F** can be obtained from the adjacency list we developed in Python earlier
    in this section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 节点E的相邻节点是A和F。但是节点A已经被访问过，所以我们只考虑节点F。要找到到节点F的最短路径或距离，我们必须找到从起始节点到节点E的距离，并将其添加到节点E和F之间的距离。我们可以通过查看节点E的最短距离列来找到从起始节点到节点E的距离，其值为2。从节点E到F的距离可以从我们在本节早些时候开发的Python中的邻接列表中获得。
- en: 'This distance is **3**. These two sum up to 5, which is less than infinity.
    Remember we are examining the adjacent node **F**. Since there are no more adjacent
    nodes to node **E**, we mark node **E** as visited. Our updated table and the
    figure will have the following values:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个距离是3。这两个加起来是5，小于无穷大。记住我们正在检查相邻的节点F。由于节点E没有更多相邻的节点，我们将节点E标记为已访问。我们更新的表和图将具有以下值：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **源的最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| B | 5 | A |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| B | 5 | A |'
- en: '| C | ∞ | None |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| C | ∞ | None |'
- en: '| D | 9 | A |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| D | 9 | A |'
- en: '| **E*** | 2 | A |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| F | 5 | E |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| F | 5 | E |'
- en: After visiting node **E**, we find the smallest value in the shortest distance
    column of the table, which is 5 for nodes **B** and **F**. Let us choose **B**
    instead of **F** purely on an alphabetical basis (we could equally have chosen
    **F**).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 访问节点E后，我们在表的最短距离列中找到最小值，即节点B和F的值为5。让我们选择B而不是F，纯粹基于字母顺序（我们也可以选择F）。
- en: The adjacent nodes to **B** are **A** and **C**, but node **A** has already
    been visited. Using the rule we established earlier, the shortest distance from
    **A** to **C** is 7\. We arrive at this number because the distance from the starting
    node to node **B** is 5, while the distance from node **B** to **C** is 2.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 节点B的相邻节点是A和C，但是节点A已经被访问。根据我们之前建立的规则，从A到C的最短距离是7。我们得到这个数字是因为从起始节点到节点B的距离是5，而从节点B到C的距离是2。
- en: 'Since 7 is less than infinity, we update the shortest distance to 7 and update
    the previous node column with node **B**:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于7小于无穷大，我们将最短距离更新为7，并用节点B更新前一个节点列：
- en: '![](Images/b6437e76-eaf8-4d3c-910e-cb5751588c6d.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b6437e76-eaf8-4d3c-910e-cb5751588c6d.png)'
- en: 'Now, **B** is also marked as visited. The new state of the table and the figure
    is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，B也被标记为已访问。表和图的新状态如下：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **源的最短距离** | **前一个节点** |'
- en: '| **A*** | 0 | None |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| **B*** | 5 | A |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **B*** | 5 | A |'
- en: '| C | 7 | B |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| C | 7 | B |'
- en: '| D | 9 | A |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| D | 9 | A |'
- en: '| **E*** | 2 | A |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| F | 5 | E |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| F | 5 | E |'
- en: The node with the shortest distance yet unvisited is node **F**. The adjacent
    nodes to **F** are nodes **D** and **E**. But node **E** has already been visited.
    As such, we focus on finding the shortest distance from the starting node to node
    **D**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最短距离但尚未访问的节点是节点**F**。**F**的相邻节点是节点**D**和**E**。但是节点**E**已经被访问过。因此，我们专注于找到从起始节点到节点**D**的最短距离。
- en: 'We calculate this distance by adding the distance from node **A** to **F**
    to the distance from node **F** to **D**. This sums up to 7, which is less than
    **9**. Thus, we update the **9** with **7** and replace **A** with **F** in node
    **D**''s previous node column:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将从节点**A**到**F**的距离与从节点**F**到**D**的距离相加来计算这个距离。这相加得到7，小于**9**。因此，我们将**9**更新为**7**，并在节点**D**的上一个节点列中用**F**替换**A**：
- en: '![](Images/d4a2d0a8-6a4e-46d5-b469-37674c0617df.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d4a2d0a8-6a4e-46d5-b469-37674c0617df.png)'
- en: 'Node **F** is now marked as visited. Here is the updated table and the figure
    up to this point:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 节点**F**现在被标记为已访问。这是更新后的表格和到目前为止的图：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **Node** | **Shortest distance from source** | **Previous node** |'
- en: '| **A*** | 0 | None |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| **B*** | 5 | A |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **B*** | 5 | A |'
- en: '| C | 7 | B |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| C | 7 | B |'
- en: '| D | 7 | F |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| D | 7 | F |'
- en: '| **E*** | 2 | A |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| **F*** | 5 | E |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **F*** | 5 | E |'
- en: 'Now, only two unvisited nodes are left, **C** and **D**, both with a distance
    cost of **7**. In alphabetical order, we choose to examine **C** because both
    nodes have the same shortest distance from the starting node **A**:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只剩下两个未访问的节点，**C**和**D**，都具有距离成本为**7**。按字母顺序，我们选择检查**C**，因为这两个节点都与起始节点**A**的最短距离相同：
- en: '![](Images/09e116c0-42d5-430f-95d8-3b10bf5f1788.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09e116c0-42d5-430f-95d8-3b10bf5f1788.png)'
- en: 'However, all the adjacent nodes to **C** have been visited. Thus, we have nothing
    to do but mark node **C** as visited. The table remains unchanged at this point:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有与**C**相邻的节点都已经被访问。因此，我们除了将节点**C**标记为已访问外，没有其他事情要做。此时表格保持不变：
- en: '![](Images/d5ea3951-91ea-4723-8337-4d655593f431.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d5ea3951-91ea-4723-8337-4d655593f431.png)'
- en: 'Lastly, we take node **D**, and find out that all its adjacent nodes have been
    visited too. We only mark it as visited. The table remains unchanged:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们取节点**D**，发现它的所有相邻节点也都已经被访问。我们只将其标记为已访问。表格保持不变：
- en: '| **Node** | **Shortest distance from source** | **Previous node** |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **Node** | **Shortest distance from source** | **Previous node** |'
- en: '| **A*** | 0 | None |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **A*** | 0 | None |'
- en: '| **B*** | 5 | A |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **B*** | 5 | A |'
- en: '| **C*** | 7 | B |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **C*** | 7 | B |'
- en: '| **D*** | 7 | F |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **D*** | 7 | F |'
- en: '| **E*** | 2 | A |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **E*** | 2 | A |'
- en: '| **F*** | 5 | E |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **F*** | 5 | E |'
- en: 'Let''s verify this table with our initial graph. From the graph, we know that
    the shortest distance from **A** to **F** is **5**. We will need to go through
    **E** to get to node **F**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的初始图表来验证这个表格。从图表中，我们知道从**A**到**F**的最短距离是**5**。我们需要通过**E**到达节点**F**：
- en: '![](Images/93a5e488-c767-400f-8fcb-4a27523a7e7d.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/93a5e488-c767-400f-8fcb-4a27523a7e7d.png)'
- en: According to the table, the shortest distance from the source column for node
    **F** is 5\. This is true. It also tells us that to get to node **F**, we need
    to visit node **E**, and from **E** to node **A**, which is our starting node.
    This is actually the shortest path.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 根据表格，从源列到节点**F**的最短距离是5。这是正确的。它还告诉我们，要到达节点**F**，我们需要访问节点**E**，然后从**E**到节点**A**，这实际上是最短路径。
- en: 'To implement Dijkstra''s algorithm to find the shortest path, we begin the
    program for finding the shortest distance by representing the table that enables
    us to track the changes in our graph. For the diagram we used, here is a dictionary
    representation of the table:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现Dijkstra算法以找到最短路径，我们开始编写程序，通过表示能够跟踪图中变化的表格来找到最短距离。对于我们使用的图表，这是表格的字典表示：
- en: '[PRE19]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The initial state of the table uses `float("inf")` to represent infinity. Each
    key in the dictionary maps to a list. At the first index of the list, the shortest
    distance from the source A is stored. At the second index, the previous node is
    stored:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的初始状态使用`float("inf")`表示无穷大。字典中的每个键映射到一个列表。在列表的第一个索引处，存储了从源头A到达的最短距离。在第二个索引处，存储了上一个节点：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To avoid the use of magic numbers, we use the preceding constants. The shortest
    path column's index is referenced by `DISTANCE`. The previous node column's index
    is referenced by `PREVIOUS_NODE`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用魔术数字，我们使用前面的常量。最短路径列的索引由`DISTANCE`引用。上一个节点列的索引由`PREVIOUS_NODE`引用。
- en: 'Now all is set for the main function of the algorithm. It will take the graph,
    represented by the adjacency list, the table, and the starting node as parameters:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都准备就绪，算法的主要函数将接受图（由邻接列表表示）、表格和起始节点作为参数：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We keep the list of visited nodes in the `visited_nodes` list. The `current_node`
    and `starting_node` variables will both point to the node in the graph we choose
    to make our starting node. The `origin` value is the reference point for all other
    nodes with respect to finding the shortest path.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将访问过的节点列表保存在`visited_nodes`列表中。`current_node`和`starting_node`变量都将指向我们选择的图中的起始节点。`origin`值是相对于找到最短路径的其他节点的参考点。
- en: 'The heavy lifting of the whole process is accomplished by the use of a `while`
    loop:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程的重要工作是通过使用`while`循环完成的：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's break down what the `while` loop is doing. In the body of the `while`
    loop, we obtain the current node in the graph we want to investigate with `adjacent_nodes
    = graph[current_node]`. Now, `current_node` should have been set prior. The `if`
    statement is used to find out whether all the adjacent nodes of `current_node`
    have been visited.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下`while`循环在做什么。在`while`循环的主体中，我们获取我们想要调查的图中的当前节点，使用`adjacent_nodes = graph[current_node]`。现在，`current_node`应该在之前已经设置好。`if`语句用于查找`current_node`的所有相邻节点是否都已经被访问。
- en: When the `while` loop is executed for the fir*s*t time, `current_node` will
    contain A and `adjacent_nodes` will contain nodes B, D, and E. Furthermore, `visited_nodes`
    will be empty too. If all nodes have been visited, we only move on to the statements
    further down the program. Otherwise, we begin a whole new step.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环第一次执行时，`current_node`将包含A，`adjacent_nodes`将包含节点B、D和E。此外，`visited_nodes`也将为空。如果所有节点都已经被访问，我们只会继续执行程序中的其他语句。否则，我们将开始一个全新的步骤。
- en: 'The `set(adjacent_nodes).difference(set(visited_nodes))` statement returns
    the nodes that have not been visited. The loop iterates over this list of unvisited
    nodes:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`set(adjacent_nodes).difference(set(visited_nodes))`返回尚未访问的节点。循环遍历这个未访问的节点列表：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `get_shortest_distance(table, vertex)` helper method will return the value
    stored in the shortest distance column of our table, using one of the unvisited
    nodes referenced by `vertex`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_shortest_distance(table, vertex)`辅助方法将返回我们表中最短距离列中存储的值，使用`vertex`引用的未访问节点之一：'
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we are examining the adjacent nodes of the starting node, `distance_from_starting_node
    == INFINITY and current_node == starting_node` will evaluate to `True`, in which
    case we only have to find the distance between the starting node and vertex by
    referencing the graph:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查起始节点的相邻节点时，`distance_from_starting_node == INFINITY and current_node ==
    starting_node` 将评估为 `True`，在这种情况下，我们只需要通过引用图找到起始节点和顶点之间的距离：
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `get_distance` method is another helper method we use to obtain the value
    (distance) of the edge between `vertex` and `current_node`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_distance`方法是我们用来获取`vertex`和`current_node`之间的边的值（距离）的另一个辅助方法。'
- en: If the condition fails, then we assign to `total_distance` the sum of the distance
    from the starting node to `current_node`, and the distance between `current_node`
    and `vertex`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件失败，那么我们将把`total_distance`赋值为从起始节点到`current_node`的距离和`current_node`到`vertex`的距离之和。
- en: 'Once we have our total distance, we need to check whether `total_distance`
    is less than the existing data in the shortest distance column of our table. If
    it is less, then we use the two helper methods to update that row:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了总距离，我们需要检查`total_distance`是否小于我们表中最短距离列中的现有数据。如果是，我们就使用这两个辅助方法来更新该行：
- en: '[PRE26]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this point, we add `current_node` to the list of visited nodes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将`current_node`添加到已访问节点列表中：
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If all nodes have been visited, then we must exit the `while` loop. To check
    whether all the nodes have been visited, we compare the length of the `visited_nodes`
    list to the number of keys in our table. If they have become equal, we simply
    exit the `while` loop.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都已经被访问，那么我们必须退出`while`循环。为了检查所有节点是否都已经被访问，我们将`visited_nodes`列表的长度与我们表中的键的数量进行比较。如果它们相等，我们就简单地退出`while`循环。
- en: The `get_next_node` helper method is used to fetch the next node to visit. It
    is this method that helps us find the minimum value in the shortest distance column
    from the starting nodes using our table.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_next_node`辅助方法用于获取下一个要访问的节点。正是这个方法帮助我们使用我们的表从起始节点中找到最短距离列中的最小值。'
- en: 'The whole method ends by returning the updated table. To print the table, we
    use the following statements:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 整个方法最终返回更新后的表。要打印表，我们使用以下语句：
- en: '[PRE28]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the output for the preceding statement:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面语句的输出：
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For the sake of completeness, let''s find out what the helper methods are doing:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，让我们找出这些辅助方法在做什么：
- en: '[PRE30]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `get_shortest_distance` function returns the value stored in index 0 of
    our table. At that index, we always store the shortest distance from the starting
    node up to `vertex`. The `set_shortest_distance` function only sets this value
    as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_shortest_distance`函数返回我们表中索引0处存储的值。在该索引处，我们始终存储从起始节点到`vertex`的最短距离。`set_shortest_distance`函数只设置该值如下：'
- en: '[PRE31]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we update the shortest distance of a node, we update its previous node
    using the following method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新节点的最短距离时，我们使用以下方法更新其上一个节点：
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember that the, `PREVIOUS_NODE` constant equals 1\. In the table, we store
    the value of `previous_node` at `table[vertex][PREVIOUS_NODE]`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`PREVIOUS_NODE`常量等于1。在表中，我们将`previous_node`的值存储在`table[vertex][PREVIOUS_NODE]`处。
- en: 'To find the distance between any two nodes, we use the `get_distance` function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到任意两个节点之间的距离，我们使用`get_distance`函数：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last helper method is the `get_next_node` function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的辅助方法是`get_next_node`函数：
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `get_next_node` function resembles a function to find the smallest item
    in a list.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_next_node`函数类似于在列表中找到最小项的函数。'
- en: The function starts off by finding the unvisited nodes in our table by using
    `visited_nodes` to obtain the difference between the two sets of lists. The very
    first item in the list of `unvisited_nodes` is assumed to be the smallest in the
    shortest distance column of `table`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先通过使用`visited_nodes`来获取两个列表集合的差异来找到我们表中未访问的节点。`unvisited_nodes`列表中的第一项被假定为`table`中最短距离列中的最小值。
- en: If a lesser value is found while the `for` loop runs, the `min_vertex` will
    be updated. The function then returns `min_vertex` as the unvisited vertex or
    node with the smallest shortest distance from the source.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`for`循环运行时找到了更小的值，`min_vertex`将被更新。然后函数将`min_vertex`作为未访问的顶点或距离源点最短的节点返回。
- en: The worst-case running time of Dijkstra's algorithm is **O**(*|E| + |V| log
    |V|*), where *|V|* is the number of vertices and *|E|* is the number of edges.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法的最坏运行时间是**O**(*|E| + |V| log |V|*)，其中*|V|*是顶点数，*|E|*是边数。
- en: Complexity classes
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂度类
- en: Complexity classes group problems on the basis of their difficulty level, and the
    resources required in terms of time and space to solve them. In this section,
    we discuss the N, NP, NP-Complete, and NP-Hard complexity classes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度类根据问题的难度级别以及解决它们所需的时间和空间资源进行分组。在本节中，我们讨论了N、NP、NP-Complete和NP-Hard复杂度类。
- en: P versus NP
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: P与NP
- en: The advent of computers has sped up the rate at which certain tasks can be performed.
    In general, computers are good at perfecting the art of calculation and solving
    problems that can be reduced to a set of mathematical computations.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的出现加快了某些任务的执行速度。总的来说，计算机擅长完善计算的艺术和解决可以归结为一组数学计算的问题。
- en: However, this assertion is not entirely true. There are some classes of problems
    that take an enormous amount of time for the computer to make a sound guess, let
    alone find the right solution.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种说法并非完全正确。有一些类别的问题对计算机来说需要大量时间来做出合理的猜测，更不用说找到正确的解决方案了。
- en: In computer science, the class of problems that computers can solve within polynomial
    time using a step-wise process of logical steps is known as P-type, where P stands
    for polynomial. These are relatively easy to solve.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，计算机可以使用逻辑步骤的逐步过程在多项式时间内解决的问题类别被称为P类型，其中P代表多项式。这些问题相对容易解决。
- en: Then there is another class of problems that are considered very hard to solve.
    The word *hard problem* is used to refer to the way in which problems increase
    in difficulty when trying to find a solution. However, despite the fact that these
    problems have a high growth rate of difficulty, it is possible to determine whether a
    proposed solution solves the problem in polynomial time. These are known as NP-type
    problems. NP here stands for nondeterministic polynomial time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有另一类被认为很难解决的问题。术语*难问题*用于指代在寻找解决方案时问题难度增加的方式。然而，尽管这些问题的难度增长率很高，但可以确定一个提议的解决方案是否在多项式时间内解决问题。这些被称为NP类型问题。这里的NP代表非确定性多项式时间。
- en: Now the million dollar question is, does *P = NP*?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在百万美元的问题是，*P = NP*吗？
- en: The proof for P* = NP* is one of the Millennium Prize Problems from the Clay
    Mathematics Institute, offering a million dollar prize for a correct solution.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: P* = NP*的证明是克莱数学研究所的百万美元问题之一，为正确解决方案提供了百万美元的奖金。
- en: 'The Traveling Salesman problem is an example of an NP-type problem. The problem
    statement says: given *n* number of cities in a country, find the shortest route
    between them all, thus making the trip a cost-effective one.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行推销员问题是NP类型问题的一个例子。问题陈述如下：在一个国家中给定*n*个城市，找到它们之间的最短路线，从而使旅行成本有效。
- en: When the number of cities is small, this problem can be solved in a reasonable
    amount of time. However, when the number of cities is above any two-digit number,
    the time taken by the computer is remarkably long.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当城市数量较小时，这个问题可以在合理的时间内解决。然而，当城市数量超过两位数时，计算机所需的时间就会非常长。
- en: A lot of computer and cybersecurity systems are based on the RSA encryption
    algorithm. The strength of the algorithm is based on the fact that it uses the
    integer factoring problem, which is an NP-type problem.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机和网络安全系统都基于RSA加密算法。该算法的强度基于它使用的整数因子问题，这是一个NP类型问题。
- en: Finding the prime factors of a prime number composed of many digits is very
    difficult. When two large prime numbers are multiplied, a large non-prime number
    is obtained. Factorization of this number is where many cryptographic algorithms
    borrow their strength.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 找到由许多位数组成的质数的质因数是非常困难的。当两个大质数相乘时，得到一个大的非质数。这个数的因数分解是许多加密算法借用其强度的地方。
- en: 'All P-type problems are subsets of **NP** problems. This means that any problem
    that can be solved in polynomial time can also be verified in polynomial time:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 所有P类型问题都是**NP**问题的子集。这意味着任何可以在多项式时间内解决的问题也可以在多项式时间内验证：
- en: '![](Images/cfbbc0d9-bc13-467e-aeb5-982db9ad6891.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cfbbc0d9-bc13-467e-aeb5-982db9ad6891.png)'
- en: But **P** = **NP** investigates whether problems that can be verified in polynomial
    time can also be solved in polynomial time. In particular, if they are equal,
    it means that problems that are solved by trying a number of possible solutions
    can be solved without the need to actually try all the possible solutions, invariably
    creating some sort of shortcut proof.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但是**P** = **NP**调查了可以在多项式时间内验证的问题是否也可以在多项式时间内解决。特别是，如果它们相等，这意味着可以在不需要实际尝试所有可能的解决方案的情况下解决通过尝试多个可能解决方案来解决的问题，从而不可避免地产生某种快捷证明。
- en: The proof, when finally discovered, will certainly have serious consequences
    for the fields of cryptography, game theory, mathematics, and many other fields.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终发现证明时，它肯定会对密码学、博弈论、数学和许多其他领域产生严重影响。
- en: NP-Hard
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NP-Hard
- en: A problem is NP-Hard if all other problems in NP can be polynomial-time-reducible,
    or mapped to it. It is at least as hard as the hardest problem in NP.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NP中的所有其他问题都可以在多项式时间内可归约或映射到它，那么问题就是NP-Hard。它至少和NP中最难的问题一样难。
- en: NP-Complete
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NP-Complete
- en: '**NP-Complete** problems are the most difficult problems. A problem is considered an
    **NP-Complete** problem if it is an **NP-Hard** problem that is also found in
    the **NP** class.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP-Complete**问题是最困难的问题。如果一个问题是**NP-Hard**问题，同时也在**NP**类中找到，那么它被认为是**NP-Complete**问题。'
- en: 'Here, we show the Venn diagram for various complexity groups:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了各种复杂性群的维恩图：
- en: '![](Images/c47f7c29-0359-481b-b287-34e5ca2e9a45.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c47f7c29-0359-481b-b287-34e5ca2e9a45.png)'
- en: Knowledge discovery in data
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据中的知识发现
- en: 'To extract useful information from the given data, we initially collect the
    raw data that is to be used to learn the patterns. Next, we apply the data preprocessing
    techniques to remove the noise from the data. Further more, we extract the important
    features from the data, which are representative of the data, to develop the model.
    Feature extraction is the most crucial step for machine learning algorithms to
    work effectively. A good feature must be informative and discriminating for the
    machine learning algorithms. Feature selection techniques are used to remove the irrelevant,
    redundant, and noisy features. Further more, the prominent features are fed to
    the machine learning algorithms to learn the patterns in the data. Finally, we
    apply the evaluation measure to judge the performance of the developed model and
    use visualization techniques to visualize the results and data. Here are the steps:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从给定数据中提取有用信息，我们首先收集要用于学习模式的原始数据。接下来，我们应用数据预处理技术来去除数据中的噪音。此外，我们从数据中提取重要特征，这些特征代表了数据，用于开发模型。特征提取是机器学习算法有效工作的最关键步骤。一个好的特征必须对机器学习算法具有信息量和区分度。特征选择技术用于去除不相关、冗余和嘈杂的特征。此外，突出的特征被输入到机器学习算法中，以学习数据中的模式。最后，我们应用评估措施来评判开发模型的性能，并使用可视化技术来可视化结果和数据。以下是步骤：
- en: Data collection
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据收集
- en: Data preprocessing
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据预处理
- en: Feature extraction
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征提取
- en: Feature selection
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征选择
- en: Machine learning
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器学习
- en: Evaluation and visualization
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估和可视化
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed in detail algorithm design techniques, which are
    very important in the computer science field. Without too much mathematical rigor,
    we also discussed some of the main categories into which algorithms are classified.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了算法设计技术，在计算机科学领域非常重要。在没有太多数学严谨的情况下，我们还讨论了一些算法分类的主要类别。
- en: Other design techniques in the field, such as the divide and conquer, dynamic
    programming, and greedy algorithms, were also covered, along with implementations
    of important sample algorithms.  Lastly, we presented a brief discussion on complexity
    classes. We saw how proof for P = NP will definitely be a game-changer in a number
    of fields, if such a proof is ever discovered.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 该领域中的其他设计技术，如分治、动态规划和贪婪算法，也被涵盖，以及重要样本算法的实现。最后，我们对复杂度类进行了简要讨论。我们看到，如果P = NP的证明被发现，它肯定会在许多领域产生重大影响。
- en: In the next chapter, we will be discussing some real-world applications, tools,
    and the basics of machine learning applications.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些真实世界的应用、工具和机器学习应用的基础知识。
