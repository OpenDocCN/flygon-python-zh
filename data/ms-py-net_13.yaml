- en: Test-Driven Development for Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络的测试驱动开发
- en: The idea of **Test-Driven Development** (**TDD**) has been around for a while.
    American software engineer Kent Beck, among others, is typically credited with
    bringing and leading the TDD movement along with agile software development. Agile
    software development requires very short build-test-deploy development cycles;
    all of the software requirements are turned into test cases. These test cases
    are usually written before the code is written, and the software code is only
    accepted when the test passes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（TDD）的想法已经存在一段时间了。美国软件工程师肯特·贝克等人通常被认为是带领TDD运动的人，同时也是敏捷软件开发的领导者。敏捷软件开发需要非常短的构建-测试-部署开发周期；所有的软件需求都被转化为测试用例。这些测试用例通常是在编写代码之前编写的，只有当测试通过时，软件代码才会被接受。'
- en: 'The same idea can be drawn in parallel with network engineering. When we face
    the challenge of designing a modern network, we can break the process down into
    the following steps:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的想法也可以与网络工程并行。当我们面临设计现代网络的挑战时，我们可以将这个过程分解为以下步骤：
- en: We start with the overall requirement for the new network. Why do we need to
    design a new or part of a new network? Maybe it is for new server hardware, a
    new storage network, or a new micro-service software architecture.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从新网络的整体需求开始。为什么我们需要设计一个新的网络或部分新的网络？也许是为了新的服务器硬件，新的存储网络，或者新的微服务软件架构。
- en: The new requirements are broken down into smaller, more specific requirements.
    This can be looking at a new switch platform, a more efficient routing protocol,
    or a new network topology (for example, fat-tree). Each of the smaller requirements
    can be broken down into the categories of must-have and optional.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的需求被分解为更小、更具体的需求。这可以是查看新的交换机平台，更高效的路由协议，或者新的网络拓扑（例如，fat-tree）。每个更小的需求都可以分解为必须和可选的类别。
- en: We draw out the test plan and evaluate it against the potential candidates for
    solutions.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们制定测试计划，并根据潜在的解决方案进行评估。
- en: The test plan will work in reverse order; we will start by testing the features,
    then integrate the new feature into a bigger topology. Finally, we will try to
    run our test as close to a production environment as possible.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试计划将按相反的顺序进行；我们将从测试功能开始，然后将新功能集成到更大的拓扑中。最后，我们将尽可能接近生产环境来运行我们的测试。
- en: The point is, even if we don't realize it, we might already be adopting a test-driven
    development methodology in network engineering. This was part of my revelation
    when I was studying the TDD mindset. We are already implicitly following this
    best practice without formalizing the method.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，即使我们没有意识到，我们可能已经在网络工程中采用了测试驱动的开发方法。这是我在学习TDD思维方式时的一部分启示。我们已经在不正式规范方法的情况下隐式地遵循了这一最佳实践。
- en: By gradually moving parts of the network as code, we can use TDD for the network
    even more. If our network topology is described in a hierarchical format in XML
    or JSON, each of the components can be correctly mapped and expressed in the desired
    state. This is the desired state that we can write test cases against. For example,
    if our desired state calls for a full mesh of switches, we can always write a
    test case to check against our production devices for the number of BGP neighbors
    it has.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐渐将网络的部分作为代码移动，我们可以更多地使用TDD来进行网络。如果我们的网络拓扑以XML或JSON的分层格式描述，每个组件都可以正确映射并以所需的状态表达。这是我们可以编写测试用例的期望状态。例如，如果我们的期望状态要求交换机的全网状，我们可以始终编写一个测试用例来检查我们的生产设备的BGP邻居数量。
- en: Test-driven development overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发概述
- en: 'The sequence of TDD is loosely based on the following six steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的顺序大致基于以下六个步骤：
- en: Write a test with the result in mind
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以结果为目标编写测试
- en: Run all tests and see whether the new test fails
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有测试，看新测试是否失败
- en: Write the code
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码
- en: Run the test again
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试
- en: Make necessary changes if the test fails
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试失败，则进行必要的更改
- en: Repeat
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复
- en: I just follow the guidelines loosely. The TDD process calls for writing the
    test cases before writing any code, or in our instance, before any components
    of the network are built. As a matter of personal preference, I always like to
    see a working version of the working network or code before writing test cases.
    It gives me a higher level of confidence. I also jump around the levels of testing;
    sometimes I test a small portion of the network; other times I conduct a system-level
    end-to-end test, such as a ping or traceroute test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是松散地遵循指南。TDD过程要求在编写任何代码之前编写测试用例，或者在我们的情况下，在构建网络的任何组件之前。出于个人偏好的原因，我总是喜欢在编写测试用例之前看到一个工作的网络或代码版本。这给了我更高的信心水平。我也在测试的级别之间跳来跳去；有时我测试网络的一小部分；其他时候我进行系统级的端到端测试，比如ping或traceroute测试。
- en: The point is, I do not believe there is a one-size-fits-all approach when it
    comes to testing. It depends on personal preference and the scope of the project.
    This is true for most of the engineers I have worked with. It is a good idea to
    keep the framework in mind, so we have a working blueprint to follow, but you
    are the best judge of your style of problem-solving.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，我不认为在测试方面有一种适合所有情况的方法。这取决于个人偏好和项目的范围。这对我合作过的大多数工程师来说都是真的。牢记框架是个好主意，这样我们就有了一个可行的蓝图，但你是解决问题风格的最佳评判者。
- en: Test definitions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试定义
- en: 'Let''s look at some of the terms commonly used in TDD:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看TDD中常用的一些术语：
- en: '**Unit test**: Checks a small piece of code. This is a test that is run against
    a single function or class'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：检查小段代码。这是针对单个函数或类运行的测试。'
- en: '**Integration test**: Checks multiple components of a code base; multiple units
    are combined and tested as a group. This can be a test that checks against a Python
    module or multiple modules'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：检查代码库的多个组件；多个单元组合在一起并作为一个组进行测试。这可以是针对Python模块或多个模块的测试'
- en: '**System test**: Checks from end to end. This is a test that runs as close
    to what an end user would see'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：端到端检查。这是一个尽可能接近最终用户所看到的测试'
- en: '**Functional test**: Checks against a single function'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：针对单个功能的检查'
- en: '**Test coverage**: A term defined as the determination of whether our test
    cases cover the application code. This is typically done by examining how much
    code is exercised when we run the test cases'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试覆盖**：一个术语，用于确定我们的测试用例是否覆盖了应用程序代码。通常通过检查运行测试用例时有多少代码被执行来完成这一点。'
- en: '**Test fixtures**: A fixed state that forms a baseline for running our tests.
    The purpose of a test fixture is to ensure there is a well-known and fixed environment
    in which tests are run, so they are repeatable'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试装置**：形成运行测试的基线的固定状态。测试装置的目的是确保测试运行在一个众所周知和固定的环境中，以便它们是可重复的'
- en: '**Setup and teardown**: All the prerequisite steps are added in the setup and
    cleaned up in the teardown'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和拆卸：所有先决步骤都添加在设置中，并在拆卸中清理
- en: The terms might seem very software-development-centric, and some might not be
    relevant to network engineering. Keep in mind that the terms are a way for us
    to communicate a concept or step we will be using these terms in the rest of this
    chapter. As we use the terms more in the network engineering context, they might
    become clearer. Let's dive into treating network topology as code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语可能看起来非常侧重于软件开发，并且有些可能与网络工程无关。请记住，这些术语是我们用来传达概念或步骤的一种方式，我们将在本章的其余部分中使用这些术语。随着我们在网络工程上下文中更多地使用这些术语，它们可能会变得更清晰。让我们深入探讨将网络拓扑视为代码。
- en: Topology as code
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拓扑作为代码
- en: Before we declare that the network is too complex, it is impossible to summarize
    it into code! Let's keep an open mind. Would it help if I tell you we have been
    using code to describe our topology in this book already?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们宣称网络太复杂，无法总结成代码之前！让我们保持开放的心态。如果我告诉您，我们已经在本书中使用代码来描述我们的拓扑，这会有所帮助吗？
- en: If you take a look at any of the VIRL topology graphs that we have been using
    in this book, they are simply XML files that include a description of the relationship
    between nodes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看本书中使用的任何VIRL拓扑图，它们只是包含节点之间关系描述的XML文件。
- en: 'In this chapter, we will use the following topology for our lab:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下拓扑进行实验：
- en: '![](assets/7a7b33f1-6e47-4a88-9d3e-11e5497c9237.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a7b33f1-6e47-4a88-9d3e-11e5497c9237.png)'
- en: 'If we open up the topology file, `chapter13_topology.virl`, with a text editor,
    we will see that the file is an XML file describing the node and the relationship
    between the nodes. The top root level is the `<topology>` node with child nodes
    of `<node>`. Each of the child nodes consists of various extensions and entries.
    The device configurations are embedded in the file as well:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用文本编辑器打开拓扑文件`chapter13_topology.virl`，我们会看到该文件是一个描述节点和节点之间关系的XML文件。顶级根节点是带有`<node>`子节点的`<topology>`节点。每个子节点都包含各种扩展和条目。设备配置也嵌入在文件中：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By expressing the network as code, we can declare a source of truth for our
    network. We can write test code to compare the actual production value against
    this blueprint. We will use this topology file as the base, and compare the production
    network value against it. But first, we will need to grab the values we want from
    the XML file. In `chapter13_1_xml.py`, we will use `ElementTree` to parse the
    `virl` topology file and construct a dictionary consisting of the information
    of our devices:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将网络表示为代码，我们可以为我们的网络声明一个真理源。我们可以编写测试代码来比较实际生产值与此蓝图。我们将使用此拓扑文件作为基础，并将生产网络值与其进行比较。但首先，我们需要从XML文件中获取我们想要的值。在`chapter13_1_xml.py`中，我们将使用`ElementTree`来解析`virl`拓扑文件，并构建一个包含我们设备信息的字典：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is a Python dictionary that consists of the devices according to
    our topology file. We can also add customary items to the dictionary:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个Python字典，其中包含根据我们的拓扑文件的设备。我们还可以向字典中添加习惯项目：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can use our example from [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, `cisco_nxapi_2.py`, to retrieve the NX-OSv
    version. When we combine the two files, we can compare the value we received from
    our topology file as well as the production device information. We can use Python's
    built-in `unittest` module to write test cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们在[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml)中的示例，*API和意图驱动网络*，`cisco_nxapi_2.py`，来检索NX-OSv版本。当我们结合这两个文件时，我们可以比较我们从拓扑文件中收到的值以及生产设备信息。我们可以使用Python内置的`unittest`模块编写测试用例。
- en: We will discuss the `unittest` module later. Feel free to skip ahead and come
    back to this example if you'd like.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将讨论`unittest`模块。如果您愿意，可以跳过并回到这个例子。
- en: 'Here is the relevant `unittest` portion in `chapter13_2_validation.py`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`chapter13_2_validation.py`中相关的`unittest`部分：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we run the validation test, we can see that the test passes because the
    software version in production matches what we expected:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行验证测试时，我们可以看到测试通过了，因为生产中的软件版本与我们预期的相匹配：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we manually change the expected NX-OSv version value to introduce a failure
    case, we will see the following failed output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手动更改预期的NX-OSv版本值以引入失败案例，我们将看到以下失败的输出：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that the test case result was returned as failed; the reason for
    failure was the version mismatch between the two values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到测试用例的结果返回为失败；失败的原因是两个值之间的版本不匹配。
- en: Python's unittest module
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的unittest模块
- en: 'In the previous example, we saw how we could use the `assertEqual()` method
    to compare the two values to return either `True` or `False`. Here is an example
    of the built-in `unittest` module to compare two values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何使用`assertEqual()`方法来比较两个值，以返回`True`或`False`。以下是内置的`unittest`模块比较两个值的示例：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the `python3` command-line interface, the `unittest` module can automatically
    discover the test cases in the script:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`python3`命令行界面，`unittest`模块可以自动发现脚本中的测试用例：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Besides comparing two values, here are more examples of testing if the expected
    value is `True` or `False`. We can also generate custom failure messages when
    a failure occurs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比较两个值之外，这里还有更多的例子，测试预期值是否为`True`或`False`。当发生失败时，我们还可以生成自定义的失败消息：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use `-v` for the option to display a more detailed output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-v`选项来显示更详细的输出：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Starting from Python 3.3, the `unittest` module includes the `module` object
    library by default ([https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)).
    This is a very useful module to make a fake HTTP API call to a remote resource
    without actually making the call. For example, we have seen the example of using
    NX-API to retrieve the NX-OS version number. What if we want to run our test,
    but we do not have an NX-OS device available? We can use the `unittest` mock object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3开始，`unittest`模块默认包含`module`对象库（[https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html)）。这是一个非常有用的模块，可以对远程资源进行假的HTTP
    API调用，而无需实际进行调用。例如，我们已经看到了使用NX-API来检索NX-OS版本号的示例。如果我们想运行我们的测试，但没有NX-OS设备可用怎么办？我们可以使用`unittest`模拟对象。
- en: 'In `chapter13_5_more_unittest_mocks.py`, we created a simple class with a method
    to make HTTP API calls and expect a JSON response:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter13_5_more_unittest_mocks.py`中，我们创建了一个简单的类，其中包含一个用于进行HTTP API调用并期望JSON响应的方法：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also created a function that mocks two URL calls:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个模拟两个URL调用的函数：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we make the API call to the two URLs in our test case. However, we
    are using the `mock.patch` decorator to intercept the API calls:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在我们的测试用例中对两个URL进行API调用。然而，我们使用`mock.patch`装饰器来拦截API调用：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we run the test, we will see that the test passes without needing to make
    an actual API call to the remote endpoint:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们会看到测试通过，而无需实际调用远程端点的API：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For more information on the `unittest` module, Doug Hellmann's Python module
    of the week ([https://pymotw.com/3/unittest/index.html#module-unittest](https://pymotw.com/3/unittest/index.html#module-unittest))
    is an excellent source of short and precise examples on the `unittest` module.
    As always, the Python documentation is a good source of information as well: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`unittest`模块的更多信息，Doug Hellmann的Python模块一周（[https://pymotw.com/3/unittest/index.html#module-unittest](https://pymotw.com/3/unittest/index.html#module-unittest)）是一个关于`unittest`模块的简短而精确的示例的绝佳来源。一如既往，Python文档也是一个很好的信息来源：[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。
- en: More on Python testing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于Python测试的内容
- en: In addition to the built-in library of `unittest`, there are lots of other Python
    testing frameworks in the community. Pytest is another robust Python testing framework
    that is worth a look. `pytest` can be used for all types and levels of software
    testing. It can be used by developers, QA engineers, individuals practicing Test-Driven
    Development, and open source projects. Many of the large-scale open source projects
    have switched from `unittest` or `nose` to `pytest`, including Mozilla and Dropbox.
    The main attractive features of `pytest` were a third-party plugin model, a simple
    fixture model, and assert rewriting.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的`unittest`库之外，社区中还有许多其他Python测试框架。Pytest是另一个强大的Python测试框架，值得一看。`pytest`可以用于各种类型和级别的软件测试。它可以被开发人员、QA工程师、练习测试驱动开发的个人和开源项目使用。许多大型开源项目已经从`unittest`或`nose`转换到`pytest`，包括Mozilla和Dropbox。`pytest`的主要吸引力在于第三方插件模型、简单的装置模型和断言重写。
- en: If you want to learn more about the `pytest` framework, I would highly recommend *Python
    Testing with PyTest* by Brian Okken (ISBN 978-1-68050-240-4). Another great source
    is the `pytest` documentation: [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`pytest`框架的信息，我强烈推荐Brian Okken的*Python Testing with PyTest*（ISBN 978-1-68050-240-4）。另一个很好的来源是`pytest`文档：[https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)。
- en: '`pytest` is command-line-driven; it can find the tests we have written automatically
    and run them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`是命令行驱动的；它可以自动找到我们编写的测试并运行它们：'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's look at some examples using `pytest`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用`pytest`的例子。
- en: pytest examples
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pytest示例
- en: 'The first `pytest` example will be a simple assert for two values:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`pytest`示例将是对两个值的简单断言：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you run with the `-v` option, `pytest` will give us a pretty robust answer
    for the failure reason:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`-v`选项运行时，`pytest`将为我们提供一个相当强大的失败原因的答案：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second example, we will create a `router` object. The `router` object
    will be initiated with some values in `None` and some values with default values.
    We will use `pytest` to test one instance with the default and one instance without:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将创建一个`router`对象。`router`对象将使用一些值进行初始化，其中一些值为`None`，另一些值为默认值。我们将使用`pytest`来测试一个具有默认值的实例和一个没有默认值的实例：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run the test, we will see whether the instance was accurately applied
    with the default values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们将看到实例是否准确地应用了默认值：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we were to replace the previous `unittest` example with `pytest`, in `chapter13_8_pytest_3.py` we
    will have a simple test case:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要用`pytest`替换之前的`unittest`示例，在`chapter13_8_pytest_3.py`中，我们将有一个简单的测试用例：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we run the test with the `pytest` command line:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`pytest`命令行运行测试：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we are writing tests for ourselves, we are free to choose any modules. Between
    `unittest` and `pytest`, I find `pytest` a more intuitive tool to use. However,
    since `unittest` is included in the standard library, many teams might have a
    preference for using the `unittest` module for their testing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为自己编写测试，我们可以自由选择任何模块。在`unittest`和`pytest`之间，我发现`pytest`是一个更直观的工具。然而，由于`unittest`包含在标准库中，许多团队可能更喜欢使用`unittest`模块进行测试。
- en: Writing tests for networking
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写网络测试
- en: So far, we have been mostly writing tests for our Python code. We have used
    both the `unittest` and `pytest` libraries to assert `True/False` and `equal/Non-equal`
    values. We were also able to write mocks to intercept our API calls when we do
    not have an actual API-capable device but still want to run our tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多数时间都在为我们的Python代码编写测试。我们使用了`unittest`和`pytest`库来断言`True/False`和`equal/Non-equal`值。我们还能够编写模拟来拦截我们的API调用，当我们没有实际的API可用设备但仍想运行我们的测试时。
- en: 'A few years ago, Matt Oswalt announced the **Testing On Demand: Distributed**
    (**ToDD**) validation tool for network changes. It is an open source framework
    aimed at testing network connectivity and distributed capacity. You can find more
    information about the project on its GitHub page: [https://github.com/toddproject/todd](https://github.com/toddproject/todd).
    Oswalt also talked about the project on this Packet Pushers Priority Queue 81,
    Network Testing with ToDD: [https://packetpushers.net/podcast/podcasts/pq-show-81-network-testing-todd/](https://packetpushers.net/podcast/podcasts/pq-show-81-network-testing-todd/).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '几年前，Matt Oswalt宣布了**Testing On Demand: Distributed**（**ToDD**）验证工具，用于测试网络连接和分布式容量。这是一个旨在测试网络连通性和分布式容量的开源框架。您可以在其GitHub页面上找到有关该项目的更多信息：[https://github.com/toddproject/todd](https://github.com/toddproject/todd)。Oswalt还在Packet
    Pushers Priority Queue 81上谈到了该项目，标题是Network Testing with ToDD：[https://packetpushers.net/podcast/podcasts/pq-show-81-network-testing-todd/](https://packetpushers.net/podcast/podcasts/pq-show-81-network-testing-todd/)。'
- en: In this section, let's look at how we can write tests that are relevant to the
    networking world. There is no shortage of commercial products when it comes to
    network monitoring and testing. Over the years, I have come across many of them.
    However, in this section, I prefer to use simple, open source tools for our tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，让我们看看如何编写与网络世界相关的测试。在网络监控和测试方面，商业产品并不少见。多年来，我接触过许多这样的产品。然而，在这一部分，我更喜欢使用简单的开源工具进行测试。
- en: Testing for reachability
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可达性测试
- en: Often, the first step of troubleshooting is to conduct a small reachability
    test. For network engineers, `ping` is our best friend when it comes to network
    reachability tests. It is a way to test the reachability of a host on an IP network
    by sending a small package across the network to the destination.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，故障排除的第一步是进行小范围的可达性测试。对于网络工程师来说，`ping`是我们在进行网络可达性测试时的好朋友。这是一种通过向目的地发送一个小数据包来测试IP网络上主机可达性的方法。
- en: 'We can automate the `ping` test via the `OS` module or the `subprocess` module:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`OS`模块或`subprocess`模块自动化`ping`测试：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `subprocess` module offers the additional benefit of catching the output
    back:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess`模块提供了捕获输出的额外好处：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These two modules prove to be very useful in many situations. Any command we
    can execute in the Linux and Unix environment can be executed via the `OS` or
    `subprocess` module.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块在许多情况下都非常有用。我们可以通过`OS`或`subprocess`模块执行在Linux和Unix环境中可以执行的任何命令。
- en: Testing for network latency
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络延迟测试
- en: The topic of network latency can sometimes be subjective. Working as a network
    engineer, we are often faced with the user saying that the network is slow. However,
    slow is a very subjective term. If we could construct tests that turn subjective
    terms into objective values, it would be very helpful. We should do this consistently
    so that we can compare the values over a time series of data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网络延迟的话题有时可能是主观的。作为网络工程师，我们经常面对用户说网络很慢的情况。然而，慢是一个非常主观的词。如果我们能构建测试，将主观的词转化为客观的值，那将非常有帮助。我们应该始终如一地这样做，这样我们就可以比较一系列数据的值。
- en: 'This can sometimes be difficult to do since the network is stateless by design.
    Just because one packet is successful does not guarantee success for the next
    packet. The best approach I have seen over the years is just to use ping across
    many hosts frequently and log the data, conducting a ping-mesh graph. We can leverage
    the same tools we used in the previous example, catch the return-result time,
    and keep a record:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时可能很难做到，因为网络是无状态的设计。成功发送一个数据包并不保证下一个数据包也会成功。多年来我见过的最好的方法就是经常使用ping跨多个主机，并记录数据，进行ping-mesh图。我们可以利用前面示例中使用的相同工具，捕获返回结果的时间，并保留记录：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the result is kept in a tuple and put into a list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果被保存在一个元组中，并放入一个列表中：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is by no means perfect, and is merely a starting point for monitoring and
    troubleshooting. However, in the absence of other tools, this offers some baseline
    of objective values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是完美的，只是监控和故障排除的起点。然而，在没有其他工具的情况下，这提供了一些客观值的基线。
- en: Testing for security
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全测试
- en: We already saw the best tool for security testing in [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml), *Network
    Security with Python*, with Scapy, in my opinion. There are lots of open source
    tools for security, but none offers the flexibility that comes with constructing
    our packets.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第6章](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml)中看到了我认为是用Python进行网络安全测试的最佳工具，即Scapy。有很多开源安全工具，但没有一个能提供构建数据包的灵活性。
- en: 'Another great tool for network security testing is `hping3` ([http://www.hping.org/](http://www.hping.org/)).
    It offers a simple way to generate a lot of packets at once. For example, you
    can use the following one-liner to generate a TCP Syn flood:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全测试的另一个很好的工具是`hping3`（[http://www.hping.org/](http://www.hping.org/)）。它提供了一种简单的方法来一次生成大量的数据包。例如，您可以使用以下一行命令生成TCP
    Syn flood：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, since this is a command-line tool, we can use the `subprocess` module
    to automate any `hping3` test we want.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于这是一个命令行工具，我们可以使用`subprocess`模块来自动化任何我们想要的`hping3`测试。
- en: Testing for transactions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易测试
- en: The network is a crucial part of the infrastructure, but it is only a part of
    it. What the users care about is often the service that runs on top of the network.
    If the user is trying to watch a YouTube video or listen to a podcast but cannot,
    in their opinion, the service is broken. We might know that it is not the network
    transport, but that doesn't comfort the user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是基础设施的重要组成部分，但它只是其中的一部分。用户关心的通常是运行在网络之上的服务。如果用户试图观看YouTube视频或收听播客却无法做到，他们会认为服务出现了故障。我们可能知道这不是网络传输的问题，但这并不能让用户感到安慰。
- en: For this reason, we should implement tests that are as similar to the user's
    experience as possible. In the example of a YouTube video, we might not be able
    to duplicate the YouTube experience 100% (unless you are part of Google), but
    we can implement a layer-seven service as close to the network edge as possible.
    We can then simulate the transaction from a client at a regular interval as a
    transactional test.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该实施尽可能接近用户体验的测试。在YouTube视频的例子中，我们可能无法100%复制YouTube体验（除非你是Google的一部分），但我们可以尽可能接近网络边缘实现第七层服务。然后，我们可以模拟来自客户端的交易作为事务性测试。
- en: 'The Python `HTTP` standard library module is a module that I often use when
    I need to quickly test layer-seven reachability on a web service:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`HTTP`标准库模块是我在需要快速测试第七层可达性的Web服务时经常使用的模块：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we can simulate a full transaction for the expected service, that is even
    better. But the Python simple `HTTP` server module in the standard library is
    always a great one for running some ad hoc web service tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以模拟预期服务的完整交易，那就更好了。但是标准库中的Python简单`HTTP`服务器模块始终是运行一些临时Web服务测试的好选择。
- en: Testing for network configuration
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络配置测试
- en: In my opinion, the best test for network configuration is using standardized
    templates to generate the configuration and back up the production configuration
    often. We have seen how we can use the Jinja2 template to standardize our configuration
    per device type or role. This will eliminate many of the mistakes caused by human
    error, such as copy and paste.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，对网络配置的最佳测试是使用标准化模板生成配置并经常备份生产配置。我们已经看到了如何使用Jinja2模板来根据设备类型或角色标准化我们的配置。这将消除许多由人为错误引起的错误，比如复制和粘贴。
- en: Once the configuration is generated, we can write tests against the configuration
    for known characteristics that we would expect before we push the configuration
    to production devices. For example, there should be no overlap of IP address in
    all of the network when it comes to loopback IP, so we can write a test to see
    whether the new configuration contains a loopback IP that is unique across our
    devices.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置生成，我们可以针对我们在将配置推送到生产设备之前期望的已知特征编写测试。例如，在网络的所有部分中，当涉及到环回IP时，IP地址不应重叠，因此我们可以编写一个测试来查看新配置是否包含在我们的设备中唯一的环回IP。
- en: Testing for Ansible
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Ansible
- en: For the time I have been using Ansible, I can not recall using a `unittest` like
    tool to test a Playbook. For the most part, the Playbooks are utilizing modules
    that were tested by the module developers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我使用Ansible的时间里，我记不起来使用类似`unittest`的工具来测试Playbook。在大多数情况下，Playbooks使用了模块，这些模块是由模块开发人员测试过的。
- en: Ansible provides unit tests for their library of modules. Unit tests in Ansible
    are currently the only way to drive tests from Python within Ansible's continuous-integration
    process. The unit tests that are run today can be found under `/test/units` ([https://github.com/ansible/ansible/tree/devel/test/units](https://github.com/ansible/ansible/tree/devel/test/units)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible为他们的模块库提供单元测试。目前，Ansible中的单元测试是从Python驱动测试的唯一方式。今天运行的单元测试可以在`/test/units` ([https://github.com/ansible/ansible/tree/devel/test/units](https://github.com/ansible/ansible/tree/devel/test/units))下找到。
- en: 'The Ansible testing strategy can be found in the following documents:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下文档中找到Ansible测试策略：
- en: '**Testing Ansible**: [https://docs.ansible.com/ansible/2.5/dev_guide/testing.html](https://docs.ansible.com/ansible/2.5/dev_guide/testing.html)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试Ansible**: [https://docs.ansible.com/ansible/2.5/dev_guide/testing.html](https://docs.ansible.com/ansible/2.5/dev_guide/testing.html)'
- en: '**Unit tests**: [https://docs.ansible.com/ansible/2.5/dev_guide/testing_units.html](https://docs.ansible.com/ansible/2.5/dev_guide/testing_units.html)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**: [https://docs.ansible.com/ansible/2.5/dev_guide/testing_units.html](https://docs.ansible.com/ansible/2.5/dev_guide/testing_units.html)'
- en: '**Unit testing Ansible modules**: [https://docs.ansible.com/ansible/2.5/dev_guide/testing_units_modules.html](https://docs.ansible.com/ansible/2.5/dev_guide/testing_units_modules.html)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试Ansible模块**: [https://docs.ansible.com/ansible/2.5/dev_guide/testing_units_modules.html](https://docs.ansible.com/ansible/2.5/dev_guide/testing_units_modules.html)'
- en: One of the interesting Ansible testing frameworks is **molecule** ([https://pypi.org/project/molecule/2.16.0/](https://pypi.org/project/molecule/2.16.0/)).
    It intends to aid in the development and testing of Ansible roles. Molecule provides
    support for testing with multiple instances, operating systems, and distributions.
    I have not used this tool, but it is where I would start if I wanted to perform
    more testing on my Ansible roles.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible测试框架中有一个有趣的工具是**molecule** ([https://pypi.org/project/molecule/2.16.0/](https://pypi.org/project/molecule/2.16.0/))。它旨在帮助开发和测试Ansible角色。Molecule支持使用多个实例、操作系统和发行版进行测试。我没有使用过这个工具，但如果我想对我的Ansible角色进行更多测试，这是我会开始的地方。
- en: Pytest in Jenkins
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins中的Pytest
- en: '**Continuous-integration** (**CI**) systems, such as Jenkins, are frequently
    used to launch tests after each of the code commits. This is one of the major
    benefits of using a CI system. Imagine that there is an invisible engineer who
    is always watching for any change in the network; upon detecting change, the engineer
    will faithfully test a bunch of functions to make sure that nothing breaks. Who
    wouldn''t want that?'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）系统，如Jenkins，经常用于在每次代码提交后启动测试。这是使用CI系统的主要好处之一。想象一下，有一个隐形的工程师一直在观察网络中的任何变化；在检测到变化后，工程师将忠实地测试一堆功能，以确保没有任何故障。谁不想要这样的工程师呢？'
- en: Let's look at an example of integrating `pytest` into the Jenkins tasks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个将`pytest`集成到Jenkins任务中的例子。
- en: Jenkins integration
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins集成
- en: 'Before we can insert the test cases into our continuous integration, let''s
    install some of the plugins that can help us visualize the operation. The two
    plugins we will install are build-name-setter and Test Result Analyzer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将测试用例插入到我们的持续集成之前，让我们安装一些可以帮助我们可视化操作的插件。我们将安装的两个插件是build-name-setter和Test
    Result Analyzer：
- en: '![](assets/cd23c244-3916-4292-bcf2-4a708cd95195.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cd23c244-3916-4292-bcf2-4a708cd95195.png)'
- en: Jenkins plugin installation
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins插件安装
- en: 'The test we will run will reach out to the NXOS device and retrieve the operating
    system version number. This will ensure that we have API reachability to the Nexus
    device. The full script content can be read in `chapter13_9_pytest_4.py` the relevant
    `pytest` portion and result are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行的测试将会连接到NXOS设备并检索操作系统版本号。这将确保我们可以通过API访问Nexus设备。完整的脚本内容可以在`chapter13_9_pytest_4.py`中阅读，相关的`pytest`部分和结果如下：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use the `--junit-xml=results.xml` option to produce the file Jenkins
    needs:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`--junit-xml=results.xml`选项来生成Jenkins需要的文件：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step would be to check this script into the GitHub repository. I prefer
    to put the test under its directory. Therefore, I created a `/test` directory
    and put the test file there:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是将此脚本检入GitHub存储库。我倾向于将测试放在其目录下。因此，我创建了一个`/test`目录，并将测试文件放在那里：
- en: '![](assets/974185c8-eb51-4ed4-86d5-5470266069bd.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/974185c8-eb51-4ed4-86d5-5470266069bd.png)'
- en: Project repository
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 项目存储库
- en: 'We will create a new project named `chapter13_example1`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`chapter13_example1`的新项目：
- en: '![](assets/5456017e-169a-4ecd-af1c-350097468fc4.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5456017e-169a-4ecd-af1c-350097468fc4.png)'
- en: Chapter 13 example 1
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章示例1
- en: 'We can copy over the previous task, so we do not need to repeat all the steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制上一个任务，这样我们就不需要重复所有步骤：
- en: '![](assets/1705abee-1ac9-4b3c-b55b-4cffa1080c59.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1705abee-1ac9-4b3c-b55b-4cffa1080c59.png)'
- en: Copy task from chapter 12 example 2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从第12章示例2复制任务
- en: 'In the execute shell section, we will add the `pytest` step:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行shell部分，我们将添加`pytest`步骤：
- en: '![](assets/10883f4c-c1a0-4230-8588-97ed8a5f2b02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/10883f4c-c1a0-4230-8588-97ed8a5f2b02.png)'
- en: Project execute shell
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 项目执行shell
- en: 'We will add a post-build step of Publish JUnit test result report:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个发布JUnit测试结果报告的构建后步骤：
- en: '![](assets/628c4028-6460-47d6-9802-16b8133f00bb.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/628c4028-6460-47d6-9802-16b8133f00bb.png)'
- en: Post-build step
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 构建后步骤
- en: 'We will specify the `results.xml` file as the JUnit result file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指定`results.xml`文件作为JUnit结果文件：
- en: '![](assets/5fc9e8fd-82ee-4259-9692-6b27b45c5cd8.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5fc9e8fd-82ee-4259-9692-6b27b45c5cd8.png)'
- en: Test report XML location
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 测试报告XML位置
- en: 'After we run the build a few times, we will be able to see the Test Result
    Analyzer graph:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建几次后，我们将能够看到测试结果分析器图表：
- en: '![](assets/91ab28c8-3cf3-475c-a267-5ebf0147fef7.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91ab28c8-3cf3-475c-a267-5ebf0147fef7.png)'
- en: Test result analyzer
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果分析器
- en: 'The test result can also be seen on the project homepage. Let''s introduce
    a test failure by shutting down the management interface of the Nexus device.
    If there is a test failure, we will be able to see it right away on the Test Result
    Trend graph on the project dashboard:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果也可以在项目主页上看到。让我们通过关闭Nexus设备的管理接口来引入一个测试失败。如果有测试失败，我们将能够立即在项目仪表板上的测试结果趋势图上看到它：
- en: '![](assets/b17f8844-1578-47c8-b6ee-32dce3b3d765.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b17f8844-1578-47c8-b6ee-32dce3b3d765.png)'
- en: Test result trend
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果趋势
- en: This is a simple but complete example. There are many ways we can integrate
    testing into Jenkins.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单但完整的例子。我们可以将测试集成到Jenkins中的许多方式。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at test-driven development and how it can be applied
    to network engineering. We started with an overview of TDD; then we looked at
    examples of using the `unittest` and `pytest` Python modules. Python and simple
    Linux command-line tools can be used to construct various tests for network reachability,
    configuration, and security.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了测试驱动开发以及如何将其应用于网络工程。我们从TDD的概述开始；然后我们看了使用`unittest`和`pytest` Python模块的示例。Python和简单的Linux命令行工具可以用来构建各种测试，包括网络可达性、配置和安全性。
- en: We also looked at how we can utilize testing in Jenkins, a continuous-integration
    tool. By integrating tests into our CI tool, we can gain more confidence in the
    sanity of our change. At the very least, we hope to catch any errors before our
    users do.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了如何在Jenkins中利用测试，这是一个持续集成工具。通过将测试集成到我们的CI工具中，我们可以更加确信我们的更改是合理的。至少，我们希望在用户之前捕捉到任何错误。
- en: Simply put, if it is not tested, it is not trusted. Everything in our network
    should be programmatically tested as much as possible. As with many software concepts,
    test-driven development is a never-ending service wheel. We strive to have as
    much test coverage as possible, but even at 100% test coverage, we can always
    find new ways and test cases to implement. This is especially true in networking,
    where the network is often the internet, and 100% test coverage of the internet
    is just not possible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果没有经过测试，就不能信任。我们网络中的一切都应尽可能地进行程序化测试。与许多软件概念一样，测试驱动开发是一个永无止境的服务轮。我们努力实现尽可能多的测试覆盖率，但即使在100%的测试覆盖率下，我们总是可以找到新的方法和测试用例来实现。这在网络中尤其如此，网络通常是互联网，而互联网的100%测试覆盖是不可能的。
