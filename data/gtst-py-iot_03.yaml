- en: Using Python for Automation and Productivity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行自动化和提高生产力
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Tkinter to create graphical user interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter创建图形用户界面
- en: Creating a graphical Start menu application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个图形启动菜单应用程序
- en: Displaying photo information in an application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中显示照片信息
- en: Organizing your photos automatically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动整理您的照片
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Until now, we have focused purely on command-line applications; however, there
    is much more to Raspberry Pi than just the command line. By using **graphical
    user interfaces** (**GUIs**), it is often easier to obtain input from a user and
    provide feedback in a simpler way. After all, we continuously process multiple
    inputs and outputs all the time, so why limit ourselves to the procedural format
    of the command line when we don't have to?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只专注于命令行应用程序；然而，树莓派不仅仅是命令行。通过使用**图形用户界面**（**GUI**），通常更容易从用户那里获取输入并以更简单的方式提供反馈。毕竟，我们一直在不断处理多个输入和输出，所以为什么在不必要的情况下限制自己只使用命令行的程序格式呢？
- en: Fortunately, Python can support this. Much like other programming languages,
    such as Visual Basic and C/C++/C#, this can be achieved using prebuilt objects
    that provide standard controls. We will use a module called **Tkinter** which
    provides a good range of controls (also referred to as **widgets**) and tools
    for creating graphical applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python可以支持这一点。与其他编程语言（如Visual Basic和C/C++/C#）类似，这可以通过使用提供标准控件的预构建对象来实现。我们将使用一个名为**Tkinter**的模块，它提供了一系列良好的控件（也称为**小部件**）和工具，用于创建图形应用程序。
- en: First, we will take an example, `encryptdecrypt.py`, and demonstrate how useful
    modules can be written and reused in a variety of ways. This is an example of
    good coding practice. We should aim to write code that can be tested thoroughly
    and then reused in many places.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将以`encryptdecrypt.py`为例，演示可以编写和在各种方式中重复使用的有用模块。这是良好编码实践的一个例子。我们应该致力于编写可以进行彻底测试，然后在许多地方重复使用的代码。
- en: Next, we will extend our previous examples by creating a small graphical Start
    menu application to run our favorite applications from.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建一个小型图形启动菜单应用程序来扩展我们之前的示例，以运行我们喜爱的应用程序。
- en: Then, we will explore using **classes** within our applications to display and
    then to
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探索在我们的应用程序中使用**类**来显示，然后
- en: organize photos.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 整理照片。
- en: Using Tkinter to create graphical user interfaces
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter创建图形用户界面
- en: We will create a basic GUI to allow the user to enter information, and the program
    can then be used to encrypt and decrypt it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的GUI，允许用户输入信息，然后程序可以用来加密和解密它。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must ensure that this file is placed in the same directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须确保该文件放置在相同的目录中。
- en: 'Since we are using Tkinter (one of many available add-ons for Python), we need
    to ensure that it is installed. It should be installed by default on the standard
    Raspbian image. We can confirm it is installed by importing it from the Python
    prompt, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了Tkinter（Python的许多可用附加组件之一），我们需要确保它已安装。它应该默认安装在标准的Raspbian镜像上。我们可以通过从Python提示符导入它来确认它已安装，如下所示：
- en: '`   Python3`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Python3`'
- en: '`   >>> import tkinter`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> import tkinter`'
- en: 'If it is not installed, an `ImportError` exception will be raised, in which
    case you can install it using the following command (use *Ctrl* + *Z* to exit
    the Python prompt):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未安装，将引发`ImportError`异常，在这种情况下，您可以使用以下命令进行安装（使用*Ctrl* + *Z*退出Python提示符）：
- en: '`   sudo apt-get install python3-tk`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt-get install python3-tk`'
- en: 'If the module did load, you can use the following command to read more about
    the module (use *Q* to quit when you are done reading):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块加载了，您可以使用以下命令来阅读有关模块的更多信息（完成阅读后使用*Q*退出）：
- en: '`   >>>help(tkinter)`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>help(tkinter)`'
- en: 'You can also get information about all the classes, functions, and methods
    within the module using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令获取有关模块内所有类、函数和方法的信息：
- en: '`   >>>help(tkinter.Button)`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>help(tkinter.Button)`'
- en: The following `dir` command will list any valid commands or variables that are
    in the scope of the `module:`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`dir`命令将列出在`module`范围内的任何有效命令或变量：
- en: '`   >>>dir(tkinter.Button)`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>dir(tkinter.Button)`'
- en: You will see that our own modules will have the information about the functions
    marked by triple quotes; this will show up if we use the `help` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到我们自己的模块将包含由三个引号标记的函数的信息；如果我们使用`help`命令，这将显示出来。
- en: The command line will not be able to display the graphical displays created
    in this chapter, so you will have to start Raspberry Pi desktop (using the command
    `startx`), or if you are using it remotely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行将无法显示本章中创建的图形显示，因此您将需要启动树莓派桌面（使用`startx`命令），或者如果您是远程使用它。
- en: Make sure you have **X11 forwarding** enabled and an **X server** running (see
    Chapter 1, *Getting Started with a Raspberry Pi 3 Computer*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已启用**X11转发**并且运行着**X服务器**（参见第1章，*使用树莓派3计算机入门*）。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will use the `tkinter` module to produce a GUI for the `encryptdecrypt.py`
    script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`tkinter`模块为`encryptdecrypt.py`脚本生成GUI。
- en: 'To generate the GUI we will create the following `tkencryptdecrypt.py` script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成GUI，我们将创建以下`tkencryptdecrypt.py`脚本：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the script using the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by importing two modules; the first is our own `encryptdecrypt` module
    and the second is the `tkinter` module. To make it easier to see which items have
    come from where, we use `ENC`/`TK`. If you want to avoid the extra reference,
    you can use `from <module_name> import *` to refer to the module items directly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入两个模块；第一个是我们自己的`encryptdecrypt`模块，第二个是`tkinter`模块。为了更容易看到哪些项目来自哪里，我们使用`ENC`/`TK`。如果您想避免额外的引用，您可以使用`from
    <module_name> import *`直接引用模块项目。
- en: The `encryptButton()` and `decryptButton()` functions will be called when we
    click on the Encrypt and Decrypt buttons; they are explained in the following
    sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击加密和解密按钮时，将调用`encryptButton()`和`decryptButton()`函数；它们将在以下部分中解释。
- en: The main Tkinter window is created using the `Tk()` command, which returns the
    main window where all the widgets/controls can be placed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Tk()`命令创建主Tkinter窗口，该命令返回所有小部件/控件可以放置的主窗口。
- en: 'We will define six controls as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义六个控件如下：
- en: '`Label`: This displays the prompt Enter message to encrypt:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`：这显示了加密消息的提示输入信息：'
- en: '`Entry`: This provides a textbox to receive the user''s message to be encrypted'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry`：这提供了一个文本框来接收用户要加密的消息'
- en: '`Button`: This is an Encrypt button to trigger the message to be encrypted'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`：这是一个加密按钮，用于触发要加密的消息'
- en: '`Button`: This is a Decrypt button to reverse the encryption'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`：这是一个解密按钮，用于反转加密'
- en: '`Label`: This displays the Key: field to prompt the user for an encryption
    key value'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`：这显示了密钥：字段以提示用户输入加密密钥值'
- en: '`Entry`: This provides a second textbox to receive values for the encryption
    keys'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry`：这提供了第二个文本框来接收加密密钥的值'
- en: 'These controls will produce a GUI similar to the one shown in the following
    screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控件将产生一个类似于以下截图所示的GUI：
- en: '![](Images/0c31ff41-4acc-4c81-aa65-3be5d6f61bac.png)The GUI to encrypt/decrypt
    messages'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/0c31ff41-4acc-4c81-aa65-3be5d6f61bac.png)加密/解密消息的GUI'
- en: 'Let''s take a look at the first `label1` definition:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下第一个`label1`的定义：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All controls must be linked to the application window; hence, we have to specify
    our Tkinter window `root`. The text used for the label is set by `text`; in this
    case, we have set it to a string named `prompt`, which has been defined previously
    with the text we require. We also set the `width` to match the number of characters
    of the message (while not essential, it provides a neater result if we add more
    text to our labels later), and finally, we set the background color using `bg='green'`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控件必须链接到应用程序窗口；因此，我们必须指定我们的Tkinter窗口`root`。标签使用的文本由`text`设置；在这种情况下，我们将其设置为一个名为`prompt`的字符串，该字符串已经在之前定义了我们需要的文本。我们还设置`width`以匹配消息的字符数（虽然不是必需的，但如果我们稍后向标签添加更多文本，它会提供更整洁的结果），最后，我们使用`bg='green'`设置背景颜色。
- en: 'Next, we define the text `Entry` box for our message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的消息定义文本`Entry`框：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will define `textvariable`—a useful way to link a variable to the contents
    of the box which is a special string variable. We could access the `text` directly
    using `textEnter.get()`, but we shall use a `Tkinter StringVar()` object instead
    to access it indirectly. If required, this will allow us to separate the data
    we are processing from the code that handles the GUI layout. The `enycrptvalue`
    variable automatically updates the `Entry` widget it is linked to whenever the
    `.set()` command is used (and the `.get()` command obtains the latest value from
    the `Entry` widget).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`textvariable`——将一个变量链接到框的内容的一种有用的方式，这是一个特殊的字符串变量。我们可以直接使用`textEnter.get()`访问`text`，但我们将使用一个`Tkinter
    StringVar()`对象来间接访问它。如果需要，这将允许我们将正在处理的数据与处理GUI布局的代码分开。`enycrptvalue`变量在使用`.set()`命令时会自动更新它所链接到的`Entry`小部件（并且`.get()`命令会从`Entry`小部件获取最新的值）。
- en: 'Next, we have our two `Button` widgets, Encrypt and Decrypt, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个`Button`小部件，加密和解密，如下所示：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, we can set a function to be called when the `Button` widget is
    clicked by setting the `command` attribute. We can define the two functions that
    will be called when each button is clicked. In the following code snippet, we
    have the `encryptButton()` function, which will set the `encryptvalue StringVar`
    that controls the contents of the first `Entry` box. This string is set to the
    result we get by calling `ENC.encryptText()` with the message we want to encrypt
    (the current value of `encryptvalue`) and the `keyvalue` variable. The `decrypt()`
    function is exactly the same, except we make the `keyvalue` variable negative
    to decrypt the message:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以设置一个函数，当点击`Button`小部件时调用该函数，方法是设置`command`属性。我们可以定义两个函数，当每个按钮被点击时将被调用。在以下代码片段中，我们有`encryptButton()`函数，它将设置控制第一个`Entry`框内容的`encryptvalue
    StringVar`。这个字符串被设置为我们通过调用`ENC.encryptText()`得到的结果，我们要加密的消息（`encryptvalue`的当前值）和`keyvalue`变量。`decrypt()`函数完全相同，只是我们将`keyvalue`变量设置为负数以解密消息：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then set the final `Label` and `Entry` widgets in a similar way. Note that
    `textvariable` can also be an integer (numerical value) if required, but there
    is no built-in check to ensure that only numbers can be entered. You will encounter
    a `ValueError` exception when the `.get()` command is used.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们以类似的方式设置最终的`Label`和`Entry`小部件。请注意，如果需要，`textvariable`也可以是整数（数值），但没有内置检查来确保只能输入数字。当使用`.get()`命令时，会遇到`ValueError`异常。
- en: 'After we have defined all the widgets to be used in the Tkinter window, we
    have to set the layout. There are three ways to define the layout in Tkinter:
    *place*, *pack*, and *grid*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了Tkinter窗口中要使用的所有小部件之后，我们必须设置布局。在Tkinter中有三种定义布局的方法：*place*、*pack*和*grid*。
- en: The place layout allows us to specify the positions and sizes using exact pixel
    positions. The pack layout places the items in the window in the order that they
    have been added in. The grid layout allows us to place the items in a specific
    layout. It is recommended that you avoid the place layout wherever possible since
    any small change to one item can have a knock-on effect on the positions and sizes
    of all the other items; the other layouts account for this by determining their
    positions relative to the other items in the window.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: place布局允许我们使用精确的像素位置指定位置和大小。pack布局按照它们被添加的顺序将项目放置在窗口中。grid布局允许我们以特定的布局放置项目。建议尽量避免使用place布局，因为对一个项目进行任何小的更改都可能对窗口中所有其他项目的位置和大小产生连锁效应；其他布局通过确定它们相对于窗口中其他项目的位置来解决这个问题。
- en: 'We will place the items as laid out in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下截图中的布局放置这些项目：
- en: '![](Images/9d8b128f-ce62-43af-bee2-b9fd14f9bfaa.png)Grid layout for the Encrypt/Decrypt
    GUI'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9d8b128f-ce62-43af-bee2-b9fd14f9bfaa.png)加密/解密GUI的网格布局'
- en: 'The positions of first two items in the GUI are set using the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码设置GUI中前两个项目的位置：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can specify that the first `Label` and `Entry` box will span both columns
    (`columnspan=2`), and we can set the sticky values to ensure they span right to
    the edges. This is achieved by setting both the `TK.E` for the east and `TK.W`
    for the west sides. We'd use `TK.N` for the north and `TK.S` for the south sides
    if we needed to do the same vertically. If the `column` value is not specified,
    the grid function defaults to `column=0`. The other items are similarly defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定第一个`Label`和`Entry`框将跨越两列（`columnspan=2`），并且我们可以设置粘性值以确保它们跨越整个宽度。这是通过设置`TK.E`表示东边和`TK.W`表示西边来实现的。如果需要在垂直方向上做同样的操作，我们会使用`TK.N`表示北边和`TK.S`表示南边。如果未指定`column`值，`grid`函数会默认为`column=0`。其他项目也是类似定义的。
- en: The last step is to call `TK.mainloop()`, which allows Tkinter to run; this
    allows the buttons to be monitored for clicks and Tkinter to call the functions
    linked to them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用`TK.mainloop()`，这允许Tkinter运行；这允许监视按钮点击并调用与它们链接的函数。
- en: Creating a graphical application – Start menu
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形应用程序-开始菜单
- en: The example in this recipe shows how we can define our own variations of Tkinter
    objects to generate custom controls and dynamically construct a menu with them.
    We will also take a quick look at using threads to allow other tasks to continue
    to function while a particular task is being executed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例显示了如何定义我们自己的Tkinter对象的变体，以生成自定义控件并动态构建菜单。我们还将简要介绍使用线程来允许其他任务继续运行，同时执行特定任务。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To view the GUI display, you will need a monitor displaying the Raspberry Pi
    desktop, or you need to be connected to another computer running the X server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看GUI显示，您需要一个显示树莓派桌面的显示器，或者您需要连接到另一台运行X服务器的计算机。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create a graphical Start menu application, create the following `graphicmenu.py`
    script:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建图形开始菜单应用程序，请创建以下`graphicmenu.py`脚本：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous code produces the following application:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的代码产生了以下应用程序：
- en: '![](Images/3782c238-32f5-4d5f-bcda-66536357deb0.png)The App Menu GUI'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/3782c238-32f5-4d5f-bcda-66536357deb0.png)应用程序菜单GUI'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create the Tkinter window as we did before; however, instead of defining
    all the items separately, we create a special class for the application buttons.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建Tkinter窗口与之前一样；但是，我们不是单独定义所有项目，而是为应用程序按钮创建一个特殊的类。
- en: The class we create acts as a blueprint or specification of what we want the
    `appButtons` items to include. Each item will consist of a string value for `app_cmd`,
    a function called `startApp()`, and an `__init__()` function. The `__init__()`
    function is a special function (called a **constructor**) that is called when
    we create an `appButtons` item; it will allow us to create any setup that is required.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的类充当了`appButtons`项目要包含的蓝图或规范。每个项目将包括一个`app_cmd`的字符串值，一个名为`startApp()`的函数和一个`__init__()`函数。`__init__()`函数是一个特殊函数（称为**构造函数**），当我们创建一个`appButtons`项目时会调用它；它将允许我们创建任何所需的设置。
- en: In this case, the `__init__()` function allows us to create a new Tkinter button
    with the text to be set to an item in `app_list` and the command to be called
    in the `startApp()` function when the button is clicked. The `self` keyword is
    used so that the command called will be the one that is part of the item; this
    means that each button will call a locally defined function that has access to
    the local data of the item.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`__init__()`函数允许我们创建一个新的Tkinter按钮，其中文本设置为`app_list`中的一个项目，当点击按钮时调用`startApp()`函数。使用`self`关键字是为了调用属于该项目的命令；这意味着每个按钮将调用一个具有访问该项目的本地数据的本地定义函数。
- en: We set the value of `self.app_cmd` to the command from `app_list` and make it
    ready for use via the `startApp()` function. We now create the `startApp()` function.
    If we run the application command here directly, the Tkinter window will freeze
    until the application we have opened is closed again. To avoid this, we can use
    the Python threading module, which allows us to perform multiple actions at the
    same time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`self.app_cmd`的值设置为`app_list`中的命令，并通过`startApp()`函数准备好使用。现在我们创建`startApp()`函数。如果我们直接在这里运行应用程序命令，Tkinter窗口将会冻结，直到我们打开的应用程序再次关闭。为了避免这种情况，我们可以使用Python线程模块，它允许我们同时执行多个操作。
- en: The `runApplicationThread()` class is created using the `threading.Thread` class
    as a template—this inherits all the features of the `threading.Thread` class in
    a new class. Just like our previous class, we provide an `__init__()` function
    for this as well. We first call the `__init__()` function of the inherited class
    to ensure it is set up correctly, and then we store the `app_cmd` value in `self.cmd`.
    After the `runApplicationThread()` function has been created and initialized,
    the `start()` function is called. This function is part of `threading.Thread`,
    which our class can use. When the `start()` function is called, it will create
    a separate application thread (that is, simulate running two things at the same
    time), allowing Tkinter to continue monitoring button clicks while executing the
    `run()` function within the class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`runApplicationThread()`类是使用`threading.Thread`类作为模板创建的——这个类继承了`threading.Thread`类的所有特性。和之前的类一样，我们也为这个类提供了`__init__()`函数。我们首先调用继承类的`__init__()`函数以确保它被正确设置，然后我们将`app_cmd`的值存储在`self.cmd`中。创建并初始化`runApplicationThread()`函数后，调用`start()`函数。这个函数是`threading.Thread`的一部分，我们的类可以使用它。当调用`start()`函数时，它将创建一个单独的应用程序线程（也就是说，模拟同时运行两个任务），允许Tkinter在执行类中的`run()`函数时继续监视按钮点击。'
- en: Therefore, we can place the code in the `run()` function to run the required
    application (using `call(self.cmd)`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将代码放在`run()`函数中来运行所需的应用程序（使用`call(self.cmd)`）。
- en: There's more...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One aspect that makes Python particularly powerful is that it supports the programming
    techniques used in **Object-Orientated Design** (**OOD**). This is commonly used
    by modern programming languages to help translate the tasks we want our program
    to perform into meaningful constructs and structures in code. The principle of
    OOD lies in the fact that we think of most problems as consisting of several objects
    (a GUI window, a button, and so on) that interact with each other to produce a
    desired result.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使Python特别强大的一个方面是它支持**面向对象设计**（**OOD**）中使用的编程技术。这是现代编程语言常用的一种技术，用来帮助将我们希望程序执行的任务转化为代码中有意义的构造和结构。OOD的原则在于，我们认为大多数问题都由几个对象（GUI窗口、按钮等）组成，它们相互交互以产生期望的结果。
- en: In the previous section, we found that we could use classes to create unique
    objects that could be reused multiple times. We created an `appButton` class,
    which generated an object with all the features of the class, including its own
    personal version of `app_cmd` that will be used by the `startApp()` function.
    Another object of the `appButton` type will have its own unrelated `[app_cmd]`
    data that its `startApp()` function will use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们发现可以使用类来创建可以多次重复使用的唯一对象。我们创建了一个`appButton`类，它生成了一个具有该类所有功能的对象，包括其自己的`app_cmd`版本，该版本将被`startApp()`函数使用。`appButton`类型的另一个对象将有其自己不相关的`[app_cmd]`数据，其`startApp()`函数将使用它。
- en: You can see that classes are useful to keep together a collection of related
    variables and functions in a single object, and the class will hold its own data
    in one place. Having multiple objects of the same type (class), each with their
    own functions and data inside them, results in better program structure. The traditional
    approach would be to keep all the information in one place and send each item
    back and forth for various functions to process; however, this may become cumbersome
    in large systems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，类对于将一组相关的变量和函数集中在一个对象中非常有用，而且类将在一个地方保存它自己的数据。拥有同一类型（类）的多个对象，每个对象内部都有自己的函数和数据，会导致更好的程序结构。传统的方法是将所有信息保存在一个地方，然后来回发送每个项目以供各种函数处理；然而，在大型系统中，这可能变得繁琐。
- en: 'The following diagram shows the organization of related functions and data:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了相关函数和数据的组织结构：
- en: '![](Images/d265bf45-fa70-4e20-be88-fa9b3234d317.png)Data and functions'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d265bf45-fa70-4e20-be88-fa9b3234d317.png)数据和函数'
- en: So far, we have used Python modules to separate parts of our programs into different
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用Python模块将程序的不同部分分开。
- en: files; this allows us to conceptually separate different parts of the program
    (an interface, encoder/decoder, or library of classes, such as Tkinter). Modules
    can provide code to control a particular bit of hardware, define an interface
    for the internet, or provide a library of common functionality; however, its most
    important function is to control the interface (the collection of functions, variables,
    and classes that are available when the item is imported). A well-implemented
    module should have a clear interface that is centered around how it is used, rather
    than how it is implemented. This allows you to create multiple modules that can
    be swapped and changed easily since they share the same interface. In our previous
    example, imagine how easy it would be to change the `encryptdecrypt` module for
    another one just by supporting `encryptText(input_text,key)`. Complex functionality
    can be split into smaller, manageable blocks that can be reused in multiple applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 文件；这使我们能够在概念上将程序的不同部分分开（界面、编码器/解码器或类库，比如Tkinter）。模块可以提供控制特定硬件的代码，定义互联网接口，或提供常用功能的类库；然而，它最重要的功能是控制接口（在导入项目时可用的函数、变量和类的集合）。一个良好实现的模块应该有一个清晰的接口，其重点是围绕它的使用方式，而不是它的实现方式。这使你能够创建多个可以轻松交换和更改的模块，因为它们共享相同的接口。在我们之前的例子中，想象一下，通过支持`encryptText(input_text,key)`，要将`encryptdecrypt`模块更改为另一个模块是多么容易。复杂的功能可以分解成更小、可管理的块，可以在多个应用程序中重复使用。
- en: Python makes use of classes and modules all the time. Each time you import a
    library, such as `sys` or Tkinter or convert a value using `value.str()` and iterate
    through a list using `for...in`, you can use them without worrying about the details.
    You don't have to use classes or modules in every bit of code you write, but they
    are useful tools to keep in your programmer's toolbox for times when they fit
    what you are doing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python一直在使用类和模块。每次你导入一个库，比如`sys`或Tkinter，或者使用`value.str()`转换一个值，或者使用`for...in`遍历一个列表，你都可以在不用担心细节的情况下使用它们。你不必在你写的每一行代码中都使用类或模块，但它们是你程序员工具箱中有用的工具，适合你正在做的事情时使用。
- en: We will understand how classes and modules allow us to produce well-structured
    code that is easier to test and maintain by using them in the examples of this
    book.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在本书的示例中使用类和模块，我们将了解它们如何使我们能够生成结构良好、易于测试和维护的代码。
- en: Displaying photo information in an application
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中显示照片信息
- en: In this example, we shall create a utility class to handle photos that can be
    used by other applications (as modules) to access photo metadata and display preview
    images easily.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个实用类来处理照片，其他应用程序（作为模块）可以使用它来访问照片元数据并轻松显示预览图像。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The following script makes use of **Python Image Library** (**PIL**); a compatible
    version for Python 3 is **Pillow**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本使用了**Python Image Library**（**PIL**）；Python 3的兼容版本是**Pillow**。
- en: Pillow has not been included in the Raspbian repository (used by `apt-get`);
    therefore, we will need to install Pillow using a **Python Package Manager** called
    **PIP**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow没有包含在Raspbian仓库中（由`apt-get`使用）；因此，我们需要使用名为**PIP**的**Python包管理器**来安装Pillow。
- en: To install packages for Python 3, we will use the Python 3 version of PIP (this
    requires 50 MB of available space).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Python 3安装包，我们将使用Python 3版本的PIP（这需要50MB的可用空间）。
- en: 'The following commands can be used to install PIP:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于安装PIP：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before you use PIP, ensure that you have installed `libjpeg-dev` to allow Pillow
    to handle JPEG files. You can do this using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PIP之前，请确保已安装`libjpeg-dev`以允许Pillow处理JPEG文件。您可以使用以下命令执行此操作：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can install Pillow using the following PIP command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用以下PIP命令安装Pillow：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: PIP also makes it easy to uninstall packages using `uninstall` instead of `install`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: PIP还可以通过使用`uninstall`而不是`install`来轻松卸载软件包。
- en: 'Finally, you can confirm that it has installed successfully by running `python3`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行`python3`来确认它已成功安装：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should not get any errors and see lots of information about PIL and its
    uses (press *Q* to finish). Check the version installed as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该收到任何错误，并且应该看到有关PIL及其用途的大量信息（按*Q*键完成）。按照以下方式检查安装的版本：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should see `2.7.0` (or similar).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到`2.7.0`（或类似）。
- en: 'PIP can also be used with Python 2 by installing pip-2.x using the following
    command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下命令安装pip-2.x，PIP也可以与Python 2一起使用：
- en: '`   sudo apt-get install python-pip`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`   sudo apt-get install python-pip`'
- en: Any packages installed using `sudo pip install` will be installed just for Python
    2.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sudo pip install`安装的任何软件包都将仅为Python 2安装。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To display photo information in an application, create the following `photohandler.py`
    script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中显示照片信息，请创建以下`photohandler.py`脚本：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code defines our `Photo` class; it is of no use to us until we
    run it in the *There's more...* section and in the next example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了我们的`Photo`类；在*还有更多...*部分和下一个示例中运行它之前，它对我们没有用处。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define a general class called `Photo`; it contains details about itself and
    provides
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Photo`的通用类；它包含有关自身的详细信息，并提供
- en: functions to access **Exchangeable Image File Format** (**EXIF**) information
    and generate
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问**可交换图像文件格式**（**EXIF**）信息并生成的函数
- en: a preview image.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个预览图像。
- en: In the `__init__()` function, we set values for our class variables and call
    `self.initImage()`, which will open the image using the `Image()` function from
    the PIL. We then call `self.initExif()` and `self.initDates()` and set a flag
    to indicate whether the file was valid or not. If not valid, the `Image()` function
    would raise an `IOError` exception.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`函数中，我们为我们的类变量设置值，并调用`self.initImage()`，它将使用PIL中的`Image()`函数打开图像。然后我们调用`self.initExif()`和`self.initDates()`，并设置一个标志来指示文件是否有效。如果无效，`Image()`函数将引发`IOError`异常。
- en: 'The `initExif()` function uses PIL to read the EXIF data from the `img` object,
    as shown in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`initExif()`函数使用PIL从`img`对象中读取EXIF数据，如下面的代码片段所示：'
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code is a series of compound statements that results in `self.exif_info`
    being populated with a dictionary of tag names and their related values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一系列复合语句，导致`self.exif_info`被填充为标签名称及其相关值的字典。
- en: '`ExifTag.TAGS` is a dictionary that contains a list of possible tag names linked
    with their IDs, as shown in the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExifTag.TAGS`是一个包含可能的标签名称及其ID的列表的字典，如下面的代码片段所示：'
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `image._getexif()` function returns a dictionary that contains all the
    values set by the camera of the image, each linked to their relevant IDs, as shown
    in the following code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`image._getexif()`函数返回一个包含图像相机设置的所有值的字典，每个值都与其相关的ID链接，如下面的代码片段所示：'
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `for` loop will go through each item in the image''s EXIF value dictionary
    and check for its occurrence in the `ExifTags.TAGS` dictionary; the result will
    get stored in `self.exif_info`. The code for this is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将遍历图像的EXIF值字典中的每个项目，并检查其在`ExifTags.TAGS`字典中的出现；结果将存储在`self.exif_info`中。其代码如下：'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, if there are no exceptions, we set a flag to indicate that the EXIF data
    is valid, or if there is no EXIF data, we raise an `AttributeError` exception.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果没有异常，我们将设置一个标志来指示EXIF数据是有效的，或者如果没有EXIF数据，我们将引发`AttributeError`异常。
- en: The `initDates()` function allows us to gather all the possible file dates and
    dates from the EXIF data so that we can select one of them as the date we wish
    to use for the file. For example, it allows us to rename all the images to a filename
    in the standard date format. We create a `self.filedates` dictionary that we populate
    with three dates extracted from the EXIF information. We then add the filesystem
    dates (created and modified) just in case no EXIF data is available. The `os`
    module allows us to use `os.path.getctime()` and `os.path.getmtime()` to obtain
    an epoch value of the file creation. It can also be the date and time when the
    file was moved – and the file modification – when it was last written to (for
    example, it often refers to the date when the picture was taken). The epoch value
    is the number of seconds since January 1, 1970, but we can use `datetime.datetime.fromtimestamp()`
    to convert it into years, months, days, hours, and seconds. Adding `date()` simply
    limits it to years, months, and days.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`initDates()`函数允许我们收集所有可能的文件日期和来自EXIF数据的日期，以便我们可以选择其中一个作为我们希望用于文件的日期。例如，它允许我们将所有图像重命名为标准日期格式的文件名。我们创建一个`self.filedates`字典，其中包含从EXIF信息中提取的三个日期。然后添加文件系统日期（创建和修改），以防没有EXIF数据可用。`os`模块允许我们使用`os.path.getctime()`和`os.path.getmtime()`来获取文件创建的时期值。它也可以是文件移动时的日期和时间-最后写入的文件修改时间（例如，通常指图片拍摄的日期）。时期值是自1970年1月1日以来的秒数，但我们可以使用`datetime.datetime.fromtimestamp()`将其转换为年、月、日、小时和秒。添加`date()`只是将其限制为年、月和日。'
- en: Now, if the `Photo` class was to be used by another module, and we wished to
    know the date of the image that was taken, we could look at the `self.dates` dictionary
    and pick out a suitable date. However, this would require the programmer to know
    how the `self.dates` values are arranged, and if we later changed how they are
    stored, it would break their program. For this reason, it is recommended that
    we access data in a class through access functions so the implementation is independent
    of the interfaces (this process is known as **encapsulation**). We provide a function
    that returns a date when called; the programmer does not need to know that it
    could be one of the five available dates or even that they are stored as epoch
    values. Using a function, we can ensure that the interface will remain the same
    no matter how the data is stored or collected.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`Photo`类被另一个模块使用，并且我们希望知道拍摄的图像的日期，我们可以查看`self.dates`字典并选择合适的日期。但是，这将要求程序员知道`self.dates`值的排列方式，如果以后更改了它们的存储方式，将会破坏他们的程序。因此，建议我们通过访问函数访问类中的数据，以便实现独立于接口（这个过程称为**封装**）。我们提供一个在调用时返回日期的函数；程序员不需要知道它可能是五个可用日期中的一个，甚至不需要知道它们是作为时期值存储的。使用函数，我们可以确保接口保持不变，无论数据的存储或收集方式如何。
- en: Finally, the last function we want the `Photo` class to provide is `previewPhoto()`.
    This function provides a method to generate a small thumbnail image and saves
    it as a **Portable Pixmap Format** (**PPM**) file. As we will discover in a moment,
    Tkinter allows us to place images on its `Canvas` widget, but unfortunately, it
    does not support JPEGs directly and only supports GIF or PPM. Therefore, we simply
    save a small copy of the image we want to display in the PPM format – with the
    added warning that the image pallet must be converted to RGB too – and then get
    Tkinter to load it onto the `Canvas` when required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望`Photo`类提供的最后一个函数是`previewPhoto()`。此函数提供了一种生成小缩略图图像并将其保存为**便携式像素图格式**(**PPM**)文件的方法。正如我们将在一会儿发现的那样，Tkinter允许我们将图像放在其`Canvas`小部件上，但不幸的是，它不直接支持JPEG，只支持GIF或PPM。因此，我们只需将要显示的图像的小副本保存为PPM格式，然后让Tkinter在需要时将其加载到`Canvas`上。
- en: 'To summarize, the `Photo` class we have created is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们创建的`Photo`类如下：
- en: '| **Operations** | **Description** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| `__init__(self,filename)` | This is the object initializer. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `__init__(self,filename)` | 这是对象初始化程序。 |'
- en: '| `initImage(self)` | This returns `img`, a PIL-type image object. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `initImage(self)` | 这将返回`img`，一个PIL类型的图像对象。 |'
- en: '| `initExif(self,image)` | This extracts all the EXIF information, if any is
    present. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `initExif(self,image)` | 如果存在，这将提取所有的EXIF信息。 |'
- en: '| `initDates(self)` | This creates a dictionary of all the dates available
    from the file and photo information. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `initDates(self)` | 这将创建一个包含文件和照片信息中所有可用日期的字典。 |'
- en: '| `getDate(self)` | This returns a string of the date when the photo was taken/created.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `getDate(self)` | 这将返回照片拍摄/创建的日期的字符串。 |'
- en: '| `previewPhoto(self)` | This returns a string of the filename of the previewed
    thumbnail. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `previewPhoto(self)` | 这将返回预览缩略图的文件名的字符串。 |'
- en: 'The properties and their respective descriptions are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 属性及其相应的描述如下：
- en: '| **Properties** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `self.filename` | The filename of the photo. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `self.filename` | 照片的文件名。 |'
- en: '| `self.filevalid` | This is set to `True` if the file is opened successfully.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `self.filevalid` | 如果文件成功打开，则设置为`True`。 |'
- en: '| `self.exifvalid` | This is set to `True` if the photo contains EXIF information.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `self.exifvalid` | 如果照片包含EXIF信息，则设置为`True`。 |'
- en: '| `self.exif_info` | This contains the EXIF information from the photo. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `self.exif_info` | 这包含照片的EXIF信息。 |'
- en: '| `self.filedates` | This contains a dictionary of the available dates from
    the file and photo information. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `self.filedates` | 这包含了文件和照片信息中可用日期的字典。 |'
- en: To test the new class, we will create some test code to confirm that everything
    is working as we expect; see the following section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试新类，我们将创建一些测试代码来确认一切是否按我们的预期工作；请参阅以下部分。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We previously created the `Photo` class. Now we can add some test code to our
    module to ensure that it functions as we expect. We can use the `__name__ ="__main__"`
    attribute
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了`Photo`类。现在我们可以向我们的模块中添加一些测试代码，以确保它按我们的预期运行。我们可以使用`__name__ ="__main__"`属性
- en: as before to detect whether the module has been run directly or not.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，以检测模块是否直接运行。
- en: 'We can add the subsequent section of code at the end of the `photohandler.py`
    script to produce the following test application, which looks as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`photohandler.py`脚本的末尾添加以下代码段，以生成以下测试应用程序，其外观如下：
- en: '![](Images/0ced9d12-c53e-4896-9395-4d7563b3b1e4.png)The Photo View Demo application'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/0ced9d12-c53e-4896-9395-4d7563b3b1e4.png)照片查看演示应用程序'
- en: 'Add the following code at the end of `photohandler.py`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在`photohandler.py`的末尾添加以下代码： '
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous test code will run the `main()` function, which takes the filename
    of a photo to use and creates a new `Photo` object called `viewPhoto`. If `viewPhoto`
    is opened successfully, we will call `dispPreview()` to display the image and
    its details.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试代码将运行`main()`函数，该函数获取要使用的照片的文件名，并创建一个名为`viewPhoto`的新`Photo`对象。如果`viewPhoto`成功打开，我们将调用`dispPreview()`来显示图像及其详细信息。
- en: 'The `dispPreview()` function creates four Tkinter widgets to be displayed:
    a `Canvas` to load the thumbnail image, a `Listbox` widget to display the photo
    information, and two scroll bars to control the `Listbox`. First, we create a
    `Canvas` widget the size of the thumbnail image (`previewsize`).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispPreview()`函数创建四个Tkinter小部件以显示：一个`Canvas`加载缩略图图像，一个`Listbox`小部件显示照片信息，以及两个滚动条来控制`Listbox`。首先，我们创建一个`Canvas`小部件，大小与缩略图图像(`previewsize`)相同。'
- en: Next, we create `photoInfo`, which will be our `listvariable` parameter linked
    to the `Listbox` widget. Since Tkinter doesn't provide a `ListVar()` function
    to create a suitable item, we use the generic type `TK.Variable()` and then ensure
    we convert it to a tuple type before setting the value. The `Listbox` widget gets
    added; we need to make sure that the `listvariable` parameter is set to `photoInfo`
    and also set the font to `monospace`. This will allow us to line up our data values
    using spaces, as `monospace` is a fixed width font, so each character takes up
    the same width as any other.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建`photoInfo`，它将是我们与`Listbox`小部件关联的`listvariable`参数。由于Tkinter没有提供`ListVar()`函数来创建合适的项目，我们使用通用类型`TK.Variable()`，然后确保在设置值之前将其转换为元组类型。添加`Listbox`小部件；我们需要确保`listvariable`参数设置为`photoInfo`，并且将字体设置为`monospace`。这将允许我们使用空格对齐我们的数据值，因为`monospace`是等宽字体，所以每个字符占用的宽度都相同。
- en: 'We define the two scroll bars, linking them to the `Listbox` widget, by setting
    the `Scrollbar` command parameters for vertical and horizontal scroll bars to
    `lbPhotoInfo.yview` and `lbPhotoInfo.xview`. Then, we adjust the parameters of
    the `Listbox` using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`Scrollbar`命令参数设置为`lbPhotoInfo.yview`和`lbPhotoInfo.xview`来定义两个滚动条，并将它们链接到`Listbox`小部件。然后，我们使用以下命令调整`Listbox`的参数：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `configure` command allows us to add or change the widget's parameters after
    it has been created, in this case linking the two scroll bars so the `Listbox`
    widget can also control them if the user scrolls within the list.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`命令允许我们在创建小部件后添加或更改小部件的参数，在这种情况下，链接两个滚动条，以便`Listbox`小部件在用户在列表中滚动时也可以控制它们。'
- en: As before, we make use of the grid layout to ensure that the `Listbox` widget
    has the two scroll bars placed correctly next to it and the `Canvas` widget is
    to the left of the `Listbox` widget.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们利用网格布局来确保`Listbox`小部件旁边正确放置了两个滚动条，`Canvas`小部件位于`Listbox`小部件的左侧。
- en: 'We now use the `Photo` object to create the `preview.ppm` thumbnail file (using
    the `aPhoto.previewPhoto()` function) and create a `TK.PhotoImage` object that
    can then be added to the `Canvas` widget with the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`Photo`对象创建`preview.ppm`缩略图文件（使用`aPhoto.previewPhoto()`函数），并创建一个`TK.PhotoImage`对象，然后可以使用以下命令将其添加到`Canvas`小部件中：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we use the date information that the `Photo` class gathers and the
    EXIF information (ensuring it is valid first) to populate the `Listbox` widget.
    We do this by converting each item into a list of strings that are spaced out
    using `.ljust(25)`—it adds left justification to the name and pads it out to make
    the string 25 characters wide. Once we have the list, we convert it to a tuple
    type and set the `listvariable` (`photoInfo`) parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Photo`类收集的日期信息和EXIF信息（确保它首先是有效的）来填充`Listbox`小部件。我们通过将每个项目转换为一系列使用`.ljust(25)`间隔的字符串来实现这一点——它添加左对齐到名称，并填充它使字符串宽度为25个字符。一旦我们有了列表，我们将其转换为元组类型并设置`listvariable`（`photoInfo`）参数。
- en: As always, we call `app.mainloop()` to start monitoring for events to respond
    to.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们调用`app.mainloop()`来开始监视事件以做出响应。
- en: Organizing your photos automatically
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动整理您的照片
- en: Now that we have a class that allows us to gather information about photos,
    we can apply this information to perform useful tasks. In this case, we will use
    the file information to automatically organize a folder full of photos into a
    subset of folders based on the dates the photos were taken on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个允许我们收集照片信息的类，我们可以将这些信息应用于执行有用的任务。在这种情况下，我们将使用文件信息自动将一个充满照片的文件夹组织成基于照片拍摄日期的子文件夹的子集。
- en: 'The following screenshot shows the output of the script:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了脚本的输出：
- en: '![](Images/d390e81f-0293-40ab-943b-25d1887f41e3.png)Script output to organize
    photos in folder'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d390e81f-0293-40ab-943b-25d1887f41e3.png)脚本输出以整理文件夹中的照片'
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a selection of photos placed in a folder on Raspberry Pi. Alternatively,
    you can insert a USB memory stick or a card reader with photos on it—they will
    be located in `/mnt/`. However, please make sure you test the scripts with a copy
    of your photos first, just in case there are any problems.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在树莓派上的一个文件夹中放置一些照片。或者，您可以插入一个带有照片的USB存储设备或读卡器——它们将位于`/mnt/`中。但是，请确保您首先使用照片的副本测试脚本，以防出现任何问题。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the following script in `filehandler.py` to automatically organize your
    photos:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下脚本`filehandler.py`以自动整理您的照片：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We shall make a class called `FileList`; it will make use of the `Photo` class
    to manage
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`FileList`的类；它将使用`Photo`类来管理
- en: 'the photos within a specific folder. There are two main steps for this: we
    first need to find all the images within the folder, and then generate a list
    containing both the filename and the photo date. We will use this information
    to generate new subfolders and move the photos into these folders.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 特定文件夹中的照片。这有两个主要步骤：首先需要找到文件夹中的所有图像，然后生成一个包含文件名和照片日期的列表。我们将使用这些信息生成新的子文件夹，并将照片移动到这些文件夹中。
- en: When we create the `FileList` object, we will create the list using `listFileDates()`.
    We will then confirm that the folder provided is valid and use `os.listdir` to
    obtain the full list of files within the directory. We will check that each file
    is a JPEG file and obtain each photo's date (using the function defined in the
    `Photo` class). Next, we will add the filename and date as a tuple to the `self.photo_namedates`
    list.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`FileList`对象时，我们将使用`listFileDates()`创建列表。然后，我们将确认提供的文件夹是有效的，并使用`os.listdir`获取目录中的所有文件的完整列表。我们将检查每个文件是否是JPEG文件，并获取每张照片的日期（使用`Photo`类中定义的函数）。接下来，我们将文件名和日期作为元组添加到`self.photo_namedates`列表中。
- en: Finally, we will use the built-in `sorted` function to place all the files in
    order of their date. While we don't need to do this here, this function would
    make it easier to remove duplicate dates if we were to use this module elsewhere.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用内置的 `sorted` 函数按日期顺序放置所有文件。虽然我们在这里不需要这样做，但如果我们在其他地方使用这个模块，这个函数将更容易删除重复的日期。
- en: The `sorted` function requires the list to be sorted, and, in this case, we
    want to sort it by the `date values:`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted` 函数需要对列表进行排序，在这种情况下，我们希望按 `date values:` 进行排序。'
- en: '`   sorted(self.photo_namedates,key=lambda date: date[DATE])`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`   sorted(self.photo_namedates,key=lambda date: date[DATE])`'
- en: We will substitute `date[DATE]` with `lambda date:` as the value to sort by.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用 `lambda date:` 替换 `date[DATE]` 作为排序的数值。
- en: Once the `FileList` object has been initialized, we can use it by calling `genFolders()`.
    First, we convert the date text into a suitable format for our folders (YYYYMMDD),
    allowing our folders to be easily sorted in order of their date. Next, it will
    create the folders within the current directory if they don't already exist. Finally,
    it will move each of the files into the required subfolder.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `FileList` 对象被初始化，我们可以通过调用 `genFolders()` 来使用它。首先，我们将日期文本转换为适合我们文件夹的格式（YYYYMMDD），使我们的文件夹可以轻松按日期顺序排序。接下来，它将在当前目录内创建文件夹（如果尚不存在）。最后，它将把每个文件移动到所需的子文件夹中。
- en: 'We end up with our `FileList` class that is ready to be tested:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到了准备测试的 `FileList` 类：
- en: '| **Operations** | **Description** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| `__init__(self,folder)` | This is the object initializer. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `__init__(self,folder)` | 这是对象初始化程序。 |'
- en: '| `getPhotoNamedates(self)` | This returns a list of the filenames of the dates
    of the photos. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `getPhotoNamedates(self)` | 这将返回一个包含照片文件名和日期的列表。 |'
- en: '| `listFileDates(self)` | This creates a list of the filenames and dates of
    the photos in the folder. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `listFileDates(self)` | 这将创建一个包含文件夹中照片文件名和日期的列表。 |'
- en: '| `genFolders(self)` | This creates new folders based on a photo''s date and
    moves the files into them. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `genFolders(self)` | 这将根据照片的日期创建新文件夹并将文件移动到其中。 |'
- en: 'The properties are listed as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 属性列如下：
- en: '| **Properties** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `self.folder` | The folder we are working with. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `self.folder` | 我们正在处理的文件夹。 |'
- en: '| `self.photo_namedates` | This contains a list of the filenames and dates.
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `self.photo_namedates` | 这包含文件名和日期的列表。 |'
- en: 'The `FileList` class encapsulates all the functions and the relevant data together,
    keeping everything in one logical place:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileList` 类将所有函数和相关数据封装在一起，将所有内容放在一个逻辑位置：'
- en: '![](Images/eb993e01-c245-49da-a981-a4fafdcc1aa5.png)Tkinter filediaglog.askdirectory()
    is used to select the photo directory'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/eb993e01-c245-49da-a981-a4fafdcc1aa5.png)Tkinter filediaglog.askdirectory()
    用于选择照片目录'
- en: To test this, we use the Tkinter `filedialog.askdirectory()` widget to allow
    us to select a target directory of pictures. We use `app.withdrawn()` to hide
    the main Tkinter window since it isn't required this time. We just need to create
    a new `FileList` object and then call `genFolders()` to move all our photos to
    new locations!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，我们使用 Tkinter 的 `filedialog.askdirectory()` 小部件来选择照片的目标文件夹。我们使用 `app.withdrawn()`
    来隐藏主Tkinter窗口，因为这次不需要它。我们只需要创建一个新的 `FileList` 对象，然后调用 `genFolders()` 将所有照片移动到新的位置！
- en: Two additional flags have been defined in this script that provide extra control
    for testing. `DEBUG` allows us to enable or disable extra debugging messages by
    setting them to either `True` or `False`. Furthermore, `FOLDERSONLY`, when set
    to `True`, only generates the folders and doesn't move the files (this is helpful
    for testing whether the new subfolders are correct).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中定义了两个额外的标志，为测试提供了额外的控制。`DEBUG` 允许我们通过将其设置为 `True` 或 `False` 来启用或禁用额外的调试消息。此外，`FOLDERSONLY`
    当设置为 `True` 时，只生成文件夹而不移动文件（这对于测试新的子文件夹是否正确非常有帮助）。
- en: Once you have run the script, you can check if all the folders have been created
    correctly. Finally, change `FOLDERSONLY` to `True`, and your program will automatically
    move and organize your photos according to their dates the next time. It is recommended
    that you only run this on a copy of your photos, just in case you get an error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，您可以检查所有文件夹是否已正确创建。最后，将 `FOLDERSONLY` 更改为 `True`，下次您的程序将根据日期自动移动和组织照片。建议您只在照片的副本上运行此操作，以防出现错误。
