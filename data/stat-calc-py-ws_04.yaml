- en: 4\. Functions and Algebra with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 函数和代数与Python
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: 'Throughout the previous chapter, we discussed a plethora of statistics-related
    topics, including variables, descriptive statistics, and inference. In this chapter,
    we come back to the general topic of mathematics and examine two of its most fundamental
    components: functions and algebra. These topics will be introduced and theoretically
    discussed in parallel with their respective implementations in Python. Knowledge
    of these topics will allow you to tackle some of the most common real-life problems
    that can be solved using mathematics and programming, which we will see an example
    of in the final activity of this chapter.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了大量与统计相关的主题，包括变量、描述性统计和推断。在本章中，我们回到数学的一般主题，并研究其中两个最基本的组成部分：函数和代数。这些主题将与它们在Python中的实现并行介绍和理论讨论。掌握这些主题将使您能够解决一些可以使用数学和编程解决的最常见的现实生活问题，我们将在本章的最后一个活动中看到一个例子。
- en: By the end of this chapter, you will have a firm grasp on the concept of mathematical
    functions and relevant notions such as domain, range, and graphing. Additionally,
    you will learn how to solve algebraic equations or systems of equations by hand
    as well as via Python programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将对数学函数的概念以及域、范围和绘图等相关概念有牢固的掌握。此外，您还将学习如何通过手工解决代数方程或方程组，以及通过Python编程解决。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: While mathematics can be divided into multiple subfields, such as calculus,
    number theory, and geometry, there are certain fundamental concepts that every
    mathematics student must be familiar with. Two of these concepts are functions
    and algebra, which are the main topics of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数学可以分为多个子领域，如微积分、数论和几何学，但有一些基本概念是每个数学学生都必须熟悉的。其中两个概念是函数和代数，这是本章的主要内容。
- en: A function is a general mathematical process that describes a certain mapping
    from one object to another. A function can take in one number and produce another
    number. It can also take in an array or vector of numbers and return a single
    output, or even multiple outputs. Functions are so important that they are also
    widely used in other scientific fields, including physics, economics, and, as
    we have seen throughout this book, programming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是描述从一个对象到另一个对象的某种映射的一般数学过程。函数可以接受一个数字并产生另一个数字。它还可以接受一组数字或向量并返回单个输出，甚至多个输出。函数如此重要，以至于它们也广泛应用于其他科学领域，包括物理学、经济学，正如我们在本书中所看到的，编程。
- en: Our goal in this chapter is to establish a concrete foundational discussion
    on the concept of functions in a mathematical context. This discussion will be
    coupled with other related topics, such as the domain, the range, and the plot
    of a function. A solid understanding of these topics will allow you to explore
    more complex mathematical analyses in later chapters.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是在数学背景下建立关于函数概念的具体基础讨论。这个讨论将与其他相关主题结合，如域、范围和函数的绘图。对这些主题的扎实理解将使您能够在以后的章节中探索更复杂的数学分析。
- en: In addition to functions, we will also consider algebra, one of the most important
    parts of mathematics. While the term generally denotes the analysis and manipulation
    of mathematical objects in the broadest sense, we will consider it in the context
    of algebraic equations and systems of equations. This will allow us to study its
    important role in mathematics while learning how to apply that knowledge to practical
    problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了函数，我们还将考虑代数，这是数学中最重要的部分之一。虽然这个术语通常表示对数学对象的分析和操作，但我们将在代数方程和方程组的背景下考虑它。这将使我们能够研究它在数学中的重要作用，同时学习如何将这些知识应用于实际问题。
- en: Functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: As previously explained, functions are mathematical objects that generally take
    in some input and produce a desired output. A function is therefore often considered
    as a mapping of one mathematical object to another. When a function receives an
    input and subsequently produces an output, the concept of *relation* can also
    be used, which emphasizes the relationship between the set of possible inputs
    and that of possible outputs that is established by the function itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数是数学对象，通常接受一些输入并产生所需的输出。因此，函数通常被认为是一个数学对象到另一个数学对象的映射。当函数接收输入并随后产生输出时，还可以使用*关系*的概念，这强调了函数本身建立的可能输入集和可能输出集之间的关系。
- en: A function is typically denoted by the lowercase letter *f* with parentheses,
    which surround an input that *f* takes in. This symbol, *f(x)*, also denotes the
    output that *f* produces when taking in *x* as input. For example, let's say the
    function *f* that outputs the square of its input; *f* can be denoted as *f(x)
    = x*2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常由小写字母*f*和括号表示，括号中包围着*f*接受的输入。这个符号，*f(x)*，也表示*f*在接受*x*作为输入时产生的输出。例如，假设函数*f*输出其输入的平方；*f*可以表示为*f(x)
    = x*2。
- en: 'We see that the syntax for declaring a function in Python also follows this
    convention. For example, to declare the same squaring function in Python, the
    code would look like the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在Python中声明函数的语法也遵循这种约定。例如，要在Python中声明相同的平方函数，代码将如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And when we would like to obtain the value of *f* with a number as its input,
    we simply say that we call *f* on the input. For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要获得*f*作为其输入的值时，我们只需说我们在输入上调用*f*。例如：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code will print out `4` and `9`, respectively. As we also know, the value
    returned from a function can also be stored in a variable via assignment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将分别打印出`4`和`9`。正如我们所知，函数返回的值也可以通过赋值存储在变量中。
- en: One of the most important characteristics of a function is the fact that no
    input can be mapped to different outputs. Once an input *x* has been associated
    with a corresponding output *f(x)*, that output is deterministic and cannot have
    more than one possible value. On the other hand, it is entirely possible that
    multiple inputs can be mapped to the same output. In other words, multiple values
    of *x* can cause *f(x)* to be a common value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最重要的特征之一是没有输入可以映射到不同的输出。一旦一个输入*x*与相应的输出*f(x)*关联起来，那个输出是确定的，不能有多个可能的值。另一方面，完全可能多个输入映射到相同的输出。换句话说，多个*x*的值可以导致*f(x)*成为一个常见值。
- en: It is also possible that a function does not have to take in any input, nor
    does it necessarily need to produce any output. For instance, in the context of
    programming, a function whose job is to read and return the data included in a
    specific file does not need to take in any input. Another example would be a function
    that updates the value of a global variable, in which case it is not required
    to return anything. That said, these functions can be considered to belong to
    a specific subset of general functions, so our discussions will still revolve
    around functions with inputs and outputs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能一个函数不需要接受任何输入，也不一定需要产生任何输出。例如，在编程的情境中，一个函数的工作是读取并返回特定文件中包含的数据，不需要接受任何输入。另一个例子是更新全局变量的值的函数，在这种情况下不需要返回任何东西。也就是说，这些函数可以被认为属于一类特定的一般函数的子集，因此我们的讨论仍将围绕具有输入和输出的函数展开。
- en: In this upcoming subsection, let's consider a number of common types of functions
    in mathematics and programming.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，让我们考虑数学和编程中一些常见类型的函数。
- en: Common Functions
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见函数
- en: 'While each function is unique in its own way, there are a number of special
    classifications, or *families*, of functions that we need to be aware of. These
    are constant, linear, polynomial, logarithmic, and exponential functions, which
    are summarized in the following table:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个函数在自己的方式上都是独特的，但有一些特殊的分类或*家族*函数，我们需要了解。这些是常数、线性、多项式、对数和指数函数，它们总结在下表中：
- en: '![Figure 4.1: Table of special families of functions'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：特殊函数家族表'
- en: '](image/B15968_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_01.jpg)'
- en: 'Figure 4.1: Table of special families of functions'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：特殊函数家族表
- en: Take a moment to consider the third column of our table, which contains the
    plots of sample functions belonging to each of the function families that are
    listed. We will go further into the theoretical details of the plot of a function
    later on in this section, but for now, we see that each family of functions gives
    us a unique style of graph; in fact, the identification of functions from their
    plots is the topic of our upcoming exercise.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间考虑我们表格的第三列，其中包含每个函数家族的样本函数的图。我们将在本节后面更深入地讨论函数的图的理论细节，但现在我们看到每个函数家族都给我们一个独特的图形风格；事实上，从它们的图形中识别函数是我们即将进行的练习的主题。
- en: 'Note that constant and linear functions are actually subsets of the polynomial
    function family (when the coefficients for larger powers of *x* are all zeros).
    Another interesting fact you may have already noticed is that the input of a logarithmic
    function has to be positive, which is why its plot does not extend past the left
    side of the *y* axis. Conversely, the output of an exponential function (given
    that the constant is positive) is always positive; correspondingly, its graph
    stays above the *x* axis. These points directly transition us to our next topic:
    the domain and range of a function.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，常数和线性函数实际上是多项式函数家族的子集（当*x*的较大幂的系数都为零时）。你可能已经注意到的另一个有趣的事实是对数函数的输入必须是正数，这就是为什么它的图不会延伸到*y*轴的左侧。相反，指数函数的输出（假设常数是正的）总是正的；相应地，它的图始终在*x*轴上方。这些观点直接过渡到我们的下一个主题：函数的域和值域。
- en: Domain and Range
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域和值域
- en: The domain and the range are two essential concepts in the context of functions.
    The domain of a function denotes the set of all possible inputs that the function
    takes in, while the range specifies the set of all possible outputs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 域和值域是函数概念中的两个基本概念。函数的域表示函数接受的所有可能输入的集合，而值域指定了所有可能输出的集合。
- en: Most of the time, the domain and range of a given function can be identified
    by considering its formulaic expression. For example, a linear function, *f(x)
    = mx + c*, takes in any real-valued *x* to produce a real-valued *mx + c*, so
    both its domain and range are the set of real numbers, *R*. The quadratic function
    *f(x) = x*2, on the other hand, only produces non-negative outputs, so its range
    is the set of non-negative real numbers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，可以通过考虑函数的公式表达来确定给定函数的域和值域。例如，线性函数*f(x) = mx + c*接受任何实数值的*x*来产生一个实数值的*mx
    + c*，因此它的域和值域都是实数集合*R*。另一方面，二次函数*f(x) = x*2*只产生非负输出，因此它的值域是非负实数集合。
- en: 'The domain and range of a function can also be examined using its plot. Consider
    the plot of a function with a single input and a single output: its domain corresponds
    to the projection of the plot onto the *x* axis; similarly, the range is obtained
    when the plot is projected onto the *y* axis. This is why we can claim that the
    domain of the logarithmic function *f(x) = ln(x)*, whose plot is included in the
    table from the previous section, is the set of positive numbers. Conversely, the
    range of the exponential function *f(x) = e*x is the set of positive numbers as
    well.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的域和值域也可以通过其图来检查。考虑一个具有单个输入和单个输出的函数的图的投影：其域对应于图在*x*轴上的投影；同样，当图在*y*轴上投影时得到值域。这就是为什么我们可以说对数函数*f(x)
    = ln(x)*的域是正数集合。相反，指数函数*f(x) = e*x*的值域也是正数集合。
- en: Overall, the domain and range of a function are dependent on the form of the
    function itself and can be highly informative regarding various behaviors of the
    function. One of these behaviors that is often of interest is the root of a function,
    which we will discuss in the next subsection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，函数的定义域和值域取决于函数本身的形式，并且可以对函数的各种行为提供高度信息。其中一个经常感兴趣的行为是函数的根，我们将在下一小节中讨论。
- en: Function Roots and Equations
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的根和方程
- en: 'A root of a function is a value belonging to its domain that makes the output
    equal to zero. Again, which value the root of a function takes is highly dependent
    on the function itself. Still using the examples that are included in the preceding
    table, *Figure 4.1*, we see that *f(x) = mx + c* accepts the unique root of *x
    = - c / m* if *m* is non-zero, while *f(x) = ln(x)* has the unique root of *x
    = 1*. Some functions might have more than one root: *f(x) = x*2 *- 3x + 2* has
    *x = 1* and *x = 2* as its roots, while *f(x) = 0* (whose plot corresponds to
    the *x* axis) accepts all values of *x* as its roots. Finally, if the range of
    a function does not include 0, then the function itself does not have any root;
    examples of this include *f(x) = e*x, *f(x) = x*2 *+ 1*, and *f(x) = 3*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的根是使输出等于零的属于其定义域的值。再次强调，函数的根取什么值高度依赖于函数本身。仍然使用前面表中包含的例子，*图4.1*，我们看到*f(x) =
    mx + c*接受* x = - c / m*作为其唯一根，如果*m*不为零，而*f(x) = ln(x)*的唯一根是*x = 1*。一些函数可能有多个根：*f(x)
    = x*2 *- 3x + 2*有*x = 1*和*x = 2*作为其根，而*f(x) = 0*（其图对应于*x*轴）接受所有*x*的值作为其根。最后，如果一个函数的值域不包括0，那么函数本身就没有任何根；这样的例子包括*f(x)
    = e*x*，*f(x) = x*2 *+ 1*和*f(x) = 3*。
- en: The process of finding all roots of a function *f(x)* is equivalent to solving
    the equation *f(x) = 0*. The term *equation* here denotes the fact that we have
    two separate quantities, *f(x)* and *0*, that are equal to each other in the mathematical
    expression. Solving equations is arguably one of the most central tasks in mathematics,
    and there are multiple techniques for doing so that apply to specific equation
    types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 找到函数*f(x)*的所有根的过程等同于解方程*f(x) = 0*。这里的*方程*一词表示我们有两个分开的量，*f(x)*和*0*，它们在数学表达式中相等。解方程可以说是数学中最核心的任务之一，有多种技术可应用于特定类型的方程。
- en: 'We are only introducing the concept of equations here as part of the topic
    of functions, and we will come back to it later in this chapter. For now, we will
    move on to the last important component of a function: plots.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是作为函数主题的一部分介绍了方程的概念，我们将在本章的后面再回到它。现在，我们将继续讨论函数的最后一个重要组成部分：图。
- en: The Plot of a Function
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的图
- en: In the earlier examples, the plot of a function is a visual representation of
    the behavior of the output, with respect to the input of the function. Specifically,
    with a function plot, we aim to examine how the output changes across the function
    range as the input of the function changes across its domain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数的图是输出行为的视觉表示，关于函数输入的。具体地说，通过函数图，我们旨在检查在函数范围内，随着函数的输入在其定义域内的变化，输出如何变化。
- en: 'In the context of programming, the plot of a function can be produced by connecting
    the scatter points corresponding to the individual values of a function over a
    set of fine-grained evenly spaced values on the *x* axis. For example, say we
    would like to visualize the plot of the function *f(x) = x + 1* between `-10`
    and `10`, we would first declare the corresponding evenly spaced values of `x`
    using NumPy:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程的背景下，函数的图可以通过连接散点对应于函数在*x*轴上一组细粒度均匀间隔值上的各个值来生成。例如，假设我们想要可视化函数*f(x) = x +
    1*在`-10`和`10`之间的图，我们首先使用NumPy声明相应的均匀间隔的`x`值：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This NumPy function generates an array of 1,000 evenly spaced numbers between
    `-10` and `10`, which is illustrated by the output of `x`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个NumPy函数生成了一个在`-10`和`10`之间的1,000个均匀间隔的数字的数组，这由`x`的输出所说明：
- en: '![Figure 4.2: Evenly spaced numbers from NumPy'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：NumPy生成的均匀间隔的数字'
- en: '](image/B15968_04_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_02.jpg)'
- en: 'Figure 4.2: Evenly spaced numbers from NumPy'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：NumPy生成的均匀间隔的数字
- en: 'The plot can then be generated using the `plot()` function from Matplotlib:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用Matplotlib的`plot()`函数生成图：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember that due to vectorization, the expression `x + 1` will compute an array
    of the same size as `x`, whose elements are the elements of `x` with 1 added to
    each. This is a great feature of the Python language, or more specifically, the
    NumPy library, that allows us to quickly generate the points that make up the
    graph of a function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于矢量化，表达式`x + 1`将计算出一个与`x`大小相同的数组，其元素是`x`的元素加1。这是Python语言的一个很好的特性，或者更具体地说，是NumPy库，它允许我们快速生成构成函数图的点。
- en: 'This code should produce the following visualization:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该产生以下可视化：
- en: '![Figure 4.3: Plot of f(x) = x + 1 in Python'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：Python中f(x) = x + 1的图'
- en: '](image/B15968_04_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_03.jpg)'
- en: 'Figure 4.3: Plot of f(x) = x + 1 in Python'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：Python中f(x) = x + 1的图
- en: The same logic can be applied to different forms of functions. We will come
    back to this process during our next exercise. For now, let's return to our theoretical
    discussion.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑可以应用于不同形式的函数。我们将在下一个练习中回到这个过程。现在，让我们回到我们的理论讨论。
- en: The plot of a function is a direct visualization of its formulaic expression
    and contains all of the information we need to know about that function. In particular,
    we have already argued that a function plot can help us identify the domain and
    range of the function. Furthermore, given a graph, we can even determine whether
    that graph is a plot of a valid function. This is done with the vertical line
    test, which dictates the following.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的图是其公式表达的直观可视化，并包含了我们需要了解的有关该函数的所有信息。特别地，我们已经论证过函数图可以帮助我们确定函数的定义域和值域。此外，给定一个图，我们甚至可以确定该图是否是一个有效函数的图。这是通过垂直线测试来完成的，该测试规定如下。
- en: 'Given a graph on a two-dimensional plane, if, for every vertical line (every
    line that is parallel to the *y* axis), the graph has more than one intersection,
    then it is not the plot of a valid function. This is a direct corollary of the
    requirement of a function that we stated earlier: one single input cannot be mapped
    to more than one output. If a graph did have at least two intersections with a
    vertical line, that would mean a point on the *x* axis could be mapped to at least
    two points on the *y* axis, which would necessarily mean that this is not a plot
    of a function.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 给定二维平面上的图形，如果对于每条垂直线（与*y*轴平行的每条线），图形有多于一个交点，则它不是有效函数的绘图。这是我们之前所述的函数要求的一个直接推论：一个单一的输入不能映射到多于一个输出。如果一个图形确实与一条垂直线有至少两个交点，那么这意味着*x*轴上的一个点可以映射到*y*轴上至少两个点，这必然意味着这不是一个函数的绘图。
- en: 'For example, consider the following graph of the unit circle (whose center
    is *O(0, 0)* and radius is equal to *1*), which fails the vertical line test,
    illustrated by the red line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑单位圆的以下图形（其中心为*O(0, 0)*，半径等于*1*），它未通过垂直线测试，由红线表示：
- en: '![Figure 4.4: The vertical line test for the unit circle'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：单位圆的垂直线测试'
- en: '](image/B15968_04_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_04.jpg)'
- en: 'Figure 4.4: The vertical line test for the unit circle'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：单位圆的垂直线测试
- en: This is to say that the unit circle is, in fact, not the plot of a function
    with respect to the two-dimensional plane that we are considering.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着单位圆实际上不是我们考虑的二维平面上函数的绘图。
- en: This topic also marks the end of our introduction to the definition of functions.
    Before we move on to the next section, let's go through an exercise that aims
    to solidify all the concepts that we have learned so far.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题也标志着我们对函数定义的介绍结束。在我们进入下一节之前，让我们通过一个旨在巩固我们迄今学到的所有概念的练习。
- en: 'Exercise 4.01: Function Identification from Plots'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：从图形中识别函数
- en: In this exercise, we will practice the skill of analyzing the behavior of a
    function given its plot. This process will allow us to combine various topics
    that we have mentioned previously, as well as understand the connection between
    the behavior of a function and its plot.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将练习分析给定图形的函数行为的技能。这个过程将使我们能够结合我们之前提到的各种主题，并理解函数行为与其图形之间的联系。
- en: 'For each of the following graphs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个图形：
- en: Determine whether it corresponds to a function and if so, go on to the next
    step.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定它是否对应于一个函数，如果是，继续下一步。
- en: 'Identify the domain, the range, and the formula of the function (hint: use
    the labeled ticks).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定函数的定义域、值域和公式（提示：使用标记的刻度）。
- en: Determine whether the function has at least one root.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定函数是否至少有一个根。
- en: Reproduce the plot using Python (the axes and their arrows are not necessary).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python重现绘图（轴及其箭头不是必需的）。
- en: '**Horizontal line**:![Figure 4.5: Horizontal line'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**水平线**：![图4.5：水平线'
- en: '](image/B15968_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_05.jpg)'
- en: 'Figure 4.5: Horizontal line'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：水平线
- en: The graph does correspond to a function. The function is *f(x) = 2*, the domain
    is the set of real numbers, and the range is *{2}*. The function does not have
    any root.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该图对应于一个函数。函数是*f(x) = 2*，定义域是实数集，值域是*{2}*。函数没有任何根。
- en: 'The following code can be used to reproduce the plot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Rotated quadratic curve**:![Figure 4.6: Rotated quadratic curve'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**旋转的二次曲线**：![图4.6：旋转的二次曲线'
- en: '](image/B15968_04_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_06.jpg)'
- en: 'Figure 4.6: Rotated quadratic curve'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：旋转的二次曲线
- en: The graph does not correspond to a function since it fails the vertical line
    test.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该图不对应于一个函数，因为它未通过垂直线测试。
- en: '**Straight line**:![Figure 4.7: Straight line'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**直线**：![图4.7：直线'
- en: '](image/B15968_04_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_07.jpg)'
- en: 'Figure 4.7: Straight line'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：直线
- en: 'The graph corresponds to the plot of the function *f(x) = x*. Both the domain
    and the range of this function are a set of real-valued numbers. The function
    has one root: *x = 0*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图对应于函数*f(x) = x*的绘图。这个函数的定义域和值域都是一组实数。函数有一个根：*x = 0*。
- en: 'The following code can be used to reproduce the plot (using the same `x` variable
    as in the solution to *Horizontal line*):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图（使用与*水平线*解决方案中相同的`x`变量）：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Quadratic curve**:![Figure 4.8: Quadratic curve'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**二次曲线**：![图4.8：二次曲线'
- en: '](image/B15968_04_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_08.jpg)'
- en: 'Figure 4.8: Quadratic curve'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：二次曲线
- en: 'The graph corresponds to the plot of the function *f(x) = x*2. The domain of
    the function is the set of all real numbers, while the range is the set of non-negative
    numbers. The function also has one root: *x = 0*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该图对应于函数*f(x) = x*2的绘图。函数的定义域是所有实数的集合，而值域是非负数的集合。函数也有一个根：*x = 0*。
- en: 'The following code can be used to reproduce the plot (thanks to vectorization
    for NumPy arrays):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图（感谢NumPy数组的矢量化）：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Through this quick exercise, we have solidified our understanding of functions
    and a number of relevant concepts, including the domain, the range, the vertical
    line test, and the process of plotting a graph using Python.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个快速练习，我们巩固了对函数和许多相关概念的理解，包括定义域、值域、垂直线测试以及使用Python绘制图形的过程。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YRMZhL](https://packt.live/2YRMZhL).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YRMZhL](https://packt.live/2YRMZhL)。
- en: You can also run this example online at [https://packt.live/2YSBgj2](https://packt.live/2YSBgj2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2YSBgj2](https://packt.live/2YSBgj2)上在线运行此示例。
- en: In the next section, we will discuss the transformation of functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论函数的转换。
- en: Function Transformations
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数转换
- en: 'Transformation is one of the most important concepts for mathematical functions.
    As suggested by the name of the term, a transformation of a function is the output
    we obtain after putting the returned value of a function through a specific transformation
    technique such as a shift or a scaling. In the most general sense, we can think
    of this process as a *composite function*: putting the output of one function
    through another function. However, there are specific types of functions that
    are commonly used as transformations due to their particular characteristics and
    usefulness, and we will go through them in the following subsections, starting
    with shifting.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 变换是数学函数中最重要的概念之一。正如术语的名称所暗示的那样，函数的变换是在将函数的返回值通过特定的变换技术（如移动或缩放）后得到的输出。在最一般的意义上，我们可以将这个过程看作是*复合函数*：将一个函数的输出通过另一个函数。然而，由于它们的特定特性和有用性，有特定类型的函数通常被用作变换，我们将在接下来的小节中介绍它们，从移动开始。
- en: Since a transformation is most easily understood in the context of the changes
    that it applies to the plot of a function, we will also frame our following discussions
    accordingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变换最容易在应用到函数的图表上时理解，我们也将根据这一点来进行下面的讨论。
- en: Shifts
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动
- en: 'A shift of a function happens when the plot of a function is shifted by a specific
    amount along the *x* axis and/or the *y* axis. For example, in the following visualization,
    the blue curve is the graph of the function *f(x) = x*2, while the red curve is
    the same graph shifted vertically by *1*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的移动发生在函数的图表沿着*x*轴和/或*y*轴的特定距离上移动。例如，在下面的可视化中，蓝色曲线是函数*f(x) = x*2*的图表，而红色曲线是同一图表向上移动*1*后的图表：
- en: '![Figure 4.9: Vertical shift of a function'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：函数的垂直移动'
- en: '](image/B15968_04_09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_09.jpg)'
- en: 'Figure 4.9: Vertical shift of a function'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：函数的垂直移动
- en: We see that every point *(x, y)* belonging to the graph of *f(x) = x*2 has been
    effectively translated to *(x, y + 1)*. Since *y = x*2 if *(x, y)* belongs to
    the graph of *f(x)*, the output of the shift is essentially the graph of the function
    *f(x) = x*2 *+ 1*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到属于*f(x) = x*2*图表的每个点*(x, y)*实际上被转换为*(x, y + 1)*。由于如果*(x, y)*属于*f(x)*的图表，那么*y
    = x*2*，移动的输出本质上是函数*f(x) = x*2 *+ 1*的图表。
- en: 'This example allows us to generalize every case of a vertical shift: the output
    of the vertical shift of any given function *f(x)* by a constant *c* is the new
    function *f(x) + c*. In our example this is *c = 1*, corresponding to a horizontal
    shift up by *1*. However, *c* can also be a negative number, in which case the
    function is shifted down, or even zero, in which case the transformation is the
    identity transformation where the graph of the function does not change.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子让我们能够概括垂直移动的每种情况：任何给定函数*f(x)*的垂直移动的输出是新函数*f(x) + c*。在我们的例子中，这是*c = 1*，对应着向上水平移动*1*。然而，*c*也可以是负数，这种情况下函数向下移动，甚至可以是零，这种情况下变换是恒等变换，函数的图表不会改变。
- en: We see that a vertical shift is done when a change is added to (or subtracted
    from) the output values of a function, or, in other words, the *y* coordinates
    of the points lying on the graph. In the same manner, a horizontal shift can be
    applied to a function by implementing a change in the input values of a function
    (when a number is added to the *x* coordinates of the points).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到当一个改变被加到（或者从中减去）函数的输出值时，或者换句话说，图表上的点的*y*坐标发生了垂直移动。同样，通过对函数的输入值进行改变（当一个数字被加到点的*x*坐标时），可以对函数进行水平移动。
- en: In general, when the graph of a function *f(x)* is shifted to the left of a
    two-dimensional plane by an amount *c*, the resulting graph is the plot of the
    function *f(x + c)*. Conversely, the graph of the function *f(x - c)* corresponds
    to a horizontal shift to the right by *c* of the function *f(x)*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当函数*f(x)*的图表在二维平面上向左移动了一个量*c*时，结果图表是函数*f(x + c)*的图表。相反，函数*f(x - c)*的图表对应于函数*f(x)*向右移动*c*的水平移动。
- en: 'Still using the example of the function *f(x) = x*2, the following graph visualizes
    the shift of the function to the right by *2*, or, in other words, the graph of
    the function *f(x) = (x - 2)*2:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用函数*f(x) = x*2*的例子，以下图表可视化了函数向右移动*2*，换句话说，函数*f(x) = (x - 2)*2*的图表：
- en: '![Figure 4.10: Horizontal shift of a function'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10：函数的水平移动'
- en: '](image/B15968_04_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_10.jpg)'
- en: 'Figure 4.10: Horizontal shift of a function'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：函数的水平移动
- en: It is also possible to combine both a vertical shift and a horizontal shift
    to transform a function so that the entire graph is moved in any given direction.
    For example, say we would like to shift the function *f(x) = x*2 in the North-East
    direction (up and right) by the amount vector (*2, 1*), then the transformed function
    will, as you can guess by now, be *f(x) = (x - 2)*2 *+ 1*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以结合垂直移动和水平移动来变换函数，使整个图表朝任意方向移动。例如，假设我们想要将函数*f(x) = x*2*向东北方向（上和右）移动一个向量(*2,
    1*)，那么变换后的函数将是*f(x) = (x - 2)*2 *+ 1*。
- en: 'Overall, a shift as a transformation *moves* the graph of a function by a specific
    amount vertically and/or horizontally. For this reason, a shift is also an *affine
    transformation*, which is defined to be a transformation that moves all the points
    of a graph in the same direction and by a constant distance. However, a shift
    cannot change the size and scale of a graph. In the next section, we will discuss
    another method of transformation that can: scaling.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，变换作为一种*移动*函数图表的方式，垂直和/或水平地移动。因此，移动也是一种*仿射变换*，它被定义为将图表的所有点以相同方向和恒定距离移动。然而，移动不能改变图表的大小和比例。在下一节中，我们将讨论另一种可以改变大小和比例的变换方法：缩放。
- en: Scaling
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放
- en: 'A scaling transformation stretches or shrinks the graph of a function by a
    specific amount, depending on the scaling factor. Consider in the following visualization
    the output of a scaling transformation when applied to our familiar function,
    *f(x) = x*2:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放变换通过特定的比例因子拉伸或收缩函数的图形，具体取决于缩放因子。考虑以下可视化中对我们熟悉的函数*f(x) = x*2*应用缩放变换的输出：
- en: '![Figure 4.11: Scaling of a function'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：函数的缩放'
- en: '](image/B15968_04_11.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_11.jpg)'
- en: 'Figure 4.11: Scaling of a function'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：函数的缩放
- en: Through the preceding scaling transformation, every point *(x, y)* lying on
    the graph of the function is transformed to *(x, y / 2)*, effectively scaling
    the graph horizontally to be closer to the *x* axis. The transformed graph, which
    corresponds to the function *f(x) = x*2 */ 2*, is wider than the original graph,
    due to the fact that the curve is scaled to be closer to the *x* axis. To be more
    exact, aside from the origin (*0, 0*), any point from the original graph has been
    *pulled down* to be closer to the *x* axis. This would also make the overall slope
    of the graph less steep. Conversely, scaling transformations that would bring
    the transformed graph further away from the *x* axis might be *f(x) = 2x*2, or
    *f(x) = 3x*2, thereby making the slope of the transformed graph steeper.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的缩放变换，函数图上的每个点*(x, y)*都被转换为*(x, y / 2)*，有效地将图形水平缩放，使其更靠近*x*轴。变换后的图形对应于函数*f(x)
    = x*2 */ 2*，比原始图形更宽，因为曲线被缩放到更靠近*x*轴。除了原点(*0, 0*)之外，原始图形的任何点都被*拉下*，使其更靠近*x*轴。这也会使图形的整体斜率变得不那么陡峭。相反，将变换后的图形远离*x*轴的缩放变换可能是*f(x)
    = 2x*2，或*f(x) = 3x*2，从而使变换后的图形的斜率更陡。
- en: In these transformations, we are multiplying the *y* coordinates of the graph
    by a constant, which gives us control of the scaling with respect to the *x* axis.
    In a similar manner, when a scaling is applied by multiplying the *x* coordinates
    of the graph of a function, a graph will be stretched or shrunk with respect to
    the *y* axis.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些变换中，我们将函数图的*y*坐标乘以一个常数，这使我们能够控制相对于*x*轴的缩放。类似地，当通过将函数图的*x*坐标乘以一个常数来应用缩放时，图形将相对于*y*轴被拉伸或收缩。
- en: In general, the effect of a scaling transformation is controlled by the *scaling
    factor*—the constant that the *x*- or *y*-coordinates of a graph are multiplied
    by. A positive scaling factor does not change the relative location of the graph
    with respect to the axes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，缩放变换的效果由*缩放因子*控制——图形的*x*或*y*坐标被乘以的常数。正的缩放因子不会改变图形相对于坐标轴的相对位置。
- en: When it is a vertical scaling (when the *y*-coordinates are scaled), a positive
    factor that is smaller than 1 will *pull* the graph to be closer to the *x* axis,
    while a large factor will *push* the graph away from the axis. The opposite is
    true for a horizontal scaling (when the *x* coordinates are scaled); a positive
    factor that is smaller than 1 will *push* the graph away from the *y* axis, and
    a large factor will *pull*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行垂直缩放（即缩放*y*坐标）时，小于1的正因子将*拉*图形靠近*x*轴，而大因子将*推*图形远离轴。水平缩放（即缩放*x*坐标）也是如此；小于1的正因子将图形*推*离*y*轴，而大因子将图形*拉*。
- en: 'While this *pulling/pushing* effect is also the same for negative scaling factors,
    when a function is scaled by a negative constant, its graph will be *flipped*
    along the corresponding axis:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种*拉/推*效应对于负缩放因子也是一样的，但当函数被负常数缩放时，其图形将沿着相应的轴*翻转*：
- en: '![Figure 4.12: Negative scaling of a function'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12：函数的负缩放'
- en: '](image/B15968_04_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_12.jpg)'
- en: 'Figure 4.12: Negative scaling of a function'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：函数的负缩放
- en: Just as we have seen in the case of shifts, multiple scaling transformations
    can be applied to a function at the same time to obtain a combined effect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在平移的情况下看到的那样，可以同时对函数应用多个缩放变换，以获得组合效果。
- en: In general, shifts and scaling constitute two of the most common methods of
    function transformation. In the next exercise, we will practice the skill of identifying
    these two transformations from their respective effect on function graphs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，平移和缩放构成了函数变换中最常见的两种方法。在下一个练习中，我们将练习识别这两种变换的技能，从它们对函数图的影响来识别。
- en: 'Exercise 4.02: Function Transformation Identification'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：函数变换识别
- en: Here, we aim to analyze the effect a specific transformation has on the graph
    of a function and identify the type as well as the characteristics of the transformation.
    This exercise will help us familiarize ourselves with how transformations can
    manipulate the behavior of functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的目标是分析特定变换对函数图的影响，并识别变换的类型和特征。这个练习将帮助我们熟悉变换如何操纵函数的行为。
- en: 'The following graph includes the plot of a cubic function, *f(x) = x*3 *- x*,
    and the plot of the sine function, *f(x) = sin(x)*, also commonly known as the
    sine wave due to its periodicity:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图形包括三次函数*f(x) = x*3 *- x*的绘图，以及正弦函数*f(x) = sin(x)*的绘图，也因其周期性而常被称为正弦波：
- en: '![Figure 4.13: Graph of a cubic function and a sine wave'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13：三次函数和正弦波的图形'
- en: '](image/B15968_04_13.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_13.jpg)'
- en: 'Figure 4.13: Graph of a cubic function and a sine wave'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：三次函数和正弦波的图形
- en: 'Each of the following graphs includes one of these two function plots as a
    blue curve and the result of a specific transformation from it as a red curve.
    For each of the graphs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形包括这两个函数绘图中的一个作为蓝色曲线，以及从中得到的特定变换的结果作为红色曲线。对于每个图形：
- en: Identify which transformation could have produced the effect.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别可能产生这种效果的变换。
- en: If it is a shift, identify the value of the shift vector (that is, up/down by
    how much, left/right by how much).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是平移，确定平移向量的值（即上/下移动多少，左/右移动多少）。
- en: If it is a scaling, identify whether the scaling factor is positive or negative
    and estimate its value (using the tick marks as a hint).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是缩放，确定缩放因子是正数还是负数，并估计其值（使用刻度标记作为提示）。
- en: Verify your estimations by producing the same graph using Python (not including
    the axes and arrows).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用Python生成相同的图表来验证您的估计（不包括坐标轴和箭头）。
- en: 'Let''s now have a look at the graphs:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下图表：
- en: '**First transformation of a cubic curve**:![Figure 4.14: First transformation
    of a cubic curve'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三次曲线的第一次变换**：![图4.14：三次曲线的第一次变换'
- en: '](image/B15968_04_14.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_14.jpg)'
- en: 'Figure 4.14: First transformation of a cubic curve'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：三次曲线的第一次变换
- en: The red curve is the result of a shift of the original sine wave. It is a horizontal
    shift to the left by `2`, so the shift is `-2`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 红色曲线是原始正弦波的移动结果。它是向左水平移动`2`，因此移动是`-2`。
- en: 'The following code can be used to reproduce the plot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Second transformation of a cubic curve**:![Figure 4.15: Second transformation
    of a cubic curve'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**三次曲线的第二次变换**：![图4.15：三次曲线的第二次变换'
- en: '](image/B15968_04_15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_15.jpg)'
- en: 'Figure 4.15: Second transformation of a cubic curve'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：三次曲线的第二次变换
- en: The red curve results from a composite shift. It is a horizontal shift to the
    right by `2` combined with a vertical shift up by `2`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 红色曲线是原始正弦波的复合移动的结果。它是向右水平移动`2`，再向上垂直移动`2`。
- en: 'The following code can be used to reproduce the plot (using the same variable,
    `x`):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图（使用相同的变量`x`）：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**First transformation of a sine wave**:![Figure 4.16: First transformation
    of a sine wave'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正弦波的第一次变换**：![图4.16：正弦波的第一次变换'
- en: '](image/B15968_04_16.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_16.jpg)'
- en: 'Figure 4.16: First transformation of a sine wave'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：正弦波的第一次变换
- en: The red curve results from a scaling. It is a vertical scaling away from the
    *x* axis by a factor of `2`, so the scaling factor is `2`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 红色曲线是通过缩放得到的。它是沿着*x*轴的垂直缩放，缩放因子为`2`。
- en: 'The following code can be used to reproduce the plot (using the same variable,
    `x`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图（使用相同的变量`x`）：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Second transformation of a sine wave**:![Figure 4.17: Second transformation
    of a sine wave'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正弦波的第二次变换**：![图4.17：正弦波的第二次变换'
- en: '](image/B15968_04_17.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_17.jpg)'
- en: 'Figure 4.17: Second transformation of a sine wave'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：正弦波的第二次变换
- en: The red curve results from a scaling. It is a horizontal scaling that pulls
    the curve closer to the *y* axis by a factor of `2`, so the scaling factor is
    `2`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 红色曲线是通过缩放得到的。它是沿着*y*轴的水平缩放，将曲线拉近到`2`的因子，因此缩放因子是`2`。
- en: 'The following code can be used to reproduce the plot (using the same variable,
    `x`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可用于重现绘图（使用相同的变量`x`）：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have thus learned how to identify the transformation type and its degree
    of change by examining the effect a transformation has on the graph of a function.
    This exercise also concludes the topic of functions in this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经学会了通过检查变换对函数图形的影响来识别变换类型及其变化程度。这个练习也结束了本章关于函数的主题。
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2U7iR](https://packt.live/2D2U7iR).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2D2U7iR](https://packt.live/2D2U7iR)。
- en: You can also run this example online at [https://packt.live/2YPtHcJ](https://packt.live/2YPtHcJ).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YPtHcJ](https://packt.live/2YPtHcJ)上在线运行此示例。
- en: 'In the next section, we will dive into a relevant concept that was briefly
    mentioned earlier: equations.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨一个之前简要提到的相关概念：方程。
- en: Equations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方程
- en: Again, an equation is formed when a function is assigned the value 0 and we
    are asked to find the values of the function input, normally *x*, that satisfy
    the equation. These values are called the roots of the original function. The
    process of finding these values is called solving an equation, which is a rich
    topic in mathematics and, specifically, algebra.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被赋予值0时，就形成了一个方程，我们被要求找到满足方程的函数输入值，通常是*x*。这些值被称为原始函数的根。找到这些值的过程称为解方程，这是数学中一个丰富的主题，特别是代数。
- en: In this section, we will discuss two fundamental methods of solving equations
    by hand as well as examine the available computational tools in Python to facilitate
    the process of automatically solving equations. We will start with the first method,
    algebraic manipulations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论手工解方程的两种基本方法，并检查Python中可用的计算工具，以便自动解方程的过程。我们将从第一种方法开始，即代数操作。
- en: Algebraic Manipulations
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数操作
- en: While we are classifying this as a method, algebra is, in general, a technique
    to *translate* an equation to a simpler form so that solutions can be found easily.
    Some typical ways to translate an equation are adding/subtracting a constant to
    both sides of the equation, multiplying/dividing both sides by a non-zero constant,
    or moving all the terms of the equation to one side.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将这个过程归类为一种方法，但代数学通常是一种将方程*转化*为更简单形式的技术，以便可以轻松找到解。一些典型的转化方程的方法包括在方程的两边加/减一个常数，将方程的两边乘/除以一个非零常数，或将方程的所有项移到一边。
- en: A simple example of this would be the *3x - 5 = 6* equation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是*3x - 5 = 6*方程。
- en: To solve for *x*, we first move the number *5* on the left-hand side to the
    right by adding *5* to both sides of the equation. This gives us *3x = 11*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要解出*x*，我们首先将左边的数字*5*移到右边，即在方程的两边都加上*5*。这给我们*3x = 11*。
- en: Finally, we multiply both sides by *1/3* so that we obtain the value of the
    variable *x*, which is *x = 11/3*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将两边都乘以*1/3*，这样我们就得到了变量*x*的值，即*x = 11/3*。
- en: 'This simple example illustrates the idea behind the whole process of manipulating
    an equation algebraically so that we can isolate the value of *x*. Let''s go through
    another example to nail down the point. Say we have an equation: *3x - 7 - 2(19x
    - 7) = (5x + 9) / 3 + 12*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子说明了代数操作整个过程的思想，以便我们可以隔离*x*的值。让我们通过另一个例子来强调这一点。假设我们有一个方程：*3x - 7 - 2(19x
    - 7) = (5x + 9) / 3 + 12*。
- en: While this equation seems significantly more complicated than the first, the
    process is actually the same. We first expand the terms inside the parentheses
    and gather the terms involving *x* into one group, and then gather the remaining
    terms into another.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方程似乎比第一个复杂得多，但过程实际上是相同的。我们首先展开括号内的项，并将涉及*x*的项收集到一组中，然后将剩余的项收集到另一组中。
- en: 'This will give us the following algebraic transformations:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下代数变换：
- en: '![Figure 4.18: Substituting the values to find the value of x'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：替换值以找到x的值
- en: '](image/B15968_04_18.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_18.jpg)'
- en: 'Figure 4.18: Substituting the values to find the value of x'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：替换值以找到x的值
- en: We see that this process is, in general, quite simple, especially when we are
    only dealing with *linear* terms of *x*. The term *linear* denotes the quantities
    that are the variable *x* multiplied by a constant. Overall, the general term
    for the two equations seen here is **linear equations**, which only contain linear
    terms of *x*. Solving linear equations, as we have seen, is a straightforward
    process, even when we do it by hand.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，总的来说，这个过程是相当简单的，特别是当我们只处理*x*的*线性*项时。术语*线性*表示的是变量*x*乘以一个常数的数量。总的来说，这两个方程的一般术语是**线性方程**，它只包含*x*的线性项。正如我们所见，解线性方程是一个直接的过程，即使我们手工进行解也是如此。
- en: In contrast, polynomial equations are equations with terms containing the variable
    *x* with degrees larger than *1*. Polynomial equations can be effectively solved
    using a specific technique, which will be discussed in the next subsection. For
    now, let's consider an example of a non-linear equation, *3e*x+2 *+ 3 = 2(e*x
    *+ 100)*, that can be solved simply using algebraic manipulations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，多项式方程是具有大于*1*的次数的变量*x*的项的方程。多项式方程可以通过一种特定的技术有效地解决，这将在下一小节中讨论。现在，让我们考虑一个非线性方程的例子，*3e*x+2
    *+ 3 = 2(e*x *+ 100)*，它可以简单地通过代数操作来解决。
- en: Note that *e* is the mathematical constant that is the base of the natural logarithmic
    function; it is approximately *2.71828*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*e*是自然对数函数的数学常数；它约为*2.71828*。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on this constant at [https://mathworld.wolfram.com/e.html](https://mathworld.wolfram.com/e.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://mathworld.wolfram.com/e.html](https://mathworld.wolfram.com/e.html)找到有关这个常数的更多信息。
- en: 'To solve this equation, we first expand the terms in this equation like so:
    *3e*x*e*2 *+ 3 = 2e*x *+ 200*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个方程，我们首先展开这个方程中的项，如下所示：*3e*x*e*2 *+ 3 = 2e*x *+ 200*
- en: 'The transformation on the left-hand side is possible because of the identity
    *a*x + y *= a*x *a*y for all positive numbers of *a*, and real numbers *x* and
    *y*. Now, we see that even though there is no linear term of *x* in this equation,
    we can still employ our strategy of isolating the terms involving *x* and group
    them together:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的变换是可能的，因为对于所有正数*a*和实数*x*和*y*，恒等式*a*x + y *= a*x *a*y*成立。现在，我们看到即使这个方程中没有*x*的线性项，我们仍然可以采用隔离涉及*x*的项并将它们分组的策略：
- en: '![Figure 4.19: Substituting the values in the equation to find ex'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19：替换方程中的值以找到ex'
- en: '](image/B15968_04_19.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_19.jpg)'
- en: 'Figure 4.19: Substituting the values in the equation to find ex'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：替换方程中的值以找到ex
- en: 'Now, having the value for *e*x, we would like to extract out the *x* term.
    To do this, we will apply the natural logarithmic function, *f(x) = ln(x)*, to
    both sides of the equation. Since *ln( e*x *) = x* for all real values of *x*,
    this step will transform the left-hand side of the equation to simply *x*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了*e*x的值，我们想要提取出*x*项。为此，我们将自然对数函数*f(x) = ln(x)*应用到方程的两边。由于对于所有实数*x*，*ln(
    e*x *) = x*，这一步将把方程的左侧转换为简单的*x*：
- en: '![Figure 4.20: Substituting the values in the equation to find x'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20：替换方程中的值以找到x'
- en: '](image/B15968_04_20.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_20.jpg)'
- en: 'Figure 4.20: Substituting the values in the equation to find x'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：替换方程中的值以找到x
- en: 'Overall, the general idea behind using algebraic transformation to solve an
    equation is to group all the terms involving *x* together and manipulate them
    into a single term. Again, this strategy alone does not always work for any equation,
    as sometimes it is not possible to simplify all the *x* terms into one single
    term. This is the case for polynomial equations, which we will be discussing in
    the context of the next method of solving equations: factoring.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，使用代数变换来解方程的一般思想是将涉及*x*的所有项分组并将它们操纵成一个单一项。同样，这种策略并不总是适用于任何方程，因为有时不可能将所有*x*项简化为一个单一项。这是多项式方程的情况，我们将在下一种解方程的方法——因式分解的背景下讨论它。
- en: Factoring
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因式分解
- en: 'While it technically belongs to the umbrella term of algebra, **factoring**
    specifically denotes the process of manipulating a given equation into the following
    form:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它在技术上属于代数的大类，**因式分解**特指将给定方程操纵成以下形式的过程：
- en: '![Figure 4.21: Formula for factoring'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.21：因式分解公式'
- en: '](image/B15968_04_21.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_21.jpg)'
- en: 'Figure 4.21: Formula for factoring'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：因式分解公式
- en: If the product of these terms is equal to zero, at least one of the terms must
    be equal to zero to satisfy the equation. In other words, solving the original
    equation is equivalent to solving each of the equations *f*1*(x) = 0*, *f*2*(x)
    = 0*, …, and *f*n*(x) = 0*. Ideally, we would want each of these *f*i*(x) = 0*
    equations to be easier to solve than the original.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些项的乘积等于零，那么至少其中一个项必须等于零才能满足方程。换句话说，解原方程等价于解每个方程*f*1*(x) = 0*，*f*2*(x) = 0*，…，和*f*n*(x)
    = 0*。理想情况下，我们希望每个这些*f*i*(x) = 0*方程都比原方程更容易解决。
- en: 'Let''s consider a starting example: x2 = 100'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个起始例子：x2 = 100
- en: Using the identity *x*2 *- y*2 *= (x - y) (x + y)* for all real *x* and *y*
    values, the equation is equivalent to *(x - 10) (x + 10) = 0*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用恒等式*x*2 *- y*2 *= (x - y) (x + y)*对于所有实数*x*和*y*值，方程等价于*(x - 10) (x + 10) =
    0*。
- en: 'Since their product is zero, either *x - 10* or *x + 10* must also be zero.
    Solving these two equations gives us the solution for the original equation: *x
    = 10* or *x = -10*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的乘积为零，*x - 10*或*x + 10*也必须为零。解这两个方程给出了原方程的解：*x = 10*或*x = -10*。
- en: 'While this is a fairly simple example, it is able to illustrate a number of
    points. First, by factoring the equation into different terms multiplied together
    being equal to 0, the problem was converted into a set of simpler sub-problems.
    Additionally, with factoring, we can achieve something that the simple addition/multiplication
    of manipulations cannot: solving polynomial equations.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个相当简单的例子，但它能够说明一些要点。首先，通过将方程分解为相乘等于0的不同项，问题被转化为一组更简单的子问题。此外，通过分解，我们可以实现简单的加法/乘法操作无法实现的事情：解多项式方程。
- en: 'Let''s consider our next example of an equation: *x*3 *- 7x*2 *+ 15x = 9*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑下一个例子：*x*3 *- 7x*2 *+ 15x = 9*
- en: We see that even when all the terms involving *x* have already been grouped
    together, it is not clear how we should proceed with simple algebra.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，即使所有涉及*x*的项已经被分组在一起，也不清楚我们应该如何进行简单的代数运算。
- en: 'Here, an insightful mathematics student may notice that this equation accepts
    *x = 1* or *x = 3* as solutions (since plugging in these values makes the left-hand
    side of the equation evaluate to 0). The fact that a polynomial equation accepts
    *x = c* as a solution not only means that by replacing *x* with *c* in the equation
    it will evaluate to zero, but it also means that the equation itself can be factored
    into the form *(x - c) g(x) = 0*, where *g(x)* is the other factored term of the
    equation. This technique also has another name, Ruffini''s rule, about which you
    can find more information at [https://mathworld.wolfram.com/RuffinisRule.html](https://mathworld.wolfram.com/RuffinisRule.html).
    With that in mind, we attempt to factor the given equation with respect to the
    term *(x - 1)* as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个有洞察力的数学学生可能会注意到这个方程接受*x = 1*或*x = 3*作为解（因为将这些值代入使方程的左边评估为0）。多项式方程接受*x
    = c*作为解不仅意味着通过在方程中用*c*替换*x*，它将评估为零，而且还意味着方程本身可以被分解成形式*(x - c) g(x) = 0*，其中*g(x)*是方程的另一个分解项。这个技巧还有另一个名字，鲁菲尼法则，关于这个你可以在[https://mathworld.wolfram.com/RuffinisRule.html](https://mathworld.wolfram.com/RuffinisRule.html)找到更多信息。考虑到这一点，我们尝试根据*(x
    - 1)*的项来分解给定的方程如下：
- en: '![Figure 4.22: Factoring the given equation'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：分解给定的方程
- en: '](image/B15968_04_22.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_22.jpg)'
- en: 'Figure 4.22: Factoring the given equation'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：分解给定的方程
- en: Keeping in mind that the equation also accepts *x = 3* as a solution, we continue
    to factor *(x*2 *- 6x + 9)* into *(x - 3)* multiplied by another term. If you
    are familiar with the quadratic formula, you might already be able to tell that
    the equation can be factored into *(x - 1) (x - 3)*2 *= 0*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 记住方程也接受*x = 3*作为解，我们继续将*(x*2 *- 6x + 9)*分解为*(x - 3)*乘以另一个项。如果你熟悉二次方程公式，你可能已经能够判断方程可以分解为*(x
    - 1) (x - 3)*2 *= 0*。
- en: 'In the end, we have proven that the given equation does accept two solutions:
    *x = 1* and *x = 3*.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们证明了给定的方程接受两个解：*x = 1*和*x = 3*。
- en: A polynomial equation of degree *n* is one where the largest degree that *x*
    has is *n*. Overall, we would like to factor such an equation to *n* different
    factors. This is because it can be mathematically proven that a polynomial equation
    of degree *n* can only have, at most, *n* unique solutions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '* n *的多项式方程是指*x*的最大次数为*n*的方程。总的来说，我们希望将这样的方程分解为*n*个不同的因子。这是因为可以数学证明，*n*次多项式方程最多只能有*n*个唯一解。'
- en: 'In other words, if we can successfully transform an equation into *n* different
    factors, each of those factors is a linear term of *x*, which can be easily solved
    using the first method that we discussed above. For example, the equation *2x*3
    *- 7x*2 *+ 7x - 2 = 0* can be factored into *(x - 1) (x - 2) (2x - 1) = 0*, which
    gives us three solutions: *x = 1*, *x = 2*, and *x = 1 / 2*.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们成功地将一个方程转化为*n*个不同的因子，那么这些因子中的每一个都是*x*的线性项，可以很容易地使用我们上面讨论的第一种方法来解决。例如，方程*2x*3
    *- 7x*2 *+ 7x - 2 = 0*可以分解为*(x - 1) (x - 2) (2x - 1) = 0*，这给出了三个解：*x = 1*，*x =
    2*和*x = 1 / 2*。
- en: Of course, there are situations in which a polynomial equation of degree *n*
    cannot be factored into *n* different linear terms of *x*. Consider the following
    example equation *x*3 *+ 4x - 5 = 0*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些情况下，*n*次多项式方程不能被分解为*x*的*n*个不同线性项。考虑以下例子方程*x*3 *+ 4x - 5 = 0*。
- en: 'This accepts a solution *x = 1*, and therefore has a factor of *(x - 1)*:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这接受了*x = 1*的解，因此有一个因子为*(x - 1)*：
- en: '![Figure 4.23: Factor for x = 1'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：x = 1的因子
- en: '](image/B15968_04_23.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_23.jpg)'
- en: 'Figure 4.23: Factor for x = 1'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：x = 1的因子
- en: Now, consider the term *x*2 *+ x + 5*. If we try plugging various values of
    *x* into the equation, we will see that none of the values can satisfy the equation.
    This suggests that this equation has no solution or, more specifically, *x*2 *+
    x + 5* is greater than 0 for all values of *x*, and we will prove that statement.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑*x*2 *+ x + 5*这个项。如果我们尝试将各种*x*的值代入方程，我们会发现没有一个值能满足方程。这表明这个方程没有解，或者更具体地说，*x*2
    *+ x + 5*对所有的*x*值都大于0，我们将证明这个陈述。
- en: When we'd like to prove that a quadratic function of a variable is always greater
    than 0, we can utilize the fact that *(g(x))*2 is always non-negative, for all
    real values of *x* and for all functions *g* (this is because the square of any
    real number is non-negative). If we could then rewrite the term *x*2 *+ x + 5*
    into the form *(g(x))*2 *+ c*, where *c* is a positive constant, we can prove
    that the term is always positive.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要证明一个变量的二次函数始终大于0时，我们可以利用*(g(x))*2对于所有实数值的*x*和所有函数*g*始终是非负的这一事实（这是因为任何实数的平方都是非负的）。如果我们能够将*x*2
    *+ x + 5*重写为*(g(x))*2 *+ c*的形式，其中*c*是一个正常数，我们就可以证明这个项始终是正的。
- en: 'Here, we use the **completing the square technique** to group the *x* terms
    into a square. This technique involves using the identity *(a + b)*2 *= a*2 *+
    2ab + b*2 for all values of *a* and *b* to construct *(g(x))*2. Specifically,
    the term *x* can be rewritten as *2 x (1/2)*, since we need it to be in the form
    of 2 multiplied by *x* multiplied by another number. So, we have *x*2 and *2 x
    (1/2);* we therefore need *(1/2)*2 *= 1/4* to *complete* the sum of the three
    numbers as a square: *x*2 *+ x + 1/4 = x*2 *+ 2 x (1/2) + (1/2)*2 *= (x + 1/2)*2.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用**完成平方技术**将*x*项分组成一个平方。这种技术涉及使用恒等式*(a + b)*2 *= a*2 *+ 2ab + b*2*对所有的*a*和*b*值来构造*(g(x))*2。具体来说，项*x*可以重写为*2
    x (1/2)*，因为我们需要它以2乘以*x*再乘以另一个数字的形式。所以，我们有*x*2和*2 x (1/2)*；因此我们需要*(1/2)*2 *= 1/4*来将这三个数字的和完成为一个平方：*x*2
    *+ x + 1/4 = x*2 *+ 2 x (1/2) + (1/2)*2 *= (x + 1/2)*2。
- en: The whole term can therefore be transformed as *x*2 *+ x + 5 = (x*2 *+ x + 1/4)
    + 19/4 = (x + 1/2)*2 *+ 19/4*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此整个项可以转换为*x*2 *+ x + 5 = (x*2 *+ x + 1/4) + 19/4 = (x + 1/2)*2 *+ 19/4*。
- en: '*(x + 1/2)*2 is non-negative for any real value of *x*, so the whole term *(x
    + 1/2)*2 *+ 19/4* is greater than or equal to *19/4*. This is to say that there
    is no real value of *x* that makes the term *x*2 *+ x + 5* equal to *0*; in other
    words, the equation *x*2 *+ x + 5 = 0* does not have any solution.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*(x + 1/2)*2对于任何实数值的*x*都是非负的，因此整个项*(x + 1/2)*2 *+ 19/4*大于或等于*19/4*。这就是说，没有任何实数值的*x*使得项*x*2
    *+ x + 5*等于*0*；换句话说，方程*x*2 *+ x + 5 = 0*没有任何解。'
- en: And that is an overview of the factoring technique to solve polynomial equations.
    By way of a final point on the topic of equations, we will discuss the use of
    Python to automate the process of solving equations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是解决多项式方程的因式分解技术的概述。最后，关于方程的主题，我们将讨论使用Python自动化解方程的过程。
- en: Using Python
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python
- en: In addition to the two methods of solving equations by hand, we also have the
    option of leveraging the computational power of Python to automatically solve
    any equation. In this section, we will look into this process in the context of
    the `SymPy` library.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动解方程的两种方法之外，我们还可以利用Python的计算能力自动解决任何方程。在本节中，我们将在`SymPy`库的背景下探讨这个过程。
- en: Broadly speaking, SymPy is one of the best libraries in Python for symbolic
    mathematics, which is an umbrella term for algebraic computations involving symbols
    (such as *x*, *y*, and *f(x)*). While SymPy offers an extensive API that includes
    support for different mathematical subfields, including calculus, geometry, logic,
    and number theory, we will only be exploring its options for solving equations
    and (in the next section) systems of equations in this chapter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上说，SymPy是Python中用于符号数学的最佳库之一，这是一个涵盖符号（如*x*、*y*和*f(x)*）的代数计算的总称。虽然SymPy提供了广泛的API，包括对不同数学子领域的支持，包括微积分、几何、逻辑和数论，但在本章中，我们只会探索它解方程和（在下一节中）解方程组的选项。
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on the library on its official website at [https://docs.sympy.org/latest/index.html](https://docs.sympy.org/latest/index.html).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其官方网站[https://docs.sympy.org/latest/index.html](https://docs.sympy.org/latest/index.html)上找到有关该库的更多信息。
- en: 'First, we need to install the library for our Python environment. This process,
    as always, can be done via `pip` and `conda`. Run either of the following commands:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的Python环境安装该库。这个过程，像往常一样，可以通过`pip`和`conda`来完成。运行以下命令中的任意一个：
- en: '[PRE11]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Following a successful installation of the library, let''s explore the options
    that it offers using a specific example, an equation that we considered in the
    last section: *x*3 *- 7x*2 *+ 15x = 9*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功安装了该库之后，让我们使用一个特定的示例来探索它提供的选项，即我们在上一节中考虑的方程：*x*3 *- 7x*2 *+ 15x = 9*。
- en: 'Being a tool for symbolic mathematics, SymPy offers an easy API to declare
    variables and functions. To do this, we first import the `Symbol` class from the
    SymPy library and declare a variable named `x`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为符号数学工具，SymPy提供了一个简单的API来声明变量和函数。为此，我们首先从SymPy库中导入`Symbol`类并声明一个名为`x`的变量：
- en: '[PRE12]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When `x` is printed out in a Jupyter notebook, we will see that the letter
    is actually formatted as a mathematical symbol:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Jupyter笔记本中打印`x`时，我们会看到这个字母实际上被格式化为一个数学符号：
- en: '![Figure 4.24: SymPy symbols in Jupyter notebook'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24：Jupyter笔记本中的SymPy符号'
- en: '](image/B15968_04_24.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_24.jpg)'
- en: 'Figure 4.24: SymPy symbols in Jupyter notebook'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：Jupyter笔记本中的SymPy符号
- en: 'Now, to solve the given equation, we import the `solve()` function from the
    `sympy.solvers` package. This `solve()` function takes in an expression containing
    a SymPy symbol (in this case, it is our variable `x`) and finds the values of
    `x` that make the expression evaluate to 0\. In other words, to solve for *x*3
    *- 7x*2 *+ 15x = 9*, we enter the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了解决给定的方程，我们从`sympy.solvers`包中导入`solve()`函数。这个`solve()`函数接受一个包含SymPy符号的表达式（在这种情况下，就是我们的变量`x`），并找到使表达式等于0的`x`的值。换句话说，要解*x*3
    *- 7x*2 *+ 15x = 9*，我们输入以下代码：
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code snippet returns a list of solutions for `x`, which, in this case,
    is `[1, 3]`. We see that this corresponds to the solution that we found earlier
    via factoring.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段返回`x`的解列表，这种情况下是`[1, 3]`。我们看到这对应于我们之前通过因式分解找到的解。
- en: 'Let''s examine another example that we have solved earlier: *3e*x + 2 *+ 3
    = 2(e*x *+ 100).* Remember that this equation has a root, *x = ln( 197 / (3e*2
    *- 2) )*, which is approximately 2.279\. Now, we enter this equation into the
    `solve()` function like so (after importing the constant `e` from the built-in
    `math` library):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查另一个我们之前解决过的例子：*3e*x + 2 *+ 3 = 2(e*x *+ 100.* 记住这个方程有一个根，*x = ln( 197 /
    (3e*2 *- 2) )*，约为2.279。现在，我们将这个方程输入到`solve()`函数中（在导入内置的`math`库中的常数`e`之后）：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will give us the following output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This, as we can see, is the same solution obtained from our algebraic analysis.
    Overall, with the ability to declare variables and have a function of any form
    as input for the `solve()` function, SymPy offers us a flexible and convenient
    way to computationally solve equations in Python.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这与我们代数分析得到的解决方案相同。总的来说，通过声明变量并将任何形式的函数作为`solve()`函数的输入，SymPy为我们提供了一种灵活和方便的方式来在Python中计算解方程。
- en: This topic also concludes our discussion on equations and methods of finding
    their solutions. Before we move on to the next topic in this chapter, let's go
    through an exercise to practice what we have learned in this section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题也结束了我们对方程和找到它们解决方法的讨论。在我们进入本章的下一个话题之前，让我们通过一个练习来练习我们在本节学到的知识。
- en: 'Exercise 4.03: Introduction to Break-Even Analysis'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：盈亏分析简介
- en: Break-even analysis is a common practice in economics and financial engineering.
    The goal of a break-even analysis is to find the specific points in time where
    the revenue of a business balances its costs. Finding these points in time is
    therefore very important to business owners and stakeholders, who are interested
    in knowing if, and when, they will make a profit.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 盈亏分析是经济学和金融工程中的常见实践。盈亏分析的目标是找到企业收入平衡成本的特定时间点。因此，找到这些时间点对于对业务所有者和利益相关者非常重要，他们希望知道是否以及何时会获利。
- en: This scenario can be modeled fairly easily using mathematical variables and
    functions, which we will be doing in this exercise. Specifically, we aim to model
    a simple business and conduct a break-even analysis by solving for the break-even
    points. By the end, you will become more familiar with the process of representing
    real-life situations using mathematical models, functions, and variables.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情景可以很容易地使用数学变量和函数进行建模，这是我们将在本练习中进行的。具体来说，我们的目标是通过解决盈亏平衡点来对一个简单的业务进行建模和进行盈亏分析。最终，您将更加熟悉使用数学模型、函数和变量来表示现实生活情况的过程。
- en: '**Scenario**: A burger restaurant incurs a cost of $6.56 for the ingredients
    of every burger that it sells. It also incurs a fixed cost of $1,312.13 every
    month, which goes into the cooks'' wages, rent, utilities, and so on. The owner
    of the restaurant would like to perform a break-even analysis to determine if
    and when the revenue will cover the cost.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**情景**：一家汉堡餐厅每卖出一份汉堡的原料成本为6.56美元。它还每个月有固定成本1312.13美元，用于厨师工资、租金、水电费等。餐厅的老板想进行盈亏分析，以确定何时收入将覆盖成本。'
- en: 'Create a new Jupyter notebook and import NumPy, Matplotlib, and SymPy in the
    first code cell:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个代码单元格中创建一个新的Jupyter笔记本，并导入NumPy、Matplotlib和SymPy：
- en: '[PRE16]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Say the restaurant sets the price of each of the burgers it sells at $8.99 and
    let *x* be a variable that represents the number of burgers that need to be sold
    each month so that the revenue made is equal to the cost. Write down the equation
    for *x* in this situation.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设餐厅将每个卖出的汉堡的价格定为8.99美元，让*x*表示每个月需要卖出的汉堡的数量，以便收入等于成本。写出这种情况下*x*的方程。
- en: 'With *x* being the number of burgers sold, *8.99x* is the revenue that the
    restaurant will make, while *6.56x + 1312.13* is the cost that the restaurant
    will incur. The equation for *x* will therefore be:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x*是卖出的汉堡的数量时，*8.99x*是餐厅将获得的收入，而*6.56x + 1312.13*是餐厅将发生的成本。因此*x*的方程将是：
- en: '*8.99x = 6.56x + 1312.13*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*8.99x = 6.56x + 1312.13*'
- en: Solve for *x* by hand and verify the result using Python in the next cell of
    the Jupyter notebook. For testing purposes, store the list of solutions returned
    by SymPy to a variable named `sols`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手工解出*x*并在Jupyter笔记本的下一个单元格中使用Python验证结果。为了测试目的，将SymPy返回的解决方案列表存储到名为`sols`的变量中。
- en: Using simple algebraic transformation, we can solve for *x* to be *x = 1312.13
    / (8.99 – 6.56) = 539.97*. So, the restaurant needs to sell roughly 540 burgers
    to break even.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的代数变换，我们可以解出*x*为*x = 1312.13 / (8.99 – 6.56) = 539.97*。因此，餐厅需要大约卖出540份汉堡才能实现盈亏平衡。
- en: 'The following code can be used to solve for *x* using SymPy:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以使用SymPy来解决*x*的问题：
- en: '[PRE17]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `sols` variable should have the value `[539.971193415638]`, which corresponds
    to our solution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`sols`变量应该有值`[539.971193415638]`，这对应于我们的解决方案。'
- en: Instead of solving for *x* to be the break-even point, construct a function
    of *x* that represents the total profit (revenue minus cost) of the restaurant
    every month.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要解出*x*作为盈亏平衡点，构建一个关于*x*的函数，表示每个月餐厅的总利润（收入减去成本）。
- en: The function should be *f(x) = 8.99x - 6.56x - 1312.13 = 2.43x - 1312.13*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数应为*f(x) = 8.99x - 6.56x - 1312.13 = 2.43x - 1312.13*。
- en: 'In the next code cell of the Jupyter notebook, plot this function for the *x*
    values between 0 and 1000 using NumPy and Matplotlib, along with a horizontal
    line at 0, which should be colored black:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本的下一个代码单元格中，使用NumPy和Matplotlib绘制这个函数，*x*的值在0到1000之间，并在0处绘制一条水平线，颜色应为黑色：
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should produce the following plot:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 4.25: Visualization of a break-even analysis'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：盈亏分析的可视化'
- en: '](image/B15968_04_25.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_25.jpg)'
- en: 'Figure 4.25: Visualization of a break-even analysis'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：盈亏分析的可视化
- en: The intersection of our profit curve and the horizontal line represents the
    break-even point. In this case, we see that it is roughly at the *x*-coordinate
    of `540`, which corresponds to the actual break-even point.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的利润曲线与水平线的交点代表盈亏平衡点。在这种情况下，我们看到它大约在*x*坐标为`540`处，这对应于实际的盈亏平衡点。
- en: Say the restaurant on average sells 400 burgers every month and now let *x*
    be the price of a burger that the restaurant can set so that they can break even.
    Write down the equation for *x* in this situation.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设餐厅平均每月销售400个汉堡，现在让*x*成为餐厅可以设置的汉堡价格，以便他们可以实现盈亏平衡。写下这种情况下*x*的方程。
- en: With *x* being the price of a burger, *400x* is the profit that the restaurant
    will make, while *(400) 6.56 + 1312.13 = 3936.13* (*$6.56* for each burger and
    a fixed amount of *$1312.13*) is the cost the restaurant will incur. The equation
    for *x* will therefore be *400x = 3936.13*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x*是汉堡的价格时，*400x*是餐厅将获得的利润，而*(400) 6.56 + 1312.13 = 3936.13*（每个汉堡*6.56*美元和固定金额*1312.13*美元）是餐厅将发生的成本。因此，*x*的方程将是*400x
    = 3936.13*。
- en: Solve for *x* by hand and verify the result with SymPy in the Jupyter notebook.
    Store the list of solutions returned by SymPy in a variable named `sols1`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手工求解*x*，并在Jupyter笔记本中使用SymPy验证结果。将SymPy返回的解列表存储在名为`sols1`的变量中。
- en: 'The equation can be simply solved by dividing both sides by 400, which gives
    us *x = 9.84*. The Python code that solves the same equation is the following,
    which also produces the same result:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两边都除以400，可以简单地解出方程，得到*x = 9.84*。解决相同方程的Python代码如下，也得到相同的结果：
- en: '[PRE19]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the next code cell, plot the function that represents the difference between
    profit and cost for the *x* values between `0` and `10`, together with the horizontal
    line at `0`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，绘制代表利润和成本之间差异的函数，*x*值在`0`和`10`之间，以及水平线在`0`处：
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should produce the following plot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 4.26: Visualization of a break-even analysis'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26：盈亏分析的可视化'
- en: '](image/B15968_04_26.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_26.jpg)'
- en: 'Figure 4.26: Visualization of a break-even analysis'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：盈亏分析的可视化
- en: Once again, the intersection of the two lines (which represents the break-even
    point) coincides with the actual solution that we have derived.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，两条线的交点（代表盈亏平衡点）与我们得出的实际解相符。
- en: And that is the end of our exercise. In it, we have been introduced to the concept
    of break-even analysis by modeling a sample real-life business with mathematical
    functions and variables. We have learned how to find the number of products to
    be produced as well as the correct price to set to break even.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们练习的结束。在其中，我们通过建模一个样本现实生活中的业务，使用数学函数和变量，介绍了盈亏分析的概念。我们已经学会了如何找到要生产的产品数量，以及设置盈亏平衡的正确价格。
- en: Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gn3JU3](https://packt.live/3gn3JU3).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gn3JU3](https://packt.live/3gn3JU3)。
- en: You can also run this example online at [https://packt.live/3gkeA0V](https://packt.live/3gkeA0V).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3gkeA0V](https://packt.live/3gkeA0V)上在线运行此示例。
- en: 'Of course, a real-life business scenario is more complicated and has many more
    factors involved. We will come back to the task of break-even analysis in the
    activity at the end of the chapter, but before that, we need to discuss this chapter''s
    final section: systems of equations.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现实生活中的业务场景更加复杂，涉及更多因素。我们将在本章末尾的活动中回到盈亏分析的任务，但在此之前，我们需要讨论本章的最后一节：方程组。
- en: Systems of Equations
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方程组
- en: 'An equation is an equality that we need to satisfy by solving for the values
    of a specific variable. In a system of equations, we have multiple equations involving
    multiple variables, and the goal is still the same: solving for the values of
    these variables so that each and every equation in the system is satisfied.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 方程是我们需要通过解出特定变量的值来满足的相等式。在方程组中，我们有涉及多个变量的多个方程，目标仍然是相同的：解出这些变量的值，使系统中的每个方程都得到满足。
- en: Overall, there is no limit to the number of equations a system can have. However,
    it can be rigorously proven that when the number of equations a system has is
    not equal to the number of its variables, the system has either infinitely many
    solutions or no solutions. In this section, we will only be considering the case
    where these two numbers match.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，系统可以有任意数量的方程。然而，可以严格证明，当系统的方程数量不等于其变量数量时，系统要么有无穷多个解，要么没有解。在本节中，我们只考虑这两个数字相等的情况。
- en: 'Additionally, we will consider two different types of systems of equations:
    systems of linear equations and those of non-linear equations. We will consider
    the methods of solving each of these two types of systems of equations, both by
    hand and by using Python. First, let''s discuss the concept of systems of linear
    equations.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将考虑两种不同类型的方程组：线性方程组和非线性方程组。我们将考虑解决这两种类型的方程组的方法，无论是手工还是使用Python。首先，让我们讨论线性方程组的概念。
- en: Systems of Linear Equations
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性方程组
- en: Similar to linear equations, which only contain constants and linear terms of
    their variables, a system of linear equations consists of linear equations, which
    also only contain linear combinations of its variables and constants.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与线性方程类似，线性方程组只包含常数和其变量的线性项，由线性方程组组成，这些方程也只包含其变量和常数的线性组合。
- en: 'A simple example of such a system is the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统的一个简单示例如下：
- en: '![Figure 4.27: An example of a linear equation system'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27：线性方程组的示例'
- en: '](image/B15968_04_27.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_27.jpg)'
- en: 'Figure 4.27: An example of a linear equation system'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：线性方程组的示例
- en: 'As we can see, this system of equations has two variables: *x* and *y*. Each
    of the two equations contains those variables multiplied by constants (linear
    terms) as well as constants themselves.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个方程组有两个变量：*x* 和 *y*。这两个方程中包含这些变量与常数（线性项）相乘以及常数本身。
- en: To solve this system of equations, you may have already noticed that if we were
    to add respective sides of the two equations together, we would obtain an extra
    equation, *3y = 8*, which we can then solve for *y = 8/3* and subsequently solve
    for *x = 5 - 8/3 = 7/3*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个方程组，您可能已经注意到，如果我们将两个方程的各自的两边相加，我们将得到一个额外的方程，*3y=8*，然后我们可以解出*y=8/3*，随后解出*x=5-8/3=7/3*。
- en: Overall, this method involves multiplying the equations provided to us by different
    constants and adding them together to sequentially eliminate variables. The goal
    is to obtain an equation that only has linear terms of a single variable left
    (and potentially constants), from which we can solve for that one variable. The
    solution value for this variable will then be plugged into the original equations,
    and the process continues for the rest of the variables.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种方法涉及将我们提供的方程分别乘以不同的常数并将它们相加，以依次消除变量。目标是获得一个只剩下单个变量的线性项（可能还有常数）的方程。然后我们可以解出这个变量。然后将这个变量的解值代入原方程，这个过程将继续进行下去，直到解出所有的变量。
- en: While this process is straightforward when the number of variables/equations
    we have is relatively small, it can get quite messy as this number grows. In this
    subsection, we will consider a method called *row reduction*, or *Gaussian elimination*,
    that will help us formalize and then automate the process of solving the system
    of equations.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当我们拥有的变量/方程的数量相对较小时，这个过程是直接的，但随着这个数量的增加，它可能会变得非常混乱。在本小节中，我们将考虑一种称为*行简化*或*高斯消元*的方法，这将帮助我们规范化并自动化解方程组的过程。
- en: 'Say we are asked to solve the following general system of linear equations
    with *n* variables and *n* equations:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被要求解下面的一般线性方程组，其中有*n*个变量和*n*个方程：
- en: '![Figure 4.28: System of linear equations with n variables and n equations'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28：具有n个变量和n个方程的线性方程组'
- en: '](image/B15968_04_28.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_28.jpg)'
- en: 'Figure 4.28: System of linear equations with n variables and n equations'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：具有n个变量和n个方程的线性方程组
- en: Here, *c*ij is the constant coefficient for variable *x*j in the *i*th equation.
    Again, these *c*ij values can take on any constant value, and this system of equation
    is the most general form of any system of linear equations.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，*c*ij是第*i*个方程中变量*x*j的常数系数。同样，这些*c*ij值可以取任何常数值，这个方程组是任何线性方程组的最一般形式。 '
- en: 'To apply the row reduction method, we construct what is called an augmented
    matrix, which is the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用行简化方法，我们构造了所谓的增广矩阵，即以下内容：
- en: '![Figure 4.29: An augmented matrix'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.29：一个增广矩阵'
- en: '](image/B15968_04_29.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_29.jpg)'
- en: 'Figure 4.29: An augmented matrix'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29：一个增广矩阵
- en: The left section of the matrix is an *n*-by-*n* submatrix whose elements correspond
    to the constant coefficients in the original system of equations; the right section
    of the matrix is a column with *n* values, which correspond to the constant values
    on the right-hand side of the equations in the original system.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的左侧部分是一个*n*乘以*n*的子矩阵，其元素对应于原方程组中的常数系数；矩阵的右侧部分是一个包含*n*个值的列，这些值对应于原方程组中方程右侧的常数值。
- en: 'Now, from this augmented matrix, we can perform three types of transformation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从这个增广矩阵中，我们可以进行三种类型的变换：
- en: Swap the locations of any given two rows.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换任意两行的位置。
- en: Multiply a row by a non-zero constant.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一行乘以非零常数。
- en: Add a row to any other row (potentially multiplied by a non-zero constant as
    well).
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一行添加到任何其他行（可能也要乘以非零常数）。
- en: 'The goal of the method is to transform the augmented matrix into *reduced row
    echelon form*, or, since we have a system of *n* equations and *n* variables,
    an identity matrix, where the *i*th element in the *i*th row is 1 and every other
    element in that row is *0*. Essentially, we would like to transform the augmented
    matrix into this matrix:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的目标是将增广矩阵转换成*简化行梯阵形式*，或者，因为我们有一个*n*个方程和*n*个变量的系统，转换成一个单位矩阵，其中第*i*行的第*i*个元素为1，该行的其他元素为*0*。基本上，我们希望将增广矩阵转换成这个矩阵：
- en: '![Figure 4.30: Matrix transformation'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.30：矩阵变换'
- en: '](image/B15968_04_30.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_30.jpg)'
- en: 'Figure 4.30: Matrix transformation'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30：矩阵变换
- en: Once this is done, the *c*i*'* values correspond to the values that make up
    the solution for the original system of equations. In other words, the solution
    would be *x*1 *= c*1*'*, *x*2 *= c*2*'*, and so on.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步之后，*c*i*'*值对应于构成原方程组解的值。换句话说，解将是*x*1*=c*1*，*x*2*=c*2*，依此类推。
- en: 'While this mathematical generalization can seem intimidating, let''s demystify
    the process by considering a specific example. Let''s say we are to solve the
    following system of linear equations:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种数学概括可能看起来令人生畏，但让我们通过考虑一个具体的例子来揭开这个过程的神秘面纱。假设我们要解下面的线性方程组：
- en: '![Figure 4.31: System of linear equations'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31：线性方程组'
- en: '](image/B15968_04_31.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_31.jpg)'
- en: 'Figure 4.31: System of linear equations'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31：线性方程组
- en: 'We first construct the corresponding augmented matrix:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构造相应的增广矩阵：
- en: '![Figure 4.32: Corresponding augmented matrix'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32：相应的增广矩阵'
- en: '](image/B15968_04_32.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_32.jpg)'
- en: 'Figure 4.32: Corresponding augmented matrix'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：相应的增广矩阵
- en: 'Now, we aim to transform this matrix into the identity form by using the three
    mentioned methods of transformation. We first subtract the second row by three
    times the first row and subsequently divide it by 4 to obtain:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的目标是通过使用三种提到的变换方法将这个矩阵转换成单位形式。我们首先将第二行减去三倍的第一行，然后除以4得到：
- en: '![Figure 4.33: Step 1 to transform the matrix into an identity matrix'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.33：将矩阵转换为单位矩阵的第一步'
- en: '](image/B15968_04_33.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_33.jpg)'
- en: 'Figure 4.33: Step 1 to transform the matrix into an identity matrix'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33：将矩阵转换为单位矩阵的第1步
- en: 'Again, the goal is to create the structure of an identity matrix on the left-hand
    side, which can be done by forcing the non-diagonal elements to be zero. We have
    done this for the first element on the second row, so let''s now try to do the
    same for the third row by subtracting it by two times the first row:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，目标是在左侧创建单位矩阵的结构，这可以通过强制非对角元素为零来实现。我们已经对第二行的第一个元素做到了这一点，所以现在让我们尝试对第三行做同样的事情，通过减去两倍的第一行：
- en: '![Figure 4.34: Step 2 to transform the matrix into an identity matrix'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34：将矩阵转换为单位矩阵'
- en: '](image/B15968_04_34.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_34.jpg)'
- en: 'Figure 4.34: Step 2 to transform the matrix into an identity matrix'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34：将矩阵转换为单位矩阵的第2步
- en: 'The second element on the third row is to be transformed to 0, which can be
    done by subtracting the third row by two times the second row:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行的第二个元素要转换为0，可以通过减去两倍的第二行来实现：
- en: '![Figure 4.35: Step 3 to transform the matrix into an identity matrix'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35：将矩阵转换为单位矩阵的第3步'
- en: '](image/B15968_04_35.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_35.jpg)'
- en: 'Figure 4.35: Step 3 to transform the matrix into an identity matrix'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35：将矩阵转换为单位矩阵的第3步
- en: 'Once the last row is in the correct form, transforming the other rows is relatively
    easy as well. We now subtract the second row by three times the third row and
    multiply it by -1, which gives us:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦最后一行处于正确形式，转换其他行也相对容易。现在我们将第二行减去三倍的第三行，并乘以-1，得到：
- en: '![Figure 4.36: Step 4 to transform the matrix into an identity matrix'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.36：将矩阵转换为单位矩阵的第4步'
- en: '](image/B15968_04_36.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_36.jpg)'
- en: 'Figure 4.36: Step 4 to transform the matrix into an identity matrix'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36：将矩阵转换为单位矩阵的第4步
- en: 'As for the first row, we first add two times the third row to it to eliminate
    the last element:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第一行，我们首先加上三倍的第三行，以消除最后一个元素：
- en: '![Figure 4.37: Step 5 to transform the matrix into an identity matrix'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.37：将矩阵转换为单位矩阵的第5步'
- en: '](image/B15968_04_37.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_37.jpg)'
- en: 'Figure 4.37: Step 5 to transform the matrix into an identity matrix'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37：将矩阵转换为单位矩阵的第5步
- en: 'Finally, we subtract it by three times the second row, which allows us to obtain
    the reduced row echelon form of our augmented matrix (with the identity matrix
    on the left):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们减去三倍的第二行，这样就可以得到增广矩阵的行阶梯形式（左侧为单位矩阵）：
- en: '![Figure 4.38: Identity matrix'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.38：单位矩阵'
- en: '](image/B15968_04_38.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_38.jpg)'
- en: 'Figure 4.38: Identity matrix'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：单位矩阵
- en: This corresponds to the solution where *x = 1*, *y = 2*, and *z = 3*. We can
    ensure that our solution is indeed correct by plugging these values into the original
    system of equations, which shows that they do satisfy the system.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于解*x = 1*，*y = 2*，和*z = 3*。我们可以通过将这些值代入原始方程组来确保我们的解确实是正确的，这显示它们确实满足该系统。
- en: 'And that is the process of using the row reduction method. As mentioned earlier,
    another method to solve a system of linear equations is the matrix solution. This
    involves representing a given system as a matrix equation. Specifically, from
    the general form of any system of linear equations:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用行简化方法的过程。如前所述，解线性方程组的另一种方法是矩阵解法。这涉及将给定系统表示为矩阵方程。具体来说，从任何线性方程组的一般形式开始：
- en: '![Figure 4.39: System of linear equation'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.39：线性方程组'
- en: '](image/B15968_04_39.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_39.jpg)'
- en: 'Figure 4.39: System of linear equation'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39：线性方程组
- en: 'We can rewrite it in matrix notation as *Ax = c*, where *A* is the *n*-by-*n*
    matrix containing the constant coefficients, *x* is the vector containing the
    variables that we have to solve for: *x*1, *x*2, …, *x*n, and *c* is similarly
    the vector containing the constant coefficients *c*1, *c*2, …, *c*n. Due to the
    definition of a product of a matrix and a vector, the equation *Ax = c* is indeed
    equivalent to the original system of equations.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其重写为矩阵表示形式*Ax = c*，其中*A*是包含常数系数的*n*乘*n*矩阵，*x*是包含我们要求解的变量的向量：*x*1，*x*2，…，*x*n，*c*同样是包含常数系数*c*1，*c*2，…，*c*n的向量。由于矩阵和向量的乘积的定义，方程*Ax
    = c*确实等价于原始方程组。
- en: In this matrix notation, the vector *x* can be solved quite easily as *x = A*-1
    *c*, where *A*-1 is the *inverse matrix* of *A*. An inverse matrix, *M*-1, of
    any given matrix, *M*, is the matrix that satisfies the equation *A A*-1 *= I*,
    where *I* is the identity matrix.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个矩阵表示中，向量*x*可以很容易地求解为*x = A*-1 *c*，其中*A*-1是*A*的*逆矩阵*。任何给定矩阵*M*的逆矩阵*M*-1是满足方程*A
    A*-1 *= I*的矩阵，其中*I*是单位矩阵。
- en: This product between a matrix and a vector is called a **dot product**, which
    outputs another vector whose elements equal the sums of products of corresponding
    elements in the original matrix and vector. In our case, the dot product between
    *A*-1 and *c* will give us a vector that makes up the solution of the system.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和向量之间的这种乘积称为**点积**，它输出另一个向量，其元素等于原始矩阵和向量中对应元素的乘积之和。在我们的情况下，*A*-1和*c*之间的点积将给出构成系统解的向量。
- en: There are matrices that do not have their corresponding inverse matrices; these
    matrices are called singular matrices. One of the signs we can use to tell that
    a matrix is singular is if one row of the matrix is exactly another row multiplied
    by a constant.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有些矩阵没有对应的逆矩阵；这些矩阵称为奇异矩阵。我们可以用来判断矩阵是否奇异的标志之一是，如果矩阵的一行恰好是另一行乘以一个常数得到的。
- en: Theoretically speaking, this is analogous to the situation where the coefficients
    in one equation of a system are exact multiplications of the coefficients in another
    equation by a constant. If this is the case, we either have duplicate information
    (when the two equations have the same information, then the system has infinitely
    many solutions) or conflicting information (when the constants on the right-hand
    side of the two equations do not match up, then the system has no solution).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这类似于一个系统中的一个方程的系数是另一个方程的系数的精确乘法。如果是这种情况，我们要么有重复信息（当两个方程具有相同信息时，系统有无穷多个解），要么有冲突信息（当两个方程右侧的常数不匹配时，系统没有解）。
- en: The theory behind this is not within the scope of this book. For now, we just
    need to know that if the corresponding coefficient matrix of a system of linear
    equations does not have an inverse matrix, the system does not have a definite
    solution.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的理论不在本书的范围之内。目前，我们只需要知道，如果线性方程组的对应系数矩阵没有逆矩阵，那么该系统就没有明确的解。
- en: So, not every matrix has its own inverse matrix, and even if a given matrix
    does, the process of computing the inverse matrix can be quite involved. Luckily,
    this can be done relatively easily in Python with NumPy, which we will see in
    the upcoming exercise. Specifically, the `linalg` (which stands for linear algebra)
    package in NumPy offers efficient implementation of many linear algebra-related
    algorithms. Here, we are interested in the `inv()` function, which takes in a
    two-dimensional NumPy array representing a matrix and returns the corresponding
    inverse matrix. We will see the effect of this function first-hand in the next
    exercise; more information about the package can also be found at [https://docs.scipy.org/doc/numpy/reference/routines.linalg.html](https://docs.scipy.org/doc/numpy/reference/routines.linalg.html).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，并非每个矩阵都有其自己的逆矩阵，即使给定的矩阵有，计算逆矩阵的过程也可能非常复杂。幸运的是，在Python中可以相对容易地使用NumPy来完成这个过程，我们将在即将进行的练习中看到。具体来说，NumPy中的`linalg`（代表线性代数）包提供了许多与线性代数相关的算法的高效实现。在这里，我们对`inv()`函数感兴趣，它接受表示矩阵的二维NumPy数组，并返回相应的逆矩阵。我们将在下一个练习中首次亲身体验这个函数的效果；有关该包的更多信息也可以在[https://docs.scipy.org/doc/numpy/reference/routines.linalg.html](https://docs.scipy.org/doc/numpy/reference/routines.linalg.html)找到。
- en: 'Exercise 4.04: Matrix Solution with NumPy'
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：使用NumPy进行矩阵解法
- en: 'In this exercise, we will write a program that takes in a system of linear
    equations and produces its solution using the matrix solution method. Again, this
    will be done by the computation of the inverse of the coefficient matrix using
    NumPy:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个程序，该程序接受一个线性方程组，并使用矩阵解法方法产生其解。同样，这将通过使用NumPy计算系数矩阵的逆矩阵来完成：
- en: 'Create a Jupyter notebook. In its first cell, import NumPy and the `inv()`
    function from its `linalg` package:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Jupyter笔记本。在其第一个单元格中，导入NumPy及其`linalg`包中的`inv()`函数：
- en: '[PRE21]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the next code cell, declare a function named `solve_eq_sys()` (for testing
    purposes) that takes in two arguments: `coeff_matrix`, which stores the matrix
    of constant coefficients in a system of linear equations, and `c`, which stores
    a vector of the constant values on the right-hand side of the equations:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，声明一个名为`solve_eq_sys()`的函数（用于测试目的），它接受两个参数：`coeff_matrix`，它存储线性方程组中常数系数的矩阵，以及`c`，它存储方程右侧的常数值向量：
- en: '[PRE22]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These two arguments completely define an instance of a system of linear equations,
    and the job of the `solve_eq_sys()` function is to compute its solution. We further
    assume that the arguments are both stored as NumPy arrays.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数完全定义了线性方程组的一个实例，`solve_eq_sys()`函数的工作是计算其解。我们进一步假设这些参数都存储为NumPy数组。
- en: Recalling that the solution for the system is *x = A*-1 *c*, we simply return
    the product of the inverse matrix of `coeff_matrix` and `c`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下，系统的解为*x = A*-1 *c*，我们只需返回`coeff_matrix`的逆矩阵和`c`的乘积。
- en: 'The inverse matrix can be computed using the `inv()` function from NumPy:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用NumPy的`inv()`函数计算逆矩阵：
- en: '[PRE23]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, the solution can be computed using the `dot()` method, which calculates
    the dot product of a matrix and a vector:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用`dot()`方法计算解决方案，该方法计算矩阵和向量的点积：
- en: '[PRE24]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our function should look like the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数应该如下所示：
- en: '[PRE25]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the next code cell, declare the corresponding coefficient matrix and `c`
    vector for the system of equations that we considered earlier and call the `solve_eq_sys()`
    function on them:![Figure 4.40: System of linear equations'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，为我们之前考虑的方程组声明相应的系数矩阵和`c`向量，并对它们调用`solve_eq_sys()`函数：![图4.40：线性方程组
- en: '](image/B15968_04_40.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_40.jpg)'
- en: 'Figure 4.40: System of linear equations'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40：线性方程组
- en: 'The code for this should be:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该是：
- en: '[PRE26]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code should produce the following output:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该产生以下输出：
- en: '[PRE27]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We see that this output exactly corresponds to the actual solution to the system
    of equations that we have derived using the row reduction method: *x = 1*, *y
    = 2*, and *z = 3*.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，这个输出恰好对应于使用行简化方法得出的方程组的实际解：*x = 1*，*y = 2*，*z = 3*。
- en: 'Now, we would like to take into account the case where our coefficient matrix
    is singular. We do this by testing our code on the following sample system of
    linear equations that has no solution:![Figure 4.41: Sample system of linear equations'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想考虑系数矩阵是奇异的情况。我们通过在以下没有解的示例线性方程组上测试我们的代码来做到这一点：![图4.41：线性方程组示例
- en: '](image/B15968_04_41.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_41.jpg)'
- en: 'Figure 4.41: Sample system of linear equations'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41：线性方程组示例
- en: We see that if we multiply the first equation by `2`, the equation we obtain
    contradicts the third equation. In other words, there is no combination of values
    for variables *x*, *y*, and *z* that can satisfy the system.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，如果我们将第一个方程乘以`2`，得到的方程与第三个方程矛盾。换句话说，没有一组变量*x*、*y*和*z*的值可以满足该系统。
- en: 'In the next code cell, call the `inv()` function on this coefficient matrix:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，对此系数矩阵调用`inv()`函数：
- en: '[PRE28]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will see that this code produces a `LinAlgError: Singular matrix` error,
    which we will fix in the next step.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将看到这段代码产生了一个`LinAlgError: Singular matrix`错误，我们将在下一步中修复这个错误。'
- en: For testing purposes, uncomment out this cell.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，取消注释此单元格。
- en: 'Come back to our code and modify our current `solve_eq_sys()` function with
    a `try...except` block to handle this error, which will need to be imported from
    NumPy first:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的代码，并用一个`try...except`块修改我们当前的`solve_eq_sys()`函数来处理这个错误，这将需要从NumPy中导入：
- en: '[PRE29]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, the function should return `False` if the input matrix is singular. It
    should look like the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果输入矩阵是奇异的，函数应该返回`False`。它应该如下所示：
- en: '[PRE30]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the next code cell, call this function on the sample system of equations
    we used in *step 5*:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，对我们在*步骤5*中使用的示例方程组调用此函数：
- en: '[PRE31]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This time, the function returns the value `False`, which is the behavior we
    desire.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，函数返回值`False`，这是我们期望的行为。
- en: Through this exercise, we have learned how to implement the matrix solution
    method to solve a system of linear equations using NumPy. This also concludes
    the topic of linear equation systems.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们学会了如何使用NumPy实现矩阵解法来解决线性方程组。这也结束了线性方程组的主题。
- en: Note
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NPpQpK](https://packt.live/2NPpQpK).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2NPpQpK](https://packt.live/2NPpQpK)。
- en: You can also run this example online at [https://packt.live/2VBNg6w](https://packt.live/2VBNg6w).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2VBNg6w](https://packt.live/2VBNg6w)上在线运行此示例。
- en: In the next and final section of this chapter, we will consider systems of equations
    that are not completely linear.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一节和最后一节中，我们将考虑不完全线性的方程组。
- en: Systems of Non-Linear Equations
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非线性方程组
- en: 'When a system contains an equation that contains some non-linear terms of its
    variables, the methods that we discussed in the previous section do not apply.
    For example, consider the following system:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个系统包含一个方程，其中包含一些变量的非线性项时，我们在上一节讨论的方法不适用。例如，考虑以下系统：
- en: '![Figure 4.42: An example system of non-linear equations'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.42：非线性方程组示例'
- en: '](image/B15968_04_42.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_42.jpg)'
- en: 'Figure 4.42: An example system of non-linear equations'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42：非线性方程组示例
- en: The problem arises with the non-linear term, *x*2, which complicates whatever
    transformations we want to apply to the system.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在非线性项*x*2上，这使我们想要对系统应用的任何转换变得复杂。
- en: 'However, we can still have a systematic approach to solving these types of
    systems. Specifically, notice that from either equation, we can solve for a variable
    in terms of the other variable. To do this, we algebraically transform each equation
    so that one variable can be represented purely in terms of the other. In particular,
    *y* can be represented as a function of *x* as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以有一个系统化的方法来解决这些类型的系统。具体来说，注意到从任一方程中，我们都可以解出一个变量的另一个变量。为了做到这一点，我们对每个方程进行代数变换，使得一个变量可以纯粹地表示为另一个变量。特别地，*y*可以表示为*x*的函数，如下所示：
- en: '![Figure 4.43: Substituting the equations to find the values of y'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.43：替换方程以找到y的值'
- en: '](image/B15968_04_43.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_43.jpg)'
- en: 'Figure 4.43: Substituting the equations to find the values of y'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43：替换方程以找到y的值
- en: 'So, in order for the system to have a valid solution, the two values of *y*
    need to match up. In other words, we have the following equation that just contains
    *x*:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使系统有一个有效的解，*y*的两个值需要匹配。换句话说，我们有以下只包含*x*的方程：
- en: '![Figure 4.44: Substituting the value of y on both sides'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.44：在两边替换y的值'
- en: '](image/B15968_04_44.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_44.jpg)'
- en: 'Figure 4.44: Substituting the value of y on both sides'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44：在两边替换y的值
- en: 'This is simply a polynomial equation for *x*, which, as we know, can be solved
    via factoring. Specifically, the equation can be factored to *(x - 2) (x - 1)
    = 0*, which obviously accepts *x = 1* and *x = 2* as solutions. Each of these
    values for *x* corresponds to a value for *y*, which can be found by plugging
    in 1 and 2 into the original system of equations. In the end, the system has two
    solutions: *(x = 1, y = 4)* and *(x = 2, y = 3)*.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于*x*的多项式方程，正如我们所知，可以通过因式分解来解决。具体来说，该方程可以因式分解为*(x - 2) (x - 1) = 0*，显然接受*x
    = 1*和*x = 2*作为解。这些*x*的每个值对应于*y*的一个值，可以通过将1和2代入原始方程组来找到。最终，该系统有两个解：*(x = 1, y =
    4)*和*(x = 2, y = 3)*。
- en: Overall, this method is called **substitution**, denoting the fact that we are
    able to solve for a variable in terms of another variable by transforming an equation.
    This solution is then substituted into another equation so that we obtain an equation
    of a single variable.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种方法称为**替换**，表示我们能够通过转换方程来解出一个变量的另一个变量。然后将这个解代入另一个方程中，这样我们就得到了一个单变量的方程。
- en: 'Let''s see another example of the application of this method with the following
    system of equations:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，应用这种方法来解决以下方程组：
- en: '![Figure 4.45: Example system of equations'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.45：方程组示例'
- en: '](image/B15968_04_45.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_45.jpg)'
- en: 'Figure 4.45: Example system of equations'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45：方程组示例
- en: While there are multiple ways of solving this, one clear way is to solve for
    *y* in the second equation, which leads to *y = (x*2 *- 1) / 2*, which can then
    be plugged into the first equation like *x*2 *- 2x - (x*2 *- 1)*2 */ 4 = -1*.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多种解决方法，但一种明显的方法是解出第二个方程中的*y*，得到*y = (x*2 *- 1) / 2*，然后将其代入第一个方程中，如*x*2 *-
    2x - (x*2 *- 1)*2 */ 4 = -1*。
- en: With some algebra, we can simplify the equation as *x*4 *-6x*2 *+ 8x -3 = 0*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些代数运算，我们可以将方程简化为*x*4 *-6x*2 *+ 8x -3 = 0*。
- en: We now have an equation that only contains one variable, so we can apply the
    techniques that we have learned in the last section to solve for *x*. Once we
    have the solution for *x*, we can also solve for *y* using the preceding *y =
    (x*2 *- 1) / 2* substitution.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个只包含一个变量的方程，所以我们可以应用我们在上一节学到的技巧来解出*x*。一旦我们得到*x*的解，我们也可以使用之前的*y = (x*2
    *- 1) / 2*代换来解出*y*。
- en: Here, factoring can be applied to find the values of *x* that satisfy this equation.
    Let's try plugging in a few values of *x* such as *-1*, *0*, *1*, or *2* to see
    which would evaluate the function to 0\. Noticing that *x = 1* is a valid solution,
    we first factor the equation with respect to *(x - 1)*, which leads to *(x - 1)
    (x*3 *+ x*2 *- 5x + 3) = 0*.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可以应用因式分解来找到满足这个方程的*x*的值。让我们尝试代入一些*x*的值，比如*-1*、*0*、*1*或*2*，看哪个能使函数的值为0。注意到*x
    = 1*是一个有效的解，我们首先将方程关于*(x - 1)*进行因式分解，得到*(x - 1) (x*3 *+ x*2 *- 5x + 3) = 0*。
- en: Once again, we notice that *x = 1* still satisfies the equation *x*3 *+ x*2
    *– 5x + 3 = 0*, thus taking another factoring step to *(x - 1)*2 *(x*2 *+ 2x -
    3) = 0*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次注意到*x = 1*仍然满足方程*x*3 *+ x*2 *– 5x + 3 = 0*，因此我们再次进行因式分解得到*(x - 1)*2 *(x*2
    *+ 2x - 3) = 0*。
- en: The quadratic function *x*2 *+ 2x - 3* can then be factored into *(x - 1) (x
    + 3)*. In the end, we have the following equation *(x - 1)*3 *(x + 3) = 0*.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 二次函数*x*2 *+ 2x - 3*可以因式分解为*(x - 1) (x + 3)*。最终，我们得到以下方程*(x - 1)*3 *(x + 3) =
    0*。
- en: 'Two values of *x* satisfy the equation: *x = 1* and *x = -3*. By plugging them
    into the original system, we can then solve for *y* and obtain two solutions for
    the system: *(x = 1, y = 0)* and *(x = -3, y = 4)*.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个*x*的值满足方程：*x = 1*和*x = -3*。通过将它们代入原方程组，我们可以解出*y*，得到方程组的两个解：*(x = 1, y = 0)*和*(x
    = -3, y = 4)*。
- en: Unfortunately, not all systems of non-linear equations allow us to employ the
    substitution method in such a straightforward manner. In many cases, subtle and
    ingenious techniques have to be used to solve complex systems of equations.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有的非线性方程组都允许我们以如此简单的方式使用代换法。在许多情况下，需要使用微妙而巧妙的技巧来解决复杂的方程组。
- en: What if, then, we would like to automate the process of finding the solutions
    for such systems? This is where the symbolic computation ability offered by the
    `sympy` library comes in handy once again. We have seen that with SymPy, we can
    solve for any one-variable equation. The same idea can also apply to systems of
    non-linear equations, only in this case, we pass a list of symbolic functions
    to the `solve()` function.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想要自动化地找到这些方程组的解，该怎么办呢？这就是`sympy`库提供的符号计算能力再次派上用场的地方。我们已经看到，使用SymPy，我们可以解决任何一个一元方程。同样的想法也可以应用于非线性方程组，只是在这种情况下，我们将一系列符号函数传递给`solve()`函数。
- en: 'Say we want to use SymPy to solve the two systems of equations we have in this
    section; firstly:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们想要使用SymPy来解决我们有的两个方程组；首先：
- en: '![Figure 4.46: The first system of equation'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.46：第一个方程组'
- en: '](image/B15968_04_46.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_46.jpg)'
- en: 'Figure 4.46: The first system of equation'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46：第一个方程组
- en: 'And secondly:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 其次：
- en: '![Figure 4.47: The second system of equation'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.47：第二个方程组'
- en: '](image/B15968_04_47.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_47.jpg)'
- en: 'Figure 4.47: The second system of equation'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47：第二个方程组
- en: 'To do this, we first declare our variables as instances of the `Symbol` class
    from SymPy:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先将我们的变量声明为SymPy中`Symbol`类的实例：
- en: '[PRE32]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can then call the `solve()` function from SymPy to find solutions for the
    systems of equations we have. For the first:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用SymPy中的`solve()`函数来找到我们有的方程组的解。对于第一个方程组：
- en: '[PRE33]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This code will return `[(1, 4), (2, 3)]`, which is the list of valid solutions
    for *x* and *y*, as we derived earlier. As for the second system:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回`[(1, 4), (2, 3)]`，这是我们之前得到的*x*和*y*的有效解的列表。至于第二个方程组：
- en: '[PRE34]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code returns `[(-3, 4), (1, 0)]`, which also corresponds to the solution
    we have derived. As we can see, SymPy offers a straightforward syntax for us to
    solve both equations and systems of equations effortlessly.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回`[(-3, 4), (1, 0)]`，这也对应着我们得到的解。正如我们所看到的，SymPy为我们提供了一个简单的语法，让我们轻松地解决方程和方程组。
- en: This example also marks the end of the material for this section. To end this
    chapter, we will consider an extension of the break-even analysis exercise that
    we worked on earlier.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也标志着这一节材料的结束。为了结束这一章，我们将考虑对我们之前进行的盈亏分析练习的扩展。
- en: 'Activity 4.01: Multi-Variable Break-Even Analysis'
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：多变量盈亏分析
- en: As we have mentioned at the end of the first break-even analysis exercise, a
    break-even analysis can become quite complex as the number of variables in our
    model grows. When there is more than one variable in a model, a system of equations
    needs to be used to find break-even points, which is what we will do in this activity.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一个盈亏分析练习的结尾提到的，随着我们模型中变量的数量增加，盈亏分析可能变得非常复杂。当模型中有多个变量时，需要使用方程组来找到盈亏平衡点，这就是我们将在这个活动中做的事情。
- en: Recall that in our example business model of a burger restaurant, we have a
    cost of $6.56 for each burger we produce as well as a fixed cost of $1,312.13
    each month for utilities, rent, and other expenses. In this activity, we will
    explore how the total profit of the business changes as a function of both the
    number of burgers we sell and the price of each burger.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在我们的例子中，汉堡餐厅的商业模型中，我们每生产一个汉堡的成本是6.56美元，每个月的固定成本是1312.13美元，用于水电费、房租和其他费用。在这个活动中，我们将探讨企业的总利润如何随着我们销售的汉堡数量和每个汉堡的价格而变化。
- en: One additional piece of information we need for this model is the demand for
    burgers from the people living in the area of the restaurant. Let's say, on average,
    the restaurant observes that their revenue is around $4,000 every month, so the
    demand for burgers is roughly 4,000 divided by the price of a burger.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个模型的一个额外信息是餐厅所在地区的人们对汉堡的需求。假设，平均而言，餐厅观察到他们的收入每个月大约是4000美元，所以对汉堡的需求大约是4000除以一个汉堡的价格。
- en: 'To complete this activity, perform the following steps:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，请执行以下步骤：
- en: Consider the number of burgers that the restaurant produces every month and
    the price of each burger as two variables for our model. Represent the monthly
    revenue, cost, and total profit of the restaurant in terms of these two variables.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将餐厅每月生产的汉堡数量和每个汉堡的价格视为我们模型的两个变量。用这两个变量表示餐厅的月收入、成本和总利润。
- en: 'Construct a system of equations that corresponds to the break-even point: when
    the number of burgers the restaurant makes satisfies demand and revenue equals
    costs.'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个与盈亏平衡点相对应的方程组：当餐厅生产的汉堡数量满足需求且收入等于成本时。
- en: Solve this system of equations by hand and verify the result using SymPy in
    a Jupyter notebook.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手工解决这个方程组，并在Jupyter笔记本中使用SymPy验证结果。
- en: In the same Jupyter notebook, write a Python function that takes in any given
    combination of the number of burgers produced and the price of each burger. The
    function is to return the total profit of the restaurant.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个Jupyter笔记本中，编写一个Python函数，该函数接受生产的汉堡数量和每个汉堡的价格的任何组合。该函数应返回餐厅的总利润。
- en: In the next code cell, create a list of potential values for the number of burgers
    to be produced, ranging from 300 to 500 every month. Generate the list of corresponding
    profits using a fixed price of $9.76 per burger and store it in a variable named
    `profits_976` (for testing purposes). Plot this list of profits as a function
    of the number of burgers produced.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，创建一个潜在值列表，表示每月生产的汉堡数量，范围从300到500。使用每个汉堡9.76美元的固定价格生成相应利润列表，并将其存储在名为`profits_976`的变量中（用于测试）。将这个利润列表作为生产的汉堡数量的函数绘制出来。
- en: In the next code cell, generate the same list of profits, this time with a fixed
    price of $9.99 per burger, and store it in a variable named `profits_999`. Create
    the same plot and interpret it in the context of break-even points.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，生成相同的利润列表，这次使用每个汉堡9.99美元的固定价格，并将其存储在名为`profits_999`的变量中。创建相同的图表，并解释它与盈亏平衡点的关系。
- en: In the next cell, create a list of potential values for the number of burgers
    to be produced; it should be every even number between 300 and 500 (for example,
    300, 302, 304, …, 500). Additionally, create a NumPy array of 100 evenly spaced
    numbers between 5 and 10 as potential prices for each burger.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，创建一个潜在值列表，表示要生产的汉堡数量；它应该是300到500之间的每个偶数（例如，300、302、304，…，500）。另外，创建一个NumPy数组，其中包含5到10之间的100个均匀间隔的潜在汉堡价格。
- en: Finally, generate a two-dimensional list where the item in the row indexed at
    *i* and the column indexed at *j* is the profit the restaurant will make, with
    the *i*th number in the first list as the number of burgers it will produce and
    the *j*th number in the second list (the NumPy array) as the price of each burger.
    Store this list in the variable named `profits` for testing purposes.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，生成一个二维列表，其中第一个列表中第*i*个数字表示将要生产的汉堡数量，第二个列表中第*j*个数字（NumPy数组）表示每个汉堡的价格。将此列表存储在名为`profits`的变量中以进行测试。
- en: Create a heatmap using Matplotlib to visualize the two-dimensional list of profits
    generated in the previous step as a function of the number of burgers produced
    (as the *y* axis) and the price of each burger (as the *x* axis).
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Matplotlib创建一个热力图，以可视化前一步生成的利润的二维列表，作为生产的汉堡数量（作为*y*轴）和每个汉堡的价格（作为*x*轴）的函数。
- en: Note
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 665.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第665页找到。
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter formally introduced the definition of functions and variables in
    the context of mathematics. Various topics relevant to functions, such as the
    domain, the range, and the plot of a function, were also discussed. In the second
    part of the chapter, we talked about the concept of equations and systems of equations,
    as well as special methods to find their solutions. During these discussions,
    the SymPy library and the function to compute the inverse of a matrix from NumPy
    were also examined. We concluded the chapter by completing a task that used algebra
    and functions to construct a multi-variable break-even analysis for a business.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 本章正式介绍了数学上函数和变量的定义。还讨论了与函数相关的各种主题，如定义域、值域和函数的图。在本章的第二部分，我们讨论了方程和方程组的概念，以及寻找它们解的特殊方法。在这些讨论中，还检查了SymPy库和NumPy中计算矩阵的逆的函数。我们通过完成一个使用代数和函数构建多变量盈亏分析的任务来结束本章。
- en: 'In the next chapter, we will continue with another important topic in mathematics:
    sequences and series.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论数学中的另一个重要主题：序列和级数。
- en: FKV27
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: FKV27
- en: GCH43
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: GCH43
