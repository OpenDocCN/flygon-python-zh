- en: Web Browsing with QtWebEngine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QtWebEngine进行Web浏览
- en: In [Chapter 8](033b3f28-c471-4561-9498-8737d8a82e81.xhtml), *Networking with
    QtNetwork*, you learned how to interact with systems over a network using sockets
    and HTTP. The modern web is much more than just networking protocols, however;
    it's a programming platform built on the combination of HTML, JavaScript, and
    CSS, and working with it effectively requires a complete web browser. Fortunately
    for us, Qt provides us with the `QtWebEngineWidgets` library, which gives our
    application a full web browser in a widget.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](033b3f28-c471-4561-9498-8737d8a82e81.xhtml)中，*使用QtNetwork进行网络操作*，您学习了如何使用套接字和HTTP与网络系统进行交互。然而，现代网络远不止于网络协议；它是建立在HTML、JavaScript和CSS组合之上的编程平台，有效地使用它需要一个完整的Web浏览器。幸运的是，Qt为我们提供了`QtWebEngineWidgets`库，为我们的应用程序提供了一个完整的Web浏览器小部件。
- en: 'In this chapter, we''re going to learn how to access the web with Qt in the
    following section:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在以下部分中使用Qt访问Web：
- en: Building a basic browser with `QWebEngineView`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QWebEngineView`构建基本浏览器
- en: Advanced `QtWebEngine` usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级`QtWebEngine`用法
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to the basic PyQt5 setup that we''ve used in this book, you will
    need to make sure you have the `PyQtWebEngine` package installed from PyPI. You
    can do this using the following command:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本书中使用的基本PyQt5设置之外，您还需要确保已从PyPI安装了`PyQtWebEngine`软件包。您可以使用以下命令执行此操作：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may also want the example code for this chapter, and this is available from
    [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter16](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter16).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想要本章的示例代码，可以从[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter16](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter16)获取。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xFtD](http://bit.ly/2M5xFtD)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：[http://bit.ly/2M5xFtD](http://bit.ly/2M5xFtD)
- en: Building a basic browser with QWebEngineView
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QWebEngineView`构建基本浏览器
- en: The primary class used from `QtWebEngineWidgets` is the `QWebEngineView` class;
    this class provides a nearly complete Chromium-based browser in a `QWidget` object.
    Chromium is the open source project that underpins much of Google Chrome, the
    newest versions of Microsoft Edge, and many other browsers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从`QtWebEngineWidgets`中使用的主要类是`QWebEngineView`类；这个类在`QWidget`对象中提供了一个几乎完整的基于Chromium的浏览器。Chromium是支持许多Google
    Chrome、最新版本的Microsoft Edge和许多其他浏览器的开源项目。
- en: Qt also has a deprecated `QtWebKit` module based on the **Webkit** rendering
    engine used in Safari, Opera, and some older browsers. There are some significant
    differences between the API and the rendering behavior of `QtWebKit` and `QtWebEngineWidgets`,
    with the latter being preferred for newer projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还有一个基于**Webkit**渲染引擎的已弃用的`QtWebKit`模块，用于Safari、Opera和一些旧版浏览器。`QtWebKit`和`QtWebEngineWidgets`之间的API和渲染行为存在一些显着差异，后者更适合新项目。
- en: In this section, we'll see how easy it is to include web content in your Qt
    application by building a simple web browser using `QtWebEngineWidgets`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到使用`QtWebEngineWidgets`构建一个简单的Web浏览器，将Web内容包含在Qt应用程序中是多么容易。
- en: Using the QWebEngineView widget
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QWebEngineView小部件
- en: We need to make a copy of our Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `simple_browser.py`; we're
    going to develop a rudimentary browser with tabs and a history display.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中复制我们的Qt应用程序模板，*使用QMainWindow构建应用程序*，并将其命名为`simple_browser.py`；我们将开发一个带有选项卡和历史记录显示的基本浏览器。
- en: 'We start by importing the `QtWebEngineWidgets` library as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`QtWebEngineWidgets`库，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that there is also a `QtWebEngine` module, but it is for use with the **Qt
    Modeling Language** (**QML**) declarative framework, not the Qt Widgets framework
    covered by this book. `QtWebEngineWidgets` contains the widgets-based browser.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有一个`QtWebEngine`模块，但它是用于与**Qt建模语言**（**QML**）声明性框架一起使用的，而不是本书涵盖的Qt小部件框架。`QtWebEngineWidgets`包含基于小部件的浏览器。
- en: 'In our `MainWindow` class constructor, we''ll start the GUI by defining a navigation
    toolbar:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MainWindow`类构造函数中，我们将通过定义导航工具栏来启动GUI：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we've defined toolbar buttons for standard browser actions, as well as
    a `QLineEdit` object for the URL bar. We've also extracted icons for these actions
    from the default style, just as we did in the *Adding toolbars* section of [Chapter
    4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building Applications with QMainWindow*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为标准浏览器操作定义了工具栏按钮，以及用于URL栏的`QLineEdit`对象。我们还从默认样式中提取了这些操作的图标，就像我们在[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)的*添加工具栏*部分中所做的那样，*使用QMainWindow构建应用程序*。
- en: 'Now we''ll create a `QWebEngineView`  object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个`QWebEngineView`对象：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `QWebEngineView` object is a (mostly, as you'll see) fully functional and
    interactive web widget, capable of retrieving and rendering HTML, CSS, JavaScript,
    images, and other standard web content.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWebEngineView`对象是一个（大多数情况下，正如您将看到的那样）功能齐全且交互式的Web小部件，能够检索和呈现HTML、CSS、JavaScript、图像和其他标准Web内容。'
- en: 'To load a URL in the view, we pass `QUrl` to its `load()` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图中加载URL，我们将`QUrl`传递给其`load()`方法：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will prompt the web view to download and render the page just like a normal
    web browser would.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示Web视图下载并呈现页面，就像普通的Web浏览器一样。
- en: 'Of course, as good as that website is, we''d like to be able to navigate to
    others, so we''ll add the following connection:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，尽管该网站很好，我们希望能够浏览其他网站，因此我们将添加以下连接：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we've connected our `go` action to a `lambda` function that retrieves
    the text of the URL bar, wraps it in a `QUrl` object, and sends it to the web
    view. If you run the script at this point, you should be able to type a URL into
    the bar, hit Go**,** and browse the web just like any other browser.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`go`操作连接到一个`lambda`函数，该函数检索URL栏的文本，将其包装在`QUrl`对象中，并将其发送到Web视图。如果此时运行脚本，您应该能够在栏中输入URL，点击Go，然后像任何其他浏览器一样浏览Web。
- en: '`QWebView` has slots for all the common browser navigation actions, which we
    can connect to our navigation bar:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWebView`具有所有常见浏览器导航操作的插槽，我们可以将其连接到我们的导航栏：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these signals connected, our script is well on its way to being a fully
    functional web-browsing experience. However, we're currently limited to a single
    browser window; we want tabs, so let's implement that in the following section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接这些信号，我们的脚本已经在成为一个完全功能的网络浏览体验的路上。但是，我们目前仅限于单个浏览器窗口；我们想要选项卡，因此让我们在以下部分实现它。
- en: Allowing multiple windows and tabs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许多个窗口和选项卡
- en: 'In `MainWindow.__init__()`, delete or comment-out the web view code you just
    added (going back to the creation of the `QWebEngineView` object). We''re going
    to move that functionality to a method instead, so that we can create multiple
    web views in a tabbed interface. We will do this as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，删除或注释掉刚刚添加的Web视图代码（返回到创建`QWebEngineView`对象）。我们将将该功能移动到一个方法中，以便我们可以在选项卡界面中创建多个Web视图。我们将按照以下方式进行：
- en: 'To begin, we''ll replace our `QWebEngineView` object with a `QTabWidget` object
    as our central widget:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将用`QTabWidget`对象替换我们的`QWebEngineView`对象作为我们的中央小部件：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tab widget will have movable and closable tabs, and a New button in the
    left corner for adding new tabs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项卡小部件将具有可移动和可关闭的选项卡，并在左上角有一个新按钮用于添加新选项卡。
- en: 'To add a new tab with a web view, we''ll create an `add_tab()` method:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加一个带有Web视图的新选项卡，我们将创建一个`add_tab()`方法：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method begins by creating a web view widget and adding it to a new tab
    in the tab widget.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先创建一个Web视图小部件，并将其添加到选项卡小部件的新选项卡中。
- en: 'Now that we have our web view object, we need to connect some signals:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的Web视图对象，我们需要连接一些信号：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `QWebEngineView` object's `urlChanged` signal is emitted whenever a new
    URL is loaded into the view, and it sends with it the new URL as a `QUrl` object.
    We're connecting this signal to a `lambda` function that sets the tab title text
    to the URL, as well as another function that sets the contents of the URL bar.
    This will keep the URL bar in sync with the browser when the user navigates using
    hyperlinks in the web page, rather than directly using the URL bar.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWebEngineView`对象的`urlChanged`信号在将新URL加载到视图中时发出，并将新URL作为`QUrl`对象发送。我们将此信号连接到一个`lambda`函数，该函数将选项卡标题文本设置为URL，以及另一个函数，该函数设置URL栏的内容。这将使URL栏与用户在网页中使用超链接导航时与浏览器保持同步，而不是直接使用URL栏。'
- en: 'We can then add default content to our web view using its `setHtml()` method:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用其`setHtml()`方法向我们的Web视图对象添加默认内容：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This sets the content of the browser window to whatever HTML string we give
    to it. If we also pass a `QUrl` object, it will be used as the current URL (and
    published to the `urlChanged` signal, for example).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使浏览器窗口的内容成为我们提供给它的任何HTML字符串。如果我们还传递一个`QUrl`对象，它将被用作当前URL（例如发布到`urlChanged`信号）。
- en: 'To enable navigation, we need to connect our toolbar actions to the browser
    widget. Since our browser has one global toolbar, we can''t just directly connect
    these to the web view widgets. We''ll need to connect them to methods that pass
    the signals on to the slots in the currently active web view. Start by creating
    the callback methods as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用导航，我们需要将我们的工具栏操作连接到浏览器小部件。由于我们的浏览器有一个全局工具栏，我们不能直接将这些连接到Web视图小部件。我们需要将它们连接到将信号传递到当前活动Web视图的插槽的方法。首先创建回调方法如下：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These methods are essentially the same as those used with the single-pane browser,
    but with one crucial change—they use the tab widget's `currentWidget()` method
    to retrieve the `QWebEngineView` object for a currently visible tab, then call
    the navigation methods on that web view.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法本质上与单窗格浏览器使用的方法相同，但有一个关键变化——它们使用选项卡窗口小部件的`currentWidget()`方法来检索当前可见选项卡的`QWebEngineView`对象，然后在该Web视图上调用导航方法。
- en: 'Back in `__init__()`, connect the following methods:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__()`中连接以下方法：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For convenience and keyboard-friendliness, we've also connected the URL bar's
    `returnPressed` signal to the `on_go()` method. We've also connected our New button
    to the `add_tab()` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便和键盘友好性，我们还将URL栏的`returnPressed`信号连接到`on_go()`方法。我们还将我们的新按钮连接到`add_tab()`方法。
- en: Give the browser a try now, and you should be able to add multiple tabs and
    browse independently in each one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试浏览器，您应该能够添加多个选项卡并在每个选项卡中独立浏览。
- en: Adding a tab for pop-up windows
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为弹出窗口添加选项卡
- en: Currently, there is a problem with our script in that if you *Ctrl* +click on
    a hyperlink, or open a link that is configured to open a new window, nothing happens.
    By default,  `QWebEngineView` is incapable of opening new tabs or windows. In
    order to enable this, we have to override its `createWindow()` method with a function
    that creates and returns a new `QWebEngineView` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的脚本存在问题，即如果您*Ctrl* +单击超链接，或打开配置为打开新窗口的链接，将不会发生任何事情。默认情况下，`QWebEngineView`无法打开新标签页或窗口。为了启用此功能，我们必须使用一个函数覆盖其`createWindow()`方法，该函数创建并返回一个新的`QWebEngineView`对象。
- en: 'We can do this fairly easily by updating our `add_tab()` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更新我们的`add_tab()`方法来轻松实现这一点：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rather than subclassing `QWebEngineView` to override the method, we'll just
    assign our `MainWindow.add_tab()` method to its `createWindow()` method. Then
    we just need to make sure that we return the created web view object at the end
    of the method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对`QWebEngineView`进行子类化以覆盖该方法，而是将我们的`MainWindow.add_tab()`方法分配给其`createWindow()`方法。然后，我们只需要确保在方法结束时返回创建的Web视图对象。
- en: Note that it's not our responsibility to load the URL in the `createWindow()`
    method; we only need to create the view and add it appropriately to the GUI. Qt
    will take care of doing what needs to be done browsing-wise in the web view object
    that we return.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要在`createWindow()`方法中加载URL；我们只需要适当地创建视图并将其添加到GUI中。Qt将负责在我们返回的Web视图对象中执行浏览所需的操作。
- en: Now when you try the browser, you should find that a *Ctrl *+ click opens a
    new tab with the requested link.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您尝试浏览器时，您应该发现*Ctrl * +单击会打开一个带有请求链接的新选项卡。
- en: Advanced QtWebEngine usage
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级QtWebEngine用法
- en: While we have implemented a basic, serviceable browser, it leaves much to be
    desired. In this section, we're going to explore some of the more advanced features
    of `QtWebEngineWidgets` by fixing some pain points in our user experience and
    implementing useful tools such as history and text search.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经实现了一个基本的、可用的浏览器，但它还有很多不足之处。在本节中，我们将通过修复用户体验中的一些痛点和实现有用的工具，如历史和文本搜索，来探索`QtWebEngineWidgets`的一些更高级的功能。
- en: Sharing a profile
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享配置文件
- en: Although we can view multiple tabs in our browser, there is a small problem
    in the way they work with authenticated websites. Visit any website where you
    have a login account; log in, then *Ctrl *+ click on a link within the site to
    open it in a new tab. You'll find that you aren't authenticated in the new tab.
    This can be a real problem with sites that use multiple windows or tabs to implement
    their user interface. We'd like authentication and other session data to be browser-wide,
    so let's fix this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在浏览器中查看多个选项卡，但它们在与经过身份验证的网站一起工作时存在一个小问题。访问任何您拥有登录帐户的网站；登录，然后*Ctrl *+单击站点内的链接以在新选项卡中打开它。您会发现您在新选项卡中没有经过身份验证。对于使用多个窗口或选项卡来实现其用户界面的网站来说，这可能是一个真正的问题。我们希望身份验证和其他会话数据是整个浏览器范围的，所以让我们来解决这个问题。
- en: Session information is stored in a **profile** that is represented by a `QWebEngineProfile`
    object. This object is autogenerated for each `QWebEngineWidget` object, but we
    can override it with an object of our own.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 会话信息存储在一个由`QWebEngineProfile`对象表示的**配置文件**中。这个对象是为每个`QWebEngineWidget`对象自动生成的，但我们可以用自己的对象来覆盖它。
- en: 'Start by creating one in `MainWindow.__init__()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`MainWindow.__init__()`中创建一个：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will need to associate this profile object with each new web view as we create
    them in `add_tab()`. Profiles, however, are not actually a property of the web
    view; they're the property of the web page object. The page, represented by a
    `QWebEnginePage` object, can be thought of as the *model* for the web view. Each
    web view generates its own `page` object, which acts as an interface to the browsing
    engine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`add_tab()`中创建新的web视图时，我们需要将这个配置文件对象与每个新的web视图关联起来。然而，配置文件实际上并不是web视图的属性；它们是web页面对象的属性。页面由`QWebEnginePage`对象表示，可以被视为web视图的*模型*。每个web视图都会生成自己的`page`对象，它充当了浏览引擎的接口。
- en: 'To override the web view''s profile, we need to create a `page` object, override
    its profile with our own, then override the web view''s page with our new page,
    like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖web视图的配置文件，我们需要创建一个`page`对象，覆盖它的配置文件，然后用我们的新页面覆盖web视图的页面，就像这样：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The profile *must* be passed as an argument to the `QWebEnginePage` constructor,
    as there is no accessor function to set it afterward. Once we've got a new `QWebEnginePage`
    object that uses our profile, we can call `QWebEngineView.setPage()` to assign
    it to our web view.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件*必须*作为参数传递给`QWebEnginePage`构造函数，因为没有访问函数可以在之后设置它。一旦我们有了一个使用我们的配置文件的新的`QWebEnginePage`对象，我们就可以调用`QWebEngineView.setPage()`将其分配给我们的web视图。
- en: Now when you test the browser, your authentication status should remain intact
    across all tabs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您测试浏览器时，您的身份验证状态应该在所有选项卡中保持不变。
- en: Viewing history
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看历史记录
- en: Each `QWebEngineView` object manages its own browsing history, which we can
    access to allow the user to view and navigate the URLs visited.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`QWebEngineView`对象都管理着自己的浏览历史，我们可以访问它来允许用户查看和导航已访问的URL。
- en: 'To build this feature, let''s create an interface that displays the history
    of the current tab and allows the user to click history items to navigate back
    to:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个功能，让我们创建一个界面，显示当前选项卡的历史记录，并允许用户点击历史记录项进行导航：
- en: 'Start by creating a dock widget for history in `MainView.__init__()`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`MainView.__init__()`中创建一个历史记录的停靠窗口小部件：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The history dock just contains a `QListWidget` object, which will display the
    history of the currently selected tab.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 历史记录停靠窗口只包含一个`QListWidget`对象，它将显示当前选定选项卡的历史记录。
- en: 'Since we''ll need to refresh this list when the user switches tabs, connect
    the tab widget''s `currentChanged` signal to a callback that can do this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要在用户切换选项卡时刷新这个列表，将选项卡小部件的`currentChanged`信号连接到一个可以执行此操作的回调函数：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `update_history()` method looks like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update_history()`方法如下：'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we clear the list widget and retrieve the web view for the currently
    active tab. If a web view exists (it might not if all the tabs are closed), we
    retrieve the web view's history using the `history()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们清除列表小部件并检索当前活动选项卡的web视图。如果web视图存在（如果所有选项卡都关闭了，它可能不存在），我们使用`history()`方法检索web视图的历史记录。
- en: This history is a `QWebEngineHistory` object; this object is a property of the
    web page object and tracks the browsing history. When the `back()` and `forward()`
    slots are called on a web view, this object is consulted to find the correct URL
    to load. The `items()` method of the history object returns a list of `QWebEngineHistoryItem`
    objects detailing the entire browsing history of the web view object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个历史记录是一个`QWebEngineHistory`对象；这个对象是web页面对象的属性，用来跟踪浏览历史。当在web视图上调用`back()`和`forward()`槽时，会查询这个对象，找到正确的URL进行加载。历史对象的`items()`方法返回一个`QWebEngineHistoryItem`对象的列表，详细描述了web视图对象的整个浏览历史。
- en: Our `update_history` method iterates this list and adds a new `QListWidgetItem`
    object for each item in the history. Note that we're using the list widget item's
    `setData()` method rather than `setText()`, as it allows us to store the `QUrl`
    object directly instead of having to convert it to a string (`QListWidget` will
    automatically convert the URL to a string for display, using the URL's `toString()`
    method).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`update_history`方法遍历这个列表，并为历史中的每个项目添加一个新的`QListWidgetItem`对象。请注意，我们使用列表小部件项的`setData()`方法，而不是`setText()`，因为它允许我们直接存储`QUrl`对象，而不必将其转换为字符串（`QListWidget`将自动将URL转换为字符串进行显示，使用URL的`toString()`方法）。
- en: 'In addition to calling this method whenever the tabs are switched, we also
    need to call it when a web view navigates to a new page, in order to keep the
    history current as the user browses. To make this happen, add a connection to
    each newly generated web view in the `add_tab()` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了在切换选项卡时调用此方法之外，我们还需要在web视图导航到新页面时调用它，以便在用户浏览时保持历史记录的最新状态。为了实现这一点，在`add_tab()`方法中为每个新生成的web视图添加一个连接：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To finish our history feature, we''d like to be able to double-click an item
    in the history and navigate to its URL in the currently open tab. We''ll start
    by creating a `MainWindow` method to do the navigation:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的历史功能，我们希望能够双击历史中的项目并在当前打开的标签中导航到其URL。我们将首先创建一个`MainWindow`方法来进行导航：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We're going to be using the `itemDoubleClicked` signal within `QListWidget`
    to trigger this method, which passes the `QListItemWidget` object that was clicked
    to its callback. We simply retrieve the URL from the list item by calling its
    `data()` accessor method, then pass the URL to the currently visible web view.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`QListWidget`中的`itemDoubleClicked`信号来触发此方法，该方法将`QListItemWidget`对象传递给其回调。我们只需通过调用其`data()`访问器方法从列表项中检索URL，然后将URL传递给当前可见的web视图。
- en: 'Now, back in `__init__()`, we''ll connect the signal to the callback as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到`__init__()`，我们将连接信号到回调如下：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This completes our history functionality; launch the browser and you'll find
    you can view and navigate using the history list in the dock.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的历史功能；启动浏览器，您会发现可以使用停靠中的历史列表查看和导航。
- en: Web settings
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web设置
- en: The `QtWebEngine` browser, just like the Chromium browser that it's based on,
    offers a very customizable web experience; we can edit many of its settings to
    implement various security, functionality, or appearance changes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtWebEngine`浏览器，就像它所基于的Chromium浏览器一样，提供了一个非常可定制的网络体验；我们可以编辑许多设置来实现各种安全、功能或外观的更改。'
- en: 'To do this, we need to access the following default `settings` object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要访问以下默认的`settings`对象：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `QWebEngineSettings` object returned by the `defaultSettings()` static method
    is a global object referenced by all web views in our program. We do not have
    to (nor can we) explicitly assign it to the web views after changing it. Once
    we've retrieved it, we can configure it in various ways and our settings will
    be respected by all the web views we create.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultSettings()`静态方法返回的`QWebEngineSettings`对象是一个全局对象，由程序中所有的web视图引用。我们不必（也不能）在更改后将其显式分配给web视图。一旦我们检索到它，我们可以以各种方式配置它，我们的设置将被所有我们创建的web视图所尊重。'
- en: 'For example, let''s alter the fonts a bit:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们稍微改变字体：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, we're setting the default font family for all sans-serif fonts
    to `Impact`. In addition to setting the font family, we can also set a default
    `fontSize` object and a `defaultTextEncoding` object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将所有无衬线字体的默认字体系列设置为`Impact`。除了设置字体系列，我们还可以设置默认的`fontSize`对象和`defaultTextEncoding`对象。
- en: 'The `settings` object also has a number of attributes, which are Boolean switches
    that we can toggle; for example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings`对象还具有许多属性，这些属性是布尔开关，我们可以切换；例如：'
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we''re enabling the use of Pepper API plugins, such as Chrome''s
    Flash implementation. There are 29 attributes that we can toggle, a few examples
    of which are listed in the following table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们启用了Pepper API插件的使用，例如Chrome的Flash实现。我们可以切换29个属性，以下是其中的一些示例：
- en: '| Attribute | Default | Description |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 默认 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `JavascriptEnabled` | `True` | Allow running JavaScript code. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `JavascriptEnabled` | `True` | 允许运行JavaScript代码。'
- en: '| `JavascriptCanOpenWindows` | `True` | Allow JavaScript to open new pop-up
    windows. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `JavascriptCanOpenWindows` | `True` | 允许JavaScript打开新的弹出窗口。'
- en: '| `FullScreenSupportEnabled` | `False` | Allow the browser to be fullscreen.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: 全屏支持已启用 | 假 | 允许浏览器全屏显示。
- en: '| `AllowRunningInsecureContent` | `False` | Allow running HTTP content on HTTPS
    pages. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `AllowRunningInsecureContent` | `False` | 允许在HTTPS页面上运行HTTP内容。'
- en: '| `PlaybackRequiresUserGesture` | `False` | Don''t play back media until the
    user interacts with the page. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `PlaybackRequiresUserGesture` | `False` | 在用户与页面交互之前不要播放媒体。'
- en: To alter settings for an individual web view, access its `QWebEnginSettings`
    object using `page().settings()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改单个web视图的设置，请使用`page().settings()`访问其`QWebEnginSettings`对象。
- en: Building a text search feature
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建文本搜索功能
- en: 'So far, we''ve loaded and displayed content in our web view widget, but we
    haven''t really done much with the actual content. One of the powerful features
    that we get with `QtWebEngine` is the ability to manipulate the contents of web
    pages by injecting our own JavaScript code into those pages. To see how this works,
    we''re going to use the following instructions to develop a text search feature
    that will highlight all instances of a search term:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在我们的web视图小部件中加载和显示了内容，但实际内容并没有做太多事情。我们通过`QtWebEngine`获得的强大功能之一是能够通过将我们自己的JavaScript代码注入到这些页面中来操纵网页的内容。为了看看这是如何工作的，我们将使用以下说明来开发一个文本搜索功能，该功能将突出显示搜索词的所有实例：
- en: 'We''ll start by adding the GUI components to `MainWindow.__init__()`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`MainWindow.__init__()`中添加GUI组件：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The search widget is just a `QLineEdit` object that is embedded in a dock widget.
    We've connected the `textChanged` signal to a callback function that will perform
    the search.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索小部件只是一个嵌入在停靠窗口中的`QLineEdit`对象。我们已经将`textChanged`信号连接到一个回调函数，该函数将执行搜索。
- en: 'To implement the search functionality, we need to write some JavaScript code
    that will locate and highlight all the instances of a search term for us. We could
    add this code as a string, but for clarity let''s write it in a separate file;
    open a file called `finder.js` and add in this code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现搜索功能，我们需要编写一些JavaScript代码，以便为我们定位和突出显示搜索词的所有实例。我们可以将此代码添加为字符串，但为了清晰起见，让我们将其写在一个单独的文件中；打开一个名为`finder.js`的文件，并添加以下代码：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This book isn''t a JavaScript text, so we won''t get into the dirty details
    of how this code works, other than to summarize what''s happening:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是一本JavaScript文本，所以我们不会深入讨论这段代码的工作原理，只是总结一下正在发生的事情：
- en: The `highlight_term()` function takes a single string as a search term. It begins
    by cleaning up any HTML `<found>` tags; this isn't a real tag—it's one we've invented
    for this functionality so that it won't conflict with any real tags.
  id: totrans-122
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`highlight_term()`函数接受一个字符串作为搜索词。它首先清理任何HTML`<found>`标签；这不是一个真正的标签——这是我们为了这个功能而发明的，这样它就不会与任何真正的标签冲突。'
- en: The function then searches forward and backward through the document looking
    for instances of the search term.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后该函数通过文档向前和向后搜索搜索词的实例。
- en: When it finds one, it wraps it in a `<found>` tag with the background color
    set to light green.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它找到一个时，它会用背景颜色设置为浅绿色的`<found>`标签包裹它。
- en: 'Back in `MainWindow.__init__()`, we''ll read in this file and save it as an
    instance variable:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`，我们将读取这个文件并将其保存为一个实例变量：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s implement our search callback method under `MainWindow`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`MainWindow`下实现我们的搜索回调方法：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To run JavaScript code in our current web view, we need to get a reference to
    its `QWebEnginePage` object. Then we can call the page's `runJavaScript()` method.
    This method simply takes a string containing JavaScript code and executes it on
    the web page.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的网页视图中运行JavaScript代码，我们需要获取它的`QWebEnginePage`对象的引用。然后我们可以调用页面的`runJavaScript()`方法。这个方法简单地接受一个包含JavaScript代码的字符串，并在网页上执行它。
- en: 'In this case, we first run the contents of our `finder.js` file to set up the
    functions, then we call the `highlight_term()` function with the search term inserted.
    As a quick-and-dirty security measure, we''re also stripping all the double quotes
    from the search term; therefore, it can''t be used to inject arbitrary JavaScript.
    If you run the application now, you should be able to search for strings on the
    page, like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们首先运行我们的`finder.js`文件的内容来设置函数，然后我们调用`highlight_term()`函数并插入搜索词。作为一个快速而粗糙的安全措施，我们还从搜索词中剥离了所有双引号；因此，它不能用于注入任意的JavaScript。如果你现在运行应用程序，你应该能够在页面上搜索字符串，就像这样：
- en: '![](assets/3e7dac13-b284-4ea5-ae91-54413221f4f9.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e7dac13-b284-4ea5-ae91-54413221f4f9.png)'
- en: This works pretty well, but it is not very efficient to redefine those functions
    every time we update the search term, is it? It would be great if we could just
    define those functions once and then have access to them on any page that we navigate
    to.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法效果还不错，但是每次更新搜索词时重新定义这些函数并不是很有效，是吗？如果我们只定义这些函数一次，然后在我们导航到的任何页面上都可以访问它们，那就太好了。
- en: 'This can be done using the `QWebEnginePage` object''s `scripts` property. This
    property stores a collection of `QWebEngineScript` objects, which contain JavaScript
    snippets to be run each time a new page is loaded. By adding our scripts to this
    collection, we can ensure that our function definitions are run only on each page
    load, rather than every time we try to search. To make this work, we''ll start
    back in `MainWindow.__init__()` by defining a `QWebEngineScript` object:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以使用`QWebEnginePage`对象的`scripts`属性来完成。这个属性存储了一个`QWebEngineScript`对象的集合，其中包含了每次加载新页面时要运行的JavaScript片段。通过将我们的脚本添加到这个集合中，我们可以确保我们的函数定义仅在每次页面加载时运行，而不是每次我们尝试搜索时都运行。为了使这个工作，我们将从`MainWindow.__init__()`开始，定义一个`QWebEngineScript`对象：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Each script in the collection is run in one of 256 **worlds**, which are isolated
    JavaScript contexts. For us to have access to our functions in subsequent calls,
    we need to make sure our `script` object is executed in the main world by setting
    its `worldId` property:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合中的每个脚本都在256个**worlds**中的一个中运行，这些worlds是隔离的JavaScript上下文。为了在后续调用中访问我们的函数，我们需要确保我们的`script`对象通过设置它的`worldId`属性在主world中执行：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`QWebEngineScript.MainWorld` is a constant that points to the main JavaScript
    execution context. If we did not set this, our script would run, but the functions
    would run in their own world, and wouldn''t be available in the web page context
    for us to use for searching.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWebEngineScript.MainWorld`是一个常量，指向主JavaScript执行上下文。如果我们没有设置这个，我们的脚本会运行，但函数会在它们自己的world中运行，并且在网页上下文中不可用于搜索。'
- en: 'Now that we have our `script` object, we need to add it to the web page object.
    This should be done in `MainWindow.add_tab()`, when we create our `page` object:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`script`对象，我们需要将它添加到网页对象中。这应该在`MainWindow.add_tab()`中完成，当我们创建我们的`page`对象时：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we can shorten the `text_search()` method:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以缩短`text_search()`方法：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Apart from just running scripts, we can also retrieve data back from the scripts
    and send it to a callback method within our Python code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行脚本，我们还可以从脚本中检索数据并将其发送到我们的Python代码中的回调方法。
- en: 'For example, we can make the following change to our JavaScript to return the
    number of matches from our function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以对我们的JavaScript进行以下更改，以从我们的函数中返回匹配项的数量：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This value is *not* returned from `runJavaScript()` as the JavaScript code is
    executed asynchronously.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值*不*是从`runJavaScript()`返回的，因为JavaScript代码是异步执行的。
- en: 'To access the return value, we need to pass a reference to a Python callable
    as a second argument to `runJavaScript()`; Qt will call that method with the return
    value of the called code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问返回值，我们需要将一个Python可调用的引用作为`runJavaScript()`的第二个参数传递；Qt将调用该方法，并传递被调用代码的返回值：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we''re going to pass the output of the JavaScript call to a method called
    `match_count()`, which looks like the following code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将JavaScript调用的输出传递给一个名为`match_count()`的方法，它看起来像下面的代码片段：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, we'll just show a status bar message if there are any matches
    found. Try the browser again and you'll see that the message should successfully
    be conveyed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果找到任何匹配项，我们将显示一个状态栏消息。再次尝试浏览器，你会看到消息应该成功传达。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the possibilities made available to us by `QtWebEngineWidgets`.
    You implemented a simple browser, then learned how to utilize features such as
    browsing history, profile sharing, multiple tabs, and common settings. You also
    learned to inject arbitrary JavaScript into web pages and retrieve the results
    of those calls.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了`QtWebEngineWidgets`为我们提供的可能性。您实现了一个简单的浏览器，然后学习了如何利用浏览历史、配置文件共享、多个选项卡和常见设置等功能。您还学会了如何向网页注入任意JavaScript并检索这些调用的结果。
- en: In the next chapter, you'll learn how to prepare your code for sharing, distribution,
    and deployment. We'll discuss how to structure your project directory properly,
    how to distribute Python code using official tools, and how to create standalone
    executables for various platforms using PyInstaller.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何准备您的代码以进行共享、分发和部署。我们将讨论如何正确地构建项目目录结构，如何使用官方工具分发Python代码，以及如何使用PyInstaller为各种平台创建独立的可执行文件。
- en: Questions
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您从本章中学到的知识：
- en: The following code is giving you an attribute error; what's wrong?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码给出了一个属性错误；出了什么问题？
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The following code should connect this `UrlBar` class with a `QWebEngineView`
    so that the entered URL is loaded when the *return*/*Enter* key is pressed. It
    doesn't work, though; what is wrong?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应该将`UrlBar`类与`QWebEngineView`连接起来，以便在按下*return*/*Enter*键时加载输入的URL。但是它不起作用；出了什么问题？
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What is the result of the following code?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的结果是什么？
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Check out the documentation for  `QWebEngineView` at [https://doc.qt.io/qt-5/qwebengineview.html](https://doc.qt.io/qt-5/qwebengineview.html).
    How would you implement a zoom feature in your browser?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看[https://doc.qt.io/qt-5/qwebengineview.html](https://doc.qt.io/qt-5/qwebengineview.html)中的`QWebEngineView`文档。您将如何在浏览器中实现缩放功能？
- en: As the name implies, `QWebEngineView` represents the view portion of a model-view
    architecture. What class represents the model in this design?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如其名称所示，`QWebEngineView`代表了模型-视图架构中的视图部分。在这个设计中，哪个类代表了模型？
- en: Given a `QWebEngineView` object that is named `webview`, write code to determine
    whether JavaScript is enabled on `webview`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个名为`webview`的`QWebEngineView`对象，编写代码来确定`webview`上是否启用了JavaScript。
- en: You saw in our browser example that `runJavaScript()` can pass an integer value
    to a callback function. Write a simple demo script to test what other kinds of
    JavaScript objects can be returned, and how they would appear in Python code.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在我们的浏览器示例中看到`runJavaScript()`可以将整数值传递给回调函数。编写一个简单的演示脚本来测试可以返回哪些其他类型的JavaScript对象，以及它们在Python代码中的表现方式。
- en: Further reading
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下内容：
- en: '**QuteBrowser** is an open source web browser written in Python using `QtWebEngineWidgets`.
    You can find its source code at [https://github.com/qutebrowser/qutebrowser](https://github.com/qutebrowser/qutebrowser).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QuteBrowser**是一个使用`QtWebEngineWidgets`用Python编写的开源网络浏览器。您可以在[https://github.com/qutebrowser/qutebrowser](https://github.com/qutebrowser/qutebrowser)找到其源代码。'
- en: '**ADMBrowser** is a browser that is based on `QtWebEngineWidgets`, which was
    created by the author of this book, and can be used with kiosk systems. You can
    find it at [https://github.com/alandmoore/admbrowser](https://github.com/alandmoore/admbrowser).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADMBrowser**是一个基于`QtWebEngineWidgets`的浏览器，由本书的作者创建，并可用于信息亭系统。您可以在[https://github.com/alandmoore/admbrowser](https://github.com/alandmoore/admbrowser)找到它。'
- en: '`QtWebChannel` is a feature that allows for more robust communication between
    your PyQt application and web content. You can start exploring this advanced feature
    at [https://doc.qt.io/qt-5/qtwebchannel-index.html](https://doc.qt.io/qt-5/qtwebchannel-index.html).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtWebChannel`是一个功能，允许您的PyQt应用程序与Web内容之间进行更强大的通信。您可以在[https://doc.qt.io/qt-5/qtwebchannel-index.html](https://doc.qt.io/qt-5/qtwebchannel-index.html)开始探索这一高级功能。'
