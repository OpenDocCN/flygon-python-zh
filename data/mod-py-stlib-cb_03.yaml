- en: Command Line
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行
- en: 'In this chapter, we will cover following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Basic logging—logging allows you to keep track of what the software is doing,
    and it's usually unrelated to its output
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本日志记录-日志记录允许您跟踪软件正在做什么，通常与其输出无关
- en: Logging to file—when logging is frequent, it is necessary to store the logs
    on a disk
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到文件-当记录频繁时，有必要将日志存储在磁盘上
- en: Logging to Syslog—if your system has a Syslog daemon, you might want to log
    in to Syslog instead of using a standalone file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到Syslog-如果您的系统有Syslog守护程序，则可能希望登录到Syslog而不是使用独立文件
- en: Parsing arguments—when writing with command-line tools, you need parsing options
    for practically any tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析参数-在使用命令行工具编写时，您需要为几乎任何工具解析选项
- en: Interactive shells—sometimes options are not enough and you need a form of Read-Eval-Print
    Loop to drive your tool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式shell-有时选项不足，您需要一种交互式的REPL来驱动您的工具
- en: Sizing terminal text—to align the displayed output properly, we need to know
    the terminal window size
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整终端文本大小-为了正确对齐显示的输出，我们需要知道终端窗口的大小
- en: Running system commands—how to integrate other third-party commands in your
    software
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行系统命令-如何将其他第三方命令集成到您的软件中
- en: Progress bar—how to show a progress bar in your text tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进度条-如何在文本工具中显示进度条
- en: Message boxes—how to display an OK/cancel message box in a text tool
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息框-如何在文本工具中显示OK/取消消息框
- en: Input box—how to ask for input in a text tool
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入框-如何在文本工具中请求输入
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When writing a new tool, one of the first needs that arises is making it able
    to interact with the surrounding environment—to display results, track errors,
    and receive inputs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写新工具时，首先出现的需求之一是使其能够与周围环境进行交互-显示结果，跟踪错误并接收输入。
- en: Users are accustomed to certain standard ways a command-line tool interacts
    with them and with the system, and following this standard might be time-consuming
    and hard if done from scratch.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户习惯于命令行工具与他们和系统交互的某些标准方式，如果从头开始遵循这个标准可能是耗时且困难的。
- en: That's why the standard library in Python provides tools to achieve the most
    common needs in implementing software that is able to interact through a shell
    and through text.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Python标准库提供了工具来实现能够通过shell和文本进行交互的软件的最常见需求。
- en: In this chapter, we will see how to implement some forms of logging, so that
    our program can keep a log file; we will see how to implement both options-based
    and interactive software, and then we will see how to implement more advanced
    graphical output based on text.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何实现某些形式的日志记录，以便我们的程序可以保留日志文件；我们将看到如何实现基于选项和交互式软件，然后我们将看到如何基于文本实现更高级的图形输出。
- en: Basic logging
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本日志记录
- en: One of the first requirements of a console software is for it to log what it
    does, that is, what's happened, and any warnings or errors. Especially when we
    are talking about long-term software or daemons running in the background.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台软件的首要要求之一是记录其所做的事情，即发生了什么以及任何警告或错误。特别是当我们谈论长期运行的软件或在后台运行的守护程序时。
- en: Sadly, if you've ever tried to use the Python `logging` module, you've probably
    noticed that you can't get any output apart from errors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，如果您曾经尝试使用Python的`logging`模块，您可能已经注意到除了错误之外，您无法获得任何输出。
- en: That's because the default enabled level is `WARNING`, so that only warnings
    and worse are tracked. Little tweaks are needed to make logging generally available.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认启用级别是“警告”，因此只有警告和更严重的情况才会被跟踪。需要进行一些小的调整，使日志通常可用。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the steps are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，步骤如下：
- en: 'The `logging` module allows us to easily set up the logging configuration through
    the `basicConfig` method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`logging`模块允许我们通过`basicConfig`方法轻松设置日志记录配置：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that our `logger` is properly configured, we can try using it:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的“logger”已经正确配置，我们可以尝试使用它：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`logging.basicConfig` configures the `root` logger (the main logger, Python
    will use if no specific configuration for the used logger is found) to write anything
    at the `INFO` level or greater. This will allow us to show everything apart from
    the debugging messages. The `format` argument specifies how our logging messages
    should be formatted; in this case, we added the date and time, the name of the
    logger, the level at which we are logging, and the message itself. Finally, the
    `stream` argument tells the logger to write its output to the standard error.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging.basicConfig`配置`root`记录器（主记录器，如果找不到用于使用的记录器的特定配置，则Python将使用它）以在`INFO`级别或更高级别写入任何内容。这将允许我们显示除调试消息之外的所有内容。`format`参数指定了我们的日志消息应该如何格式化；在这种情况下，我们添加了日期和时间，记录器的名称，我们正在记录的级别以及消息本身。最后，`stream`参数告诉记录器将其输出写入标准错误。'
- en: Once we have the `root` logger configured, any logging we pick that doesn't
    have a specific configuration will just end up using the `root` logger one.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了`root`记录器，任何我们选择的日志记录，如果没有特定的配置，都将使用`root`记录器。
- en: So the next line, `logging.getLogger(__name__)`, gets a logger named similar
    to the Python module that it's executing. If you saved your code to a file, the
    logger will be named something such as `dosum` (given your file is named `dosum.py`);
    if you didn't, then the logger will be named `__main__`, as in the previous example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一行`logging.getLogger(__name__)`会获得一个与执行的Python模块类似命名的记录器。如果您将代码保存到文件中，则记录器的名称将类似于`dosum`（假设您的文件名为`dosum.py`）；如果没有，则记录器的名称将为`__main__`，就像前面的示例中一样。
- en: Python loggers are created the first time they are retrieved with `logging.getLogger`,
    and any subsequent call to `getLogger` will just return the already existing one.
    While, for a very simple program, the name won't matter much, in bigger software,
    it's usually a good idea to grab more than one logger, so that you can distinguish
    from which subsystem of your software the messages are coming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python记录器在使用`logging.getLogger`检索时首次创建，并且对`getLogger`的任何后续调用只会返回已经存在的记录器。对于非常简单的程序，名称可能并不重要，但在更大的软件中，通常最好抓取多个记录器，这样您可以区分消息来自软件的哪个子系统。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You might be wondering why we configured `logging` to send its output to `stderr`,
    instead of the standard output. This allows us to separate the output of our software
    (which is written to `stdout` through the print statements) from the logging information.
    This is usually a good practice because the user of your tool might need to call
    the output of your tool without all the noise generated by logging messages, and
    doing so allows us to call our script with something such as the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么我们配置`logging`将其输出发送到`stderr`，而不是标准输出。这样可以将我们软件的输出（通过打印语句写入`stdout`）与日志信息分开。这通常是一个好的做法，因为您的工具的用户可能需要调用您的工具的输出，而不带有日志消息生成的所有噪音，这样做可以让我们以以下方式调用我们的脚本：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll only get back the results, without all the noise, because we redirected
    `stderr` to `/dev/null`, which on Unix systems leads to throwing away all that
    was written to `stderr`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会得到结果，而不会有所有的噪音，因为我们将`stderr`重定向到`/dev/null`，这在Unix系统上会导致丢弃所有写入`stderr`的内容。
- en: Logging to file
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录到文件
- en: For long-running programs, logging to the screen is not a very viable option.
    After running the code for hours, the oldest logged messages will be lost, and
    even if they were still available, it wouldn't be very easy to read all the logs
    or search through them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的程序，将日志记录到屏幕并不是一个非常可行的选择。在运行代码数小时后，最旧的日志消息将丢失，即使它们仍然可用，也不容易阅读所有日志或搜索其中的内容。
- en: Saving logs to a file allows for unlimited length (as far as our disk allows
    it) and enables the usage of tools, such as `grep`, to search through them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志保存到文件允许无限长度（只要我们的磁盘允许）并且可以使用`grep`等工具进行搜索。
- en: By default, Python logging is configured to write to screen, but it's easy to
    provide a way to write to any file when logging is configured.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python日志配置为写入屏幕，但在配置日志时很容易提供一种方式来写入任何文件。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: To test `logging` to a file, we are going to create a short tool that computes
    up to the *n^(th)* Fibonacci number based on the current time. If it's 3:01 P.M.,
    we want to compute only 1 number, while if it's 3:59 P.M., we want to compute
    59 numbers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试将日志记录到文件，我们将创建一个简短的工具，根据当前时间计算最多*n*个斐波那契数。如果是下午3:01，我们只想计算1个数字，而如果是下午3:59，我们想计算59个数字。
- en: 'The software will provide the computed numbers as the output, but we also want
    to log up to which number it computed and when it was run:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 软件将提供计算出的数字作为输出，但我们还想记录计算到哪个数字以及何时运行：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The code is split into three sections: initializing logging, the `fibo` function,
    and the `main` function of our tool. We explicitly divided code this way because
    the `fibo` function might be used in other modules, and in such a case, we don''t
    want `logging` to be reconfigured; we just want to use the logging configuration
    that the program will provide. For that reason, the `logging.basicConfig` call
    is wrapped in `__name__ == ''__main__''` so that `logging` is only configured
    when the module is called directly as a tool and not when it''s imported by other
    modules.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分为三个部分：初始化日志记录、`fibo`函数和我们工具的`main`函数。我们明确地以这种方式划分代码，因为`fibo`函数可能会在其他模块中使用，在这种情况下，我们不希望重新配置`logging`；我们只想使用程序提供的日志配置。因此，`logging.basicConfig`调用被包装在`__name__
    == '__main__'`中，以便只有在模块被直接调用为工具时才配置`logging`，而不是在被其他模块导入时。
- en: When multiple `logging.basicConfig` instances are called, only the first one
    will be considered. If we didn't wrap our logging configuration in `if` when imported
    by other modules, it might end up driving the whole software logging configuration,
    depending on the order the modules were imported in, which is something we clearly
    don't want.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用多个`logging.basicConfig`实例时，只有第一个会被考虑。如果我们在其他模块中导入时没有将日志配置包装在`if`中，它可能最终会驱动整个软件的日志配置，这取决于模块导入的顺序，这显然是我们不想要的。
- en: Differently from our previous recipe, `basicConfig` is configured with the `filename`
    argument instead of the `stream` argument. This means `logging.FileHandler` will
    be created to handle the logging messages and the messages will be appended to
    that file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法不同，`basicConfig`是使用`filename`参数而不是`stream`参数进行配置的。这意味着将创建`logging.FileHandler`来处理日志消息，并且消息将被追加到该文件中。
- en: The central part of the code is the `fibo` function itself, and the last part
    is a check to see whether the code was called as a Python script or imported as
    a module. When imported as a module, we just want to provide the `fibo` function
    and avoid running it, but when executed as a script, we want to compute the Fibonacci
    numbers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的核心部分是`fibo`函数本身，最后一部分是检查代码是作为Python脚本调用还是作为模块导入。当作为模块导入时，我们只想提供`fibo`函数并避免运行它，但当作为脚本执行时，我们想计算斐波那契数。
- en: You might be wondering why I used two `if __name__ == '__main__'` sections;
    if you merge the two into one, the script will continue to work. But it's usually
    a good idea to ensure that `logging` is configured before trying to use it, or
    the result will be that we will end up using the `logging.lastResort` handler,
    which will just write to `stderr` until the logging is configured.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么我使用了两个`if __name__ == '__main__'`部分；如果将两者合并成一个，脚本将继续工作。但通常最好确保在尝试使用日志之前配置`logging`，否则结果将是我们最终会使用`logging.lastResort`处理程序，它只会写入`stderr`直到日志被配置。
- en: Logging to Syslog
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录到Syslog
- en: Unix-like systems usually provide a way to gather logging messages through the
    `syslog` protocol, which allows us to separate the system storing the logs from
    the one generating them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类Unix系统通常提供一种通过`syslog`协议收集日志消息的方法，这使我们能够将存储日志的系统与生成日志的系统分开。
- en: Especially in the context of applications distributed across multiple servers,
    this is very convenient; you certainly don't want to log into 20 different servers
    to gather all the logs of your Python application because it was running on multiple
    nodes. Especially for web applications, this is very common nowadays with cloud
    providers, so it's very convenient to be able to gather all the Python logs in
    a single place.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在跨多个服务器分布的应用程序的情况下，这非常方便；您肯定不想登录到20个不同的服务器上收集您的Python应用程序的所有日志，因为它在多个节点上运行。特别是对于Web应用程序来说，这在云服务提供商中现在非常常见，因此能够在一个地方收集所有Python日志非常方便。
- en: That's exactly what using `syslog` allows us to do; we will see how to send
    the log messages to the daemon running on our system, but it's possible to send
    them to any system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是使用`syslog`允许我们做的事情；我们将看到如何将日志消息发送到运行在我们系统上的守护程序，但也可以将它们发送到任何系统。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: While this recipe doesn't need a `syslog` daemon to work, you will need one
    to check that it's properly working or the messages won't be readable. In the
    case of Linux or macOS systems, this is usually configured out of the box, but
    in the case of a Windows system, you will need to install a Syslog server or use
    a cloud solution. Many exist and a quick search on Google should provide you with
    some cheap or even free alternatives.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法不需要`syslog`守护程序才能工作，但您需要一个来检查它是否正常工作，否则消息将无法被读取。在Linux或macOS系统的情况下，这通常是开箱即用的，但在Windows系统的情况下，您需要安装一个Syslog服务器或使用云解决方案。有许多选择，只需在Google上快速搜索，就可以找到一些便宜甚至免费的替代方案。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'When using a heavily customized solution for logging, it''s not possible to
    rely on `logging.basicConfig` anymore, so we will have to manually set up the
    logging environment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个定制程度很高的日志记录解决方案时，就不再能依赖于`logging.basicConfig`，因此我们将不得不手动设置日志记录环境：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If this worked properly, your message should be recorded by Syslog and visible
    when running the `syslog` command on macOS or with `tail` as `/var/log/syslog`
    on Linux:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样操作正常，您的消息应该被Syslog记录，并且在macOS上运行`syslog`命令或在Linux上作为`/var/log/syslog`的`tail`命令时可见：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `syslog` file path might change from distribution to distribution; if `/var/log/syslog` doesn't
    work, try `/var/log/messages` or refer to your distribution documentation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`syslog`文件路径可能因发行版而异；如果`/var/log/syslog`不起作用，请尝试`/var/log/messages`或参考您的发行版文档。'
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we relied on `dictConfig`, you noticed that our configuration is a bit more
    complex than in previous recipes. This is because we configured the bits that
    are part of the logging infrastructure ourselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们依赖于`dictConfig`，您会注意到我们的配置比以前的方法更复杂。这是因为我们自己配置了日志基础设施的部分。
- en: 'Whenever you configure logging, you write your messages with a logger. By default,
    the system only has one logger: the `root` logger (the one you get if you call
    `logging.getLogger` without providing any specific name).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您配置日志记录时，都要使用记录器写入您的消息。默认情况下，系统只有一个记录器：`root`记录器（如果您调用`logging.getLogger`而不提供任何特定名称，则会得到该记录器）。
- en: The logger doesn't handle messages itself, as writing or printing log messages
    is something handlers are in charge of. Consequently, if you want to read the
    log messages you send, you need to configure a handler. In our case, we use `SysLogHandler`,
    which writes to Syslog.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器本身不处理消息，因为写入或打印日志消息是处理程序的职责。因此，如果您想要读取您发送的日志消息，您需要配置一个处理程序。在我们的情况下，我们使用`SysLogHandler`，它写入到Syslog。
- en: Handler is then in charge of writing a message, but doesn't really get involved
    in how that message should be built/formatted. You noticed that apart your own
    message, when you log something, you also get the log level, logger name, timestamp,
    and a few details that are added by the logging system for you. Adding those details
    to the message is usually the formatter's work. The formatter takes all the information
    made available by the logger and packs them in a message that should be written
    by the handler.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序负责写入消息，但实际上并不涉及消息应该如何构建/格式化。您会注意到，除了您自己的消息之外，当您记录某些内容时，还会得到日志级别、记录器名称、时间戳以及由日志系统为您添加的一些细节。将这些细节添加到消息中通常是格式化程序的工作。格式化程序获取记录器提供的所有信息，并将它们打包成应该由处理程序写入的消息。
- en: Last but not least, your logging configuration can be very complex. You can
    set up some messages to go to a local file and some messages to go to Syslog and
    more that should be printed on screen. This would involve multiple handlers, which
    should know which messages they should threat and which they should ignore. Allowing
    this knowledge is the job of filters. Once you attach a filter to a handler, it's
    possible to control which messages should be saved by that handler and which should
    be ignored.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，您的日志配置可能非常复杂。您可以设置一些消息发送到本地文件，一些消息发送到Syslog，还有一些应该打印在屏幕上。这将涉及多个处理程序，它们应该知道哪些消息应该处理，哪些消息应该忽略。允许这种知识是过滤器的工作。一旦将过滤器附加到处理程序，就可以控制哪些消息应该由该处理程序保存，哪些应该被忽略。
- en: The Python logging system might now look very intuitive, and that's because
    it's a very powerful solution that can be configured in many ways, but once you
    understand the building blocks that are available, it's possible to combine them
    in very flexible ways.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python日志系统现在可能看起来非常直观，这是因为它是一个非常强大的解决方案，可以以多种方式进行配置，但一旦您了解了可用的构建模块，就可以以非常灵活的方式将它们组合起来。
- en: Parsing arguments
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析参数
- en: When writing command-line tools, it's usually common to have it change behavior
    based on options provided to the executable. These options are usually available
    in `sys.argv` together with the executable name, but parsing them is not as easy
    as it might seem, especially when multiple arguments must be supported. Also,
    when an option is malformed, it's usually a good idea to provide a usage message
    to inform the user about the right way to use the tool.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写命令行工具时，通常会根据提供给可执行文件的选项来改变其行为。这些选项通常与可执行文件名称一起在`sys.argv`中可用，但解析它们并不像看起来那么容易，特别是当必须支持多个参数时。此外，当选项格式不正确时，通常最好提供一个使用消息，以便通知用户正确使用工具的方法。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps for this recipe:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此食谱的以下步骤：
- en: 'The `argparse.ArgumentParser` object is the primary object in charge of parsing
    command-line options:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`argparse.ArgumentParser`对象是负责解析命令行选项的主要对象：'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once our command is called without any arguments, it will provide a short usage
    text:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的命令没有任何参数被调用，它将提供一个简短的使用文本：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we provide the `-h` option, `argparse` will generate a complete usage guide
    for us:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们提供了`-h`选项，`argparse`将为我们生成一个完整的使用指南：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the command will lead to the expected result:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该命令将会得到预期的结果：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We used the `ArgumentParser.add_argument` method to populate the list of available
    options. For every argument, it's possible to also provide a `help` option, which
    will declare the `help` string for that argument.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`ArgumentParser.add_argument`方法来填充可用选项的列表。对于每个参数，还可以提供一个`help`选项，它将为该参数声明`help`字符串。
- en: 'Positional arguments are provided with just the name of the argument:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数只需提供参数的名称：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `nargs` option tells `ArgumentParser` how many times we expect that argument
    to be specified, the `+` value means at least once or more than once. Then `type=int`
    tells us that the arguments should be converted to integers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`nargs`选项告诉`ArgumentParser`我们期望该参数被指定的次数，`+`值表示至少一次或多次。然后`type=int`告诉我们参数应该被转换为整数。'
- en: 'Once we have the numbers to which we want to apply the operation, we need to
    know the operation itself:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了要应用操作的数字，我们需要知道操作本身：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, we specified an option (starts with a dash, `-`), which can be
    provided both as `-o` or `--operation`. We stated that the only possible values
    are `'add'`, `'sub'`, `'mul'`, or `'div'` (providing a different value will result
    in `argparse` complaining), and that the default value, if the user didn't specify
    one, is `add`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定了一个选项（以破折号`-`开头），可以提供`-o`或`--operation`。我们声明唯一可能的值是`'add'`、`'sub'`、`'mul'`或`'div'`（提供不同的值将导致`argparse`抱怨），如果用户没有指定默认值，则为`add`。
- en: 'As a best practice, our command prints only the result; it was convenient to
    be able to ask some logging about what it was going to do. For this reason, we
    provided the `verbose` option, which drives the logging level we enabled for our
    command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我们的命令只打印结果；能够询问一些关于它将要做什么的日志是很方便的。因此，我们提供了`verbose`选项，它驱动了我们为命令启用的日志级别：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If that option is provided, we will just store that `verbose` mode is enabled
    (`action="store_true"` makes it so that `True` is stored in `opts.verbose`) and
    we will configure the `logging` module accordingly, such that our `log.info` is
    only visible when `verbose` is enabled.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了该选项，我们将只存储`verbose`模式已启用（`action="store_true"`使得`True`被存储在`opts.verbose`中），并且我们将相应地配置`logging`模块，这样我们的`log.info`只有在`verbose`被启用时才可见。
- en: 'Finally, we can actually parse the command-line options and get the result
    back into the `opts` object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实际解析命令行选项并将结果返回到`opts`对象中：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we have the options available, we configure logging so that we can read
    the `verbose` option and configure it accordingly:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了可用的选项，我们配置日志，以便我们可以读取`verbose`选项并相应地配置它：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once options are parsed and `logging` is configured, the rest is just actually
    performing the expected operation on the set of provided numbers and printing
    the result:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选项被解析并且`logging`被配置，剩下的就是在提供的数字集上执行预期的操作并打印结果：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you mix command-line options with the *Dictionary with fallback* recipe in
    Chapter 1, *Containers and Data Structures*, you can extend the behavior of your
    tools to not only read options from the command line, but also from environment
    variables, which is usually very convenient when you don't have complete control
    over how the command is called but you can set environment variables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将命令行选项与第1章*容器和数据结构*中的*带回退的字典*食谱相结合，你可以扩展工具的行为，不仅可以从命令行读取选项，还可以从环境变量中读取，当你无法完全控制命令的调用方式但可以设置环境变量时，这通常非常方便。
- en: Interactive shells
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式shell
- en: Sometimes, writing a command-line tool is not enough, and you need to be able
    to provide some sort of interactivity. Suppose you want to write a mail client.
    In this case, it's not very convenient to have to call `mymail list` to see your
    mail, or `mymail read` to read a specific mail from your shell, and so on. Furthermore,
    if you want to implement stateful behaviors—such as a `mymail reply` instance that
    should reply to the current mail you are viewing—this might not even be possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，编写命令行工具是不够的，你需要能够提供某种交互。假设你想要编写一个邮件客户端。在这种情况下，必须要调用`mymail list`来查看你的邮件，或者从你的shell中读取特定的邮件，等等，这是不太方便的。此外，如果你想要实现有状态的行为，比如一个`mymail
    reply`实例，它应该回复你正在查看的当前邮件，这甚至可能是不可能的。
- en: Interactive programs are better in these cases, and the Python standard library
    provides all the tools we need to write one through the `cmd` module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，交互式程序更好，Python标准库通过`cmd`模块提供了编写这样一个程序所需的所有工具。
- en: We can try to write an interactive shell for our `mymail` program; it won't
    read real email, but we will fake the behavior enough to showcase a fully featured
    shell.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试为我们的`mymail`程序编写一个交互式shell；它不会读取真实的电子邮件，但我们将伪造足够的行为来展示一个功能齐全的shell。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的步骤如下：
- en: 'The `cmd.Cmd` class allows us to start interactive shells and implement commands
    based on them:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmd.Cmd`类允许我们启动交互式shell并基于它们实现命令：'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Starting our script should provide a nice interactive prompt:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动我们的脚本应该提供一个很好的交互提示：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As stated with documents, we should be able to read the list of emails, read
    a specific email, and reply to the currently open one:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如文档所述，我们应该能够读取邮件列表，阅读特定的邮件，并回复当前打开的邮件：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can rely on the more advanced send commands, which also provide autocompletion
    of recipients for our new emails:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以依赖更高级的发送命令，这些命令还为我们的新邮件提供了收件人的自动完成：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `cmd.Cmd` loop prints the `prompt` we provided through the `prompt` class
    property and awaits a command. Anything we write after `prompt` is split and the
    first part is looked up against the list of methods provided by our own subclass.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd.Cmd`循环通过`prompt`类属性打印我们提供的`prompt`并等待命令。在`prompt`之后写的任何东西都会被分割，然后第一部分会被查找我们自己的子类提供的方法列表。'
- en: Whenever a command is provided, `cmd.Cmd.cmdloop` calls the associated method
    and then starts again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每当提供一个命令时，`cmd.Cmd.cmdloop`调用相关的方法，然后重新开始。
- en: Any method starting with `do_*` is a command, and the part after `do_` is the
    command name. Any docstring of the method implementing the command is then reported
    in our tool's documentation if the `help` command is used within the interactive
    prompt.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以`do_*`开头的方法都是一个命令，`do_`之后的部分是命令名称。如果在交互提示中使用`help`命令，则实现命令的方法的docstring将被报告在我们工具的文档中。
- en: The `Cmd` class provides no facility to parse arguments for a command, so if
    your command has more than a single argument, your have to split them yourself.
    In our case, we relied on `shlex` so that the user has control over how the arguments
    should be split. This allowed us to parse subjects and messages while providing
    a way to include spaces in them. Otherwise, we would have no way to know where
    the subject ends and the message starts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmd`类不提供解析命令参数的功能，因此，如果您的命令有多个参数，您必须自己拆分它们。在我们的情况下，我们依赖于`shlex`，以便用户可以控制参数的拆分方式。这使我们能够解析主题和消息，同时提供了一种包含空格的方法。否则，我们将无法知道主题在哪里结束，消息从哪里开始。'
- en: The `send` command also supports autocompleting recipients, through the `complete_send`
    method. If a `complete_*` method is provided, it is called by `Cmd` when *Tab*
    is pressed to autocomplete command arguments. The method receives the text that
    needs to be completed and some details about the whole line of text and the current
    position of the cursor. As nothing is done to parse the arguments, the position
    of the cursors and the whole line of text can help in providing different autocomplete
    behaviors for each argument. In our case, we could only autocomplete the recipient,
    so there was no need to distinguish between the various arguments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`命令还支持自动完成收件人，通过`complete_send`方法。如果提供了`complete_*`方法，当按下*Tab*自动完成命令参数时，`Cmd`会调用它。该方法接收需要完成的文本以及有关整行文本和光标当前位置的一些详细信息。由于没有对参数进行解析，光标的位置和整行文本可以帮助提供不同的自动完成行为。在我们的情况下，我们只能自动完成收件人，因此无需区分各个参数。'
- en: Last but not least, the `do_EOF` command allows a way to exit the command line
    when *Ctrl* + *D* is pressed. Otherwise, we would have to way to quit the interactive
    shell. That's a convention provided by `Cmd`, and if the `do_EOF` command returns
    `True`, it means that the shell can quit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，`do_EOF`命令允许在按下*Ctrl* + *D*时退出命令行。否则，我们将无法退出交互式shell。这是`Cmd`提供的一个约定，如果`do_EOF`命令返回`True`，则表示shell可以退出。
- en: Sizing terminal text
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整终端文本大小
- en: We saw the *Aligning text* recipe in [Chapter 2](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml),
    *Text Management*, which showcased a possible solution to align text within a
    fixed space. The amount of space available was defined in a `COLSIZE` constant
    that was chosen to fit most terminals with three columns (most terminals fit 80
    columns).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml)的*文本管理*中看到了*对齐文本*的示例，其中展示了在固定空间内对齐文本的可能解决方案。可用空间的大小在`COLSIZE`常量中定义，选择适合大多数终端的三列（大多数终端适合80列）。
- en: But what happened if the user had a terminal window smaller than 60 columns?
    Our alignment would have been broken badly. Also, on very big windows, while the
    text wouldn't be broken, it would have looked too small compared to the window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果用户的终端窗口小于60列会发生什么？我们的对齐会被严重破坏。此外，在非常大的窗口上，虽然文本不会被破坏，但与窗口相比会显得太小。
- en: For this reason, it's usually better to also take into consideration the size
    of the user terminal window whenever displaying text that should retain proper
    alignment properties.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当显示应保持正确对齐属性的文本时，通常最好考虑用户终端窗口的大小。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: 'The `shutil.get_terminal_size` function can give guidance on the terminal window
    size and provide a fallback for cases where it''s not available. We will adapt
    the `maketable` function from the *Aligning text* recipe of [Chapter 2](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml), *Text
    Management* to account for terminal size:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shutil.get_terminal_size`函数可以指导终端窗口的大小，并为无法获得大小的情况提供后备。我们将调整`maketable`函数，以适应终端大小。'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now it is possible to print any text in multiple columns and see it adapt to
    the size of your terminal window:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以在多列中打印任何文本，并看到它适应您的终端窗口的大小：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you try to resize you terminal window and rerun the script, you will notice
    that the text is now always aligned differently to ensure it fits the space available.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试调整终端窗口大小并重新运行脚本，您会注意到文本现在总是以不同的方式对齐，以确保它适合可用的空间。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Instead of relying on a constant for the size of a column, our `maketable` function
    now computes it by taking the terminal width (`term_size.columns`) and dividing
    it by the number of columns to show.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`maketable`函数现在通过获取终端宽度(`term_size.columns`)并将其除以要显示的列数来计算列的大小，而不是依赖于列的大小的常量。
- en: Three characters are always subtracted, because we want to account for the space
    consumed by the `|` separator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 始终减去三个字符，因为我们要考虑`|`分隔符占用的空间。
- en: The size of the terminal (`term_size`) is fetched through `shutil.get_terminal_size`,
    which will look at `stdout` to check the size of the connected terminal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 终端的大小(`term_size`)通过`shutil.get_terminal_size`获取，它将查看`stdout`以检查连接终端的大小。
- en: 'If it fails to retrieve the size or something that is not a terminal is connected
    as the output, then a fallback value is used. You can check the fallback value
    is working as expected simply by redirecting the output of your script to a file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法检索大小或连接的输出不是终端，则使用回退值。您可以通过将脚本的输出重定向到文件来检查回退值是否按预期工作：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you open `output.txt`, you should see that the fallback of 80 characters
    was used as a file doesn't have any specified width.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`output.txt`，您应该会看到80个字符的回退值被用作文件没有指定宽度。
- en: Running system commands
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行系统命令
- en: In some cases, especially when writing system tools, there might be work that
    you need to offload to another command. For example, if you have to decompress
    a file, in many cases, it might make sense to offload the work to `gunzip`/`zip`
    commands instead or trying to reproduce the same behavior in Python.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，特别是在编写系统工具时，可能有一些工作需要转移到另一个命令。例如，如果你需要解压文件，在许多情况下，将工作转移到`gunzip`/`zip`命令可能更合理，而不是尝试在Python中复制相同的行为。
- en: While there are many ways in Python to handle this work, they all have subtle
    differences that might make the life of any developer hard, so it's good to have
    a generally working solution that tackles the most common issues.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有许多处理这项工作的方法，它们都有微妙的差异，可能会让任何开发人员的生活变得困难，因此最好有一个通常有效的解决方案来解决最常见的问题。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Combining the `subprocess` and `shlex` modules allows us to build a solution
    that is reliable in most cases:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合`subprocess`和`shlex`模块使我们能够构建一个在大多数情况下都可靠的解决方案：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s easy to check that it works as expected both for successful and failing
    commands:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很容易检查它是否按预期工作，无论是成功还是失败的命令：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On my system, this properly lists the root of the filesystem and complains
    for a non-existing path:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的系统上，这样可以正确列出文件系统的根目录，并对不存在的路径进行抱怨：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Calling the command itself is performed by the `subprocess.check_output` function,
    but before we can call it, we need to properly split the command in a list containing
    the command itself and its arguments. Relying on `shlex` allows us to drive and
    distinguish how arguments should be split. To see its effect, you can try to compare
    `run('ls / var')` with `run('ls "/ var"')` on any Unix-like system. The first
    will print a lot of files, while the second will complain that the path doesn't
    exist. That's because, in the first case, we actually sent two different arguments
    to `ls` (`/` and `var`), while in the second case, we sent a single argument (`"/
    var"`). If we didn't use `shlex`, there would have been no way to distinguish
    between the two cases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 调用命令本身是由`subprocess.check_output`函数执行的，但在调用之前，我们需要正确地将命令拆分为包含命令本身及其参数的列表。依赖于`shlex`使我们能够驱动和区分参数应如何拆分。要查看其效果，可以尝试在任何类Unix系统上比较`run('ls
    / var')`和`run('ls "/ var"')`。第一个将打印很多文件，而第二个将抱怨路径不存在。这是因为在第一种情况下，我们实际上向`ls`发送了两个不同的参数（`/`和`var`），而在第二种情况下，我们发送了一个单一的参数（`"/
    var"`）。如果我们没有使用`shlex`，就无法区分这两种情况。
- en: Passing the `stderr=subprocess.STDOUT` option then takes care of cases where
    the command fails (which we can detect because the `run` function will return
    a status that is not zero), allowing us to receive the failure description.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`stderr=subprocess.STDOUT`选项，然后处理命令失败的情况（我们可以检测到，因为`run`函数将返回一个非零的状态），允许我们接收失败的描述。
- en: 'The heavy lifting of calling our command is then performed by `subprocess.check_output`,
    which, in fact, is a wrapper around `subprocess.Popen` that will do two things:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的命令的繁重工作由`subprocess.check_output`执行，实际上，它是`subprocess.Popen`的包装器，将执行两件事：
- en: Spawn the required command with `subprocess.Popen`, configured to write the
    output into a pipe, so that the parent process (our own program) can read from
    that pipe and grab the output.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`subprocess.Popen`生成所需的命令，配置为将输出写入管道，以便父进程（我们自己的程序）可以从该管道中读取并获取输出。
- en: Spawn threads to continuously consume from the content of the pipes opened to
    communicate with the child process. This ensures that they never fill up, as,
    if they did, the command we called would just block as it would be unable to write
    any more output.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成线程以持续从打开的管道中消耗内容，以与子进程通信。这确保它们永远不会填满，因为如果它们填满了，我们调用的命令将会被阻塞，因为它将无法再写入任何输出。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One important thing to note is that our `run` function will look for an executable
    that can satisfy the requested command, but won't run any shell expression. So,
    it's not possible to send shell scripts to it. If that's required, the `shell=True`
    option can be passed to `subprocess.check_output`, but that's heavily discouraged
    because it allows the injection of shell code into our program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，我们的`run`函数将寻找一个可满足请求命令的可执行文件，但不会运行任何shell表达式。因此，无法将shell脚本发送给它。如果需要，可以将`shell=True`选项传递给`subprocess.check_output`，但这是极不鼓励的，因为它允许将shell代码注入到我们的程序中。
- en: 'Suppose you want to write a command that prints the content of a directory
    that the user choose; a very simple solution might be the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想编写一个命令，打印用户选择的目录的内容；一个非常简单的解决方案可能是以下内容：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, what would happen if we allowed `shell=True` in `run` and the user provided
    a path such as `/var; rm -rf /`? The user might end up deleting the whole system
    disk, and while this is still limited by the fact that we are relying on `shlex`
    to split arguments, it's still not safe to go through a shell to just run a command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在`run`中允许`shell=True`，并且用户提供了诸如`/var; rm -rf /`这样的路径，会发生什么？用户可能最终会删除整个系统磁盘，尽管我们仍然依赖于`shlex`来分割参数，但通过shell运行命令仍然不安全。
- en: Progress bar
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进度条
- en: When doing work that requires a lot of time (usually anything that requires
    I/O to slower endpoints, such as disk or network), it's a good idea to let your
    user know that you are moving forward and how much work is left to do. Progress
    bars, while not precise, are a very good way to give our users an overview of
    how much work we have done so far and how much we have left to do.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行需要大量时间的工作时（通常是需要I/O到较慢的端点，如磁盘或网络的任何工作），让用户知道您正在前进以及还有多少工作要做是一个好主意。进度条虽然不精确，但是是给我们的用户一个关于我们已经完成了多少工作以及还有多少工作要做的概览的很好的方法。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The recipe steps are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 配方步骤如下：
- en: 'The progress bar itself will be displayed by a decorator, so that we can apply
    it to any function for which we want to report progress with minimum effort:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进度条本身将由装饰器显示，这样我们就可以将其应用到任何我们想要以最小的努力报告进度的函数上。
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we need a function that actually does something for which we might want
    to report progress. For the sake of this example, it will be just a simple function
    that waits a specified amount of time:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要一个实际执行某些操作并且可能想要报告进度的函数。在这个例子中，它将是一个简单的等待指定时间的函数。
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now calling the decorated function should tell us how long it has waited and
    display a progress bar while waiting:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调用被装饰的函数应该告诉我们它等待了多长时间，并在等待时显示一个进度条。
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'While the script is running, you should see your progress bar and the final
    result, looking something like this:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当脚本运行时，您应该看到您的进度条和最终结果，看起来像这样：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All the work is done by the `withprogressbar` function. It acts as a decorator,
    so we can apply it to any function with the `@withprogressbar` syntax.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的工作都由`withprogressbar`函数完成。它充当装饰器，因此我们可以使用`@withprogressbar`语法将其应用到任何函数上。
- en: That is very convenient because the code that reports progress is isolated from
    the code actually doing the work, which allows us to reuse it in many different
    cases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，因为报告进度的代码与实际执行工作的代码是隔离的，这使我们能够在许多不同的情况下重用它。
- en: 'To make a decorator that interacts with the decorated function while the function
    itself is running, we relied on Python generators:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个装饰器，它在函数本身运行时与被装饰的函数交互，我们依赖于Python生成器。
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we call the decorated function (in our example, the `wait` function),
    we will be in fact calling `_func_with_progress` from our decorator. The first
    thing that function will do is call the decorated function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用被装饰的函数（在我们的例子中是`wait`函数）时，实际上我们将调用装饰器中的`_func_with_progress`。该函数将要做的第一件事就是调用被装饰的函数。
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As the decorated function contains a `yield progress` statement, any time it
    wants to display some progress (`yield i` from within the `for` loop in `wait`),
    the function will return `generator`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被装饰的函数包含一个`yield progress`语句，每当它想显示一些进度（在`wait`中的`for`循环中的`yield i`），函数将返回`generator`。
- en: 'Any time the generator faces a `yield progress` statement, we will receive
    it back as the return value of the next function applied to the generator:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每当生成器遇到`yield progress`语句时，我们将其作为应用于生成器的下一个函数的返回值收到。
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can then display our progress and call `next(gen)` again so that the decorated
    function can move forward and return a new progress (the decorated function is
    currently paused at `yield` and won't process until we call `next` on it—that's
    why our whole code is wrapped in `while True:`, to let the function continue forever,
    until it finishes what it has to do).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以显示我们的进度并再次调用`next(gen)`，这样被装饰的函数就可以继续前进并返回新的进度（被装饰的函数当前在`yield`处暂停，直到我们在其上调用`next`，这就是为什么我们的整个代码都包裹在`while
    True:`中的原因，让函数永远继续，直到它完成它要做的工作）。
- en: Once the decorated function finished all the work it had to do, it will raise
    a `StopIteration` exception, which will contain the value returned by the decorated
    function in the `.value` attribute.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当被装饰的函数完成了所有它要做的工作时，它将引发一个`StopIteration`异常，该异常将包含被装饰函数在`.value`属性中返回的值。
- en: As we want to propagate any returned value to the caller, we just return that
    value ourselves. This is especially important if the function that was decorated
    is supposed to return some result of the work it did, such as a `download(url)`
    function that is supposed to return a reference to the downloaded file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望将任何返回值传播给调用者，我们只需自己返回该值。如果被装饰的函数应该返回其完成的工作的某些结果，比如一个`download(url)`函数应该返回对下载文件的引用，这一点尤为重要。
- en: 'Before returning, we print a new line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前，我们打印一个新行。
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This ensures that anything that follows the progress bar won't overlap with
    the progress bar itself, but will be printed on a new line.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了进度条后面的任何内容不会与进度条本身重叠，而是会打印在新的一行上。
- en: 'Then we are left with just displaying the progress bar itself. The core of
    the progress bar part of the recipe is based on just two lines of code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需显示进度条本身。配方中进度条部分的核心基于只有两行代码：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These two lines will ensure that our message is printed on the screen without
    moving to a new line like `print` normally does. Instead, this will move back
    to the beginning of the same line. Try replacing that `'\r'` with `'\n'` and you'll
    immediately see the difference. With `'\r'`, you see a single progress bar moving
    from 0-100%, while with `'\n'`, you will see many progress bars being printed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行将确保我们的消息在屏幕上打印，而不像`print`通常做的那样换行。相反，这将回到同一行的开头。尝试用`'\n'`替换`'\r'`，你会立即看到区别。使用`'\r'`，你会看到一个进度条从0到100%移动，而使用`'\n'`，你会看到许多进度条被打印。
- en: The call to `sys.stdout.flush()` is then required to ensure that the progress
    bar is actually displayed, as usually output is only flushed on a new line, and
    as we are just printing the same line over and over, it wouldn't get flushed unless
    we did it explicitly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要调用`sys.stdout.flush()`来确保进度条实际上被显示出来，因为通常只有在新的一行上才会刷新输出，而我们只是一遍又一遍地打印同一行，除非我们明确地刷新它，否则它不会被刷新。
- en: 'Now that we know how to draw a progress bar and update it, the rest of the
    function is involved in computing the progress bar to display:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何绘制进度条并更新它，函数的其余部分涉及计算要显示的进度条：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we compute `message`, which is what we want to show on screen. The message
    is computed without the progress bar itself, for the progress bar, we are leaving
    a `%s` placeholder so that we can fill it later on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算`message`，这是我们想要显示在屏幕上的内容。消息是在没有进度条本身的情况下计算的，对于进度条，我们留下了一个`%s`占位符，以便稍后填充它。
- en: We do this so that we know how much space is left for the bar itself after we
    displayed the surrounding brackets and the percentage. That value is `bar_width`,
    which is computed by subtracting from the maximum screen width (retrieved with
    `shutil.get_terminal_size()` at the beginning of our function) from the size of
    our message. The three extra characters we have to add will address the space
    that was consumed by `%s` and `%%` in our message, which won't actually be there
    once the message is displayed to screen, as the `%s` will be replaced by the bar
    itself and the `%%` will resolve to a single `%`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了知道在我们显示周围的括号和百分比后，进度条本身还有多少空间。这个值是`bar_width`，它是通过从屏幕宽度的最大值（在我们的函数开始时使用`shutil.get_terminal_size()`检索）中减去我们的消息的大小来计算的。我们必须添加的三个额外字符将解决在我们的消息中`%s`和`%%`消耗的空间，一旦消息显示到屏幕上，`%s`将被进度条本身替换，`%%`将解析为一个单独的`%`。
- en: 'Once we know how much space is available for the bar itself, we compute how
    much of that space should be filled with `''=''` (the already completed part of
    the work) and how much should be filled with empty space, `'' ''` (the part of
    the work that is yet to come). This is achieved by computing the size of the screen
    to fill and match the percentage of our progress:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了进度条本身有多少空间可用，我们就计算出应该用`'='`（已完成的部分）填充多少空间，以及应该用空格`' '`（尚未完成的部分）填充多少空间。这是通过计算要填充和匹配我们的进度的百分比的屏幕大小来实现的：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we know how much to fill with `''=''`, the rest is just empty spaces:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道要用`'='`填充多少，剩下的就只是空格：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, we can build our bar with filled equal signs and `spaceleft` empty spaces:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以用填充的等号和`spaceleft`空格来构建我们的进度条：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the bar is ready, it will be injected into the message that is displayed
    onscreen through the usage of the `%` string formatting operator:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进度条准备好了，它将通过`%`字符串格式化操作符注入到在屏幕上显示的消息中：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you noticed, I mixed two types of string formatting (`str.format` and `%`).
    I did so because I think it makes what's going on with the formatting clearer,
    instead of having to properly account for escaping on each formatting step.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我混合了两种字符串格式化（`str.format`和`%`）。我这样做是因为我认为这样做可以更清楚地说明格式化的过程，而不是在每个格式化步骤上都要正确地进行转义。
- en: Message boxes
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息框
- en: While less common nowadays, there is still a lot of value in being able to create
    interactive character-based user interfaces, especially when just a simple message
    dialog with an OK button or an OK/cancel dialog is needed; you can achieve a better
    result by directing the user's attention to them through a nice-looking text dialog.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在不太常见，但能够创建交互式基于字符的用户界面仍然具有很大的价值，特别是当只需要一个带有“确定”按钮的简单消息对话框或一个带有“确定/取消”对话框时；通过一个漂亮的文本对话框，可以更好地引导用户的注意力。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `curses` library is only included, in Python for Unix systems, so Windows
    users might need a solution, such as CygWin or the Linux Subsystem for Windows,
    to be able to have a Python setup that includes `curses` support.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`curses`库只包括在Unix系统的Python中，因此Windows用户可能需要一个解决方案，比如CygWin或Linux子系统，以便能够拥有包括`curses`支持的Python设置。'
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For this recipe, perform the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，执行以下步骤：
- en: 'We will make a `MessageBox.show` method which we can use to show a message
    box whenever we need it. The `MessageBox` class will be able to show message boxes
    with just OK or OK/cancel buttons:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将制作一个`MessageBox.show`方法，我们可以在需要时用它来显示消息框。`MessageBox`类将能够显示只有确定或确定/取消按钮的消息框。
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then we can use it through the `MessageBox.show` method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以通过`MessageBox.show`方法来使用它：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can even use it to check for user choices:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以用它来检查用户的选择：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The message box is based on the `curses` library, which allows us to draw text-based
    graphics on the screen. When we use the dialog box, we will enter a full-screen
    text graphic mode, and as soon as we exit it, we will recover our previous terminal
    state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 消息框基于`curses`库，它允许我们在屏幕上绘制基于文本的图形。当我们使用对话框时，我们将进入全屏文本图形模式，一旦退出，我们将恢复先前的终端状态。
- en: That allows us to interleave the `MessageBox` class in more complex programs
    without having to write the whole program with `curses`. This is allowed by the
    `curses.wrapper` function that is used in the `MessageBox.show` class method to
    wrap the `MessageBox._show` method that actually shows the box.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在更复杂的程序中交错使用`MessageBox`类，而不必用`curses`编写整个程序。这是由`curses.wrapper`函数允许的，该函数在`MessageBox.show`类方法中用于包装实际显示框的`MessageBox._show`方法。
- en: The message to show is prepared in the `MessageBox` initializer, through the
    `MessageBox._build_message` method, to ensure that it wraps when it's too long
    and that multiple lines of text are properly handled. The height of the message
    box depends on the length of the message and the resulting number of lines, plus
    six lines that we always include to add borders (which consume two lines) and
    the buttons (which consume four lines).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 消息显示是在`MessageBox`初始化程序中准备的，通过`MessageBox._build_message`方法，以确保当消息太长时自动换行，并正确处理多行文本。消息框的高度取决于消息的长度和结果行数，再加上我们始终包括的六行，用于添加边框（占用两行）和按钮（占用四行）。
- en: The `MessageBox._show` method then creates the actual box window, adds a border
    to it, and displays the message within it. Once the message is displayed, we enter `MessageBox._loop`,
    which will wait for the user choice between OK and cancel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`MessageBox._show`方法创建实际的框窗口，为其添加边框，并在其中显示消息。消息显示后，我们进入`MessageBox._loop`，等待用户在OK和取消之间做出选择。
- en: The `MessageBox._loop` method draws all the required buttons with their own
    borders through the `win.derwin` function. Each button is 10-characters wide and
    3-characters tall, and will display itself depending on the value of `allowedspace,` which
    reserves an equal portion of the box space to each button. Then, once the button
    box is drawn, it will check whether the currently displayed button is the selected
    one; if it is, then the label of the button is displayed with bold text. This
    allows the user to know the currently selected choice.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox._loop`方法通过`win.derwin`函数绘制所有必需的按钮及其边框。每个按钮宽10个字符，高3个字符，并根据`allowedspace`的值显示自身，该值为每个按钮保留了相等的框空间。然后，一旦绘制了按钮框，它将检查当前显示的按钮是否为所选按钮；如果是，则使用粗体文本显示按钮的标签。这使用户可以知道当前选择的选项。'
- en: Once both buttons are drawn, we call `win.refresh()` to actually display on
    screen what we've just drawn.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制了两个按钮后，我们调用`win.refresh()`来实际在屏幕上显示我们刚刚绘制的内容。
- en: Then we wait for the user to press any key to update the screen accordingly;
    the left/right arrow keys will switch between the OK/cancel choices, and *Enter*
    will confirm the current choice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们等待用户按任意键以相应地更新屏幕；左/右箭头键将在OK/取消选项之间切换，*Enter*将确认当前选择。
- en: If the the user changes the selected button (by pressing the left or right keys),
    we loop again and redraw the buttons. We only need to redraw the buttons because
    the rest of the screen has not changed; the window border and the message are
    still the same, so there is no need to draw over them. The content of the screen
    is always preserved unless a `win.erase()` method is called, so we never need
    to redraw parts of the screen we don't need to update.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户更改了所选按钮（通过按左或右键），我们将再次循环并重新绘制按钮。我们只需要重新绘制按钮，因为屏幕的其余部分没有改变；窗口边框和消息仍然是相同的，因此无需覆盖它们。屏幕的内容始终保留，除非调用了`win.erase()`方法，因此我们永远不需要重新绘制不需要更新的屏幕部分。
- en: By being smart about this, we could also avoid redrawing the buttons themselves.
    This is because only the cancel/OK text needs to be redrawn when it changes from
    bold to normal and vice versa.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们还可以避免重新绘制按钮本身。这是因为只有取消/确定文本在从粗体到普通体和反之时需要重新绘制。
- en: Once the user presses the *Enter* key, we quit the loop and return the currently
    selected choice between OK and cancel. That allows the caller to act according
    to the user choice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用户按下*Enter*键后，我们退出循环，并返回当前选择的OK和取消之间的选择。这允许调用者根据用户的选择采取行动。
- en: Input box
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入框
- en: When writing console-based software, it is sometimes necessary to ask users
    to provide long text inputs that can't easily be provided through command options.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于控制台的软件时，有时需要要求用户提供无法通过命令选项轻松提供的长文本输入。
- en: There are few examples of this in the Unix world, such as editing `crontab`
    or tweaking multiple configuration options at once. Most of them rely on starting
    a fully-fledged third-party editor, such as **nano** or **vim**, but it's possible
    to easily roll a solution that in many cases will suffice with just the Python
    standard library, such that our tools can ask long or complex user input.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix世界中有一些这样的例子，比如编辑`crontab`或一次调整多个配置选项。其中大多数依赖于启动一个完整的第三方编辑器，比如**nano**或**vim**，但是可以很容易地使用Python标准库滚动一个解决方案，这在许多情况下将足够满足我们的工具需要长或复杂的用户输入。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `curses` library is only included in Python for Unix systems, so Windows
    users might need a solution, such as CygWin or the Linux Subsystem for Windows,
    to be able to have a Python setup that includes `curses` support.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`curses`库仅包含在Unix系统的Python中，因此Windows用户可能需要一个解决方案，例如CygWin或Linux子系统，以便能够拥有包括`curses`支持的Python设置。'
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, perform the following steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，执行以下步骤：
- en: 'The Python standard library provides a `curses.textpad` module that has the
    foundation of a multiline text editor with `emacs`, such as key bindings. We just
    need to extend it a little to add some required behaviors and fixes:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python标准库提供了一个`curses.textpad`模块，其中包含一个带有`emacs`的多行文本编辑器的基础，例如键绑定。我们只需要稍微扩展它以添加一些所需的行为和修复：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we can read input from the user:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以从用户那里读取输入：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can even ask it to edit an existing text:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以要求它编辑现有文本：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Everything starts with the `TextInput._show` method, which prepares two windows;
    the first draws the help text (`'Insert your name:'` in our example) and a border
    box for the text area.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于`TextInput._show`方法，该方法准备了两个窗口；第一个绘制帮助文本（在我们的示例中为'插入您的姓名：'），以及文本区域的边框框。
- en: Once those are drawn, it creates a new window dedicated to `Textbox` as the
    textbox will be freely inserting, removing, and editing the content of that window.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦绘制完成，它会创建一个专门用于`Textbox`的新窗口，因为文本框将自由地插入、删除和编辑该窗口的内容。
- en: If we have existing content (`content= argument`), the `TextInput._load` function
    takes care of inserting it into the textbox before moving forward with editing.
    Each character in the provided content is injected into the textbox window through
    the `Textbox._insert_printable_char` function.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有现有的内容（`content=参数`），`TextInput._load`函数会负责在继续编辑之前将其插入到文本框中。提供的内容中的每个字符都通过`Textbox._insert_printable_char`函数注入到文本框窗口中。
- en: Then we can finally enter the edit loop (the `TextInput._edit` method), where
    we listen for key presses and react accordingly. Actually, most of the work is
    already done for us by `Textbox.do_command`, so we just need to forward the pressed
    key to it to insert the characters into our text or react to a special command.
    The only special part of this method is that we check for character 127, which
    is *Backspace*, and replace it with `curses.KEY_BACKSPACE`, as not all terminals
    send the same codes when the *Backspace* key is pressed. Once the character is
    handled by `do_command`, we can refresh the window so that any new text appears
    and we loop again.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们最终可以进入编辑循环（`TextInput._edit`方法），在那里我们监听按键并做出相应反应。实际上，`Textbox.do_command`已经为我们完成了大部分工作，因此我们只需要将按下的键转发给它，以将字符插入到我们的文本中或对特殊命令做出反应。这个方法的特殊部分是我们检查字符127，它是*Backspace*，并将其替换为`curses.KEY_BACKSPACE`，因为并非所有终端在按下*Backspace*键时发送相同的代码。一旦字符被`do_command`处理，我们就可以刷新窗口，以便任何新文本出现并再次循环。
- en: When the user presses *Ctrl* + *G*, the editor will consider the text complete
    and will quit the edit loop. Before doing so, we call `Textbox.gather` to fetch
    the entire contents of the text editor and send it back to the caller.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Ctrl* + *G*时，编辑器将认为文本已完成并退出编辑循环。在这之前，我们调用`Textbox.gather`来获取文本编辑器的全部内容并将其发送回调用者。
- en: One thing to note is that the content is actually fetched from the content of
    the `curses` window. So, it actually includes all the empty space you can see
    on your screen. For this reason, the `Textbox.gather` method will strip empty
    space to avoid sending you back a response that is mostly empty space surrounding
    your text. This is quite clear if you try to write something that includes multiple
    empty lines; they will all be stripped together with the rest of the empty space.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，内容实际上是从`curses`窗口的内容中获取的。因此，它实际上包括您屏幕上看到的所有空白空间。因此，`Textbox.gather`方法将剥离空白空间，以避免将大部分空白空间包围您的文本发送回给您。如果您尝试编写包含多个空行的内容，这一点就非常明显；它们将与其余空白空间一起被剥离。
