- en: Working with Forensic Evidence Container Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字取证容器配方
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Opening acquisitions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开收购
- en: Gathering acquisition and media information
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集收购和媒体信息
- en: Iterating through files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历文件
- en: Processing files within the container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理容器内的文件
- en: Searching for hashes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索哈希
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The Sleuth Kit, and its Python bindings `pytsk3`, is perhaps the most well-known
    Python forensic library. This library offers rich support for accessing and manipulating
    filesystems. And with the help of supporting libraries, such as `pyewf`, they
    can be used to work with common forensic containers such as EnCase's popular `E01`
    format. Without these libraries (and many others), we would be inherently more
    limited by what can be accomplished with Python in forensics. Due to its lofty
    goal as an all-in-one filesystem analysis tool, `pytsk3` is perhaps the most complicated
    library we will work with in this book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Sleuth Kit及其Python绑定`pytsk3`可能是最知名的Python数字取证库。该库提供了丰富的支持，用于访问和操作文件系统。借助支持库（如`pyewf`），它们可以用于处理EnCase流行的`E01`格式等常见数字取证容器。如果没有这些库（以及许多其他库），我们在数字取证中所能完成的工作将受到更多限制。由于其作为一体化文件系统分析工具的宏伟目标，`pytsk3`可能是我们在本书中使用的最复杂的库。
- en: For this reason, we have dedicated a number of recipes exploring the fundamentals
    of this library. Up to this point, recipes have been mainly focused on loose file
    support. That convention ends here. We will routinely use this library going forward
    to interact with forensic evidence. Understanding how to interact with forensic
    containers will take your Python forensic capabilities to the next level.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，我们专门制定了一些配方，探索了这个库的基本原理。到目前为止，配方主要集中在松散文件支持上。这种惯例到此为止。我们将会经常使用这个库来与数字取证证据进行交互。了解如何与数字取证容器进行交互将使您的Python数字取证能力提升到一个新的水平。
- en: 'In this chapter, we will learn how to install `pytsk3` and `pyewf`, two libraries
    that will allow us to leverage the Sleuth Kit and `E01` image support, respectively.
    Additionally, we will learn how to perform basic tasks, such as accessing and
    printing a partition table, iterating through a filesystem, exporting files by
    extension, and searching for known bad hashes in an evidence container. You will
    learn about:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何安装`pytsk3`和`pyewf`，这两个库将允许我们利用Sleuth Kit和`E01`镜像支持。此外，我们还将学习如何执行基本任务，如访问和打印分区表，遍历文件系统，按扩展名导出文件，以及在数字取证容器中搜索已知的不良哈希。您将学习以下内容：
- en: Installing and setting up `pytsk3` and `pyewf`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和设置`pytsk3`和`pyewf`
- en: Opening forensic acquisitions such as `raw` and `E01` files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开数字取证收购，如`raw`和`E01`文件
- en: Extracting partition table data and `E01` metadata
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取分区表数据和`E01`元数据
- en: Recursing through active files and creating an active file listing spreadsheet
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归遍历活动文件并创建活动文件列表电子表格
- en: Exporting files from the evidence container by file extension
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按文件扩展名从数字取证容器中导出文件
- en: Searching for known bad hashes in an evidence container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字取证容器中搜索已知的不良哈希
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)下载本章的代码包。
- en: Opening acquisitions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开收购
- en: 'Recipe Difficulty: Medium'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：中等
- en: 'Python Version: 2.7'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7
- en: 'Operating System: Linux'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Linux
- en: 'With `pyewf` and `pytsk3` comes a whole new set of tools and operations we
    must first learn. In this recipe, we will start with the basics: opening an evidence
    container. This recipe supports `raw` and `E01` images. Note that unlike our previous
    scripts, these recipes will use Python 2.X due to some bugs found while working
    with the Python 3.X version of these libraries. That said, the main logic would
    not differ between the two versions and could easily be ported. Before we learn
    to open the container, we need to set up our environment. We will explore this
    in the next section.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pyewf`和`pytsk3`将带来一整套新的工具和操作，我们必须首先学习。在这个配方中，我们将从基础知识开始：打开数字取证容器。这个配方支持`raw`和`E01`镜像。请注意，与我们之前的脚本不同，由于在使用这些库的Python
    3.X版本时发现了一些错误，这些配方将使用Python 2.X。也就是说，主要逻辑在两个版本之间并没有区别，可以很容易地移植。在学习如何打开容器之前，我们需要设置我们的环境。我们将在下一节中探讨这个问题。
- en: Getting started
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Excluding a few scripts, we have been OS agnostic for the majority of this
    cookbook. Here, however, we will specifically provide instructions for building
    on Ubuntu 16.04.2\. With a fresh install of Ubuntu, execute the following commands
    to install necessary dependencies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些脚本之外，我们在本书的大部分内容中都是与操作系统无关的。然而，在这里，我们将专门提供在Ubuntu 16.04.2上构建的说明。在Ubuntu的新安装中，执行以下命令以安装必要的依赖项：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Beyond the two previously mentioned libraries (`pytsk3` and `pyewf`), we will
    also be using the third-party module `tabulate` to print tables to the console.
    As that is the easiest module to install, let''s complete that task first by executing
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的两个库（`pytsk3`和`pyewf`）之外，我们还将使用第三方模块`tabulate`来在控制台打印表格。由于这是最容易安装的模块，让我们首先完成这个任务，执行以下操作：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To learn more about the tabulate library, visit [https://pypi.python.org/pypi/tabulate](https://pypi.python.org/pypi/tabulate).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于tabulate库的信息，请访问[https://pypi.python.org/pypi/tabulate](https://pypi.python.org/pypi/tabulate)。
- en: 'Believe it or not, we can install `pytsk3` using `pip` as well:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们也可以使用`pip`安装`pytsk3`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To learn more about the `pytsk3` library, visit [https://github.com/py4n6/pytsk.](https://github.com/py4n6/pytsk)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pytsk3`库的信息，请访问[https://github.com/py4n6/pytsk.](https://github.com/py4n6/pytsk)
- en: 'Lastly, for `pyewf`, we must take a slightly more circuitous route and install
    it from its GitHub repository, [https://github.com/libyal/libewf/releases](https://github.com/libyal/libewf/releases).
    These recipes were written using the `libewf-experimental-20170605` release, and
    we recommend you install that version here. Once the package has been downloaded
    and extracted, open a Command Prompt in the extracted directory and execute the
    following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`pyewf`，我们必须采取稍微绕弯的方法，从其GitHub存储库中安装，[https://github.com/libyal/libewf/releases](https://github.com/libyal/libewf/releases)。这些配方是使用`libewf-experimental-20170605`版本编写的，我们建议您在这里安装该版本。一旦包被下载并解压，打开提取目录中的命令提示符，并执行以下操作：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To learn more about the `pyewf` library, visit : [https://github.com/libyal/libewf.](https://github.com/libyal/libewf)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pyewf`库的信息，请访问：[https://github.com/libyal/libewf.](https://github.com/libyal/libewf)
- en: It goes without saying that for this script you will need a `raw` or `E01` evidence
    file to run these recipes against. For the first script, we recommend using a
    logical image, such as `fat-img-kw.dd` from [http://dftt.sourceforge.net/test2/index.html](http://dftt.sourceforge.net/test2/index.html).
    The reason is that this first script will lack some necessary logic to handle
    physical disk images and their partitions. We will introduce this functionality
    in the *Gathering acquisition and media information* recipe.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，对于这个脚本，您需要一个`raw`或`E01`证据文件来运行这些配方。对于第一个脚本，我们建议使用逻辑图像，比如来自[http://dftt.sourceforge.net/test2/index.html](http://dftt.sourceforge.net/test2/index.html)的`fat-img-kw.dd`。原因是这个第一个脚本将缺少一些处理物理磁盘图像及其分区所需的必要逻辑。我们将在*收集获取和媒体信息*配方中介绍这个功能。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We employ the following methodology to open forensic evidence containers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用以下方法来打开法证证据容器：
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定证据容器是`raw`图像还是`E01`容器。
- en: Access the image using `pytsk3`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pytsk3`访问图像。
- en: Print a table of the root-level folders and files to the console.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台上打印根级文件夹和文件的表格。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We import a number of libraries to assist with argument parsing, handling evidence
    containers and filesystems, and creating tabular console data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了一些库来帮助解析参数、处理证据容器和文件系统，并创建表格式的控制台数据。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This recipe's command-line handler takes two positional arguments, `EVIDENCE_FILE`
    and `TYPE`, which represent the path to the evidence file and the type of evidence
    file (that is, `raw` or `ewf`). Note that for segmented `E01` files, you only
    need to supply the path to the first `E01` (with the assumption that the other
    splits are in the same directory). After performing some input validation on the
    evidence file, we supply the `main()` function with the two provided inputs and
    begin executing the script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受两个位置参数，`EVIDENCE_FILE`和`TYPE`，它们代表证据文件的路径和证据文件的类型（即`raw`或`ewf`）。请注意，对于分段的`E01`文件，您只需要提供第一个`E01`的路径（假设其他分段在同一个目录中）。在对证据文件进行一些输入验证后，我们将提供两个输入给`main()`函数，并开始执行脚本。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `main()` function, we first check what type of evidence file we are working
    with. If it is an `E01` container, we need to first use `pyewf` to create a handle
    before we can access its contents with `pytsk3`. With a `raw` image, we can directly
    access its contents with `pytsk3` without needing to perform this intermediate
    step first.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们首先检查我们正在处理的证据文件的类型。如果是`E01`容器，我们需要首先使用`pyewf`创建一个句柄，然后才能使用`pytsk3`访问其内容。对于`raw`图像，我们可以直接使用`pytsk3`访问其内容，而无需先执行这个中间步骤。
- en: The `pyewf.glob()` method is used here to combine all segments of the `E01`
    container, if there are any, and store the segment names in a list. Once we have
    the list of filenames, we can create the `E01` handle object. We can then use
    this object to open the `filenames`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用`pyewf.glob()`方法来组合`E01`容器的所有段，如果有的话，并将段的名称存储在一个列表中。一旦我们有了文件名列表，我们就可以创建`E01`句柄对象。然后我们可以使用这个对象来打开`filenames`。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we must pass the `ewf_handle` to the `EWFImgInfo` class, which will create
    the `pytsk3` object. The else statement here is for `raw` images that can use
    the `pytsk3.Img_Info` function to achieve the same task. Let's now look at the
    `EWFImgInfo` class to understand how EWF files are processed slightly differently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将`ewf_handle`传递给`EWFImgInfo`类，该类将创建`pytsk3`对象。这里的else语句是为了`raw`图像，可以使用`pytsk3.Img_Info`函数来实现相同的任务。现在让我们看看`EWFImgInfo`类，了解EWF文件是如何稍有不同地处理的。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code for this component of the script is from the *Combining pyewf* *with
    pytsk3* section of the Python development page for `pyewf`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本组件的代码来自`pyewf`的Python开发页面的*将pyewf与pytsk3结合使用*部分。
- en: Learn more about `pyewf` functions, visit [https://github.com/libyal/libewf/wiki/Development](https://github.com/libyal/libewf/wiki/Development).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于`pyewf`函数的信息，请访问[https://github.com/libyal/libewf/wiki/Development](https://github.com/libyal/libewf/wiki/Development)。
- en: This `EWFImgInfo` class inherits from the `pytsk3.Img_Info` base class and is
    of the type `TSK_IMG_TYPE_EXTERNAL`. It is important to note that the three functions
    defined next, `close()`, `read()`, and `get_size(),` are all required by `pytsk3`
    to interact with the evidence container appropriately. With this simple class
    created, we can now use `pytsk3` with any supplied `E01` file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`EWFImgInfo`类继承自`pytsk3.Img_Info`基类，属于`TSK_IMG_TYPE_EXTERNAL`类型。重要的是要注意，接下来定义的三个函数，`close()`、`read()`和`get_size()`，都是`pytsk3`要求的，以便与证据容器进行适当的交互。有了这个简单的类，我们现在可以使用`pytsk3`来处理任何提供的`E01`文件。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Back in the `main()` function, we have successfully created our `pytsk3` handler
    for either `raw` or `E01` images. We can now begin accessing the filesystem. As
    mentioned, this script is designed to work with logical images and not physical
    images. We will introduce support for physical images in the next recipe. Accessing
    the filesystem is really simple; we do so by calling the `FS_Info()` function
    on the `pytsk3` handle.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main()`函数，我们已经成功地为`raw`或`E01`镜像创建了`pytsk3`处理程序。现在我们可以开始访问文件系统。如前所述，此脚本旨在处理逻辑图像而不是物理图像。我们将在下一个步骤中引入对物理图像的支持。访问文件系统非常简单；我们通过在`pytsk3`处理程序上调用`FS_Info()`函数来实现。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With access to the filesystem, we can iterate through the folders and files
    in the root directory. First, we access the root using the `open_dir()` method
    on the filesystem and specifying the root directory, `**/**`, as the input. Next,
    we create a nested list structure that will hold the table content, which we will
    later print to the console using `tabulate`. The first element of this list is
    the headers of that table.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对文件系统的访问权限，我们可以遍历根目录中的文件夹和文件。首先，我们使用文件系统上的`open_dir()`方法，并指定根目录`**/**`作为输入来访问根目录。接下来，我们创建一个嵌套的列表结构，用于保存表格内容，稍后我们将使用`tabulate`将其打印到控制台。这个列表的第一个元素是表格的标题。
- en: Following that, we'll begin to iterate through the image as we would with any
    Python iterable object. There are a variety of attributes and functions for each
    object, and we begin to use them here. First, we extract the name of the object
    using the `f.info.name.name` attribute. We then check if we are dealing with a
    directory or a file using the `f.info.meta.type` attribute. If this is equal to
    the built-in `TSK_FS_META_TYPE_DIR` object, then we set the `f_type` variable
    to `DIR`; otherwise, to `FILE`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将开始遍历图像，就像处理任何Python可迭代对象一样。每个对象都有各种属性和函数，我们从这里开始使用它们。首先，我们使用`f.info.name.name`属性提取对象的名称。然后，我们使用`f.info.meta.type`属性检查我们处理的是目录还是文件。如果这等于内置的`TSK_FS_META_TYPE_DIR`对象，则将`f_type`变量设置为`DIR`；否则，设置为`FILE`。
- en: Lastly, we use a few more attributes to extract the directory or file size and
    create and modify timestamps. Be aware that object timestamps are stored in `Unix`
    time and must be converted if you would like to display them in a human-readable
    format. With these attributes extracted, we append the data to the `table` list
    and continue on to the next object. Once we have finished processing all objects
    in the root folder, we use `tabulate` to print the data to the console. This is
    accomplished in one line by supplying the `tabulate()` method with the list and
    setting the `headers` keyword argument to `firstrow` to indicate that the first
    element in the list should be used as the table header.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用更多的属性来提取目录或文件的大小，并创建和修改时间戳。请注意，对象时间戳存储在`Unix`时间中，如果您想以人类可读的格式显示它们，必须进行转换。提取了这些属性后，我们将数据附加到`table`列表中，并继续处理下一个对象。一旦我们完成了对根文件夹中所有对象的处理，我们就使用`tabulate`将数据打印到控制台。通过向`tabulate()`方法提供列表并将`headers`关键字参数设置为`firstrow`，以指示应使用列表中的第一个元素作为表头，可以在一行中完成此操作。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run the script, we can learn about the files and folders at the root
    of the evidence container as seen in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行脚本时，我们可以了解到在证据容器的根目录中看到的文件和文件夹，如下截图所示：
- en: '![](../images/00090.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00090.jpeg)'
- en: Gathering acquisition and media information
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集获取和媒体信息
- en: 'Recipe Difficulty: Medium'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：中等
- en: 'Python Version: 2.7'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7
- en: 'Operating System: Linux'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Linux
- en: In this recipe, we learn how to view and print the partition table using `tabulate`.
    Additionally, for `E01` containers, we will print `E01` acquisition and container
    metadata stored in the evidence file. Oftentimes, we will be working with a physical
    disk image of a given machine. In pretty much any process going forward, we will
    need to iterate through the different partitions (or a user-selected partition)
    to get a handle on the filesystem and its files. Therefore, this recipe is of
    critical importance as we build upon our burgeoning understanding of the Sleuth
    Kit and its bevy of features.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们学习如何使用`tabulate`查看和打印分区表。此外，对于`E01`容器，我们将打印存储在证据文件中的`E01`获取和容器元数据。通常，我们将使用给定机器的物理磁盘镜像。在接下来的任何过程中，我们都需要遍历不同的分区（或用户选择的分区）来获取文件系统及其文件的处理。因此，这个食谱对于我们建立对Sleuth
    Kit及其众多功能的理解至关重要。
- en: Getting started
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the build environment and setup details for `pytsk3`, `pyewf`,
    and `tabulate`. All other libraries used in this script are present in Python's
    standard library.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pytsk3`、`pyewf`和`tabulate`的构建环境和设置详细信息，请参阅*打开获取*食谱中的*入门*部分。此脚本中使用的所有其他库都包含在Python的标准库中。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The recipe follows these basic steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱遵循以下基本步骤：
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定证据容器是`raw`镜像还是`E01`容器。
- en: Access the image using `pytsk3`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pytsk3`访问镜像。
- en: If applicable, print `E01` metadata to the console.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果适用，将`E01`元数据打印到控制台。
- en: Print partition table data to the console.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分区表数据打印到控制台。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We import a number of libraries to assist with argument parsing, handling evidence
    containers and filesystems, and creating tabular console data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了许多库来帮助解析参数、处理证据容器和文件系统，并创建表格式的控制台数据。
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This recipe's command-line handler takes two positional arguments, `EVIDENCE_FILE`
    and `TYPE`, which represent the path to the evidence file and the type of evidence
    file. Additionally, if the user is experiencing difficulties with the evidence
    file, they can use the optional `p` switch to manually supply the partition. This
    switch should not be necessary for the most part but has been added as a precaution.
    After performing input validation checks, we pass the three arguments to the `main()`
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受两个位置参数，`EVIDENCE_FILE`和`TYPE`，它们代表证据文件的路径和证据文件的类型。此外，如果用户在处理证据文件时遇到困难，他们可以使用可选的`p`开关手动提供分区。这个开关在大多数情况下不应该是必要的，但作为一种预防措施已经添加。在执行输入验证检查后，我们将这三个参数传递给`main（）`函数。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `main()` function is substantially similar, at least initially, to the previous
    recipe. We must first create the `pyewf` handle and then use the `EWFImgInfo`
    class to create, as shown previously in the `pytsk3` handle. If you would like
    to learn more about the `EWFImgInfo` class, refer to the *Opening Acquisitions*
    recipe. However, note that we have added an additional line calling the `e01_metadata()`
    function to print `E01` metadata to the console. Let's explore that function now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`main（）`函数在很大程度上与之前的配方相似，至少最初是这样。我们必须首先创建`pyewf`句柄，然后使用`EWFImgInfo`类来创建，如前面在`pytsk3`句柄中所示。如果您想了解更多关于`EWFImgInfo`类的信息，请参阅*打开获取*配方。但是，请注意，我们添加了一个额外的行调用`e01_metadata（）`函数来将`E01`元数据打印到控制台。现在让我们来探索一下这个函数。'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `e01_metadata()` function primarily relies on the `get_header_values()`
    and `get_hash_values()` methods to acquire `E01`-specific metadata. The `get_header_values()`
    method returns a dictionary of `key-value` pairs for various types of acquisition
    and media metadata. We use a loop to iterate through this dictionary and print
    the `key-value` pairs to the console.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`e01_metadata（）`函数主要依赖于`get_header_values（）`和`get_hash_values（）`方法来获取`E01`特定的元数据。`get_header_values（）`方法返回各种类型的获取和媒体元数据的`键值`对字典。我们使用循环来遍历这个字典，并将`键值`对打印到控制台。'
- en: Similarly, we use a loop with the `hashes` dictionary to print stored acquisition
    hashes of the image to the console. Lastly, we call an attribute and a few functions
    to print acquisition size metadata.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`hashes`字典的循环将图像的存储获取哈希打印到控制台。最后，我们调用一个属性和一些函数来打印获取大小的元数据。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that covered, we can now return to the `main()` function. Recall that
    in the first recipe of this chapter, we did not create support for physical acquisitions
    (which was totally on purpose). Now, however, we add that support in using the
    `Volume_Info()` function. While `pytsk3` can be daunting at first, appreciate
    the consistency in naming conventions used in the major functions we have introduced
    so far: `Img_Info`, `FS_Info`, and `Volume_Info`. These three functions are vital
    in order to access the contents of the evidence container. In this recipe, we
    will not be using the `FS_Info()` function as the purpose here is to only print
    out the partition table.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在可以回到`main（）`函数。回想一下，在本章的第一个配方中，我们没有为物理获取创建支持（这完全是有意的）。然而，现在，我们使用`Volume_Info（）`函数添加了对此的支持。虽然`pytsk3`一开始可能令人生畏，但要欣赏到目前为止我们介绍的主要函数中使用的命名约定的一致性：`Img_Info`、`FS_Info`和`Volume_Info`。这三个函数对于访问证据容器的内容至关重要。在这个配方中，我们不会使用`FS_Info（）`函数，因为这里的目的只是打印分区表。
- en: We attempt to access the volume info in a `try-except` block. First, we check
    if the `p` switch was supplied by the user and, if so, assign the attribute for
    that partition type to a variable. Then we supply that, along with the `pytsk3`
    handle, in the `Volume_Info` method. Otherwise, if no partition was specified,
    we call the `Volume_Info` method and supply it with just the `pytsk3` handle object.
    If we receive an `IOError` attempting to do this, we catch the exception as `e`
    and print it to the console before exiting. If we are able to access the volume
    info, we pass this onto the `part_metadata()` function to print the partition
    data to the console.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在`try-except`块中访问卷信息。首先，我们检查用户是否提供了`p`开关，如果是，则将该分区类型的属性分配给一个变量。然后，我们将它与`pytsk3`句柄一起提供给`Volume_Info`方法。否则，如果没有指定分区，我们调用`Volume_Info`方法，并只提供`pytsk3`句柄对象。如果我们尝试这样做时收到`IOError`，我们将捕获异常作为`e`并将其打印到控制台，然后退出。如果我们能够访问卷信息，我们将其传递给`part_metadata（）`函数，以将分区数据打印到控制台。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `part_metadata()` function is relatively light on logic. We create a nested
    list structure, as seen in the previous recipe, with the first element representing
    the eventual table header. Next, we iterate through the volume object and append
    the partition address, type, offset, and length to the `table` list. Once we have
    iterated through the partitions, we use `tabulate` to print a table of this data
    to the console using `firstrow` as the table header.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`part_metadata（）`函数在逻辑上相对较轻。我们创建一个嵌套的列表结构，如前面的配方中所见，第一个元素代表最终的表头。接下来，我们遍历卷对象，并将分区地址、类型、偏移量和长度附加到`table`列表中。一旦我们遍历了分区，我们使用`tabulate`使用`firstrow`作为表头将这些数据的表格打印到控制台。'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When running this code, we can review information about the acquisition and
    partition information in the console, if present:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，如果存在，我们可以在控制台中查看有关获取和分区信息的信息：
- en: '![](../images/00091.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00091.jpeg)'
- en: Iterating through files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历文件
- en: 'Recipe Difficulty: Medium'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：中等
- en: 'Python Version: 2.7'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7
- en: 'Operating System: Linux'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Linux
- en: In this recipe, we learn how to recurse through the filesystem and create an
    active file listing. Oftentimes, one of the first questions we, as the forensic
    examiner, are often asked is "What data is on the device?". An active file listing
    comes in handy here. Creating a file listing of loose files is a very straightforward
    task in Python. However, this will be slightly more complicated because we are
    working with a forensic image rather than loose files. This recipe will be a cornerstone
    for future scripts as it will allow us to recursively access and process every
    file in the image. As you may have noticed, this chapter's recipes are building
    upon each other as each function we develop it becomes necessary to explore the
    image further. In a similar way, this recipe will become integral in future recipes
    to iterate through directories and process files.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们学习如何递归遍历文件系统并创建一个活动文件列表。作为法庭鉴定人，我们经常被问到的第一个问题之一是“设备上有什么数据？”。在这里，活动文件列表非常有用。在Python中，创建松散文件的文件列表是一个非常简单的任务。然而，这将会稍微复杂一些，因为我们处理的是法庭图像而不是松散文件。这个配方将成为未来脚本的基石，因为它将允许我们递归访问和处理图像中的每个文件。正如您可能已经注意到的，本章的配方是相互建立的，因为我们开发的每个函数都需要进一步探索图像。类似地，这个配方将成为未来配方中的一个重要部分，用于迭代目录并处理文件。
- en: Getting started
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the build environment and setup details for `pytsk3` and `pyewf`.
    All other libraries used in this script are present in Python's standard library.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pytsk3`和`pyewf`的构建环境和设置详细信息，请参考*开始*部分中的*打开获取*配方。此脚本中使用的所有其他库都包含在Python的标准库中。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We perform the following steps in this recipe:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中执行以下步骤：
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定证据容器是`raw`图像还是`E01`容器。
- en: Access the forensic image using `pytsk3`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pytsk3`访问法庭图像。
- en: Recurse through all directories in each partition.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归遍历每个分区中的所有目录。
- en: Store file metadata in a list.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件元数据存储在列表中。
- en: Write the `active` file list to CSV.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“active”文件列表写入CSV。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We import a number of libraries to assist with argument parsing, parsing dates,
    creating CSV spreadsheets, and handling evidence containers and filesystems.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了许多库来帮助解析参数、解析日期、创建CSV电子表格，以及处理证据容器和文件系统。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This recipe's command-line handler takes three positional arguments, `EVIDENCE_FILE`,
    `TYPE`, and `OUTPUT_CSV`, which represent the path to the evidence file, the type
    of evidence file, and the output CSV file, respectively. Similar to the previous
    recipe, the optional `p` switch can be supplied to specify a partition type. We
    use the `os.path.dirname()` method to extract the desired output directory path
    for the CSV file and, with the `os.makedirs()` function, create the necessary
    output directories if they do not exist.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受三个位置参数，`EVIDENCE_FILE`、`TYPE`和`OUTPUT_CSV`，分别代表证据文件的路径、证据文件的类型和输出CSV文件。与上一个配方类似，可以提供可选的`p`开关来指定分区类型。我们使用`os.path.dirname()`方法来提取CSV文件的所需输出目录路径，并使用`os.makedirs()`函数，如果不存在，则创建必要的输出目录。
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once we have validated the input evidence file by checking that it exists and
    is a file, the four arguments are passed to the `main()` function. If there is
    an issue with initial validation of the input, an error is printed to the console
    before the script exits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过检查输入证据文件是否存在并且是一个文件来验证了输入证据文件，四个参数将被传递给`main()`函数。如果在输入的初始验证中出现问题，脚本将在退出之前将错误打印到控制台。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `main()` function, we instantiate the volume variable with `None` to
    avoid errors referencing it later in the script. After printing a status message
    to the console, we check if the evidence type is an `E01` to properly process
    it and create a valid `pyewf` handle, as demonstrated in more detail in the *Opening
    Acquisitions* recipe. Refer to that recipe for more details as this part of the
    function is identical. The end result is the creation of the `pytsk3` handle,
    `img_info`, for the user-supplied evidence file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们用`None`实例化卷变量，以避免在脚本后面引用它时出错。在控制台打印状态消息后，我们检查证据类型是否为`E01`，以便正确处理它并创建有效的`pyewf`句柄，如在*打开获取*配方中更详细地演示的那样。有关更多详细信息，请参阅该配方。最终结果是为用户提供的证据文件创建`pytsk3`句柄`img_info`。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, we attempt to access the volume of the image using the `pytsk3.Volume_Info()`
    method by supplying it with the image handle. If the partition type argument was
    supplied, we add its attribute ID as the second argument. If we receive an `IOError`
    when attempting to access the volume, we catch the exception as `e` and print
    it to the console. Notice, however, that we do not exit the script as we often
    do when we receive an error. We'll explain why in the next function. Ultimately,
    we pass the `volume`, `img_info`, and `output` variables to the `open_fs()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试使用`pytsk3.Volume_Info()`方法访问图像的卷，通过提供图像句柄作为参数。如果提供了分区类型参数，我们将其属性ID添加为第二个参数。如果在尝试访问卷时收到`IOError`，我们将捕获异常作为`e`并将其打印到控制台。然而，请注意，当我们收到错误时，我们不会退出脚本。我们将在下一个函数中解释原因。最终，我们将`volume`、`img_info`和`output`变量传递给`open_fs()`方法。
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `open_fs()` method tries to access the filesystem of the container in two
    ways. If the `volume` variable is not `None`, it iterates through each partition
    and, if that partition meets certain criteria, attempts to open it. If, however,
    the `volume` variable is `None`, it instead tries to directly call the `pytsk3.FS_Info()`
    method on the image handle, `img`. As we saw, this latter method will work and
    give us filesystem access for logical images, whereas the former works for physical
    images. Let's look at the differences between these two methods.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`open_fs()`方法尝试以两种方式访问容器的文件系统。如果`volume`变量不是`None`，它会遍历每个分区，并且如果该分区符合某些条件，则尝试打开它。但是，如果`volume`变量是`None`，它将尝试直接在图像句柄`img`上调用`pytsk3.FS_Info()`方法。正如我们所看到的，后一种方法将适用于逻辑图像，并为我们提供文件系统访问权限，而前一种方法适用于物理图像。让我们看看这两种方法之间的区别。'
- en: Regardless of the method, we create a `recursed_data` list to hold our active
    file metadata. In the first instance, where we have a physical image, we iterate
    through each partition and check whether it is greater than `2,048` sectors and
    does not contain the words `Unallocated`, `Extended`, or `Primary Table` in its
    description. For partitions meeting these criteria, we attempt to access their
    filesystem using the `FS_Info()` function by supplying the `pytsk3 img` object
    and the offset of the partition in bytes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法，我们都创建一个`recursed_data`列表来保存我们的活动文件元数据。在第一种情况下，我们有一个物理图像，我们遍历每个分区，并检查它是否大于`2,048`扇区，并且在其描述中不包含`Unallocated`、`Extended`或`Primary
    Table`这些词。对于符合这些条件的分区，我们尝试使用`FS_Info()`函数访问它们的文件系统，方法是提供`pytsk3 img`对象和分区的偏移量（以字节为单位）。
- en: If we are able to access the filesystem, we use the `open_dir()` method to get
    the root directory and pass that, along with the partition address ID, the filesystem
    object, two empty lists, and an empty string, to the `recurse_files()` method.
    These empty lists and string will come into play in recursive calls to this function,
    as we will see shortly. Once the `recurse_files()` method returns, we append the
    active file metadata to the `recursed_data` list. We repeat this process for each
    partition.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够访问文件系统，我们将使用`open_dir()`方法获取根目录，并将其与分区地址ID、文件系统对象、两个空列表和一个空字符串一起传递给`recurse_files()`方法。这些空列表和字符串将在对此函数进行递归调用时发挥作用，我们很快就会看到。一旦`recurse_files()`方法返回，我们将活动文件的元数据附加到`recursed_data`列表中。我们对每个分区重复这个过程。
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We employ a similar method for the second instance, where we have a logical
    image, where the volume is `None`. In this case, we attempt to directly access
    the filesystem and, if successful, we pass that to the `recurseFiles()` method
    and append the returned data to our `recursed_data` list. Once we have our active
    file list, we send it and the user-supplied output file path to the `csvWriter()`
    method. Let's dive into the `recurseFiles()` method, which is the meat of this
    recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，我们有一个逻辑图像，卷是`None`。在这种情况下，我们尝试直接访问文件系统，如果成功，我们将其传递给`recurseFiles()`方法，并将返回的数据附加到我们的`recursed_data`列表中。一旦我们有了活动文件列表，我们将其和用户提供的输出文件路径发送到`csvWriter()`方法。让我们深入了解`recurseFiles()`方法，这是本教程的核心。
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `recurse_files()` function is based on an example of the *FLS* tool ([https://github.com/py4n6/pytsk/blob/master/examples/fls.py](https://github.com/py4n6/pytsk/blob/master/examples/fls.py))
    and David Cowen's tool DFIR Wizard ([https://github.com/dlcowen/dfirwizard/blob/master/dfirwizard-v9.py](https://github.com/dlcowen/dfirwizard/blob/master/dfirwizard-v9.py)).
    To start this function, we append the root directory `inode` to the `dirs` list.
    This list is used later to avoid unending loops. Next, we begin to loop through
    each object in the root directory and check whether it has certain attributes
    we would expect and that its name is not either `"**.**"` or `"**..**"`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`recurse_files()`函数基于*FLS*工具的一个示例（[https://github.com/py4n6/pytsk/blob/master/examples/fls.py](https://github.com/py4n6/pytsk/blob/master/examples/fls.py)）和David
    Cowen的工具DFIR Wizard（[https://github.com/dlcowen/dfirwizard/blob/master/dfirwizard-v9.py](https://github.com/dlcowen/dfirwizard/blob/master/dfirwizard-v9.py)）。为了启动这个函数，我们将根目录`inode`附加到`dirs`列表中。稍后将使用此列表以避免无休止的循环。接下来，我们开始循环遍历根目录中的每个对象，并检查它是否具有我们期望的某些属性，以及它的名称既不是`"**.**"`也不是`"**..**"`。'
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the object passes that test, we extract its name using the `info.name.name`
    attribute. Next, we use the `parent` variable, which was supplied as one of the
    function's inputs, to manually create the file path for this object. There is
    no built-in method or attribute to do this automatically for us.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象通过了这个测试，我们将使用`info.name.name`属性提取其名称。接下来，我们使用作为函数输入之一提供的`parent`变量手动为此对象创建文件路径。对于我们来说，没有内置的方法或属性可以自动执行此操作。
- en: We then check if the file is a directory or not and set the `f_type` variable
    to the appropriate type. If the object is a file, and it has an extension, we
    extract it and store it in the `file_ext` variable. If we encounter an `AttributeError`
    when attempting to extract this data, we continue onto the next object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查文件是否是目录，并将`f_type`变量设置为适当的类型。如果对象是文件，并且具有扩展名，我们将提取它并将其存储在`file_ext`变量中。如果在尝试提取此数据时遇到`AttributeError`，我们将继续到下一个对象。
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similar to the first recipe in this chapter, we create variables for the object
    size and timestamps. However, notice that we pass the dates to a `convert_time()`
    method. This function exists to convert the `Unix` timestamps into a human-readable
    format. With these attributes extracted, we append them to the data list using
    the partition address ID to ensure we keep track of which partition the object
    is from.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章第一个示例类似，我们为对象大小和时间戳创建变量。但是，请注意，我们将日期传递给`convert_time()`方法。此函数用于将`Unix`时间戳转换为人类可读的格式。提取了这些属性后，我们使用分区地址ID将它们附加到数据列表中，以确保我们跟踪对象来自哪个分区。
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the object is a directory, we need to recurse through it to access all of
    its subdirectories and files. To accomplish this, we append the directory name
    to the `parent` list. Then, we create a directory object using the `as_directory()`
    method. We use the `inode` here, which is for all intents and purposes a unique
    number, and check that the `inode` is not already in the `dirs` list. If that
    were the case, then we would not process this directory as it would have already
    been processed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是一个目录，我们需要递归遍历它，以访问其所有子目录和文件。为此，我们将目录名称附加到`parent`列表中。然后，我们使用`as_directory()`方法创建一个目录对象。我们在这里使用`inode`，这对于所有目的来说都是一个唯一的数字，并检查`inode`是否已经在`dirs`列表中。如果是这样，那么我们将不处理这个目录，因为它已经被处理过了。
- en: If the directory needs to be processed, we call the `recurse_files()` method
    on the new `sub_directory` and pass it current `dirs`, `data`, and `parent` variables.
    Once we have processed a given directory, we pop that directory from the `parent`
    list. Failing to do this will result in false file path details as all of the
    former directories will continue to be referenced in the path unless removed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要处理目录，我们在新的`sub_directory`上调用`recurse_files()`方法，并传递当前的`dirs`、`data`和`parent`变量。一旦我们处理了给定的目录，我们就从`parent`列表中弹出该目录。如果不这样做，将导致错误的文件路径细节，因为除非删除，否则所有以前的目录将继续在路径中被引用。
- en: Most of this function was in a large `try-except` block. We pass on any `IOError`
    exception generated during this process. Once we have iterated through all of
    the subdirectories, we return the data list to the `open_fs()` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的大部分内容都在一个大的`try-except`块中。我们传递在这个过程中生成的任何`IOError`异常。一旦我们遍历了所有的子目录，我们将数据列表返回给`open_fs()`函数。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s briefly look at the `convert_time()` function. We''ve seen this type
    of function before: if the `Unix` timestamp is not `0`, we use the `datetime.utcfromtimestamp()`
    method to convert the timestamp into a human-readable format.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下`convert_time()`函数。我们以前见过这种类型的函数：如果`Unix`时间戳不是`0`，我们使用`datetime.utcfromtimestamp()`方法将时间戳转换为人类可读的格式。
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the active file listing data in hand, we are now ready to write it to a
    CSV file using the `write_csv()` method. If we did find data (that is, the list
    is not empty), we open the output CSV file, write the headers, and loop through
    each list in the `data` variable. We use the `csvwriterows()` method to write
    each nested list structure to the CSV file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有了手头的活动文件列表数据，我们现在准备使用`write_csv()`方法将其写入CSV文件。如果我们找到了数据（即列表不为空），我们打开输出CSV文件，写入标题，并循环遍历`data`变量中的每个列表。我们使用`csvwriterows()`方法将每个嵌套列表结构写入CSV文件。
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot demonstrates the type of data this recipe extracts
    from forensic images:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了这个示例从取证图像中提取的数据类型：
- en: '![](../images/00092.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00092.jpeg)'
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们提供了一个或多个建议，如下所示：
- en: Use `tqdm`, or another library, to create a progress bar to inform the user
    of the current execution progress
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tqdm`或其他库创建进度条，以通知用户当前执行的进度
- en: Learn about the additional metadata values that can be extracted from filesystem
    objects using `pytsk3` and add them to the output CSV file
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可以使用`pytsk3`从文件系统对象中提取的附加元数据值，并将它们添加到输出CSV文件中
- en: Processing files within the container
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理容器内的文件
- en: 'Recipe Difficulty: Medium'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：中等
- en: 'Python Version: 2.7'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7
- en: 'Operating System: Linux'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Linux
- en: Now that we can iterate through a filesystem, let's look at how we can create
    file objects as we have been accustomed to doing. In this recipe, we create a
    simple triage script that extracts files matching specified file extensions and
    copies them to an output directory while preserving their original file path.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以遍历文件系统，让我们看看如何创建文件对象，就像我们习惯做的那样。在这个示例中，我们创建一个简单的分流脚本，提取与指定文件扩展名匹配的文件，并将它们复制到输出目录，同时保留它们的原始文件路径。
- en: Getting started
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the build environment and setup details for `pytsk3` and `pyewf`.
    All other libraries used in this script are present in Python's standard library.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关构建环境和`pytsk3`和`pyewf`的设置详细信息，请参考*入门*部分中的*打开收购*食谱。此脚本中使用的所有其他库都包含在Python的标准库中。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will perform the following steps in this recipe:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将执行以下步骤：
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定证据容器是`raw`镜像还是`E01`容器。
- en: Access the image using `pytsk3`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pytsk3`访问图像。
- en: Recurse through all directories in each partition.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归遍历每个分区中的所有目录。
- en: Check if the file extension matches those supplied.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件扩展名是否与提供的扩展名匹配。
- en: Write responsive files with the preserved folder structure to the output directory.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具有保留文件夹结构的响应文件写入输出目录。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We import a number of libraries to assist with argument parsing, creating CSV
    spreadsheets, and handling evidence containers and filesystems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了许多库来帮助解析参数、创建CSV电子表格，并处理证据容器和文件系统。
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This recipe''s command-line handler takes four positional arguments: `EVIDENCE_FILE`,
    `TYPE`, `EXT`, and `OUTPUT_DIR`. These are the evidence file itself, the type
    of evidence file, a comma-delimited list of extensions to extract, and the desired
    output directory, respectively. We also have the optional `p` switch to manually
    specify the partition type.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的命令行处理程序接受四个位置参数：`EVIDENCE_FILE`、`TYPE`、`EXT`和`OUTPUT_DIR`。它们分别是证据文件本身、证据文件类型、要提取的逗号分隔的扩展名列表，以及所需的输出目录。我们还有可选的`p`开关，用于手动指定分区类型。
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before calling the `main()` function, we create any necessary output directories
    and perform our standard input-validation steps. Once we have validated the input,
    we pass the supplied arguments onto the `main()` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`main()`函数之前，我们创建任何必要的输出目录，并执行我们的标准输入验证步骤。一旦我们验证了输入，我们将提供的参数传递给`main()`函数。
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `main()` function, `EWFImgInfo` class, and the `open_fs()` function, have
    been covered in previous recipes. Recall that this chapter takes a more iterative
    approach to our recipes as we build upon the previous ones. Refer to those previous
    recipes for a more detailed description of each function and the `EWFImgInfo`
    class. Let's briefly show the two functions again so as to avoid jumping around
    logically.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数、`EWFImgInfo`类和`open_fs()`函数在之前的配方中已经涵盖过。请记住，本章采用更迭代的方法来构建我们的配方。有关每个函数和`EWFImgInfo`类的更详细描述，请参考之前的配方。让我们简要地再次展示这两个函数，以避免逻辑上的跳跃。'
- en: In the `main()` function, we check whether the evidence file is a `raw` file
    or an `E01` file. Then, we perform the necessary steps to ultimately create a
    `pytsk3` handle on the evidence file. With this handle, we attempt to access the
    volume, using the manually supplied partition type if supplied. If we are able
    to open the volume, we pass `pytsk3` handle and volume to the `open_fs()` method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们检查证据文件是`raw`文件还是`E01`文件。然后，我们执行必要的步骤，最终在证据文件上创建一个`pytsk3`句柄。有了这个句柄，我们尝试访问卷，使用手动提供的分区类型（如果提供）。如果我们能够打开卷，我们将`pytsk3`句柄和卷传递给`open_fs()`方法。
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `open_fs()` function, we use logic to support accessing the filesystem
    for both logical and physical acquisitions. For logical acquisitions, we can simply
    attempt to access the root of the filesystem on the `pytsk3` handle. On the other
    hand, for physical acquisitions, we must iterate through each partition and attempt
    to access the filesystem for those meeting certain criteria. Once we have access
    to the filesystem, we call the `recurse_files()` method to iterate through all
    of the files in the filesystem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`open_fs()`函数中，我们使用逻辑来支持对文件系统进行逻辑和物理获取。对于逻辑获取，我们可以简单地尝试访问`pytsk3`句柄上文件系统的根。另一方面，对于物理获取，我们必须迭代每个分区，并尝试访问那些符合特定条件的文件系统。一旦我们访问到文件系统，我们调用`recurse_files()`方法来迭代文件系统中的所有文件。
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Stop skimming here! The new logic for this recipe is contained in the `recurse_files()`
    method. This is sort of a blink-and-you'll-miss-it recipe. We've done the heavy
    lifting with the previous recipes, and we can now essentially treat these files
    like we would any other file with Python. Let's look at how this works.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不要浏览了！这个配方的新逻辑包含在`recurse_files()`方法中。这有点像眨眼就错过的配方。我们已经在之前的配方中做了大部分工作，现在我们基本上可以像处理任何其他Python文件一样处理这些文件。让我们看看这是如何工作的。
- en: Admittedly, the first part of this function is still the same as before, with
    one exception. On the first line of the function, we use list comprehension to
    split each comma-delimited extension supplied by the user and remove any white
    spaces and normalize the string to lowercase. As we iterate through each object,
    we check whether the object is a directory or a file. If it is a file, we separate
    and normalize the file's extension to lower case and store it in a `file_ext`
    variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这个函数的第一部分仍然与以前相同，只有一个例外。在函数的第一行，我们使用列表推导来分割用户提供的每个逗号分隔的扩展名，并删除任何空格并将字符串规范化为小写。当我们迭代每个对象时，我们检查对象是目录还是文件。如果是文件，我们将文件的扩展名分离并规范化为小写，并将其存储在`file_ext`变量中。
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we check if the extracted file's extension is in our user supplied list.
    If it is, we pass the file object itself and its name, extension, path, and the
    desired output directory to the `file_writer()` method to output. Notice that
    this operation, we have logic, discussed in the previous recipe, to recursively
    process any subdirectories to identify more potential files matching the extension
    criteria. So far, so good; let's now take a look at this last function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查提取的文件扩展名是否在用户提供的列表中。如果是，我们将文件对象本身及其名称、扩展名、路径和所需的输出目录传递给`file_writer()`方法进行输出。请注意，在这个操作中，我们有逻辑，即在前面的配方中讨论过的逻辑，来递归处理任何子目录，以识别更多符合扩展名条件的潜在文件。到目前为止，一切顺利；现在让我们来看看这最后一个函数。
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `file_writer()` method relies on the file object''s `read_random()` method
    to access the file content. Before we do that, however, we first set up the output
    path for the file by combining the user-supplied output with the extension and
    the path of the file. We then create these directories if they do not already
    exist. Next, we open the output file in `"w"` mode and are now ready to write
    the file''s content to the output file. As used here, the `read_random()` function
    takes two inputs: the byte offset within the file to start reading from and the
    number of bytes to read. In this case, since we want to read the entire file,
    we use the integer `0` as the first argument and the file''s size as the second
    argument.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_writer()`方法依赖于文件对象的`read_random()`方法来访问文件内容。然而，在这之前，我们首先设置文件的输出路径，将用户提供的输出与扩展名和文件的路径结合起来。然后，如果这些目录不存在，我们就创建这些目录。接下来，我们以“w”模式打开输出文件，现在准备好将文件的内容写入输出文件。在这里使用的`read_random()`函数接受两个输入：文件中要开始读取的字节偏移量和要读取的字节数。在这种情况下，由于我们想要读取整个文件，我们使用整数`0`作为第一个参数，文件的大小作为第二个参数。'
- en: We supply this directly to the `write()` method, although note that going forward,
    if we were to perform any processing to this file, we could instead read it into
    a variable and work with the file from there. Also, note that for evidence containers
    with large files, this process of reading the entire file into memory may not
    be ideal. In that scenario, you would want to read and write to this file in chunks
    rather than all at once.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接将其提供给`write()`方法，尽管请注意，如果我们要对这个文件进行任何处理，我们可以将其读入变量中，并从那里处理文件。另外，请注意，对于包含大文件的证据容器，将整个文件读入内存的这个过程可能并不理想。在这种情况下，您可能希望分块读取和写入这个文件，而不是一次性全部读取和写入。
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When we run this script, we see responsive files based on the supplied extensions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，我们会看到基于提供的扩展名的响应文件：
- en: '![](../images/00093.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00093.jpeg)'
- en: 'Additionally, we can review these files within the defined structure as shown
    in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在以下截图中查看这些文件的定义结构：
- en: '![](../images/00094.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00094.jpeg)'
- en: Searching for hashes
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索哈希
- en: 'Recipe Difficulty: Hard'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：困难
- en: 'Python Version: 2.7'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7
- en: 'Operating System: Linux'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Linux
- en: In this recipe, we create another triage script, this time focused on identifying
    files matching provided hash values. This script takes a text file containing
    `MD5`, `SHA-1`, or `SHA-256` hashes, separated by a newline, and searches for
    those hashes within the evidence container. With this recipe, we will be able
    to quickly process evidence files, locate files of interest, and alert the user
    by printing the file path to the console.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了另一个分类脚本，这次专注于识别与提供的哈希值匹配的文件。该脚本接受一个文本文件，其中包含以换行符分隔的`MD5`、`SHA-1`或`SHA-256`哈希，并在证据容器中搜索这些哈希。通过这个配方，我们将能够快速处理证据文件，找到感兴趣的文件，并通过将文件路径打印到控制台来提醒用户。
- en: Getting started
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Refer to the *Getting started* section in the *Opening Acquisitions* recipe
    for information on the `build` environment and setup details for `pytsk3` and
    `pyewf`. All other libraries used in this script are present in Python's standard
    library.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参考*打开获取*配方中的*入门*部分，了解有关`build`环境和`pytsk3`和`pyewf`的设置详细信息。此脚本中使用的所有其他库都包含在Python的标准库中。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We use the following methodology to accomplish our objective:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方法来实现我们的目标：
- en: Identify if the evidence container is a `raw` image or an `E01` container.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定证据容器是`raw`图像还是`E01`容器。
- en: Access the image using `pytsk3`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pytsk3`访问图像。
- en: Recurse through all directories in each partition.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归遍历每个分区中的所有目录。
- en: Send each file to be hashed using the appropriate hashing algorithm.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的哈希算法发送每个文件进行哈希处理。
- en: Check if the hash matches one of those provided and if so, print to the console.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查哈希是否与提供的哈希之一匹配，如果是，则打印到控制台。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We import a number of libraries to assist with argument parsing, creating CSV
    spreadsheets, hashing files, handling evidence containers and filesystems, and
    creating progress bars.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了许多库来帮助解析参数、创建CSV电子表格、对文件进行哈希处理、处理证据容器和文件系统，并创建进度条。
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This recipe's command-line handler takes three positional arguments, `EVIDENCE_FILE`,
    `TYPE`, and `HASH_LIST`, which represent the evidence file, the type of evidence
    file, and the newline delimited list of hashes to search for, respectively. As
    always, the user can also manually supply the partition type using the `p` switch
    if necessary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方的命令行处理程序接受三个位置参数，`EVIDENCE_FILE`，`TYPE`和`HASH_LIST`，分别表示证据文件，证据文件类型和要搜索的换行分隔哈希列表。与往常一样，用户也可以在必要时使用`p`开关手动提供分区类型。
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After we parse the inputs, we perform our typical input-validation checks on
    both the evidence file and the hash list. If those pass, we call the `main()`
    function and supply it with the user-supplied inputs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析输入后，我们对证据文件和哈希列表进行了典型的输入验证检查。如果通过了这些检查，我们调用`main()`函数并提供用户提供的输入。
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As in the previous recipe, the `main()` function, `EWFImgInfo` class, and the
    `open_fs()` function are nearly identical to the previous recipes. For a more
    detailed explanation of these functions, refer to the previous recipes. One new
    addition to the `main()` function is the first line, where we call the `read_hashes()`
    method. This method reads the input hash list and returns a list of hashes and
    the type of hash (that is, `MD5`, `SHA-1`, or `SHA-256`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的配方一样，`main()`函数、`EWFImgInfo`类和`open_fs()`函数几乎与以前的配方相同。有关这些函数的更详细解释，请参考以前的配方。`main()`函数的一个新添加是第一行，我们在其中调用`read_hashes()`方法。该方法读取输入的哈希列表并返回哈希列表和哈希类型（即`MD5`、`SHA-1`或`SHA-256`）。
- en: Other than that, the `main()` function proceeds as we are accustomed to seeing
    it. First, it determines what type of evidence file it is working with in order
    to create a `pytsk3` handle on the image. Then, it uses that handle and attempts
    to access the image volume. Once this process has completed, the variables are
    sent to the `open_fs()` function for further processing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`main()`函数的执行方式与我们习惯看到的方式相同。首先，它确定正在处理的证据文件的类型，以便在图像上创建一个`pytsk3`句柄。然后，它使用该句柄并尝试访问图像卷。完成此过程后，变量被发送到`open_fs()`函数进行进一步处理。
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's quickly look at one of the new functions, the `read_hashes()` method.
    First, we instantiate the `hash_list` and `hash_type` variables as an empty list
    and `None` object, respectively. Next, we open and iterate through the input hash
    list and add each hash to our list. As we do this, if the `hash_type` variable
    is still `None`, we check the length of the line as a means of identifying the
    type of hash algorithm we should use.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下新函数`read_hashes()`方法。首先，我们将`hash_list`和`hash_type`变量实例化为空列表和`None`对象。接下来，我们打开并遍历输入的哈希列表，并将每个哈希添加到我们的列表中。在这样做时，如果`hash_type`变量仍然是`None`，我们检查行的长度作为识别应该使用的哈希算法类型的手段。
- en: At the end of this process, if for whatever reason the `hash_type` variable
    is still `None`, then the hash list must be made up of hashes we do not support,
    and so we exit the script after printing the error to the console.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程结束时，如果`hash_type`变量仍然是`None`，则哈希列表必须由我们不支持的哈希组成，因此在将错误打印到控制台后退出脚本。
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `open_fs()` method function is identical to that of previous recipes. It
    tries to use two different methods to access both physical and logical filesystems.
    Once successful, it passes these filesystems onto the `recurse_files()` method.
    As with the previous recipe, the magic happens within this function. We are also
    incorporating a progress bar with `tqdm` to provide feedback to the user, as it
    may take a while to hash all of the files within an image.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`open_fs()`方法函数与以前的配方相同。它尝试使用两种不同的方法来访问物理和逻辑文件系统。一旦成功，它将这些文件系统传递给`recurse_files()`方法。与以前的配方一样，这个函数中发生了奇迹。我们还使用`tqdm`来提供进度条，向用户提供反馈，因为在图像中对所有文件进行哈希可能需要一段时间。'
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Within the `recurse_files()` method, we iterate through all subdirectories and
    hash each file. We skip the `.` and `..` directory entries and check that the
    `fs_object` has the correct properties. If so, we build the file path for use
    in our output.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recurse_files()`方法中，我们遍历所有子目录并对每个文件进行哈希处理。我们跳过`。`和`..`目录条目，并检查`fs_object`是否具有正确的属性。如果是，我们构建文件路径以在输出中使用。
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we perform each iteration, we determine which objects are files versus directories.
    For each file discovered, we send it to the `hash_file()` method along with its
    path, the list of hashes, and the hash algorithm. The remainder of the `recurse_files()`
    function logic is specifically designed to handle directories and makes recursive
    calls to this function for any sub-directories to ensure the whole tree is walked
    and files are not missed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行每次迭代时，我们确定哪些对象是文件，哪些是目录。对于发现的每个文件，我们将其发送到`hash_file()`方法，以及其路径，哈希列表和哈希算法。`recurse_files()`函数逻辑的其余部分专门设计用于处理目录，并对任何子目录进行递归调用，以确保整个树都被遍历并且不会错过文件。
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `hash_file()` method first checks which type of hash algorithm instance
    to create based on the `hash_type` variable. With that decided and an update of
    the file size to the progress bar, we read the file's data into the hash object
    using the `read_random()` method. Again, we read the entire file's contents by
    starting our read at the first byte and reading the entire file's size. We generate
    the hash of the file using the `hexdigest()` function on the hash object and then
    check whether that hash is in our list of supplied hashes. If it is, we alert
    the user by printing the file path, using `pbar.write()` to prevent progress bar
    display issues, and name to the console.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash_file()`方法首先检查要创建的哈希算法实例的类型，根据`hash_type`变量。确定了这一点，并更新了文件大小到进度条，我们使用`read_random()`方法将文件的数据读入哈希对象。同样，我们通过从第一个字节开始读取并读取整个文件的大小来读取整个文件的内容。我们使用哈希对象上的`hexdigest()`函数生成文件的哈希，然后检查该哈希是否在我们提供的哈希列表中。如果是，我们通过打印文件路径来提醒用户，使用`pbar.write()`来防止进度条显示问题，并将名称打印到控制台。'
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By running the script we are presented with a nice progress bar showing the
    hashing status and a list of files that match the list of provided hashes, as
    seen in the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行脚本，我们可以看到一个漂亮的进度条，显示哈希状态和与提供的哈希列表匹配的文件列表，如下面的屏幕截图所示：
- en: '![](../images/00095.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00095.jpeg)'
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们提供了一个或多个建议，如下所示：
- en: Rather than printing matches, create a CSV of matching files with metadata for
    review
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是打印匹配项，创建一个包含匹配文件的元数据的CSV文件以供审查。
- en: Add an optional switch to dump matching files to an output directory (with the
    folder path preserved)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个可选开关，将匹配的文件转储到输出目录（保留文件夹路径）
