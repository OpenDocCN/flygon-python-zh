- en: Extracting Useful Data from Network Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络设备中提取有用数据
- en: We have already seen in the previous chapter how to access a network device
    using different methods and protocols, then execute commands on the remote device
    to get an output back to Python. Now, it's time to extract some useful data from
    this output.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经看到了如何使用不同的方法和协议访问网络设备，然后在远程设备上执行命令，将输出返回到Python。现在，是时候从这个输出中提取一些有用的数据了。
- en: In this chapter, you'll learn how to use different tools and libraries in Python
    to extract useful data from returned output and act on it using regular expressions.
    Also, we will use a special library called `CiscoConfParse` to audit the configuration,
    then we will learn how to visualize data to generate visually appealing graphs
    and reports using the `matplotlib` library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Python中的不同工具和库从返回的输出中提取有用的数据，并使用正则表达式对其进行操作。此外，我们将使用一个名为`CiscoConfParse`的特殊库来审计配置，然后学习如何使用`matplotlib`库可视化数据，生成视觉上吸引人的图形和报告。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding parsers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解解析器
- en: Introduction to regular expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式简介
- en: Configuration auditing using `Ciscoconfparse`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Ciscoconfparse`进行配置审计
- en: Visualizing returned data with `matplotlib`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`matplotlib`可视化返回的数据
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following tools should be installed and available in your environment:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您的环境中应安装并可用以下工具：
- en: Python 2.7.1x
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.7.1x
- en: PyCharm Community or Pro edition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm社区版或专业版
- en: EVE-NG lab
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EVE-NG实验室
- en: 'You can find the full scripts developed in this chapter at the following GitHub
    URL:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub URL找到本章开发的完整脚本：
- en: '[https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git)'
- en: Understanding parsers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解解析器
- en: In the previous chapter, we explored different ways to access network devices,
    execute commands, and return output to our terminal. We now need to work on the
    returned output and extract some useful information from it. Notice that, from
    Python's point of view, the output is just a multiline string and Python doesn't
    differentiate between IP address, interface name, or node hostname because they're
    all strings. So, the first step is to design and develop our own parser using
    Python to categorize and differentiate between items based on the important information
    in the returned output.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了访问网络设备、执行命令并将输出返回到终端的不同方式。现在我们需要处理返回的输出，并从中提取一些有用的信息。请注意，从Python的角度来看，输出只是一个多行字符串，Python不区分IP地址、接口名称或节点主机名，因为它们都是字符串。因此，第一步是设计和开发我们自己的解析器，使用Python根据返回的输出中的重要信息对项目进行分类和区分。
- en: After that, you can work on the parsed data and generate graphs that help to
    visualize or even store them to persistent and external storage or databases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以处理解析后的数据，并生成有助于可视化的图形，甚至将它们存储到持久的外部存储或数据库中。
- en: Introduction to regular expressions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式简介
- en: 'Regular expressions are a language used to match specific occurrences of strings
    by following their pattern across the whole string. When a match is found, the
    resulting matched string will be returned back to user and will be held inside
    a structure in Python format, such as `tuple`, `list`, or `dictionary`. The following
    table summarizes the most common patterns in regular expressions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种语言，用于通过跟随整个字符串的模式来匹配特定的字符串出现。当找到匹配时，将返回匹配的字符串，并将其保存在Python格式的结构中，如`tuple`、`list`或`dictionary`。以下表总结了正则表达式中最常见的模式：
- en: '![](../images/00090.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00090.jpeg)'
- en: 'Also, one of the important rules in regular expressions is you can write your
    own regex and surround it with parentheses `()`, which is called the capturing
    group and helps you to hold important data to reference it later using the capturing
    group number:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正则表达式中的一个重要规则是您可以编写自己的正则表达式，并用括号`()`括起来，这称为捕获组，它可以帮助您保存重要数据，以便稍后使用捕获组编号引用它：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: PyCharm will automatically color strings written as regular expressions and
    can help you to check the validity of a regex before applying it to data. Make
    sure the Check RegExp intention is enabled in the settings, as shown here:![](../images/00091.jpeg)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm将自动对写成正则表达式的字符串进行着色，并可以帮助您在将其应用于数据之前检查正则表达式的有效性。请确保在设置中启用了Check RegExp意图，如下所示：![](../images/00091.jpeg)
- en: Creating a regular expression in Python
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中创建正则表达式
- en: 'You can construct a regular expression in Python using the `re` module that
    is natively shipped with the Python installation. There are several methods inside
    this module, such as `search()`, `sub()`, `split()`, `compile()`, and `findall()`,
    which will return the result as a regex object. Here is a summary of the use of
    each function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Python中的`re`模块构建正则表达式，该模块已经与Python安装一起原生地提供。该模块内部有几种方法，如`search()`、`sub()`、`split()`、`compile()`和`findall()`，它们将以正则表达式对象的形式返回结果。以下是每个函数的用法总结：
- en: '| **Function Name** | **Usage** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **函数名称** | **用法** |'
- en: '| `search()` | Search and match the first occurrence of the pattern. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `search()` | 搜索和匹配模式的第一个出现。 |'
- en: '| `findall()` | Search and match all occurrences of the pattern and return
    the result as a list. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `findall()` | 搜索和匹配模式的所有出现，并将结果作为列表返回。 |'
- en: '| `Finditer()` | Search and match all occurrences of the pattern and return
    the result as an iterator. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `Finditer()` | 搜索和匹配模式的所有出现，并将结果作为迭代器返回。 |'
- en: '| `compile()` | Compile the regex into a pattern object that has methods for
    various operations, such as searching for pattern matches or performing string
    substitutions. This is extremely useful if you use the same regex pattern multiple
    times inside your script. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `compile()` | 将正则表达式编译为具有各种操作方法的模式对象，例如搜索模式匹配或执行字符串替换。如果您在脚本中多次使用相同的正则表达式模式，这将非常有用。
    |'
- en: '| `sub()` | Used to replace matched pattern with another string. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `sub()` | 用于用另一个字符串替换匹配的模式。 |'
- en: '| `split()` | Used to split on matched pattern and create a list. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `split()` | 用于在匹配模式上拆分并创建列表。 |'
- en: Regular expressions are hard to read; for that reason, let's start simple and
    look at some easy regular expressions at the most basic level.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式很难阅读；因此，让我们从简单的开始，看一些最基本级别的简单正则表达式。
- en: The first step of working with the `re` module is to import it inside your Python
    code
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`re`模块的第一步是在Python代码中导入它
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will start to explore the most common function in the `re` module, which
    is `search()`, and then we will explore `findall()`. The `search()` function is
    suitable when you need to find only one match in a string or when you write your
    regex pattern to match the entire output and need to get the result with a method
    called `groups()`, as we will see in the following examples.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始探索`re`模块中最常见的函数，即`search()`，然后我们将探索`findall()`。当您需要在字符串中找到一个匹配项，或者当您编写正则表达式模式来匹配整个输出并需要使用`groups()`方法来获取结果时，`search()`函数是合适的，正如我们将在接下来的例子中看到的。
- en: 'The syntax of the `re.search()` function is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.search()`函数的语法如下：'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first parameter, `''regex pattern''`, is the regular expression developed
    in order to match a specific occurrence inside the `''string''`. When a match
    is found, the `search()` function returns a special match object, otherwise it
    will return `None`. Note that `search()` will return the first occurrence only
    of the pattern and will ignore the rest of them. Let''s see a few examples of
    using the `re` module in Python:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`'regex pattern'`是为了匹配`'string'`中的特定出现而开发的正则表达式。当找到匹配项时，`search()`函数将返回一个特殊的匹配对象，否则将返回`None`。请注意，`search()`将仅返回模式的第一个匹配项，并将忽略其余的匹配项。让我们看一些在Python中使用`re`模块的例子：
- en: '**Example 1: Searching for a specific IP address**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例1：搜索特定IP地址**'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we can see the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: The `re` module is imported into our Python script.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`模块被导入到我们的Python脚本中。'
- en: We have a string that corresponds to interface details and contains the name,
    IP address, and status. This string could be hardcoded in the script or generated
    from the network device using the Netmiko library.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个字符串，对应于接口详细信息，并包含名称、IP地址和状态。这个字符串可以在脚本中硬编码，也可以使用Netmiko库从网络设备中生成。
- en: We passed this string to the `search()` function, along with our regular expression,
    which is just the IP address.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将这个字符串传递给`search()`函数，以及我们的正则表达式，即IP地址。
- en: Then, the script checks whether there's a `match` object returned from the previous
    operation; if so, it will print it.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，脚本检查前一个操作是否返回了`match`对象；如果是，则会打印出来。
- en: The most basic method of testing for a match is via the `re.match` function,
    as we did in the previous example. The `match` function takes a regular expression
    pattern and a string value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 测试匹配的最基本方法是通过`re.match`函数，就像我们在前面的例子中所做的那样。`match`函数接受一个正则表达式模式和一个字符串值。
- en: Notice we're only searching for a specific string inside the `intf_ip` parameter,
    not every IP address pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只在`intf_ip`参数内搜索特定的字符串，而不是每个IP地址模式。
- en: '**Example 1 output**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例1输出**'
- en: '![](../images/00092.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00092.jpeg)'
- en: '**Example 2: Matching the IP address pattern**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例2：匹配IP地址模式**'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we can see the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: The `re` module is imported into our Python script.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`模块被导入到我们的Python脚本中。'
- en: We have a multi-line string that corresponds to the interface details and contains
    the name, IP address, and status.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个多行字符串，对应于接口详细信息，并包含名称、IP地址和状态。
- en: We passed this string to the `search()` function along with our regular expression,
    which is the IP address pattern constructed using both `\d+`, which matches one
    or more digits, and `\.`, which matches the occurrence of the dot.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将这个字符串传递给`search()`函数，以及我们的正则表达式，即使用`\d+`匹配一个或多个数字，以及`\.`匹配点的出现。
- en: Then, the script checks whether there's a `match` object returned from a previous
    operation; if so, it will print it. Otherwise, the `None` object is returned.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，脚本检查前一个操作是否返回了`match`对象；如果是，则会打印出来。否则，将返回`None`对象。
- en: '**Example 2 output**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例2输出**'
- en: '![](../images/00093.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00093.jpeg)'
- en: Notice the `search()` function returns only the first matched occurrence of
    the pattern, not all occurrences.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`search()`函数只返回模式的第一个匹配项，而不是所有匹配项。
- en: '**Example 3: Using** **groups() regular expressions**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例3：使用** **groups()正则表达式**'
- en: 'If you have a long output and you need to extract multiple strings from it,
    then you could surround the extracted value with `()` and write your regex inside
    it. This is called a **capturing group** and is used to catch a specific pattern
    within a long string, as shown in the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个长输出，并且需要从中提取多个字符串，那么您可以用`()`括起提取的值，并在其中编写您的正则表达式。这称为**捕获组**，用于捕获长字符串中的特定模式，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we can see the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: The `re` module is imported into our Python script.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`模块被导入到我们的Python脚本中。'
- en: We have a string that corresponds to an event that occurred in the router and
    is stored in logging.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个字符串，对应于路由器中发生的事件，并存储在日志中。
- en: We passed this string to the `search()` function along with our regular expression.
    Notice that we enclosed the timestamp, event type, interface name, and the new
    state of the capturing group and wrote our regex inside it.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将这个字符串传递给`search()`函数，以及我们的正则表达式。请注意，我们将时间戳、事件类型、接口名称和捕获组的新状态都括起来，并在其中编写我们的正则表达式。
- en: Then, the script checks whether there's a match object returned from the previous
    operation; if so, it will print it, but this time we used `groups()` instead of
    `group()`, as we are capturing multiple strings.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，脚本检查前一个操作是否返回了匹配对象；如果是，则会打印出来，但这次我们使用了`groups()`而不是`group()`，因为我们正在捕获多个字符串。
- en: '**Example 3 output**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例3输出**'
- en: '![](../images/00094.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00094.jpeg)'
- en: Notice the returned data is in a structured format called a **tuple**. We could
    use this output later to trigger an event and start, for example, a recovery procedure
    on a redundant interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，返回的数据是一个名为**tuple**的结构化格式。我们可以稍后使用此输出来触发事件，并且例如在冗余接口上启动恢复过程。
- en: 'We could enhance our previous code and use a `Named` group to give each capture
    group a name that could be referenced later or used to create a dictionary. In
    this case, we prefixed our regex with `?P<"NAME">` as in the next example (**Example
    4** in the GitHub repository):**Example 4: Named group**![](../images/00095.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增强我们之前的代码，并使用`Named`组来为每个捕获组命名，以便稍后引用或用于创建字典。在这种情况下，我们在正则表达式前面加上了`?P<"NAME">`，就像下一个示例（GitHub存储库中的**示例4**）中一样：**示例4：命名组**![](../images/00095.jpeg)
- en: '**Example 5-1: Searching for multiple lines using re.search()**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例5-1：使用re.search()搜索多行**'
- en: 'Assume we have multiple lines in the output and we need to check all of them
    against the regex pattern. Remember that the `search()` function exits when it
    finds the first pattern match. In that case, we have two solutions. The first
    one is to feed each line to the search function by splitting the whole string
    on `"\n"`, and the second solution is to use the `findall()` function. Let''s
    explore the two solutions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的输出中有多行，并且我们需要针对正则表达式模式检查所有这些行。请记住，`search()`函数在找到第一个模式匹配时退出。在这种情况下，我们有两种解决方案。第一种是通过在`"\n"`上拆分整个字符串将每行输入到搜索函数中，第二种解决方案是使用`findall()`函数。让我们探讨这两种解决方案：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding script will split the `show ip interface brief` output and search
    for a specific pattern, which is the interface name and the IP address configured
    on it. Based on the matched data, the script will continue to check each IP address
    and validate it using `start with 57`, then the script will print the corresponding
    interface and the full IP address.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的脚本将拆分`show ip interface brief`输出并搜索特定模式，即接口名称和配置在其上的IP地址。根据匹配的数据，脚本将继续检查每个IP地址并使用`start
    with 57`进行验证，然后脚本将打印相应的接口和完整的IP地址。
- en: '**Example 5-1 output**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例5-1输出**'
- en: '![](../images/00096.jpeg)If you''re searching only for the first occurrence,
    you can optimize the script and only get the first result by breaking the outer
    `for` loop upon locating the first match, but note that the second match won''t
    be located or printed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00096.jpeg)如果您只搜索第一次出现，可以优化脚本，并且只需在找到第一个匹配项时中断外部`for`循环，但请注意，第二个匹配项将无法找到或打印。'
- en: '**Example 5-2: Searching for multiple lines using re.findall()**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例5-2：使用re.findall()搜索多行**'
- en: 'The `findall()` function searches for all non-overlapping matches in the provided
    string and returns a list of strings (unlike the `search` function, which returns
    the `match` object) that matched by regex pattern if there''s no capturing group.
    If you enclosed your regex with a capturing group, then `findall()` will return
    a list of tuples. In the following script, we have the same multi-line output
    and we will use the `findall()` method to get all interfaces that are configured
    with an IP address that starts with 57:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`findall()`函数在提供的字符串中搜索所有不重叠的匹配项，并返回与正则表达式模式匹配的字符串列表（与`search`函数不同，后者返回`match`对象），如果没有捕获组，则返回。如果您用捕获组括起您的正则表达式，那么`findall()`将返回一个元组列表。在下面的脚本中，我们有相同的多行输出，并且我们将使用`findall()`方法来获取所有配置了以57开头的IP地址的接口：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Example 5-2 output**:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例5-2输出**：'
- en: '![](../images/00097.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00097.jpeg)'
- en: Notice this time we didn't have to write a `for` loop to check each line against
    the regex pattern. This will be done automatically in the `findall()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次我们不必编写`for`循环来检查每行是否符合正则表达式模式。这将在`findall()`方法中自动完成。
- en: Configuration auditing using CiscoConfParse
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CiscoConfParse进行配置审计
- en: Applying regular expressions on network configuration to get specific information
    from the output requires us to write some complex expressions to solve some complex
    use cases. In some cases, you just need to retrieve some configuration or modify
    an existing one without going deeply into writing regular expressions, and that
    was the reason for the birth of the `CiscoConfParse` library ([https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络配置上应用正则表达式以从输出中获取特定信息需要我们编写一些复杂的表达式来解决一些复杂的用例。在某些情况下，您只需要检索一些配置或修改现有配置而不深入编写正则表达式，这就是`CiscoConfParse`库诞生的原因（[https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)）。
- en: CiscoConfParse library
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CiscoConfParse库
- en: 'As the official GitHub page says, the library examines an iOS-style config
    and breaks it into a set of linked parent/child relationships. You can perform
    complex queries on these relationships:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如官方GitHub页面所说，该库检查了一个类似iOS风格的配置，并将其分解成一组链接的父/子关系。您可以对这些关系执行复杂的查询：
- en: '![](../images/00098.jpeg)Source: [https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00098.jpeg)来源：[https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)'
- en: So, the first line of the configuration is considered the parent, while the
    subsequent lines are considered the children of the parent. The `CiscoConfparse`
    library builds the relationship between parent and child into an object so the
    end user can easily retrieve the configuration of a specific parent without the
    need to write complex expressions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，配置的第一行被视为父级，而后续行被视为父级的子级。`CiscoConfparse`库将父级和子级之间的关系构建成一个对象，因此最终用户可以轻松地检索特定父级的配置，而无需编写复杂的表达式。
- en: It's extremely important that your configuration file is well-formatted in order
    to build the correct relationship between the parent and child.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，您的配置文件格式良好，以便在父级和子级之间建立正确的关系。
- en: The same concept also applies if you need to inject configuration into the file.
    The library will search for the given parent and will insert the configuration
    just under it and save it to the new file. This is helpful in case you need to
    run a config audit job on multiple files and make sure they all have a consistent
    configuration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要向文件中注入配置，也适用相同的概念。该库将搜索给定的父级，并将配置插入其下方，并保存到新文件中。这在您需要对多个文件运行配置审计作业并确保它们都具有一致的配置时非常有用。
- en: Supported vendors
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持的供应商
- en: As a rule of thumb, any file that has a tab-delimited configuration can be parsed
    by `CiscoConfParse` and it will build the parent and child relationship.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，任何具有制表符分隔配置的文件都可以被`CiscoConfParse`解析，并且它将构建父子关系。
- en: 'The following is the list of supported vendors:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是支持的供应商列表：
- en: Cisco IOS, Cisco Nexus, Cisco IOS-XR, Cisco IOS-XE, Aironet OS, Cisco ASA, Cisco
    CatOS
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco IOS，Cisco Nexus，Cisco IOS-XR，Cisco IOS-XE，Aironet OS，Cisco ASA，Cisco CatOS
- en: Arista EOS
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista EOS
- en: Brocade
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brocade
- en: HP switches
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HP交换机
- en: Force10 switches
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Force10交换机
- en: Dell PowerConnect switches
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dell PowerConnect交换机
- en: Extreme Networks
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Extreme Networks
- en: Enterasys
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enterasys
- en: ScreenOS
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScreenOS
- en: 'Also, starting from version 1.2.4, `CiscoConfParse` can handle the curly braces
    delimited configuration, which means it can handle the following vendors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，从1.2.4版本开始，`CiscoConfParse`可以处理花括号分隔的配置，这意味着它可以处理以下供应商：
- en: Juniper Network's Junos OS
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper Network的Junos OS
- en: Palo Alto Networks firewall configurations
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Palo Alto Networks防火墙配置
- en: F5 Networks configurations
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F5 Networks配置
- en: CiscoConfParse installation
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CiscoConfParse安装
- en: '`CiscoConfParse` can be installed by using `pip` on the Windows command line
    or Linux shell:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`CiscoConfParse`可以通过在Windows命令行或Linux shell上使用`pip`来安装：'
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../images/00099.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00099.jpeg)'
- en: Notice that some additional dependencies are also installed, such as `ipaddr`,
    `dnsPython`, and `colorama`, which are used by `CiscoConfParse`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还安装了一些其他依赖项，例如`ipaddr`，`dnsPython`和`colorama`，这些依赖项被`CiscoConfParse`使用。
- en: Working with CiscoConfParse
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CiscoConfParse
- en: The first example that we will work on is extracting the shutdown interfaces
    from a sample Cisco configuration located in a file named `Cisco_Config.txt`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一个示例是从名为`Cisco_Config.txt`的文件中提取关闭接口的示例Cisco配置。
- en: '![](../images/00100.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00100.jpeg)'
- en: 'In this example, we can see the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: From the `CiscoConfParse` module, we imported the `CiscoConfParse` class. Also,
    we imported the `pprint` module to print the output in readable format to fit
    the Python console output.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`CiscoConfParse`模块中，我们导入了`CiscoConfParse`类。同时，我们导入了`pprint`模块，以便以可读格式打印输出以适应Python控制台输出。
- en: Then, we provided the `config` file full path to the `CiscoConfParse` class.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`config`文件的完整路径提供给`CiscoConfParse`类。
- en: The final step is to use one of the built-in functions such as `find_parents_w_child()`
    and provide two parameters. The first one is the parent specification, which is
    searching for anything starting with the `interface` keyword, while the child
    specification has the `shutdown` keyword.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是使用内置函数之一，例如`find_parents_w_child()`，并提供两个参数。第一个是父级规范，它搜索以`interface`关键字开头的任何内容，而子规范具有`shutdown`关键字。
- en: As you can see, in three simple steps, we were able to get all interfaces that
    have the shutdown keyword inside and output as a structured list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在三个简单的步骤中，我们能够获取所有具有关闭关键字的接口，并以结构化列表输出。
- en: '**Example 1 output**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例1输出**'
- en: '![](../images/00101.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00101.jpeg)'
- en: '**Example 2: Checking the existing of a specific feature**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例2：检查特定功能的存在**'
- en: 'The second example will check whether the router keyword exists within the
    configuration file as an indication of whether a routing protocol, such as `ospf`
    or `bgp` is enabled or not. If the module finds it, then the result will be `True`.
    Otherwise, it will be `False`. This can be achieved by a built-in function within
    a module called `has_line_with()`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例将检查配置文件中是否存在路由器关键字，以指示路由协议（例如`ospf`或`bgp`）是否已启用。如果模块找到它，则结果将为`True`。否则，将为`False`。这可以通过模块内的内置函数`has_line_with()`来实现：
- en: '![](../images/00102.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00102.jpeg)'
- en: This method can be used to design a condition inside an `if` statement, as we
    will see in the next and final example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以用于设计`if`语句内的条件，我们将在下一个和最后一个示例中看到。
- en: '**Example 2 output**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例2输出**'
- en: '![](../images/00103.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00103.jpeg)'
- en: '**Example 3: Printing specific children from a parent**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例3：从父级打印特定子项**：'
- en: '![](../images/00104.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00104.jpeg)'
- en: 'In this example, we can see the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: From the `CiscoConfParse` module, we imported the `CiscoConfParse` class. Also,
    we imported the `pprint` module to print the output in readable format to fit
    the Python console output.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`CiscoConfParse`模块中，我们导入了`CiscoConfParse`类。同时，我们导入了`pprint`模块，以便以可读格式打印输出以适应Python控制台输出。
- en: Then, we provided the `config` file full path to the `CiscoConfParse` class.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`config`文件的完整路径提供给`CiscoConfParse`类。
- en: We used one of the built-in functions, such as `find_all_children()`, and provided
    only the parent. This will instruct the `CiscoConfParse` class to list all configuration
    lines under this parent.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了一个内置函数，例如`find_all_children()`，并且只提供了父级。这将指示`CiscoConfParse`类列出此父级下的所有配置行。
- en: Finally, we iterated over the returned output (remember, it's a list) and checked
    whether the network keyword exists within the string. If yes, then it will append
    it to the network list, which will be printed at the end.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们遍历返回的输出（记住，它是一个列表），并检查字符串中是否存在网络关键字。如果是，则将其附加到网络列表中，并在最后打印出来。
- en: '**Example 3 output:**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例3输出：**'
- en: '![](../images/00105.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00105.jpeg)'
- en: 'There''re many other functions available inside the `CiscoConfParse` module
    that could be used to easily extract data from the configuration file and return
    the output in a structured format. Here is a list of other functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`CiscoConfParse`模块中还有许多其他可用的函数，可用于轻松从配置文件中提取数据并以结构化格式返回输出。以下是其他函数的列表：'
- en: '`find_lineage`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_lineage`'
- en: '`find_lines()`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找行()
- en: '`find_all_children()`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有子级()
- en: '`find_blocks()`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找块()
- en: '`find_parent_w_children()`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找有子级的父级()
- en: '`find_children_w_parent()`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找有父级的子级()
- en: '`find_parent_wo_children()`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找没有子级的父级()
- en: '`find_children_wo_parent()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找没有父级的子级()
- en: Visualizing returned data with matplotLib
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用matplotLib可视化返回的数据
- en: As an old saying goes, *a picture is worth a thousand words*. There's a lot
    of information that could be extracted from the network, such as interface status,
    interface counters, router updates, packets dropped, traffic volume, and more.
    Visualizing this data and putting it into a graph will help you to see the big
    picture of your network. Python has an excellent library called **matplotlib**
    ([https://matplotlib.org/](https://matplotlib.org/)) that is used to generate
    graphs and customize them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说，“一图胜千言”。可以从网络中提取大量信息，如接口状态、接口计数器、路由器更新、丢包、流量量等。将这些数据可视化并放入图表中将帮助您看到网络的整体情况。Python有一个名为**matplotlib**的优秀库（[https://matplotlib.org/](https://matplotlib.org/)），用于生成图表并对其进行自定义。
- en: Matplotlib is capable of creating most kinds of charts, such as line graphs,
    scatter plots, bar charts, pie charts, stack plots, 3D graphs, and geographic
    map graphs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib能够创建大多数类型的图表，如折线图、散点图、条形图、饼图、堆叠图、3D图和地理地图图表。
- en: Matplotlib installation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib安装
- en: 'We will start by first installing the library from PYpI using `pip`. Notice
    some additional packages will be installed along with matplotlib, such as `numpy`
    and `six`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`pip`从PYpI安装库。请注意，除了matplotlib之外，还将安装一些其他包，如`numpy`和`six`：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../images/00106.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00106.jpeg)'
- en: 'Now, try to import `matplotlib` and, if no errors are printed, then the module
    is successfully imported:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试导入`matplotlib`，如果没有打印错误，则成功导入模块：
- en: '![](../images/00107.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00107.jpeg)'
- en: Hands-on with matplotlib
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib实践
- en: 'We will start with simple examples to explore matplotlib''s functionality.
    The first thing we do usually is import `matplotlib` into our Python script:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的示例开始，以探索matplotlib的功能。我们通常做的第一件事是将`matplotlib`导入到我们的Python脚本中：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice we imported `pyplot` as a short name, `plt`, to be used inside our script.
    Now, we will use the `plot()` method inside it to plot our data, which consists
    of two lists. The first list represents the values of the *x*-axis while the second
    list represents the values of the *y*-axis:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`pyplot`导入为一个简短的名称`plt`，以便在我们的脚本中使用。现在，我们将在其中使用`plot()`方法来绘制我们的数据，其中包括两个列表。第一个列表表示*x*轴的值，而第二个列表表示*y*轴的值：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the values are dropped into the plot.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些值被放入了图表中。
- en: 'The last step is to show that plot as a window using the `show()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`show()`方法将该图表显示为窗口：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](../images/00108.jpeg)You may need to install `Python-tk` in Ubuntu in order
    to view the graph. Use `apt install Python-tk`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00108.jpeg)在Ubuntu中，您可能需要安装`Python-tk`才能查看图表。使用`apt install Python-tk`。'
- en: 'The resulted graph will show a line representing the input values of the x
    and y axes. In the window, you can do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表将显示代表x轴和y轴输入值的线。在窗口中，您可以执行以下操作：
- en: Move the graph around with the cross icon
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用十字图标移动图表
- en: Resize the graph
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整图表大小
- en: Zoom into a specific area with the zoom icon
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩放图标放大特定区域
- en: Reset to the original view with the home icon
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主页图标重置到原始视图
- en: Save the figure with the save icon
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用保存图标保存图表
- en: 'You can customize the generated figure by adding a title to it and labels to
    both axes. Also, add a legend that explains the meaning of each line in case there
    are multiple lines on the same graph:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为图表添加标题和两个轴的标签来自定义生成的图表。此外，如果图表上有多条线，还可以添加解释每条线含义的图例：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../images/00109.jpeg)Notice that we usually don''t hardcode the plotted
    values inside the Python script, but we will get them externally from the network,
    as we will see in the next example.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00109.jpeg)请注意，我们通常不会在Python脚本中硬编码绘制的值，而是会从网络外部获取这些值，这将在下一个示例中看到。'
- en: 'Also, you can plot multiple datasets on the same figure. You can add another
    list that represents data to the previous figure and `matplotlib` will draw it.
    Also, you can add labels to differentiate between the datasets on the graph. The
    legend for these labels will be printed on the graph using the `legend()` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在同一图表上绘制多个数据集。您可以添加另一个代表先前图表数据的列表，`matplotlib`将绘制它。此外，您可以添加标签以区分图表上的数据集。这些标签的图例将使用`legend()`函数打印在图表上：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../images/00110.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00110.jpeg)'
- en: Visualizing SNMP using matplotlib
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用matplotlib可视化SNMP
- en: 'In this use case, we will utilize the `pysnmp` module to send SNMP `GET` requests
    to our router, retrieve the input and output traffic rates for a specific interface,
    and visualize the output using the `matplotlib` library. The OIDs used are `.1.3.6.1.4.1.9.2.2.1.1.6`
    and `.1.3.6.1.4.1.9.2.2.1.1.8`, which represent the input and output rates respectively:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们将利用`pysnmp`模块向路由器发送SNMP `GET`请求，检索特定接口的输入和输出流量速率，并使用`matplotlib`库对输出进行可视化。使用的OID是`.1.3.6.1.4.1.9.2.2.1.1.6`和`.1.3.6.1.4.1.9.2.2.1.1.8`，分别表示输入和输出速率：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we can see the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到以下内容：
- en: We imported `cmdgen` from the `pysnmp` module, which was used to create SNMP
    `GET` commands for the router. We also imported the `matplotlib` module.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`pysnmp`模块导入了`cmdgen`，用于为路由器创建SNMP `GET`命令。我们还导入了`matplotlib`模块。
- en: Then, we used `cmdgen` to define the transport channel properties between Python
    and the router and provide the SNMP community.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用`cmdgen`来定义Python和路由器之间的传输通道属性，并提供SNMP社区。
- en: '`pysnmp` will start to send the SNMP GET requests with the provided OIDs and
    return the output and errors (if any) to `errorIndication`, `errorStatus`, `errorIndex`,
    and `varBinds`. We are interested in `varBinds` as it holds the actual values
    for the input and output traffic rate.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pysnmp`将开始使用提供的OID发送SNMP GET请求，并将输出和错误（如果有）返回到`errorIndication`、`errorStatus`、`errorIndex`和`varBinds`。我们对`varBinds`感兴趣，因为它包含输入和输出流量速率的实际值。'
- en: Note that `varBinds` will be in the form of `<oid> = <value>`, so we extracted
    only the value and added it to the corresponding list we created before.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，`varBinds` 的形式将是 `<oid> = <value>`，因此我们只提取了值，并将其添加到之前创建的相应列表中。
- en: This operation will be repeated 100 times at 6-second intervals to collect useful
    data.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个操作将在6秒的间隔内重复100次，以收集有用的数据。
- en: 'Finally, we provided the collected data to the `plt` imported from `matplotlib`
    and customized the graph by providing the `xlabel`, `ylabel`, title, and `legends`:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将收集到的数据提供给从 `matplotlib` 导入的 `plt`，并通过提供 `xlabel`、`ylabel`、标题和 `legends`
    来自定义图表：
- en: '**Script output**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本输出**：'
- en: '![](../images/00111.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00111.jpeg)'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use different tools and techniques inside
    Python to extract useful data from returned output and act upon it. Also, we used
    a special library called `CiscoConfParse` to audit the configuration and learned
    how to visualize data to generate appealing graphs and reports.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Python中使用不同的工具和技术从返回的输出中提取有用的数据并对其进行操作。此外，我们使用了一个名为 `CiscoConfParse`
    的特殊库来审计配置，并学习了如何可视化数据以生成吸引人的图表和报告。
- en: In the next chapter, we will learn how to write a template and use it to generate
    configurations with a Jinja2 templating language.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写模板并使用它来使用 Jinja2 模板语言生成配置。
