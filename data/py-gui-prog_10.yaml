- en: Improving Data Storage with SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQL改进数据存储
- en: 'As weeks have passed by, there is a growing problem at the lab: the CSV files
    are everywhere! Conflicting copies, missing files, records getting changed by
    non-data entry staff, and other CSV-related frustrations are plaguing the project.
    It''s clear that individual CSV files are not working out as a way to store data
    for the experiments. Something better is needed.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，实验室出现了一个越来越严重的问题：CSV文件到处都是！冲突的副本，丢失的文件，非数据输入人员更改的记录，以及其他与CSV相关的挫折正在困扰着项目。很明显，单独的CSV文件不适合作为存储实验数据的方式。需要更好的东西。
- en: The facility has an older Linux server with a PostgreSQL database installed.
    You've been asked to update your program so that it stores data in the PostgreSQL
    database rather than in the CSV files. This promises to be a major update to your
    application!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 该设施有一个安装了PostgreSQL数据库的较旧的Linux服务器。您被要求更新您的程序，以便将数据存储在PostgreSQL数据库中，而不是在CSV文件中。这将是对您的应用程序的重大更新！
- en: 'In this chapter, you''ll learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Installing and configuring the PostgreSQL database system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置PostgreSQL数据库系统
- en: Structuring data in a database for good performance and reliability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中构建数据以获得良好的性能和可靠性
- en: The basics of SQL queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL查询的基础知识
- en: Using the `psycopg2` library to connect your program to PostgreSQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`psycopg2`库将您的程序连接到PostgreSQL
- en: PostgreSQL
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL (usually pronounced post-gress) is a free, open source, cross-platform
    relational database system. It runs as a network service with which you can communicate
    using client programs or software libraries. At the time of writing, the project
    has just released version 10.0.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL（通常发音为post-gress）是一个免费的、开源的、跨平台的关系数据库系统。它作为一个网络服务运行，您可以使用客户端程序或软件库进行通信。在撰写本文时，该项目刚刚发布了10.0版本。
- en: Although ABQ has provided a PostgreSQL server which is already installed and
    configured, you'll need to download and install the software on your workstation
    for development purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ABQ提供了一个已安装和配置的PostgreSQL服务器，但您需要为开发目的在您的工作站上下载并安装该软件。
- en: Shared production resources such as databases and web services should never
    be used for testing or development. Always set up a separate development copy
    of these resources on your own workstation or a separate server machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的生产资源，如数据库和网络服务，永远不应该用于测试或开发。始终在您自己的工作站或单独的服务器上设置这些资源的独立开发副本。
- en: Installing and configuring PostgreSQL
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置PostgreSQL
- en: To download PostgreSQL, visit [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    Installers are provided for Windows, macOS, and Linux by the EnterpriseDB company,
    a commercial entity that provides paid support for PostgreSQL. These packages
    include the server, command-line client, and pgAdmin graphical client all in one
    package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载PostgreSQL，请访问[https://www.postgresql.org/download/](https://www.postgresql.org/download)。EnterpriseDB公司为Windows、macOS和Linux提供了安装程序，这是一个为PostgreSQL提供付费支持的商业实体。这些软件包包括服务器、命令行客户端和pgAdmin图形客户端。
- en: To install the software, launch the installer using an account with administrative
    rights and follow the screens in the installation wizard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装软件，请使用具有管理权限的帐户启动安装程序，并按照安装向导中的屏幕进行操作。
- en: Once installed, launch pgAdmin and create a new admin user for yourself by selecting Object |
    Create | Login/Group Role. Make sure to visit the Privileges tab to check Superuser,
    and the Definition tab to set a password. Then, create a database by selecting
    Object | Create | Database. Make sure to set your user as an owner. To run SQL
    commands on your database, select your database and click Tools | Query Tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，启动pgAdmin，并通过选择Object | Create | Login/Group Role来为自己创建一个新的管理员用户。确保访问特权选项卡以检查超级用户，并访问定义选项卡以设置密码。然后，通过选择Object
    | Create | Database来创建一个数据库。确保将您的用户设置为所有者。要在数据库上运行SQL命令，请选择您的数据库并单击Tools | Query
    Tool。
- en: 'MacOS or Linux users who prefer the command line can also use the following
    these commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢使用命令行的MacOS或Linux用户也可以使用以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although Enterprise DB provides binary installers for Linux, most Linux users
    will prefer to use packages supplied by their distribution. You may end up with
    a slightly older version of PostgreSQL, but that won't matter for most basic use
    cases. Be aware that pgAdmin is usually part of a separate package, and that the
    latest version (pgAdmin 4) may not be available. Regardless, you should have no
    trouble following this chapter with the older version.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Enterprise DB为Linux提供了二进制安装程序，但大多数Linux用户更喜欢使用其发行版提供的软件包。您可能会得到一个稍旧的PostgreSQL版本，但对于大多数基本用例来说这并不重要。请注意，pgAdmin通常是单独的软件包的一部分，最新版本（pgAdmin
    4）可能不可用。不过，您应该没有问题遵循本章使用旧版本。
- en: Connecting with psycopg2
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用psycopg2连接
- en: To make SQL queries from our application, we'll need to install a Python library
    that can talk directly to our database. The most popular choice is `psycopg2`.
    The `psycopg2` library is not a part of the Python standard library. You can find
    the most current installation instructions at [http://initd.org/psycopg/docs/install.html](http://initd.org/psycopg/docs/install.html);
    however, the preferred method is to use `pip`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的应用程序进行SQL查询，我们需要安装一个可以直接与我们的数据库通信的Python库。最受欢迎的选择是`psycopg2`。`psycopg2`库不是Python标准库的一部分。您可以在[http://initd.org/psycopg/docs/install.html](http://initd.org/psycopg/docs/install.html)找到最新的安装说明；但是，首选方法是使用`pip`。
- en: 'For Windows, macOS, and Linux, the following command should work:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows、macOS和Linux，以下命令应该有效：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If that doesn't work, or if you'd rather install it from the source, check the
    requirements on the website. The `psycopg2` library is written in C, not Python,
    so it requires a C compiler and a few other development packages. Linux users
    can usually install `psycopg2` from their distribution's package management system.
    We'll get in-depth with the use of `psycopg2` later in the chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不起作用，或者您更愿意从源代码安装它，请在网站上检查要求。`psycopg2`库是用C编写的，而不是Python，因此它需要C编译器和其他几个开发包。Linux用户通常可以从其发行版的软件包管理系统中安装`psycopg2`。我们将在本章后面深入研究`psycopg2`的使用。
- en: SQL and relational database basics
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL和关系数据库基础知识
- en: Before we can start using PostgreSQL with Python, you'll need to have at least
    a basic understanding of SQL. If you already have one, you can skip to the next
    section; otherwise, brace yourself for a super-short crash course on relational
    databases and SQL.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Python与PostgreSQL之前，您至少需要对SQL有基本的了解。如果您已经有了，可以跳到下一节；否则，准备好接受关系数据库和SQL的超短速成课程。
- en: For over three decades, relational database systems have remained a de-facto
    standard for storing business data. They are more commonly known as **SQL databases**,
    after the **Structured Query Language** (**SQL**) used to interact with them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 三十多年来，关系数据库系统一直是存储业务数据的事实标准。它们更常被称为**SQL数据库**，因为与它们交互的**结构化查询语言**（**SQL**）。
- en: SQL databases are made up of tables. A table is something like our CSV file,
    in that it has rows representing individual items and columns representing data
    values associated with each item. A SQL table has some important differences from
    our CSV file. First, each column in the table is assigned a data type which is
    strictly enforced; just as Python will produce an error when you try to use `abcd`
    as an `int`, a SQL database will complain if you try to insert letters into a
    numeric or other non-string column. SQL databases typically support data types
    for text, numbers, dates and times, boolean values, binary data, and more.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库由表组成。表类似于我们的CSV文件，因为它具有表示单个项目的行和表示与每个项目关联的数据值的列。SQL表与我们的CSV文件有一些重要的区别。首先，表中的每一列都被分配了一个严格执行的数据类型；就像当您尝试将`abcd`作为`int`使用时，Python会产生错误一样，当您尝试将字母插入到数字或其他非字符串列中时，SQL数据库会抱怨。SQL数据库通常支持文本、数字、日期和时间、布尔值、二进制数据等数据类型。
- en: SQL tables can also have constraints, which further enforce the validity of
    data inserted into the table. For example, a column can be given a unique constraint,
    which prevents two rows having the same value, or a not null constraint, which
    means that every row must have a value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SQL表还可以具有约束，进一步强制执行插入到表中的数据的有效性。例如，可以给列添加唯一约束，这可以防止两行具有相同的值，或者添加非空约束，这意味着每一行都必须有一个值。
- en: SQL databases commonly contain many tables; these tables can be joined together
    to represent much more complicated data structures. By breaking data into multiple
    linked tables, it can be stored in a way that is much more efficient and resilient
    than our two-dimensional plaintext CSV files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库通常包含许多表；这些表可以连接在一起，以表示更复杂的数据结构。通过将数据分解为多个链接的表，可以以比我们的二维纯文本CSV文件更有效和更具弹性的方式存储数据。
- en: Basic SQL operations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的SQL操作
- en: SQL is a powerful and expressive language for doing mass manipulations of tabular
    data, but the basics can be grasped quickly. SQL is executed as individual queries
    which either define or manipulate data in the database. SQL dialects vary somewhat
    between different relational database products, but most of them support ANSI/ISO-standard
    SQL for core operations. While we'll be using PostgreSQL in this chapter, most
    of the SQL statements we write will be portable to different databases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是一个用于对表格数据进行大规模操作的强大而表达性的语言，但基础知识可以很快掌握。SQL作为单独的查询来执行，这些查询要么定义数据，要么在数据库中操作数据。SQL方言在不同的关系数据库产品之间略有不同，但它们大多数支持ANSI/ISO标准SQL进行核心操作。虽然我们将在本章中使用PostgreSQL，但我们编写的大多数SQL语句都可以在不同的数据库中使用。
- en: To follow this section, connect to an empty database on your PostgreSQL database
    server, either using the `psql` command-line tool, the pgAdmin 4 graphical tool,
    or another database client software of your choosing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本节，连接到您的PostgreSQL数据库服务器上的空数据库，可以使用`psql`命令行工具、pgAdmin 4图形工具或您选择的其他数据库客户端软件。
- en: Syntax differences from Python
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Python的语法差异
- en: If you've only ever programmed in Python, SQL may feel odd at first, as the
    rules and syntax are very different.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只在Python中编程过，那么最初可能会觉得SQL很奇怪，因为规则和语法非常不同。
- en: 'We''ll be going over the individual commands and keywords, but the following
    are some general differences from Python:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍各个命令和关键字，但以下是与Python不同的一些一般区别：
- en: '**SQL is (mostly) case-insensitive**: Although it''s conventional for readability
    purposes to type the SQL keywords in all-caps, most SQL implementations are not
    case-sensitive. There are a few small exceptions here and there, but, for the
    most part, you can type SQL in whatever case is easiest for you.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL（大部分）不区分大小写**：尽管为了可读性的目的，按照惯例，将SQL关键字输入为全大写，但大多数SQL实现不区分大小写。这里有一些小的例外，但大部分情况下，您可以以最容易的方式输入SQL的大小写。'
- en: '**Whitespace is not significant**: In Python, new lines and indentation can
    change the meaning of a piece of code. In SQL, whitespace is not significant and
    statements are terminated with a semicolon. Indents and new lines in a query are
    only there for readability.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空格不重要**：在Python中，换行和缩进可以改变代码的含义。在SQL中，空格不重要，语句以分号结尾。查询中的缩进和换行只是为了可读性。'
- en: '**SQL is declarative**: Python could be described as an imperative programming
    language: we tell Python what we want it to do by telling it how to do it. SQL
    is more of a declarative language: we describe what we want, and the SQL engine
    figures out how to do it.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL是声明性的**：Python可以被描述为一种命令式编程语言：我们通过告诉Python如何做来告诉Python我们想要它做什么。SQL更像是一种声明性语言：我们描述我们想要的，SQL引擎会找出如何做。'
- en: We'll encounter additional syntax differences as we look at specific SQL code
    examples.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看特定的SQL代码示例时，我们会遇到其他语法差异。
- en: Defining tables and inserting data
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义表和插入数据
- en: 'SQL tables are created using the `CREATE TABLE` command as shown in the following
    SQL query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SQL表是使用`CREATE TABLE`命令创建的，如下面的SQL查询所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we're creating a table called `musicians`. After the name,
    we specify a list of column definitions. Each column definition follows the format
    `column_name data_type constraints`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在创建一个名为`musicians`的表。在名称之后，我们指定了一系列列定义。每个列定义都遵循`column_name data_type
    constraints`的格式。
- en: 'In this case, we have the following four columns:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有以下四列：
- en: The `id` column will be an arbitrary row ID. It's type is `SERIAL`, which means
    it will be an autoincrementing integer field, and its constraint is `PRIMARY KEY`,
    which means it will be used as the unique identifier for the row.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`列将是任意的行ID。它的类型是`SERIAL`，这意味着它将是一个自动递增的整数字段，其约束是`PRIMARY KEY`，这意味着它将用作行的唯一标识符。'
- en: The `name` field is of type `TEXT`, so it can hold a string of any length. Its
    constraint of `NOT NULL` means that the `NULL` values are not allowed in this
    field.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`字段的类型是`TEXT`，因此它可以容纳任意长度的字符串。它的`NOT NULL`约束意味着在该字段中不允许`NULL`值。'
- en: The `born` and `died` fields are the `DATE` fields, so they can only hold a
    date value. The `born` field has no constraints, but `died` has a `CHECK` constraint
    enforcing that its value must be greater than the value of `born` for any given
    row.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`born`和`died`字段是`DATE`字段，因此它们只能容纳日期值。`born`字段没有约束，但`died`有一个`CHECK`约束，强制其值必须大于任何给定行的`born`的值。'
- en: Although it's not required, it's a good practice to specify a primary key for
    each table. Primary keys can be one field, or a combination of fields, but the
    value must be unique for any given row. For example, if we made `name` the primary
    key field, we couldn't have two musicians with the same name in our table.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但为每个表指定一个主键是一个好习惯。主键可以是一个字段，也可以是多个字段的组合，但对于任何给定的行，值必须是唯一的。例如，如果我们将`name`作为主键字段，那么我们的表中不能有两个同名的音乐家。
- en: 'To add rows of data to this table, we use the `INSERT INTO` command as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要向该表添加数据行，我们使用`INSERT INTO`命令如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `INSERT INTO` command takes a table name and an optional list specifying
    the fields to receive data; other fields will receive their default value (`NULL`
    if not otherwise specified in the `CREATE` statement). The `VALUES` keyword indicates
    that a list of data values to be followed, formatted as a comma-separated list
    of tuples. Each tuple corresponds to one table row and must match the field list
    specified after the table name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSERT INTO`命令接受表名和一个可选的列表，指定接收数据的字段；其他字段将接收它们的默认值（如果在`CREATE`语句中没有另外指定，则为`NULL`）。`VALUES`关键字表示要跟随的数据值列表，格式为逗号分隔的元组列表。每个元组对应一个表行，必须与在表名之后指定的字段列表匹配。'
- en: 'Note that strings are delimited by the single quote character. Unlike Python,
    single quotes and double quotes have different meanings in SQL: a single quote
    indicates a string literal, while double quotes are used for object names that
    include spaces or need to preserve case. Had we used double quotes here, it would
    have resulted in an error.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符串由单引号字符括起来。与Python不同，单引号和双引号在SQL中具有不同的含义：单引号表示字符串文字，而双引号用于包含空格或需要保留大小写的对象名称。如果我们在这里使用双引号，将导致错误。
- en: 'Let''s create and populate an `instruments` table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并填充一个`instruments`表：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `VALUES` lists must always use parentheses around each row, even
    if there's only one value per row.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`VALUES`列表必须始终在每一行周围使用括号，即使每行只有一个值。
- en: 'Tables can be changed after they are created using the `ALTER TABLE` command
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表在创建后可以使用`ALTER TABLE`命令进行更改，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ALTER TABLE` command takes a table name, then a command altering some aspect
    of the table. In this case, we're adding a new column called `main_instrument`,
    which will be an integer. The `REFERENCES` constraint we've specified is known
    as a **foreign key** constraint; it limits the possible values of `main_instrument`
    to existing ID numbers in the `instruments` table.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER TABLE`命令接受表名，然后是改变表的某个方面的命令。在这种情况下，我们正在添加一个名为`main_instrument`的新列，它将是一个整数。我们指定的`REFERENCES`约束称为**外键**约束；它将`main_instrument`的可能值限制为`instruments`表中现有的ID号码。'
- en: Retrieving data from tables
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从表中检索数据
- en: 'To retrieve data from tables, we use the `SELECT` statement as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表中检索数据，我们使用`SELECT`语句如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `SELECT` command takes a column or comma-separated list of columns followed
    by a `FROM` clause, which specifies the table or tables containing the specified
    columns. This query asks for the `name` column from the `musicians` table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`命令接受一个列或以逗号分隔的列列表，后面跟着一个`FROM`子句，指定包含指定列的表或表。此查询要求从`musicians`表中获取`name`列。'
- en: 'Its output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它的输出如下：
- en: '| `name` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `name` |'
- en: '| `Bill Bruford` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Bill Bruford` |'
- en: '| `Keith Emerson` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Keith Emerson` |'
- en: '| `Greg Lake` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Greg Lake` |'
- en: '| `Robert Fripp` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Robert Fripp` |'
- en: '| `David Gilmour` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `David Gilmour` |'
- en: 'Instead of a list of columns, we can also specify an asterisk, which means
    all columns as shown in the following query:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定一个星号，表示所有列，如下面的查询所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The  preceding SQL query returns a following table of data:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的SQL查询返回以下数据表：
- en: '| `ID` | `name` | `born` | `died` | `main_instrument` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `ID` | `name` | `born` | `died` | `main_instrument` |'
- en: '| `4` | `Bill Bruford` | `1949-05-17` |  |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `Bill Bruford` | `1949-05-17` |  |  |'
- en: '| `2` | `Keith Emerson` | `1944-11-02` | `2016-03-11` |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `Keith Emerson` | `1944-11-02` | `2016-03-11` |  |'
- en: '| `3` | `Greg Lake` | `1947-11-10` | `2016-12-07` |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `Greg Lake` | `1947-11-10` | `2016-12-07` |  |'
- en: '| `1` | `Robert Fripp` | `1946-05-16` |  |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `Robert Fripp` | `1946-05-16` |  |  |'
- en: '| `5` | `David Gilmour` | `1946-03-06` |  |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `5` | `David Gilmour` | `1946-03-06` |  |  |'
- en: 'To filter out rows we don''t want, we can specify a `WHERE` clause as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤掉我们不想要的行，我们可以指定一个`WHERE`子句，如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `WHERE` command must be followed by a conditional statement; rows that satisfy
    the condition are shown, while rows that do not are left out. In this case, we
    have asked for the names of musicians who do not have a date of death.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`命令必须跟随一个条件语句；满足条件的行将被显示，而不满足条件的行将被排除。在这种情况下，我们要求没有死亡日期的音乐家的名字。'
- en: 'We can specify complex conditions with the `AND` and `OR` operators as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AND`和`OR`运算符指定复杂条件如下：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, we would only get musicians born before 1945 who have not died.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只会得到1945年之前出生且尚未去世的音乐家。
- en: 'The `SELECT` command can also do operations on fields, or re-order the results
    by certain columns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`命令也可以对字段进行操作，或者按照某些列重新排序结果：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we're using the `age()` function to determine the age of the
    musicians from their birth dates. We're also doing math on the `died` and `born`
    dates to determine the age at death for those who have passed. Notice that we're
    using the `AS` keyword to rename, or alias, the generated column.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`age()`函数来确定音乐家的年龄。我们还对`died`和`born`日期进行数学运算，以确定那些已故者的死亡年龄。请注意，我们使用`AS`关键字来重命名或别名生成的列。
- en: When you run this query, notice that `age at death` is `NULL` for those without
    a date of death. Mathematical or logical operations on a `NULL` value always return
    an answer of `NULL`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此查询时，请注意，对于没有死亡日期的人，`age at death`为`NULL`。对`NULL`值进行数学或逻辑运算总是返回`NULL`。
- en: The `ORDER BY` clause specifies a column or list of columns by which the results
    should be ordered. It also takes an argument of `DESC` or `ASC` to specify descending
    or ascending order. We have ordered the output here by date of birth in descending
    order. Note that each data type has its own rules for sorting data, just like
    in Python. Dates are ordered by their calendar position, strings by alphabetical
    order, and numbers by their numeric value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDER BY`子句指定结果应该按照哪些列进行排序。它还接受`DESC`或`ASC`的参数来指定降序或升序。我们在这里按出生日期降序排序输出。请注意，每种数据类型都有其自己的排序规则，就像在Python中一样。日期按照它们的日历位置排序，字符串按照字母顺序排序，数字按照它们的数值排序。'
- en: Updating rows, deleting rows, and more WHERE clauses
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新行，删除行，以及更多的WHERE子句
- en: To update or delete existing rows, we use the `UPDATE` and `DELETE FROM` keywords
    in conjunction with a `WHERE` clause to select the affected rows.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新或删除现有行，我们使用`UPDATE`和`DELETE FROM`关键字与`WHERE`子句一起选择受影响的行。
- en: 'Deleting is fairly simple looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 删除很简单，看起来像这样：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `DELETE FROM` command will delete any rows that match the `WHERE` conditions.
    In this case, we match the primary key to ensure only one row is deleted. If no
    rows match the `WHERE` conditions, no rows will be deleted. Note, however, that
    the `WHERE` clause is technically optional: `DELETE FROM instruments` will simply
    delete all rows in the table.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE FROM`命令将删除与`WHERE`条件匹配的任何行。在这种情况下，我们匹配主键以确保只删除一行。如果没有行与`WHERE`条件匹配，将不会删除任何行。然而，请注意，`WHERE`子句在技术上是可选的：`DELETE
    FROM instruments`将简单地删除表中的所有行。'
- en: 'Updating is similar, except it includes a `SET` clause to specify new column
    values as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更新类似，只是包括一个`SET`子句来指定新的列值如下：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we are setting `main_instrument` to the corresponding `instruments` primary
    key value for two musicians. We can select our musician records to update by primary
    key, name, or any valid set of conditions. Like `DELETE`, omitting the `WHERE`
    clause would affect all rows.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`main_instrument`设置为两位音乐家对应的`instruments`主键值。我们可以通过主键、名称或任何有效的条件集来选择要更新的音乐家记录。与`DELETE`一样，省略`WHERE`子句会影响所有行。
- en: 'Any number of columns can be updated in the `SET` clause:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`子句中可以更新任意数量的列：'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additional column updates are just separated by commas. Note that we''ve also
    matched the record using the `LIKE` operator in tandem with the `%` wildcard character.
    `LIKE` can be used with text and string data types to match partial values. Standard
    SQL supports two wildcard characters: `%`, which matches any number of characters,
    and `_`, which matches a single character.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的列更新只需用逗号分隔。请注意，我们还使用`LIKE`运算符与`%`通配符一起匹配记录。`LIKE`可用于文本和字符串数据类型，以匹配部分数值。标准SQL支持两个通配符字符：`%`，匹配任意数量的字符，`_`，匹配单个字符。
- en: 'We can also match against transformed column values:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以匹配转换后的列值：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we've used the `LOWER` function to match our string against the lowercase
    version of the column value. This doesn't permanently change the data in the table;
    it just temporarily changes the value for the check.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`LOWER`函数将我们的字符串与列值的小写版本进行匹配。这不会永久改变表中的数据；它只是临时更改值以进行检查。
- en: Standard SQL specifies that `LIKE` is a case-sensitive match. PostgreSQL offers
    an `ILIKE` operator which does case-insensitive matching as well as a `SIMILAR
    TO` operator that matches using more advanced regular expression syntax.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 标准SQL规定`LIKE`是区分大小写的匹配。PostgreSQL提供了一个`ILIKE`运算符，它可以进行不区分大小写的匹配，还有一个`SIMILAR
    TO`运算符，它使用更高级的正则表达式语法进行匹配。
- en: Subqueries
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子查询
- en: 'Rather than using the raw primary key values of our `instruments` table each
    time, we can use a subquery as shown in the following SQL query:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与其每次使用`instruments`表的原始主键值，我们可以像以下SQL查询中所示使用子查询：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A subquery is a SQL query within a SQL query. If your subquery can be guaranteed
    to return a single value, it can be used anywhere you would use a literal value.
    In this case, we're letting our database do the work of figuring out what the
    primary key of `guitar` is, and inserting that for our `main_instrument` value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询是SQL查询中的SQL查询。如果可以保证子查询返回单个值，它可以用在任何需要使用文字值的地方。在这种情况下，我们让我们的数据库来确定`guitar`的主键是什么，并将其插入我们的`main_instrument`值。
- en: In the `WHERE` clause, we've also used the `IN` operator to match against a
    list of values. This allows us to match against a list of values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WHERE`子句中，我们还使用`IN`运算符来匹配一个值列表。这允许我们匹配一个值列表。
- en: '`IN` can be used with a subquery as well as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`IN`可以与子查询一起使用，如下所示：'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since `IN` is meant to be used with a list of values, any query that returns
    a single column with any number of rows is valid.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`IN`是用于与值列表一起使用的，任何返回单列的查询都是有效的。
- en: 'Subqueries that return multiple rows and multiple columns can be used anywhere
    a table can be used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多行和多列的子查询可以在任何可以使用表的地方使用：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that subqueries in a `FROM` clause require an alias; we've aliased the
    subquery as `living_musicians`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`FROM`子句中的子查询需要一个别名；我们将子查询命名为`living_musicians`。
- en: Joining tables
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接表
- en: Subqueries are one way of using multiple tables together, but a more flexible
    and powerful way is to use `JOIN`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询是使用多个表的一种方法，但更灵活和强大的方法是使用`JOIN`。
- en: '`JOIN` is used in the `FROM` clause of an SQL statement as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`JOIN`在SQL语句的`FROM`子句中使用如下：'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A `JOIN` statement requires an `ON` clause that specifies the conditions used
    to match rows in each table. The `ON` clause acts like a filter, much like the
    `WHERE` clause does; you can imagine that the `JOIN` creates a new table containing
    every possible combination of rows from both tables, then filters out the ones
    that don't match the `ON` conditions. Tables are typically joined by matching
    the values in common fields, such as those specified in a foreign key constraint.
    In this case, our `musicians.main_instrument` column contains the `id` values
    from the `instrument` table, so we can join the two tables based on this.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`JOIN`语句需要一个`ON`子句，指定用于匹配每个表中的行的条件。`ON`子句就像一个过滤器，就像`WHERE`子句一样；你可以想象`JOIN`创建一个包含来自两个表的每个可能组合的新表，然后过滤掉不匹配`ON`条件的行。表通常通过匹配共同字段中的值进行连接，比如在外键约束中指定的那些字段。在这种情况下，我们的`musicians.main_instrument`列包含`instrument`表的`id`值，所以我们可以基于此连接这两个表。'
- en: 'Joins are used to implement the following four types of table relationships:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 连接用于实现以下四种类型的表关系：
- en: One-to-one joins match exactly one row in the first table to exactly one row
    in the second.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一连接将第一个表中的一行精确匹配到第二个表中的一行。
- en: Many-to-one joins match multiple rows in the first table to exactly one row
    in the second.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一连接将第一个表中的多行精确匹配到第二个表中的一行。
- en: One-to-many joins match one row in the first table to multiple rows in the second.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多连接将第一个表中的一行匹配到第二个表中的多行。
- en: Many-to-many joins match multiple rows in both tables. This kind of join requires
    the use of an intermediary table.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多连接匹配两个表中的多行。这种连接需要使用一个中间表。
- en: The earlier query shows a many-to-one join, since many musicians can have the
    same main instrument. Many-to-one joins are often used when a column's value should
    be limited to a set of options, such as fields that our GUI might represent with
    a `ComboBox` widget. The table joined is called a **lookup table**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的查询显示了一个多对一的连接，因为许多音乐家可以有相同的主要乐器。当一个列的值应该限制在一组选项时，通常会使用多对一连接，比如我们的GUI可能会用`ComboBox`小部件表示的字段。连接的表称为**查找表**。
- en: 'If we were to reverse it, it would be one-to-many:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要反转它，它将是一对多：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One-to-many joins are commonly used when a record has a list of sub-records
    associated with it; in this case, each instrument has a list of musicians who
    consider it their main instrument. The joined table is often called a **detail
    table**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多连接通常在记录有与之关联的子记录列表时使用；在这种情况下，每个乐器都有一个将其视为主要乐器的音乐家列表。连接的表通常称为**详细表**。
- en: 'The preceding SQL query will give you the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的SQL查询将给出以下输出：
- en: '| `instrument` | `musician` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `instrument` | `musician` |'
- en: '| `drums` | `Bill Bruford` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `drums` | `Bill Bruford` |'
- en: '| `keyboards` | `Keith Emerson` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `keyboards` | `Keith Emerson` |'
- en: '| `bass` | `Greg Lake` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `bass` | `Greg Lake` |'
- en: '| `guitar` | `Robert Fripp` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `guitar` | `Robert Fripp` |'
- en: '| `guitar` | `David Gilmour` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `guitar` | `David Gilmour` |'
- en: Notice that `guitar` is duplicated in the instrument list. When two tables are
    joined, the rows of the result no longer refer to the same type of object. One
    row in the instrument table represents an instrument. One row in the `musician`
    table represents one musician. One row in this table represents an `instrument`-`musician`
    relationship.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`guitar`在乐器列表中重复了。当两个表连接时，结果的行不再指代相同类型的对象。乐器表中的一行代表一个乐器。`musician`表中的一行代表一个音乐家。这个表中的一行代表一个`instrument`-`musician`关系。
- en: 'But suppose we wanted to keep the output such that one row represented one
    instrument but could still include information about associated musicians in each
    row. To do this, we''ll need to aggregate the matched musician rows using an aggregate
    function and the `GROUP BY` clause as shown in the following SQL query:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们想要保持输出，使得一行代表一个乐器，但仍然可以在每行中包含有关关联音乐家的信息。为了做到这一点，我们需要使用聚合函数和`GROUP BY`子句来聚合匹配的音乐家行，如下面的SQL查询所示：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `GROUP BY` clause specifies which column or columns describe what each row
    in the output table represents. Output columns not in the `GROUP BY` clause must
    then be reduced to single values using an aggregate function. In this case, we're
    using the `count()` function to count the total number of musician records associated
    with each instrument. Standard SQL contains several more aggregate functions,
    such as `min()`, `max()`, and `sum()`, and most SQL implementations extend this
    with their own functions as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUP BY`子句指定输出表中的每一行代表什么列。不在`GROUP BY`子句中的输出列必须使用聚合函数减少为单个值。在这种情况下，我们使用`count()`函数来计算与每个乐器关联的音乐家记录的总数。标准SQL包含几个更多的聚合函数，如`min()`、`max()`和`sum()`，大多数SQL实现也扩展了这些函数。'
- en: Many-to-one and one-to-many joins don't quite cover every possible situation
    that databases need to model; quite often, a many-to-many relationship is required.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多对一和一对多连接并不能完全涵盖数据库需要建模的每种可能情况；很多时候，需要一个多对多的关系。
- en: 'To demonstrate a many-to-many join, let''s create a new table called `bands` as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示多对多连接，让我们创建一个名为`bands`的新表，如下所示：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A band has multiple musicians, and musicians can be part of multiple bands.
    How can we create a relationship between musicians and bands? If we added a `band`
    field to the `musicians` table, this would limit each musician to one band. If
    we added a `musician` field to the `band` table, this would limit each band to
    one musician. To make the connection, we need to create a **junction table**,
    in which each row represents a musician's membership in a band.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个乐队有多位音乐家，音乐家也可以是多个乐队的一部分。我们如何在音乐家和乐队之间创建关系？如果我们在`musicians`表中添加一个`band`字段，这将限制每个音乐家只能属于一个乐队。如果我们在`band`表中添加一个`musician`字段，这将限制每个乐队只能有一个音乐家。为了建立连接，我们需要创建一个**连接表**，其中每一行代表一个音乐家在一个乐队中的成员资格。
- en: 'By convention, we call this `musicians_bands`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们称之为`musicians_bands`：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `musicians_bands` table simply contains two foreign key fields, one to
    point to a musician''s ID and one to point to the band''s ID. Notice that instead
    of creating or specifying one field as the primary key, we use the combination
    of both fields as the primary key. It wouldn''t make sense to have multiple rows
    with the same two values in them, so the combination makes an acceptable primary
    key. To write a query that uses this relationship, our `FROM` clause needs to
    specify two `JOIN` statements: one from `musicians` to `musicians_bands` and one
    from `bands` to `musicians_bands`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`musicians_bands`表只包含两个外键字段，一个指向音乐家的ID，一个指向乐队的ID。请注意，我们使用两个字段的组合作为主键，而不是创建或指定一个字段作为主键。有多行具有相同的两个值是没有意义的，因此这种组合可以作为一个合适的主键。要编写使用这种关系的查询，我们的`FROM`子句需要指定两个`JOIN`语句：一个从`musicians`到`musicians_bands`，一个从`bands`到`musicians_bands`。'
- en: 'For example, let''s get the names of the bands each musician has been in:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取每位音乐家所在乐队的名字：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This query ties `musicians` to `bands` using the junction table, then displays
    musician names next to an aggregated list of the bands they've been in, and orders
    it by the musician's name.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询使用连接表将`音乐家`和`乐队`联系起来，然后显示音乐家的名字以及他们所在乐队的聚合列表，并按音乐家的名字排序。
- en: 'The preceding SQL query gives you the following output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的SQL查询给出了以下输出：
- en: '| `name` | `bands` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `name` | `bands` |'
- en: '| `Bill Bruford` | `{ABWH,"King Crimson",Yes}` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `Bill Bruford` | `{ABWH,"King Crimson",Yes}` |'
- en: '| `David Gilmour` | `{"Pink Floyd"}` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `David Gilmour` | `{"Pink Floyd"}` |'
- en: '| `Greg Lake` | `{ELP,"King Crimson"}` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `Greg Lake` | `{ELP,"King Crimson"}` |'
- en: '| `Keith Emerson` | `{ELP}` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `Keith Emerson` | `{ELP}` |'
- en: '| `Robert Fripp` | ``{"King Crimson"}`` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `Robert Fripp` | ``{"King Crimson"}`` |'
- en: The `array_agg()` function used here aggregates string values into an array
    structure. This method and the `ARRAY` data type are specific to PostgreSQL. There
    is no SQL standard function for aggregating string values, but most SQL implementations
    have a solution for it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`array_agg()`函数将字符串值聚合成数组结构。这种方法和`ARRAY`数据类型是特定于PostgreSQL的。没有用于聚合字符串值的SQL标准函数，但大多数SQL实现都有解决方案。
- en: Learning more
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多
- en: This has been a quick overview of SQL concepts and syntax; we've covered most
    of what you need to know to write a simple database application, but there's much
    more to learn. The PostgreSQL manual, available at [https://www.postgresql.org/docs/manuals/](https://www.postgresql.org/docs/manuals/),
    is a great resource and reference for SQL syntax and the specific features of
    PostgreSQL.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对SQL概念和语法的快速概述；我们已经涵盖了你需要了解的大部分内容，但还有很多东西需要学习。PostgreSQL手册，可在[https://www.postgresql.org/docs/manuals/](https://www.postgresql.org/docs/manuals/)上找到，是SQL语法和PostgreSQL特定功能的重要资源和参考。
- en: Modeling relational data
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模关系数据
- en: Our application currently stores data in a single CSV file; a file like this
    is often called a **flat file**, because the data has been flattened to two dimensions.
    While this format works acceptably for our application and could be translated
    directly to an SQL table, a more accurate and useful data model requires more
    complexity.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用目前将数据存储在一个单独的CSV文件中；这种文件通常被称为**平面文件**，因为数据已经被压缩成了两个维度。虽然这种格式对我们的应用程序来说可以接受，并且可以直接转换成SQL表，但更准确和有用的数据模型需要更复杂的结构。
- en: Normalization
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范化
- en: The process of breaking out a flat data file into multiple tables is called
    **normalization**. Normalization is a process involving a series of levels called
    **normal forms** which progressively remove duplication and create a more precise
    model of the data we're storing. Although there are many normal forms, most issues
    encountered in common business data can be handled by conforming to the first
    three.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将平面数据文件拆分成多个表的过程称为**规范化**。规范化是一个涉及一系列级别的过程，称为**范式**，逐步消除重复并创建更精确的数据模型。虽然有许多范式，但大多数常见业务数据中遇到的问题都可以通过符合前三个范式来解决。
- en: 'Roughly speaking, that requires the following conditions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，这需要以下条件：
- en: The **first normal form** requires that each field contains only one value,
    and that repeating columns must be eliminated.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一范式**要求每个字段只包含一个值，并且必须消除重复的列。'
- en: The **second normal form**additionally requires that every value must be dependent
    on the entire primary key. In other words, if a table has primary key fields `A`,
    `B`, and `C`, and the value of column of `X` depends solely on the value of column
    `A` without respect to `B` or `C`, the table violates the second normal form.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二范式**还要求每个值必须依赖于整个主键。换句话说，如果一个表有主键字段`A`、`B`和`C`，并且列`X`的值仅取决于列`A`的值，而不考虑`B`或`C`，那么该表就违反了第二范式。'
- en: The **third normal form** additionally requires every value in the tableto be
    dependent only on the primary key. In other words, given a table with primary
    key `A`, and data fields `X` and `Y`, the value of `Y` can't depend on the value
    of `X`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三范式**还要求表中的每个值只依赖于主键。换句话说，给定一个具有主键`A`和数据字段`X`和`Y`的表，`Y`的值不能依赖于`X`的值。'
- en: Conforming data to these forms eliminates the potential for redundant, conflicting,
    or undefined data situations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 符合这些规范的数据消除了冗余、冲突或未定义数据情况的可能性。
- en: The entity-relationship diagrams
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体关系图
- en: One effective way to help normalize our data and prepare it for a relational
    database is to analyze it and create an **entity-relationship diagram**, or **ERD**.
    An ERD is a way of diagramming the things which our database is storing information
    about and the relationships between those things.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助规范化我们的数据并为关系数据库做好准备的一种有效方法是分析数据并创建一个**实体-关系图**，或**ERD**。 ERD是一种用图表表示数据库存储信息和这些信息之间关系的方法。
- en: Those things are called **entities**. An **entity** is a uniquely identifiable
    object; it corresponds to a single row of a single table. Entities have attributes,
    which correspond to the columns of its table. Entities have relationships with
    other entities, which correspond to the foreign key relationships we define in
    SQL.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西被称为**实体**。**实体**是一个唯一可识别的对象；它对应于单个表的单行。实体具有属性，对应于其表的列。实体与其他实体有关系，这对应于我们在SQL中定义的外键关系。
- en: 'Let''s consider the entities in our lab scenario with their attributes and
    relationships:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑实验室场景中的实体及其属性和关系：
- en: There are labs. Each lab has a name.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有实验室。每个实验室都有一个名字。
- en: There are plots. Each plot belongs to a lab and has a number. A seed sample
    is planted in the plot.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有地块。每个地块都属于一个实验室，并有一个编号。在地块中种植种子样本。
- en: There are lab technicians, who each have a name.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有实验室技术人员，每个人都有一个名字。
- en: There are lab checks, which are performed by a lab tech at a given lab. Each
    one has a date and time.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有实验室检查，由实验室技术人员在特定实验室进行。每个检查都有日期和时间。
- en: There are plot checks, which is the data gathered at a plot during a lab check.
    Each plot check has various plant and environmental data recorded on it.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有地块检查，这是在实验室检查期间在地块上收集的数据。每个地块检查都记录了各种植物和环境数据。
- en: 'The following diagram of these entities and relationships is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些实体和关系的图表：
- en: '![](assets/7fd91062-81f2-4025-a39e-26abb3216732.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7fd91062-81f2-4025-a39e-26abb3216732.png)'
- en: 'In the preceding diagram, the entities are represented by rectangles. We have
    five entities: **Lab**, **Plot**, **Lab Tech**, **Lab Check**, and **Plot Check**.
    Each entity has attributes, represented by the ovals. The relationships are represented
    by diamonds, with the words describing the left-to-right relationship. For example,
    **Lab Tech** performs **Lab Check**, and **Lab Check** is performed in **Lab**.
    Note the small **1** and **n** characters around the relationship: these show
    whether a relationship is one-to-many, many-to-one, or many-to-many.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，实体由矩形表示。我们有五个实体：**实验室**，**地块**，**实验室技术人员**，**实验室检查**和**地块检查**。每个实体都有属性，用椭圆形表示。关系由菱形表示，其中的文字描述了左到右的关系。例如，**实验室技术人员**执行**实验室检查**，**实验室检查**在**实验室**中进行。请注意关系周围的小**1**和**n**字符：这些显示了关系是一对多，多对一还是多对多。
- en: This diagram represents a reasonably normalized structure for our data. To implement
    it in SQL, we'd just make a table for each entity, a column for each attribute,
    and a foreign key relationship (possibly including an intermediate table) for
    each relationship. Before we can do that, let's consider SQL data types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表代表了我们数据的一个相当规范化的结构。要在SQL中实现它，我们只需为每个实体创建一个表，为每个属性创建一个列，并为每个关系创建一个外键关系（可能包括一个中间表）。在我们这样做之前，让我们考虑SQL数据类型。
- en: Assigning data types
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配数据类型
- en: Standard SQL defines 16 data types, including types for integers and floating-point
    numbers of various sizes, ASCII or Unicode strings of either fixed or variable
    sizes, date and time types, and bit types. Nearly every SQL engine extends this
    with yet more types to accommodate binary data, special types of strings or numbers,
    and more. Many data types seem a little redundant, and several have aliases that
    may be different between implementations. Choosing data types for your columns
    can be surprisingly confusing!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标准SQL定义了16种数据类型，包括各种大小的整数和浮点数类型、固定大小或可变大小的ASCII或Unicode字符串、日期和时间类型以及位类型。几乎每个SQL引擎都会扩展这些类型，以适应二进制数据、特殊类型的字符串或数字等。许多数据类型似乎有点多余，而且有几个别名在不同的实现之间可能是不同的。选择列的数据类型可能会令人困惑！
- en: 'For PostgreSQL, the following chart provides some reasonable choices:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PostgreSQL，以下图表提供了一些合理的选择：
- en: '| **Data being stored** | **Recommended type** | **Notes** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **存储的数据** | **推荐类型** | **备注** |'
- en: '| Fixed-length strings | `CHAR` | Requires a length. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 固定长度字符串 | `CHAR` | 需要长度。 |'
- en: '| Short-to-medium strings | `VARCHAR` | Requires a max length argument, for
    example, `VARCHAR(256)`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 短到中等长度的字符串 | `VARCHAR` | 需要一个最大长度参数，例如，`VARCHAR(256)`。 |'
- en: '| Long, freeform text | `TEXT` | Unlimited length, slower performance. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 长、自由格式文本 | `TEXT` | 无限长度，性能较慢。 |'
- en: '| Smaller Integers | `SMALLINT` | Up to ±32,767. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 较小的整数 | `SMALLINT` | 最多±32,767。 |'
- en: '| Most Integers | `INT` | Up to around ±2.1 billion. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 大多数整数 | `INT` | 最多约±21亿。 |'
- en: '| Larger Integers | `BIGINT` | Up to around ±922 quadrillion. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 较大的整数 | `BIGINT` | 最多约±922万亿。 |'
- en: '| Decimals numbers | `NUMERIC` | Takes optional length and precision arguments.
    |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 小数 | `NUMERIC` | 接受可选的长度和精度参数。 |'
- en: '| Integer Primary Key | `SERIAL`, `BIGSERIAL` | Autoincrementing integer or
    big integers. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 整数主键 | `SERIAL`，`BIGSERIAL` | 自动递增整数或大整数。 |'
- en: '| Boolean | `BOOLEAN` |  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: 布尔 | `BOOLEAN` |  |
- en: '| Date and time | `TIMESTAMP WITH TIMEZONE` | Stores date, time, and timezone.
    Accurate to 1 µs. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 日期和时间 | `TIMESTAMP WITH TIMEZONE` | 存储日期、时间和时区。精确到1微秒。 |'
- en: '| Date without time | `DATE` |  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 无时间的日期 | `DATE` |  |'
- en: '| Time without date | `TIME` | Can be with or without time zone. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 无日期的时间 | `TIME` | 可以有或没有时区。 |'
- en: These types will probably meet the vast majority of your needs in most applications,
    and we'll be using a subset of these for our ABQ database. As we create our tables,
    we'll refer to our data dictionary and choose appropriate data types for our columns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型可能在大多数应用中满足您的绝大多数需求，我们将在我们的ABQ数据库中使用其中的一部分。在创建表时，我们将参考我们的数据字典，并为我们的列选择适当的数据类型。
- en: Be careful not to choose overly specific or restrictive data types. Any data
    can ultimately be stored in a `TEXT` field; the purpose of choosing more specific
    types is mainly to enable the use of operators, functions, or sorting specific
    to that type. If those aren't required, consider a more generic type. For example,
    phone numbers and U.S. Social Security numbers can be represented purely with
    digits, but that's no reason to make them `INTEGER` or `NUMERIC` fields; after
    all, you wouldn't do arithmetic with them!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要选择过于具体或限制性的数据类型。任何数据最终都可以存储在`TEXT`字段中；选择更具体的类型的目的主要是为了能够使用特定类型的运算符、函数或排序。如果不需要这些，可以考虑使用更通用的类型。例如，电话号码和美国社会安全号码可以纯粹用数字表示，但这并不意味着要将它们作为`INTEGER`或`NUMERIC`字段；毕竟，你不会用它们进行算术运算！
- en: Creating the ABQ database
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ABQ数据库
- en: Now that we've modeled our data and gotten a feel for the data types available,
    it's time to build our database. To begin, create a database on your SQL server
    called `abq` and make yourself the owner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对数据进行了建模，并对可用的数据类型有了一定的了解，是时候建立我们的数据库了。首先，在您的SQL服务器上创建一个名为`abq`的数据库，并将自己设为所有者。
- en: Next, under your project root folder, create a new directory called `sql`. Inside
    the `sql` folder, create a file called `create_db.sql`. We'll start writing our
    database creation code in this file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的项目根目录下，创建一个名为`sql`的新目录。在`sql`文件夹中，创建一个名为`create_db.sql`的文件。我们将从这个文件开始编写我们的数据库创建代码。
- en: Creating our tables
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的表
- en: The order in which we create our tables is significant. Any table referred to
    in a foreign key relationship will need to exist before the relationship is defined.
    Because of this, it's best to start with your lookup tables and follow the chain
    of one-to-many relationships until all the tables are created. In our ERD, that
    takes us from roughly the upper-left to the lower-right.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建表的顺序很重要。在外键关系中引用的任何表都需要在定义关系之前存在。因此，最好从查找表开始，并遵循一对多关系的链，直到所有表都被创建。在我们的ERD中，这将使我们从大致左上到右下。
- en: Creating the lookup tables
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建查找表
- en: 'We need to create the following three lookup tables:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建以下三个查找表：
- en: '`labs`: This lookup table will contain the ID strings for our laboratories.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs`：这个查找表将包含我们实验室的ID字符串。'
- en: '`lab_techs`: This lookup table will have the names of the lab technicians,
    identified by their employee ID numbers.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lab_techs`：这个查找表将包含实验室技术员的姓名，通过他们的员工ID号进行标识。'
- en: '`plots`: This lookup table will have one row for each physical plot, identified
    by lab and plot numbers. It will also keep track of the current seed sample planted
    in the plot.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plots`：这个查找表将为每个物理地块创建一行，由实验室和地块号标识。它还将跟踪地块中种植的当前种子样本。'
- en: 'Add the SQL query for creating these tables to `create_db.sql` as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将用于创建这些表的SQL查询添加到`create_db.sql`中，如下所示：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before we can use our database, the lookup tables will need to be populated:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用我们的数据库之前，查找表将需要被填充：
- en: '`labs` should have values `A` through `E` for the five labs.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs`应该有值`A`到`E`，代表五个实验室。'
- en: '`lab_techs` needs the name and ID number for our four lab technicians: `J Simms`
    (`4291`), `P Taylor` (`4319`), `Q Murphy` (`4478`), and `L Taniff` (`5607`).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lab_techs`需要我们四名实验室技术员的姓名和ID号：`J Simms`（`4291`）、`P Taylor`（`4319`）、`Q Murphy`（`4478`）和`L
    Taniff`（`5607`）。'
- en: '`plots` needs all 100 of the plots, numbers `1` through `20` for each lab.
    The seed sample rotates between four values such as `AXM477`, `AXM478`, `AXM479`,
    and `AXM480`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plots`需要所有100个地块，每个实验室的地块号为`1`到`20`。种子样本在四个值之间轮换，如`AXM477`、`AXM478`、`AXM479`和`AXM480`。'
- en: You can populate these tables by hand using pgAdmin, or using the `db_populate.sql`
    script included with the example code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动使用pgAdmin填充这些表，或者使用包含在示例代码中的`db_populate.sql`脚本。
- en: The lab_checks table
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室检查表
- en: 'The `lab_check` table is an instance of a technician checking all the plots
    of a lab at a given time on a given date as shown in the following SQL query:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`lab_check`表是一个技术人员在给定日期的给定时间检查实验室的所有地块的一个实例，如下所示的SQL查询：'
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `date`, `time`, and `lab_id` columns together uniquely identify a lab check,
    and so we designate them the primary key columns. The ID of the lab technician
    performing the check is the lone attribute in this table.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`、`time`和`lab_id`列一起唯一标识了实验室检查，因此我们将它们指定为主键列。执行检查的实验室技术员的ID是这个表中唯一的属性。'
- en: The plot_checks table
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地块检查表
- en: Plot checks are the actual data records collected at individual plots. These
    are part of a lab check, and so must refer back to an existing lab check.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 地块检查是在单个地块收集的实际数据记录。这些是实验室检查的一部分，因此必须参考现有的实验室检查。
- en: 'We''ll begin with the primary key columns:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从主键列开始：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is the primary key of a `lab_check` table plus a `plot` number; its key
    constraints look like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`lab_check`表的主键加上`plot`号；它的键约束看起来像这样：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can add the attribute columns:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加属性列：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice our use of data types and the `CHECK` constraint to duplicate the limits
    from our `data` dictionary. Using these, we've leveraged the power of the database
    to safeguard against invalid data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们对数据类型和`CHECK`约束的使用，以复制我们的`data`字典中的限制。使用这些，我们利用了数据库的功能来防止无效数据。
- en: Creating a view
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: Before we finish our database design, we're going to create a view that will
    simplify access to our data. A view behaves like a table in most respects, but
    contains no actual data; it's really just a stored `SELECT` query. Our view will
    format our data for easier interaction with the GUI.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成数据库设计之前，我们将创建一个视图，以简化对我们数据的访问。视图在大多数方面都像表一样，但不包含实际数据；它实际上只是一个存储的`SELECT`查询。我们的视图将为与GUI交互更容易地格式化我们的数据。
- en: 'Views are created using the `CREATE VIEW` command as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是使用`CREATE VIEW`命令创建的，如下所示：
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the parentheses, we put the `SELECT` query that will return the table
    data for our view:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在括号内，我们放置将为我们的视图返回表数据的`SELECT`查询：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We're selecting the `plot_checks` table, and joining it to `lab_checks` and
    `lab_techs` by way of our foreign key relationships. Notice that we've aliased
    these tables by using the `AS` keyword. Short aliases like this can help make
    a large query more readable. We're also aliasing each field to the name used in
    the application's data structures. These must be enclosed in double quotes to
    allow for the use of spaces and to preserve case. By making the column names match
    the `data` dictionary keys in our application, we won't need to translate field
    names in our application code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在选择`plot_checks`表，并通过外键关系将其与`lab_checks`和`lab_techs`连接起来。请注意，我们使用`AS`关键字给这些表起了别名。像这样的简短别名可以帮助使大查询更易读。我们还将每个字段别名为应用程序数据结构中使用的名称。这些必须用双引号括起来，以允许使用空格并保留大小写。通过使列名与应用程序中的`data`字典键匹配，我们就不需要在应用程序代码中翻译字段名。
- en: SQL database engines such as PostgreSQL are highly efficient at joining and
    transforming tabular data. Whenever possible, leverage this power and make the
    database do the work of formatting the data for the convenience of your application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如PostgreSQL之类的SQL数据库引擎在连接和转换表格数据方面非常高效。在可能的情况下，利用这种能力，让数据库为了您的应用程序的方便而进行数据格式化工作。
- en: This completes our database creation script. Run this script in your PostgreSQL
    client and verify that the four tables and the view have been created.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的数据库创建脚本。在您的PostgreSQL客户端中运行此脚本，并验证已创建四个表和视图。
- en: Integrating SQL into our application
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SQL集成到我们的应用程序中
- en: Converting our application to a SQL backend will be no small task. The application
    was built around the assumption of the CSV files, and although we've taken care
    to separate our concerns, many things are going to need to change.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序转换为SQL后端将不是一项小任务。该应用程序是围绕CSV文件的假设构建的，尽管我们已经注意到了分离我们的关注点，但许多事情都需要改变。
- en: 'Let''s break down the steps we''ll need to take:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们需要采取的步骤：
- en: We'll need to write a SQL model
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要编写一个SQL模型
- en: Our `Application` class will need to use the SQL model
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`Application`类将需要使用SQL模型
- en: The record form will need to be reordered to prioritize our keys, use the new
    lookups, and autopopulate using the database
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录表格需要重新排序以优先考虑我们的键，使用新的查找和使用数据库自动填充
- en: The record list will need to be adjusted to work with the new data model and
    primary keys
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录列表将需要调整以适应新的数据模型和主键
- en: Along the way, we'll need to fix other bugs or implement some new UI elements
    as needed. Let's get started!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将需要修复其他错误或根据需要实现一些新的UI元素。让我们开始吧！
- en: Creating a new model
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新模型
- en: 'We''ll start in `models.py` by importing `psycopg2` and `DictCursor`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`models.py`开始导入`psycopg2`和`DictCursor`：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`DictCursor` will allow us to fetch results in Python dictionary rather than
    the default tuples, which is easier to work with in our application.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`DictCursor`将允许我们以Python字典而不是默认的元组获取结果，这在我们的应用程序中更容易处理。'
- en: Begin a new model class called `SQLModel` and copy over the `fields` property
    from the `CSVModel`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个名为`SQLModel`的新模型类，并从`CSVModel`复制`fields`属性。
- en: 'Start by clearing the value lists from `Technician`, `Lab`, and `Plot`, and
    making `Technician` an `FT.string_list` type:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先清除`Technician`、`Lab`和`Plot`的值列表，并将`Technician`设置为`FT.string_list`类型：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These lists will be populated from our lookup tables rather than hardcoded into
    the model.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表将从我们的查找表中填充，而不是硬编码到模型中。
- en: 'We''ll do that in the `__init__()` method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`__init__()`方法中完成这些列表的填充：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`__init__()` takes our basic database connection details and establishes a
    connection to the database using `psycopg2.connect()`. Because we passed in `DictCursor`
    as the `cursor_factory`, this connection will return lists of dictionaries for
    all data queries.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`接受我们基本的数据库连接细节，并使用`psycopg2.connect()`建立与数据库的连接。因为我们将`DictCursor`作为`cursor_factory`传入，这个连接将返回所有数据查询的字典列表。'
- en: Then, we query the database for the pertinent columns in our three lookup tables
    and use a list comprehension to flatten the results of each query for the `values`
    list.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查询数据库以获取我们三个查找表中的相关列，并使用列表推导式来展平每个查询的结果以获得`values`列表。
- en: 'The `query` method used here is a wrapper that we need to write next:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`query`方法是我们需要接下来编写的包装器：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Querying a database using `psycopg2` involves generating a `cursor` object from
    the connection, then calling its `execute()` method with the query string and
    optional parameter data. By default, all queries are executed in a transaction,
    meaning they don't take effect until we commit the changes. If the query raises
    an exception for any reason (SQL syntax error, constraint violation, connection
    issue, and so on) the transaction enters a corrupt state and must be rolled back
    (reverted to the beginning state of the transaction) before we can use our connection
    again. Therefore, we will execute our queries in a `try` block and rollback the
    transaction using `connection.rollback()` in the event of any `psycopg2`-related
    exceptions (which all descend from `pg.Error`).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`psycopg2`查询数据库涉及从连接生成`cursor`对象，然后使用查询字符串和可选参数数据调用其`execute()`方法。默认情况下，所有查询都在事务中执行，这意味着它们在我们提交更改之前不会生效。如果查询因任何原因（SQL语法错误、约束违反、连接问题等）引发异常，事务将进入损坏状态，并且必须在我们再次使用连接之前回滚（恢复事务的初始状态）。因此，我们将在`try`块中执行我们的查询，并在任何`psycopg2`相关异常（所有都是从`pg.Error`继承的）的情况下使用`connection.rollback()`回滚事务。
- en: 'To retrieve data from a cursor after the query is executed, we''re using the
    `fetchall()` method, which retrieves all results as a list. However, if the query
    wasn''t a data-returning query (such as `INSERT`, for example), `fetchall()` will
    throw an exception. To avoid this, we first check `cursor.description`: if the
    query returned data (even an empty set of data), `cursor.description` will contain
    metadata about the returned table (column names, for example). If not, it will
    be `None`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询执行后从游标中检索数据时，我们使用 `fetchall()` 方法，它将所有结果作为列表检索。但是，如果查询不是返回数据的查询（例如 `INSERT`），`fetchall()`
    将抛出异常。为了避免这种情况，我们首先检查 `cursor.description`：如果查询返回了数据（即使是空数据集），`cursor.description`
    将包含有关返回表的元数据（例如列名）。如果没有，则为 `None`。
- en: 'Let''s test our `query()` method by writing the `get_all_records()` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写 `get_all_records()` 方法来测试我们的 `query()` 方法：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since our users are used to working with only the current day's data, we'll
    only show that data by default, but add an optional flag should we ever need to
    retrieve all data. We can get the current date in most SQL implementations using
    the `CURRENT_DATE` constant, which we've used here. To use our `all_dates` flag,
    we're employing a prepared query.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用户习惯于仅使用当天的数据，因此默认情况下只显示该数据，但如果我们需要检索所有数据，我们可以添加一个可选标志。我们可以在大多数 SQL 实现中使用
    `CURRENT_DATE` 常量获取当前日期，我们在这里使用了它。为了使用我们的 `all_dates` 标志，我们正在使用准备好的查询。
- en: The syntax `%(all_dates)s` defines a parameter; it tells `psycopg2` to check
    the included parameter dictionary for the key `all_dates` and substitute its value
    into the query. The `psycopg2` library will automatically do this in a way that's
    both safe and works correctly with various data types like `None` or Boolean values.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 语法 `%(all_dates)s` 定义了一个参数；它告诉 `psycopg2` 检查包含的参数字典，以便将其值替换到查询中。`psycopg2` 库将自动以一种安全的方式执行此操作，并正确处理各种数据类型，如
    `None` 或布尔值。
- en: Always use prepared queries to pass data into a SQL query. Never use string
    formatting or concatenation! Not only is it harder than you think to get it right,
    it can leave you open to accidental or malicious database corruption.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用准备好的查询将数据传递到 SQL 查询中。永远不要使用字符串格式化或连接！不仅比你想象的更难以正确实现，而且可能会导致意外或恶意的数据库损坏。
- en: 'Next, let''s create `get_record()`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `get_record()`：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We're no longer dealing in row numbers like our `CSVModel` did, so this method
    needs all four key fields to retrieve a record. Once again, we're using a prepared
    query, specifying parameters for the four fields. Take note of the `s` after the
    closing parenthesis of the parameter; this is a required format specifier, and
    should always be `s`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再处理像我们的 `CSVModel` 那样的行号，因此此方法需要所有四个关键字段来检索记录。再次，我们使用了准备好的查询，为这四个字段指定参数。请注意参数括号的右括号后面的
    `s`；这是一个必需的格式说明符，应始终为 `s`。
- en: Even with a single row, `query()` is going to return results in a list. Our
    application expects a single row dictionary from `get_record()`, so our `return`
    statement extracts the first item in `result` if the list is not empty, or an
    empty `dict` if it is.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有一行，`query()` 也会以列表的形式返回结果。我们的应用程序期望从 `get_record()` 中获得一个单行字典，因此我们的 `return`
    语句会在列表不为空时提取 `result` 中的第一项，如果为空则返回一个空的 `dict`。
- en: 'Retrieving a lab check record is very similar:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 检索实验室检查记录非常类似：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this query, we're using a join to make sure we have the technician name available
    and not just the ID. This method will come in handy in our `save_record()` method
    and form data autofill methods.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在此查询中，我们使用连接来确保我们有技术员名称可用，而不仅仅是 ID。这种方法将在我们的 `save_record()` 方法和表单数据自动填充方法中非常有用。
- en: 'The `save_record()` method will need four queries: an `INSERT` and `UPDATE`
    query for each of `lab_checks` and `plot_checks`. To keep the method reasonably
    concise, let''s create the query strings as class properties.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_record()` 方法将需要四个查询：对 `lab_checks` 和 `plot_checks` 的 `INSERT` 和 `UPDATE`
    查询。为了保持方法相对简洁，让我们将查询字符串创建为类属性。'
- en: 'We''ll start with the lab check queries:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实验室检查查询开始：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These queries are fairly straightforward, though note our use of a subquery
    to populate `lab_tech_id` in each case. Our application will have no idea what
    a lab tech's ID is, so we'll need to look the ID up by name. Also, take note that
    our parameter names match the names used in our application's fields. This will
    save us having to reformat the record data acquired from our form.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询非常简单，但请注意我们使用子查询来填充每种情况中的 `lab_tech_id`。我们的应用程序不知道实验室技术员的 ID 是什么，因此我们需要通过名称查找
    ID。另外，请注意我们的参数名称与应用程序字段中使用的名称相匹配。这将使我们无需重新格式化从表单获取的记录数据。
- en: 'The plot check queries are longer but no more complicated:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 地块检查查询更长，但并不复杂：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the queries in place, we can start the `save_record()` method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些查询，我们可以开始 `save_record()` 方法：
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `CSVModel.save_record()` method took a `record` dictionary and a `rownum`,
    but we no longer need the `rownum` since it's meaningless. All our key information
    is already in the record. For convenience, we'll extract those four fields and
    assign them local variable names.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSVModel.save_record()` 方法接受一个 `record` 字典和一个 `rownum`，但是我们不再需要 `rownum`，因为它没有意义。我们所有的关键信息已经在记录中。为了方便起见，我们将提取这四个字段并为它们分配本地变量名。'
- en: 'There are three possibilities when we try to save a record in this database:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在这个数据库中保存记录时，有三种可能性：
- en: Neither a lab check or plot check record exists. Both will need to be created.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室检查或地块检查记录都不存在。两者都需要创建。
- en: The lab check exists but the plot check does not. The lab check will need to
    be updated, in case the user wants to correct the technician value, and the plot
    check will need to be added.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室检查存在，但地块检查不存在。如果用户想要更正技术员的值，则需要更新实验室检查，而地块检查需要添加。
- en: Both the lab check and plot check exist. Both will need to be updated with the
    submitted values.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室检查和地块检查都存在。两者都需要使用提交的值进行更新。
- en: 'To determine which possibility is true, we''ll make use of our `get_` methods:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哪种可能性是真实的，我们将利用我们的 `get_` 方法：
- en: '[PRE41]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For both the lab check and plot check, we attempt to retrieve a record from
    the respective table using our key values. If one is found, we'll use our update
    queries; otherwise, we'll use our insert queries.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实验室检查和地块检查，我们尝试使用我们的键值从各自的表中检索记录。如果找到了一个，我们将使用我们的更新查询；否则，我们将使用我们的插入查询。
- en: 'Now, we just run those queries with `record` as the parameter list:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需使用`record`作为参数列表运行这些查询。
- en: '[PRE42]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that `psycopg2` has no problem with us passing a dictionary with extra
    parameters that aren't referenced in the query, so we don't need to bother with
    filtering unneeded items from `record`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`psycopg2`不会因为我们传递了一个在查询中没有引用的额外参数的字典而出现问题，因此我们不需要费心从`record`中过滤不需要的项目。
- en: 'There is one more thing we need to do here: remember that our `Application`
    needs to keep track of updated and inserted rows. Since we are no longer dealing
    with row numbers, only the database model knows whether an insert or update was
    performed.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一件事情要做：记住我们的`Application`需要跟踪更新和插入的行。由于我们不再处理行号，只有数据库模型知道是否执行了插入或更新。
- en: 'Let''s create an instance property to share that information:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实例属性来共享这些信息：
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now `Application` can check the value of `last_write` after calling `save_record()`
    to determine which operation was done.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Application`可以在调用`save_record()`后检查`last_write`的值，以确定执行了哪种操作。
- en: There is one last method this model needs; since our database knows what seed
    sample is currently in each plot, we want our form to populate this automatically
    for the user. We'll need a method that takes a `lab` and `plot_id` and returns
    the seed sample name.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型还需要最后一个方法；因为我们的数据库知道每个地块当前种子样本是什么，我们希望我们的表单自动为用户填充这些信息。我们需要一个方法，它接受一个`lab`和`plot_id`，并返回种子样本名称。
- en: 'We''ll call it `get_current_seed_sample()`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称其为`get_current_seed_sample()`。
- en: '[PRE44]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This time, our `return` statement is not just extracting the first row of results,
    but the value of the `current_seed_sample` column from that first row. If there's
    no `result`, we return an empty string.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的`return`语句不仅仅是提取结果的第一行，而是提取该第一行中`current_seed_sample`列的值。如果没有`result`，我们将返回一个空字符串。
- en: That completes our model class; now let's incorporate it into the application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的模型类；现在让我们将其合并到应用程序中。
- en: Adjusting the Application class for the SQL backend
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整SQL后端的Application类
- en: The first thing the `Application` class will need is the database connection
    information to pass to the model.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`类需要的第一件事是数据库连接信息，以传递给模型。'
- en: 'For the host and database name, we can just add settings to our `SettingsModel`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主机和数据库名称，我们可以只需向我们的`SettingsModel`添加设置：
- en: '[PRE45]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These can be saved in our JSON `config` file, which can be edited to switch
    from development to production, but our username and password will need to be
    entered by the user. For that, we'll need to build a login dialog.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以保存在我们的JSON`config`文件中，可以编辑以从开发切换到生产，但我们的用户名和密码需要用户输入。为此，我们需要构建一个登录对话框。
- en: Building a login window
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建登录窗口
- en: Tkinter does not provide us with a ready-made login dialog, but it does provide
    us with a generic `Dialog` class which can be subclassed to create custom dialogs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter没有为我们提供现成的登录对话框，但它提供了一个通用的`Dialog`类，可以被子类化以创建自定义对话框。
- en: 'Import this class from `tkinter.simpledialog` into our `views.py` file:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 从`tkinter.simpledialog`中导入这个类到我们的`views.py`文件：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s start with our class declaration and `__init__()` method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的类声明和`__init__()`方法开始：
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Our class will take a `parent` as usual, a window `title`, and an optional `error`,
    which will be used in case we need to re-display the dialog with an `error` message
    (for example, if the password is wrong). The rest of `__init__()` sets up some
    Tkinter variables for the password, username, and `error` string; then, it finishes
    with the customary call to `super()`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类将像往常一样接受一个`parent`，一个窗口`title`，以及一个可选的`error`，如果需要重新显示带有`error`消息的对话框（例如，如果密码错误）。`__init__()`的其余部分为密码、用户名和`error`字符串设置了一些Tkinter变量；然后，它以通常的方式调用`super()`结束。
- en: 'The form itself is not defined in `__init__()`; instead, we need to override
    the `body()` method:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 表单本身不是在`__init__()`中定义的；相反，我们需要重写`body()`方法：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first thing we do is make a frame and add a title label to the first row
    using a large font.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是制作一个框架，并使用大字体在第一行添加一个标题标签。
- en: 'Next, we''ll check for an `error` string and, if there is one, display it in
    an appropriate style:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查是否有`error`字符串，如果有，以适当的样式显示它。
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we''ll add the username and password fields and `pack` our frame into the
    dialog:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加用户名和密码字段，并将我们的框架打包到对话框中。
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice our use of the `show` option in the password entry, which replaces any
    typed text with the character we specify, to create a hidden text field. Also,
    note that we return the username input widget from the method. `Dialog` will focus
    whichever widget is returned here when it's displayed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在密码输入中使用`show`选项，它用我们指定的字符替换任何输入的文本，以创建一个隐藏的文本字段。另外，请注意我们从方法中返回用户名输入小部件。`Dialog`在显示时将聚焦在这里返回的小部件上。
- en: '`Dialog` automatically supplies the OK and Cancel buttons; we''ll want to know
    which button was clicked, and if it was the OK button, retrieve the entered information.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dialog`自动提供`OK`和`Cancel`按钮；我们想知道点击了哪个按钮，如果是`OK`按钮，检索输入的信息。'
- en: 'Clicking OK calls the `apply()` method, so we can override it to set up a `result`
    value:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 点击OK会调用`apply()`方法，因此我们可以重写它来设置一个`result`值。
- en: '[PRE51]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Dialog` creates a property by default called `result` which is set to `None`.
    But now, if our user clicks OK, `result` will be a tuple containing a username
    and password. We''ll use this property to determine what was clicked and what
    was entered.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dialog`默认创建一个名为`result`的属性，其值设置为`None`。但是现在，如果我们的用户点击了OK，`result`将是一个包含用户名和密码的元组。我们将使用这个属性来确定点击了什么，输入了什么。'
- en: Using the login window
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用登录窗口
- en: To use the dialog, our application needs a method that will display the dialog
    in an infinite loop until either the user clicks Cancel or the provided credentials
    successfully authenticate.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用对话框，我们的应用程序需要一个方法，它将在无限循环中显示对话框，直到用户单击取消或提供的凭据成功验证。
- en: 'Start a new `database_login()` method in `Application`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application`中启动一个新的`database_login()`方法：
- en: '[PRE52]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We begin by setting up an empty `error` string and a `title` string to pass
    to our `LoginDialog` class.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个空的`error`字符串和一个`title`字符串，以传递给我们的`LoginDialog`类。
- en: 'Now we''ll start the infinite loop:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始无限循环：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Inside the loop, we create a `LoginDialog`, which will block until the user
    clicks one button or the other. After the dialog returns, if `login.result` is
    `None`, the user has clicked Cancel, so we break out of the loop and exit the
    method.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们创建一个`LoginDialog`，它将阻塞，直到用户单击其中一个按钮。对话框返回后，如果`login.result`是`None`，则用户已单击取消，因此我们会跳出循环并退出方法。
- en: 'If we have a non-`None` `login.result`, we''ll attempt to log in with it:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个非`None`的`login.result`，我们将尝试用它登录：
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After extracting the `username` and `password` from the `result` tuple, we try
    to create a `SQLModel` instance with it. If the credentials fail, `psycopg2.connect`
    will raise an `OperationalError`, in which case we'll simply populate our `error`
    string and let the infinite loop iterate again.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从`result`元组中提取`username`和`password`后，我们尝试用它创建一个`SQLModel`实例。如果凭据失败，`psycopg2.connect`将引发`OperationalError`，在这种情况下，我们将简单地填充我们的`error`字符串，让无限循环再次迭代。
- en: If the data model creation succeeded, we simply break out of the loop and exit
    the method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据模型创建成功，我们只需跳出循环并退出方法。
- en: 'Back in `__init__()`, just after setting up our settings, let''s put `database_login()`
    to work:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，在设置我们的设置之后，让我们让`database_login()`开始工作：
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After our call to `self.database_login()`, `Application` either has a `data_model`
    attribute (because the login succeeded) or doesn't (because the user clicked Cancel).
    If it doesn't, we'll quit the application by destroying the main window and returning
    immediately from `__init__()`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`self.database_login()`之后，`Application`要么有一个`data_model`属性（因为登录成功），要么没有（因为用户单击了取消）。如果没有，我们将通过销毁主窗口并立即从`__init__()`返回来退出应用程序。
- en: 'Of course, before this logic will work, we need to delete the creation of the
    `CSVModel`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个逻辑生效之前，我们需要删除`CSVModel`的创建：
- en: '[PRE56]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Fixing some model incompatibilities
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复一些模型不兼容性
- en: In theory, we should be able to swap in a new model with the same method calls
    and our application object will just work, but this isn't quite the case. There
    are a few small fixes we need to make to get `Application` working with our new
    model.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们应该能够用相同的方法调用交换一个新模型，我们的应用程序对象将正常工作，但情况并非完全如此。我们需要做一些小的修复来让`Application`与我们的新模型一起工作。
- en: DataRecordForm creation
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DataRecordForm创建
- en: 'First, let''s fix our `DataRecordForm` instantiation in `Application.__init__()`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`Application.__init__()`中修复`DataRecordForm`的实例化：
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Previously, we'd pulled the `fields` argument from the static class property
    of `CSVModel`. We need to pull it from our data model instance instead, since
    the instance is setting up some values.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们从`CSVModel`的静态类属性中提取了`fields`参数。我们现在需要从我们的数据模型实例中提取它，因为实例正在设置一些值。
- en: Fixing the open_record() method
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复open_record()方法
- en: Next, we need to fix our `open_record()` method. It takes a `rownum` currently,
    but we no longer have row numbers; we have `date`, `time`, `lab`, and `plot`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修复我们的`open_record()`方法。它目前需要一个`rownum`，但我们不再有行号；我们有`date`、`time`、`lab`和`plot`。
- en: 'To reflect this, replace all instances of `rownum` with `rowkey`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反映这一点，用`rowkey`替换所有`rownum`的实例：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, expand `rowkey` in the `get_record()` call, since it expects four
    positional arguments:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`get_record()`调用中扩展`rowkey`，因为它期望四个位置参数：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Fixing the on_save() method
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复on_save()方法
- en: 'The error handling portion of `on_save()` is fine, but after the `if errors:`
    block, we''ll start changing things:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_save()`的错误处理部分是好的，但在`if errors:`块之后，我们将开始改变事情：'
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We no longer need to extract the row number or pass it into `save_record()`,
    and we can delete the handling of `IndexError` since `SQLModel` will not raise
    that exception. We also need to rewrite the updating of `inserted_rows` and `updated_rows`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要提取行号或将其传递给`save_record()`，并且我们可以删除对`IndexError`的处理，因为`SQLModel`不会引发该异常。我们还需要重写`inserted_rows`和`updated_rows`的更新。
- en: 'Remove all the code in this method after the call to `self.status.set()`, and
    replace it with this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`self.status.set()`之后，删除此方法中的所有代码，并用以下代码替换：
- en: '[PRE61]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After building the primary key tuple from `data` passed into the method, we
    use the value of `last_write` to append it to the proper list. Finally, we reset
    the record form in the case of an insert.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从传递给方法的`data`中构建主键元组后，我们使用`last_write`的值将其附加到正确的列表中。最后，在插入的情况下重置记录表单。
- en: Creating new callbacks
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的回调
- en: There are two callbacks we want to have for our record form. When the user enters
    a `lab` and `plot` value, we want to automatically populate the correct `seed`
    value that is currently planted in that `plot`. Also, when the `date`, `time`,
    and `lab` values have been entered, and we have an existing lab check that matches,
    we should populate the name of the lab tech who did that check.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为我们的记录表单有两个回调。当用户输入`lab`和`plot`值时，我们希望自动填充当前种植在该`plot`中的正确`seed`值。此外，当`date`、`time`和`lab`值已输入，并且我们有匹配的现有实验室检查时，我们应该填充执行该检查的实验室技术人员的姓名。
- en: Of course, if our user prefers not to have data autofilled, we shouldn't do
    either of these things.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们的用户不希望数据自动填充，我们也不应该做这些事情。
- en: 'Let''s start with the `get_current_seed_sample()` method:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`get_current_seed_sample()`方法开始：
- en: '[PRE62]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We begin by checking whether we have a record form object created, and whether
    the user wants data autofilled. If not, we exit the method. Next, we fetch the
    `plot` and `lab` from the form's current data. If we have both, we use them to
    fetch the `seed` sample value from the model and set the form's `Seed sample`
    value accordingly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否已创建记录表单对象，以及用户是否希望数据自动填充。如果不是，我们退出该方法。接下来，我们从表单的当前数据中获取`plot`和`lab`。如果我们两者都有，我们将使用它们从模型中获取`seed`样本值，并相应地设置表单的`Seed
    sample`值。
- en: 'We''ll do something similar with the lab tech value:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以类似的方式处理实验技术值：
- en: '[PRE63]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This time, we need the `date`, `time`, and `lab` arguments to fetch the lab
    check record. Because we can't be sure if a check matching the values exists,
    we'll set `tech` to a blank string if we can't find a matching lab check.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们需要`date`、`time`和`lab`参数来获取实验检查记录。因为我们不能确定是否存在与这些值匹配的检查，所以如果我们找不到匹配的实验检查，我们将把`tech`设置为空字符串。
- en: Add these two methods to the `callbacks` dictionary and the `Application` class
    should be ready to go.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两种方法添加到`callbacks`字典中，`Application`类应该准备就绪。
- en: Updating our views for the SQL backend
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的视图以适应SQL后端
- en: 'Let''s review the changes we need to make in our views:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们需要在视图中进行的更改：
- en: Re-arrange our fields to put all the primary keys upfront
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排列我们的字段，将所有主键放在前面
- en: Fix our form's `load_record()` method to work with the new key structure
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复我们表单的`load_record()`方法，使其与新的关键结构配合使用
- en: Add triggers to our form to populate `Technician` and `Seed sample`
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的表单添加触发器以填充`Technician`和`Seed sample`
- en: Fix our record list to work with the new keys
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复我们的记录列表以适应新的关键
- en: Let's start with our record form.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的记录表单开始。
- en: The data record form
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据记录表单
- en: 'The first task we have is to move the fields around. This is really just a
    matter of cutting and pasting code and then fixing our `grid()` arguments. Place
    them in the proper key order: Date, Time, Lab, Plot. Then, leave Technician and
    Seed sample at the end of the Record Information section.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是移动字段。这实际上只是剪切和粘贴代码，然后修复我们的`grid()`参数。将它们放在正确的键顺序中：Date、Time、Lab、Plot。然后，将Technician和Seed
    sample留在Record Information部分的末尾。
- en: 'It should look like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像这样：
- en: '![](assets/c9aa7446-02f5-4cf4-b810-7b805ae2dd1b.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c9aa7446-02f5-4cf4-b810-7b805ae2dd1b.png)'
- en: The reason for this change is so that all the fields which could trigger autofilling
    of Technician or Seed sample will come before those fields. If any of them came
    after, we'd be uselessly autofilling a field the user had already filled.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改的原因是，所有可能触发Technician或Seed sample自动填充的字段将出现在这些字段之前。如果它们中的任何一个出现在之后，我们将无用地自动填充用户已经填写的字段。
- en: 'At the end of `__init__()`, let''s add our triggers to populate Technician
    and Seed sample:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`的末尾，让我们添加触发器来填充Technician和Seed sample：
- en: '[PRE64]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We're putting a trace on the key variables for lab check and plot; should any
    of them change, we'll call the appropriate callback to auto-populate the form.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对实验检查和绘图的关键变量进行跟踪；如果它们中的任何一个发生变化，我们将调用适当的回调函数来自动填充表单。
- en: 'In `load_record()`, replace `rownum` with `rowkey` for clarity, then fix the
    label `text` so that it makes sense:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在`load_record()`中，为了清晰起见，用`rowkey`替换`rownum`，然后修复标签`text`，使其有意义：
- en: '[PRE65]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The last change of all for `DataRecordForm` deals with a small usability issue.
    As we auto-populate the form, it gets more and more confusing to determine which
    field we need to focus next. We're going to address this by creating a method
    that finds and focuses the first empty field in the form.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DataRecordForm`的最后一个更改涉及一个小的可用性问题。随着我们自动填充表单，确定下一个需要聚焦的字段变得越来越令人困惑。我们将通过创建一个方法来解决这个问题，该方法找到并聚焦表单中的第一个空字段。
- en: 'We''ll call it `focus_next_empty()`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称之为`focus_next_empty()`：
- en: '[PRE66]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this method, we're just iterating all the inputs and checking their current
    value. When we find one returns an empty string, we focus it, then break through
    the loop so that no more are checked. We can remove any calls to focus fields
    from `DataRecordForm.reset()` and replace them with a call to this method. You
    can also add it to our application's autofill methods, `get_current_seed_sample()`
    and `get_tech_for_lab_check()`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们只是迭代所有的输入并检查它们当前的值。当我们找到一个返回空字符串时，我们将聚焦它，然后打破循环，这样就不会再检查了。我们可以删除`DataRecordForm.reset()`中对聚焦字段的任何调用，并将其替换为对此方法的调用。您还可以将其添加到我们应用程序的自动填充方法`get_current_seed_sample()`和`get_tech_for_lab_check()`中。
- en: The record list
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录列表
- en: In `RecordList`, the `Row` column no longer contains useful information we wish
    to display.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RecordList`中，`Row`列不再包含我们希望显示的有用信息。
- en: 'We can''t remove it, but we can hide it with this code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法删除它，但我们可以使用这段代码隐藏它：
- en: '[PRE67]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `show` configuration option takes any or both of two values: `tree` and
    `headings`. The `tree` argument represents the `#0` column since it''s used to
    expand `tree`. The `headings` argument represents the remaining columns. By specifying
    only `headings` here, the `#0` column is hidden.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`配置选项接受两个值中的任意一个或两个：`tree`和`headings`。`tree`参数代表`#0`列，因为它用于展开`tree`。`headings`参数代表其余的列。通过在这里只指定`headings`，`#0`列被隐藏了。'
- en: We also need to deal with our `populate()` method, which relies heavily on `rownum`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理我们的`populate()`方法，它在很大程度上依赖于`rownum`。
- en: 'We''ll start by changing the `for` loop that populates the values:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更改填充值的`for`循环开始：
- en: '[PRE68]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We can remove the `enumerate()` call and just deal with the row data, extracting
    the `rowkey` tuple from it by getting `Date`, `Time`, `Lab`, and `Plot`. These
    need to be cast to string, because they come out of the database as Python objects
    like `date` and `int`, and we need to match them against the keys in `inserted`
    and `updated` which are all string values (since they were pulled from our form).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除`enumerate()`调用，只需处理行数据，从中提取`rowkey`元组，通过获取`Date`、`Time`、`Lab`和`Plot`。这些需要转换为字符串，因为它们作为Python对象（如`date`和`int`）从数据库中出来，我们需要将它们与`inserted`和`updated`中的键进行匹配，这些键都是字符串值（因为它们是从我们的表单中提取的）。
- en: 'Let''s do that comparison and set our row tags:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行比较并设置我们的行标签：
- en: '[PRE69]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, we need to decide how to handle our row's `iid` value. The `iid` values
    must be strings; this wasn't a problem when our primary key was an integer (easily
    castable to and from a string), but our tuple must be serialized in some way that
    we can easily reverse.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要决定如何处理我们行的`iid`值。`iid`值必须是字符串；当我们的主键是整数时，这不是问题（可以轻松转换为字符串），但是我们的元组必须以某种方式进行序列化，以便我们可以轻松地反转。
- en: 'A simple way to address this is to turn our tuple into a delimited string:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法是将我们的元组转换为一个分隔的字符串：
- en: '[PRE70]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Any character that isn't going to appear in the data will work fine as a delimiter;
    we've chosen to use the pipe character in this case.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不会出现在数据中的字符都可以作为分隔符；在这种情况下，我们选择使用管道字符。
- en: 'Now we can use the string version of the key in `treeview`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在`treeview`中使用键的字符串版本：
- en: '[PRE71]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The last part of this method focuses the first row for keyboard users. To focus
    the first row before, we relied on the fact that the first `iid` was always `0`.
    Now it will be some data-dependent tuple, so we'll have to retrieve the first
    `iid` before we can set the selection and focus.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的最后部分将键盘用户聚焦在第一行。以前，为了聚焦第一行，我们依赖于第一个`iid`始终为`0`的事实。现在它将是一些数据相关的元组，所以我们必须在设置选择和焦点之前检索第一个`iid`。
- en: 'We can do this by using the `Treeview.identify_row()` method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Treeview.identify_row()`方法来实现这一点：
- en: '[PRE72]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `identify_row()` method takes a row number and returns the `iid` of that
    row. Once we have that, we can pass it to `selection_set()` and `focus()`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`identify_row()`方法接受行号并返回该行的`iid`。一旦我们有了这个，我们就可以将它传递给`selection_set()`和`focus()`。'
- en: Our final change is to the `on_open_record()` method. Since we've used our serialized
    tuple as an `iid` value, we obviously need to translate this back to a tuple that
    can be passed back to the `on_open_record()` method.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的更改是`on_open_record()`方法。由于我们使用了我们序列化的元组作为`iid`值，显然我们需要将其转换回一个可以传递回`on_open_record()`方法的元组。
- en: 'This is as easy as calling `split()`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像调用`split()`一样简单：
- en: '[PRE73]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That fixes all our view code, and our program is ready to run!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这修复了我们所有的视图代码，我们的程序已经准备好运行了！
- en: Last changes
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的更改
- en: Phew! That was quite a journey, but you're not quite done yet. As homework,
    you'll need to update your unit tests to accommodate the database and login. The
    best approach would be to mock out the database and login dialog.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这是一次相当艰难的旅程，但你还没有完成。作业是，您需要更新您的单元测试以适应数据库和登录。最好的方法是模拟数据库和登录对话框。
- en: There are also still some remnants of the CSV backend sitting around, such as
    the Select target… item in the file menu. You can delete those UI elements, but
    leave the backend code as it may come in handy in the near future.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些CSV后端的残留物，比如文件菜单中的选择目标... 项目。您可以删除这些UI元素，但是将后端代码保留下来可能会在不久的将来派上用场。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about relational databases and SQL, the language
    used to work with them. You learned to model and normalize data to reduce the
    possibility of inconsistencies, and how to convert flat files into relational
    data. You learned how to work with the `psycopg2` library, and went through the
    arduous task of converting the application to use a SQL backend.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了关系数据库和SQL，用于处理它们的语言。您学会了对数据进行建模和规范化，以减少不一致性的可能性，以及如何将平面文件转换为关系数据。您学会了如何使用`psycopg2`库，并经历了将应用程序转换为使用SQL后端的艰巨任务。
- en: In the next chapter, we'll be reaching out to the cloud. We'll need to contact
    some remote servers using different networking protocols to exchange data. You'll
    learn about the Python standard library's modules for working with HTTP and FTP,
    and use them to download and upload data.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将接触云。我们需要使用不同的网络协议联系一些远程服务器来交换数据。您将了解有关Python标准库模块的信息，用于处理HTTP和FTP，并使用它们来下载和上传数据。
