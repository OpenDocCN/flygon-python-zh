- en: Working with Trees and Networks
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 处理树和网络
- en: Networks are objects that contain *n**odes*and *edges* between pairs of nodes.
    They can be used to represent a wide variety of real-world situations, such as
    distribution and scheduling. Mathematically, networks are useful for visualizing
    combinatorial problems and make for a rich and fascinating theory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是包含*n**odes*和节点对之间的*edges*的对象。它们可以用来表示各种真实世界的情况，如分布和调度。在数学上，网络对于可视化组合问题非常有用，并且构成了一个丰富而迷人的理论。
- en: There are, of course, several different kinds of networks. We will mostly deal
    with simple networks, where edges connect two distinct nodes (so there are no
    self-loops), there is, at most, one edge between any two nodes, and all the edges
    are bidirectional. A *tree*is a special kind of network in which there are no
    cycles; that is, there are no lists of nodes in which each node is connected to
    the following node by an edge, and the final node is connected to the first. Trees
    are especially simple in terms of their theory because they connect a number of
    nodes with the fewest possible edges. A *complete network*is a network in which
    every node is connected to every other node by an edge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有几种不同类型的网络。我们将主要处理简单的网络，其中边连接两个不同的节点（因此没有自环），任何两个节点之间最多只有一条边，并且所有边都是双向的。*树*是一种特殊类型的网络，其中没有循环；也就是说，没有节点列表，其中每个节点都通过一条边连接到下一个节点，并且最后一个节点连接到第一个节点。树在理论上特别简单，因为它们用尽可能少的边连接了许多节点。*完全网络*是一种网络，其中每个节点都通过一条边连接到其他每个节点。
- en: Networks can be directed, where each edge has a source and a destination node
    or can carry additional attributes such as weights. Weighted networks are especially
    useful in certain applications. There are also networks in which we allow multiple
    edges between two given nodes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可以是有向的，其中每条边都有源节点和目标节点，或者可以携带额外的属性，如权重。在某些应用中，加权网络特别有用。还有一些网络，我们允许两个给定节点之间有多条边。
- en: In this chapter, we will learn how to create, manipulate, and analyze networks,
    and then apply network algorithms to solve various problems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建、操作和分析网络，然后应用网络算法来解决各种问题。
- en: In the literature, especially in mathematical texts, networks are more commonly
    called *graphs*. Nodes are sometimes called *vertices*. We favor the term network
    to avoid confusion with the more common usage of graph to mean a plot of a function.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，特别是在数学文本中，网络更常被称为*图*。节点有时被称为*顶点*。我们更倾向于使用术语网络，以避免与图常用于表示函数图的更常见用法混淆。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Creating networks in Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中创建网络
- en: Visualizing networks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化网络
- en: Getting the basic characteristics of networks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取网络的基本特征
- en: Generating the adjacency matrix for a network
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为网络生成邻接矩阵
- en: Creating directed and weighted networks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有向和加权网络
- en: Finding the shortest paths in a network
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络中查找最短路径
- en: Quantifying clustering in a network
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量化网络中的聚类
- en: Coloring a network
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给网络着色
- en: Finding minimal spanning trees and dominating sets
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找最小生成树和支配集
- en: Let's get started!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will primarily use the NetworkX package for working with
    trees and networks. This package can be installed using your favorite package
    manager, such as `pip:`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用NetworkX包来处理树和网络。可以使用您喜欢的软件包管理器（如`pip`）安装此软件包：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We usually import this under the alias `nx`, following the conventions established
    in the official NetworkX documentation, using the following `import` statement:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们按照官方NetworkX文档中建立的约定，将其别名为`nx`导入：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for this chapter can be found in the `Chapter 05` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库的`Chapter 05`文件夹中找到：[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2WJQt4p](https://bit.ly/2WJQt4p).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/2WJQt4p](https://bit.ly/2WJQt4p)。
- en: Creating networks in Python
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中创建网络
- en: In order to solve the multitude of problems that can be expressed as network
    problems, we first need a way of creating networks in Python. For this, we will
    make use of the NetworkX package and the routines and classes it provides to create,
    manipulate, and analyze networks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决可以表示为网络问题的多种问题，我们首先需要一种在Python中创建网络的方法。为此，我们将利用NetworkX包及其提供的例程和类来创建、操作和分析网络。
- en: In this recipe, we'll create an object in Python that represents a network and
    add nodes and edges to this object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个代表网络的Python对象，并向该对象添加节点和边。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As we mentioned in the *Technical requirements* section, we need the NetworkX
    package to be imported under the alias `nx` by using the following `import` statement:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*技术要求*部分中提到的，我们需要导入NetworkX包，并使用以下`import`语句将其别名为`nx`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create a Python representation of a simple graph:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建简单图的Python表示形式：
- en: 'We need to create a new `Graph`object that will store the nodes and edges that
    constitute the graph:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个将存储构成图的节点和边的新`Graph`对象：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we need to add the nodes for the network using the `add_node` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`add_node`方法为网络添加节点：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To avoid calling this method repetitively, we can use the `add_nodes_from`
    method to add nodes from an iterable such as a list:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免重复调用此方法，我们可以使用`add_nodes_from`方法从可迭代对象（如列表）中添加节点：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to add edges between the nodes that we''ve added using either
    the `add_edge` method or the `add_edges_from` method, which add either a single
    edge or a list of edges (as tuples), respectively:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`add_edge`方法或`add_edges_from`方法在我们添加的节点之间添加边，分别向网络添加单个边或边的列表（作为元组）：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we retrieve a view of the current nodes and edges in a graph by accessing
    the `nodes` and `edges` attributes, respectively:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过访问`nodes`和`edges`属性，我们可以检索图中当前节点和边的视图：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The NetworkX package adds several classes and routines for creating, manipulating,
    and analyzing networks using Python. The `Graph` class is the most basic class
    for representing networks that do not contain multiple edges between any given
    nodes and where their edges are undirected (bidirectional).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX软件包添加了几个类和例程，用于使用Python创建、操作和分析网络。`Graph`类是表示不包含任何给定节点之间多条边的网络的最基本类，其边是无向的（双向的）。
- en: Once a blank `Graph` object has been created, we can add new nodes and edges
    using the methods described in this recipe. In this recipe, we created nodes that
    hold integer values. However, a node can hold any hashable Python object except
    `None.` Moreover, associated data can be added to a node via keyword arguments
    passed to the `add_node` method. Attributes can also be added when using the `add_nodes_from`
    method by supplying a list of tuples containing the node object and a dictionary
    of attributes. The `add_nodes_from` method is useful for adding nodes in bulk,
    while `add_node` is useful for attaching individual nodes to an existing network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的`Graph`对象后，我们可以使用本示例中描述的方法添加新节点和边。在这个示例中，我们创建了保存整数值的节点。然而，节点可以保存除`None`之外的任何可散列的Python对象。此外，可以通过传递给`add_node`方法的关键字参数向节点添加关联数据。在使用`add_nodes_from`方法时，还可以添加属性，方法是提供包含节点对象和属性字典的元组列表。`add_nodes_from`方法用于批量添加节点，而`add_node`用于将单个节点附加到现有网络。
- en: An edge in a network is a tuple containing two (distinct) nodes. In a simple
    network, such as the one represented by the basic `Graph` class, there can be,
    at most, one edge between any two given nodes. The edges are added via the `add_edge`
    or `add_edges_from` methods, which add either a single edge or a list of edges
    to the network, respectively. As for the nodes, edges can hold arbitrary associated
    data via an attributes dictionary. In particular, weights can be added by supplying
    the `weight` attribute when adding edges. We will provide more details about weighted
    graphs in the *Creating directed and weighted networks* recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的边是包含两个（不同的）节点的元组。在简单网络中，例如基本的`Graph`类表示的网络中，任何两个给定节点之间最多只能有一条边。边是通过`add_edge`或`add_edges_from`方法添加的，分别向网络添加单个边或边的列表。与节点一样，边可以通过属性字典保存任意关联数据。特别是，可以通过在添加边时提供`weight`属性来添加权重。我们将在*创建有向和加权网络*中提供有关加权图的更多细节。
- en: The `nodes` and `edges` attributes hold the nodes and edges that constitute
    the network, respectively. The `nodes` attribute returns a `NodesView` object,
    which is a dictionary-like interface to the nodes and their associated data. Similarly,
    the `edges` attribute returns an `EdgeView` object. This can be used to inspect
    individual edges and their associated data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodes`和`edges`属性分别保存构成网络的节点和边。`nodes`属性返回一个`NodesView`对象，它是节点及其关联数据的类似字典的接口。类似地，`edges`属性返回一个`EdgeView`对象。这可以用于检查单个边及其关联数据。'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Graph` class represents *simple networks*, which are networks in which
    nodes are joined by, at most, one edge, and the edges are not directed. We will
    discuss directed networks in the *Creating directed and weighted networks* recipe.
    There is a separate class for representing networks in which there can be multiple
    edges between a pair of nodes called `MultiGraph`. All of the network types allow
    self-loops, which are sometimes not allowed in a "simple network" in the literature,
    where a simple network typically refers to an undirected network with no self-loops.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph`类表示*简单网络*，这些网络是指节点之间最多只有一条边相连，并且边是无向的。我们将在*创建有向和加权网络*中讨论有向网络。有一个单独的类用于表示节点对之间可以有多条边的网络，称为`MultiGraph`。所有网络类型都允许自环，这在文献中有时不允许在“简单网络”中，在那里简单网络通常指的是没有自环的无向网络。'
- en: All network types offer various methods for adding nodes and edges, as well
    as inspecting the current nodes and edges. There are also methods for copying
    networks into some other kind of network or extracting subnetworks. There are
    also several utility routines in the NetworkX package for generating standard
    networks and adding subnetworks to an existing network.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网络类型都提供了各种方法来添加节点和边，以及检查当前节点和边。还有一些方法可以将网络复制到其他类型的网络中，或者提取子网络。NetworkX软件包中还有几个实用程序例程，用于生成标准网络并将子网络添加到现有网络中。
- en: NetworkX also provides various routines for reading and writing networks to
    different file formats, such as GraphML, JSON, and YAML. For example, we can write
    a network to a GraphML file using the `nx.write_graphml` routine and read it using
    the `nx.read_graphml` routine.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX还提供了各种例程，用于将网络读取和写入不同的文件格式，例如GraphML、JSON和YAML。例如，我们可以使用`nx.write_graphml`例程将网络写入GraphML文件，并使用`nx.read_graphml`例程进行读取。
- en: Visualizing networks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化网络
- en: A common first step in analyzing a network is to draw the network, which can
    help us identify some of the prominent features of a network. (Of course, drawings
    can be misleading, so we should not rely on them too heavily in our analysis.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 分析网络的常见第一步是绘制网络，这可以帮助我们识别网络的一些显著特征。（当然，绘图可能会产生误导，因此我们不应过分依赖它们进行分析。）
- en: In this recipe, we'll describe how to use the network drawing facilities in
    the NetworkX package to visualize a network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将描述如何使用NetworkX软件包中的网络绘图工具来可视化网络。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need to import the NetworkX package under the name
    `nx`, as described in the *Technical requirements* section. We will also need
    the Matplotlib package. For this, as usual, we import the `pyplot` module as `plt`
    using the following `import` statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们需要按照*技术要求*部分中描述的方式导入NetworkX包，并且还需要Matplotlib包。像往常一样，我们使用以下`import`语句将`pyplot`模块导入为`plt`：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps outline how to draw a simple network object using the drawing
    routines from NetworkX:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何使用NetworkX的绘图例程绘制简单的网络对象：
- en: 'First, we create a simple example network to draw:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的示例网络来绘制：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create new Matplotlib `Figure` and `Axes` objects for it, ready to
    plot the network using the `subplots` routine from `plt`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为其创建新的Matplotlib`Figure`和`Axes`对象，准备使用`plt`的`subplots`例程绘制网络：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can create a layout that will be used to position the nodes on the
    figure. For this figure, we shall use a shell layout using the `shell_layout`
    routine:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个布局，用于在图上放置节点。对于这个图，我们将使用`shell_layout`例程使用壳布局：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use the `draw` routine to draw the network on the figure. Since we have
    already created a Matplotlib `Figure` and `Axes`, we will supply the `ax` keyword
    argument. We will also add labels to the nodes using the `with_labels` keyword
    argument and specify the layout that we just created using the `pos` argument:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`draw`例程在图上绘制网络。由于我们已经创建了Matplotlib的`Figure`和`Axes`，我们将提供`ax`关键字参数。我们还将使用`with_labels`关键字参数为节点添加标签，并使用`pos`参数指定我们刚刚创建的布局：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting drawing can be seen in the following figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的绘图如下图所示：
- en: '![](assets/4b625495-d1f5-44db-9a3e-dbb369a33298.png)Figure 5.1: A drawing of
    a simple network arranged using a shell layout'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4b625495-d1f5-44db-9a3e-dbb369a33298.png)图5.1：使用壳布局排列的简单网络的绘图'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `draw` routine is a specialized plotting routine specifically for drawing
    networks. The layout we created specifies the coordinates at which each of the
    nodes will be placed. We used a *shell layout*, which arranges the nodes in a
    concentric circle arrangement, which is determined by the nodes and edges of the
    network. By default, the `draw` routine creates a randomized layout.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`例程是专门用于绘制网络的专用绘图例程。我们创建的布局指定了每个节点将被放置的坐标。我们使用了*壳布局*，它将节点排列在同心圆的布局中，这由网络的节点和边确定。默认情况下，`draw`例程会创建一个随机布局。'
- en: The `draw` routine has numerous keyword arguments for customizing the appearance
    of the plotted network. In this recipe, we added the `with_labels` keyword argument
    to label the nodes in the figure according to the objects they hold. The nodes
    hold integers, which is why the nodes in the preceding figure are labeled by integers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`例程有许多关键字参数，用于自定义绘制网络的外观。在本示例中，我们添加了`with_labels`关键字参数，根据节点所持有的对象在图中标记节点。节点持有整数，这就是为什么前面的图中的节点被标记为整数。'
- en: We also created a set of axes separately using the `plt.subplots` routine. This
    isn't strictly necessary since the `draw` routine will automatically create a
    new figure and axes if they're not provided.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`plt.subplots`例程单独创建了一组坐标轴。这并不是严格必要的，因为如果没有提供，`draw`例程将自动创建新的图和坐标轴。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The NetworkX package provides several layout-generating routines, similar to
    the `shell_layout` routine that we used in this recipe. The layout is simply a
    dictionary, indexed by the nodes, whose elements are the *x* and *y* coordinates
    of the position where the node should be plotted. The NetworkX routines for creating
    layouts represent common arrangements that will be useful for most cases, but
    you can also create custom layouts, should you need them. A full list of the different
    layout creation routines is provided in the NetworkX documentation. There are
    also shortcut drawing routines that will use a specific layout with the need to
    create the layout separately; for example, the `draw_shell` routine will draw
    the network with the shell layout that is equivalent to the `draw` call given
    in this recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX包提供了几种生成布局的例程，类似于我们在本示例中使用的`shell_layout`例程。布局简单地是一个由节点索引的字典，其元素是节点应该被绘制的位置的*x*和*y*坐标。NetworkX用于创建布局的例程表示了对大多数情况有用的常见布局，但如果需要，您也可以创建自定义布局。不同布局创建例程的完整列表在NetworkX文档中提供。还有一些快捷绘图例程，它们将使用特定布局而无需单独创建布局；例如，`draw_shell`例程将使用与本示例中给出的`draw`调用等效的壳布局绘制网络。
- en: The `draw` routine takes a number of keyword arguments to customize the appearance
    of the figure. For example, there are keyword arguments to control the node's
    size, color, shape, and transparency. We can also add arrows (for directed edges)
    and/or only draw a specific set of nodes and edges from the network.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`例程接受许多关键字参数来自定义图形的外观。例如，有关键字参数来控制节点的大小、颜色、形状和透明度。我们还可以添加箭头（用于有向边）和/或仅从网络中绘制特定的节点和边。'
- en: Getting the basic characteristics of networks
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取网络的基本特征
- en: Networks have various basic characteristics beyond the number of nodes and edges
    that are useful for analyzing a graph. For example, the*degree*of a node is the
    number of edges that start (or end) at that node. A higher degree indicates that
    the node is better connected to the rest of the network.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 网络具有各种基本特征，除了节点和边的数量之外，这些特征对于分析图形是有用的。例如，节点的*度*是以该节点为起点（或终点）的边的数量。较高的度表明该节点与网络的其余部分连接更好。
- en: In this recipe, we will learn how to access the basic attributes and compute
    various basic measures associated with a network.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何访问基本属性并计算与网络相关的各种基本度量。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, we need to import the NetworkX package under the name `nx`. We also
    need to import the Matplotlib `pyplot` module under the name `plt`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们需要将NetworkX包导入为`nx`。我们还需要将Matplotlib的`pyplot`模块导入为`plt`。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to access the various basic characteristics of a network:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤访问网络的各种基本特征：
- en: 'Create a sample network that we will analyze in this recipe, like so:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个我们将在本示例中分析的示例网络，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, it is good practice to draw the network and arrange the nodes in a circular
    layout:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将网络绘制并将节点布置在圆形布局中是一个良好的做法：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The resulting plot can be seen in the following figure. As we can see, the
    network is split into two distinct parts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在下图中看到生成的图。正如我们所看到的，网络分为两个不同的部分：
- en: '![](assets/c4e518ea-19a9-4785-bb2c-00494cf4da5a.png)Figure 5.2: Simple network
    drawn in a circular arrangement. There are two distinct components visible in
    this network'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c4e518ea-19a9-4785-bb2c-00494cf4da5a.png)图5.2：以圆形排列绘制的简单网络。在这个网络中可以看到两个不同的组件'
- en: 'Next, we use the `nx.info` routine to display some basic information about
    the network:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`nx.info`例程显示有关网络的一些基本信息：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we use the `degree` property of the `Graph` object to retrieve the degree
    of a specific node:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`Graph`对象的`degree`属性来检索特定节点的度：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can get the connected components of the network using the `connected_components`
    routine, which returns a generator that we make into a list:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`connected_components`例程获取网络的连接组件，它返回一个我们可以转换为列表的生成器：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We compute the *density* of a network using the `density` routine, which returns
    a float between 0 and 1\. This represents the proportion of edges meeting the
    node to the total number of possible edges at the node:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`density`例程计算网络的*密度*，它返回一个介于0和1之间的浮点数。这代表了满足节点的边与节点可能的总边数之间的比例：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we can determine whether a network is *planar*– meaning that no two
    edges need to be drawn crossing one another – by using the `check_planarity` routine:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`check_planarity`例程确定网络是否*平面*——意味着没有两条边需要绘制交叉——：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `info` routine generates a small summary of the network, including the type
    of the network (which is a simple `Graph` type in this recipe), the number of
    nodes and edges, and the average degrees of the nodes in the network. The actual
    degree of a node in the network can be accessed using the `degree` property, which
    offers a dictionary-like interface for finding the degree of each node.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`info`例程生成网络的一个小总结，包括网络的类型（在本示例中是简单的`Graph`类型），节点和边的数量，以及网络中节点的平均度。可以使用`degree`属性访问网络中节点的实际度，该属性提供类似字典的接口来查找每个节点的度。'
- en: A set of nodes is said to be connected if every node in the set is joined to
    the others by an edge or sequence of edges. The *connected components* of a network
    are the largest sets of nodes that are connected. Any two distinct connected components
    are obviously disjointed. Every network can be decomposed into one or more connected
    components. The network we defined in this recipe has two connected components,
    `{0, 1, 2, 3, 4, 5}` and `{8, 9, 6, 7}`. These are clearly visible in the preceding
    figure, where the first connected component is drawn above the second connected
    component. In this figure, we can trace a path along the edges of the network
    from any node in a component to any other; for example, from 0 to 5\.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组节点中的每个节点都通过边或一系列边连接到其他节点，则称为连接的。网络的*连接组件*是连接的最大节点集。任何两个不同的连接组件显然是不相交的。每个网络可以分解为一个或多个连接的组件。我们在本示例中定义的网络有两个连接的组件，`{0,
    1, 2, 3, 4, 5}`和`{8, 9, 6, 7}`。这些在前面的图中清晰可见，第一个连接的组件绘制在第二个连接的组件上方。在这个图中，我们可以沿着网络的边从一个组件中的任何节点到达另一个组件中的任何节点；例如，从0到5。
- en: The *density* of a network measures the ratio of the number of edges in the
    network to the total possible number of edges given by the number of nodes in
    a network. The density of a complete network is 1, but in general, the density
    will be less than 1.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*密度*衡量了网络中边的数量与网络中节点数量给出的总可能边数之间的比率。完全网络的密度为1，但一般情况下，密度会小于1。
- en: A network is *planar* if it can be drawn on a flat surface without crossing
    edges. The easiest example of a non-planar network is a complete network with
    five nodes. Complete networks with, at most, four nodes are planar. A little experimentation
    with the way you draw these networks on paper will reveal a drawing that doesn't
    contain crossing edges. In addition, any network that contains a complete graph
    with at least five nodes is not planar. Planar networks are important in theory
    due to their relative simplicity, but they are less common in networks that arise
    in applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络可以在平面表面上绘制而不交叉，则网络是*平面*的。非平面网络的最简单示例是具有五个节点的完全网络。至多具有四个节点的完全网络是平面的。通过在纸上绘制这些网络的方式进行一些实验，将会发现一个不包含交叉边的图。此外，任何包含至少五个节点的完全图的网络都不是平面的。平面网络在理论上很重要，因为它们相对简单，但在应用中出现的网络中它们较少。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to the methods on the network classes, there are a number of other
    routines in the NetworkX package that can be used to access the attributes of
    the nodes and edges in a network. For example, `nx.get_node_attributes` gets a
    named attribute from each node in the network.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络类中的方法之外，NetworkX包中还有许多其他例程可用于访问网络中节点和边的属性。例如，`nx.get_node_attributes`从网络中的每个节点获取一个命名属性。
- en: Generating the adjacency matrix for a network
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成网络的邻接矩阵
- en: One potent tool in the analysis of graphs is the adjacency matrix, which has
    entries *a[ij]* = 1 if there is an edge from node *i* to node *j*,*and 0 otherwise.
    For most networks, the adjacency matrix will be sparse (most of the entries are
    0). For networks that are not directed, the matrix will also be symmetric (*a[ij]*
    =**a**[ji]*). There are numerous other matrices that can be associated with a
    network. We will briefly discuss these in the *There's more...* section of this
    recipe.**
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的分析中，一个强大的工具是邻接矩阵，它的条目*a[ij]* = 1，如果有一条边从节点*i*到节点*j*，否则为0。对于大多数网络，邻接矩阵将是稀疏的（大多数条目为0）。对于非定向的网络，矩阵也将是对称的（*a[ij]*
    =**a**[ji]*）。还有许多其他可以与网络相关联的矩阵。我们将在本教程的*更多内容...*部分简要讨论这些。**
- en: '**In this recipe, we will generate the adjacency matrix for a network and learn
    how to get some basic properties of the network from this matrix.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这个教程中，我们将生成网络的邻接矩阵，并学习如何从这个矩阵中获得网络的一些基本属性。'
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the NetworkX package imported under the name `nx`,
    and the NumPy module imported under the name `np`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将需要将NetworkX包导入为`nx`，将NumPy模块导入为`np`。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps outline how to generate the adjacency matrix for a network
    and derive some simple properties of the network from this matrix:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何为网络生成邻接矩阵，并从这个矩阵中推导出网络的一些简单属性：
- en: 'First, we will generate a network to work with throughout this recipe. We''ll
    generate a random network with five nodes and five edges while using a seed for
    reproducibility:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将生成一个网络，然后在整个教程中使用它。我们将生成一个具有五个节点和五条边的随机网络，同时使用一个种子以便重现：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To generate the adjacency matrix, we use the `adjacency_matrix` routine from
    NetworkX. This returns a sparse matrix by default, so we will also convert this
    into a full NumPy array for this demonstration using the `todense` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成邻接矩阵，我们使用NetworkX的`adjacency_matrix`例程。这默认返回一个稀疏矩阵，因此我们还将使用`todense`方法将其转换为完整的NumPy数组以进行演示：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Taking the *n*th power of the adjacency matrix gives us the number of paths
    of length *n* from one node to another:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对邻接矩阵进行*n*次幂运算可以得到从一个节点到另一个节点的长度为*n*的路径数：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `dense_gnm_random_graph` routine generates a (dense) random network, chosen
    uniformly from the family of all networks with *n* nodes and *m* edges. In the
    recipe, *n=5* and *m=5*. The dense prefix indicates that this routine uses an
    algorithm that should be faster than the alternative `gnm_random_graph` for dense
    networks with a relatively large number of edges compared to nodes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`dense_gnm_random_graph`例程生成一个（密集的）随机网络，从所有具有*n*个节点和*m*条边的网络家族中均匀选择。在这个教程中，*n=5*，*m=5*。密集前缀表示这个例程使用的算法应该比对于节点数相对较大的密集网络的替代`gnm_random_graph`更快。'
- en: The adjacency matrix of a network is easy to generate, especially in sparse
    form, when the graph is relatively small. For larger networks, this can be an
    expensive operation, so it might not be practical, particularly if you convert
    it into a full matrix, as we saw in this recipe. You don't need to do this in
    general, since we can simply use the sparse matrix generated by the `adjacency_matrix`
    routine and the sparse linear algebra tools in the SciPy `sparse` module instead.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的邻接矩阵很容易生成，特别是在图相对较小的情况下，尤其是在稀疏形式下。对于更大的网络，这可能是一个昂贵的操作，因此可能不太实际，特别是如果你将其转换为完整矩阵，就像我们在这个教程中看到的那样。一般来说，你不需要这样做，因为我们可以简单地使用`adjacency_matrix`例程生成的稀疏矩阵和SciPy
    `sparse`模块中的稀疏线性代数工具。
- en: The matrix powers provide information about the number of paths of a given length.
    This can easily be seen by tracing through the definitions of matrix multiplication.
    Remember that the entries of the adjacency matrix are 1 when there is an edge
    (path of length 1) between two given nodes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的幂提供了关于给定长度的路径数的信息。通过追踪矩阵乘法的定义，这很容易看出。请记住，当两个给定节点之间存在边（长度为1的路径）时，邻接矩阵的条目为1。
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The Eigenvalues of the adjacency matrix for a network provide some additional
    information about the structure of the network, such as the bounds for the chromatic
    number of the network. (See the *Coloring a network* recipe for more information
    about coloring a network.) There is a separate routine for computing the Eigenvalues
    of the adjacency matrix. For example, we can use the `adjacency_spectrum` routine
    to generate the Eigenvalues of the adjacency matrix of a network. Methods involving
    the Eigenvalues of a matrix associated with a network are usually called *spectral
    methods*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的邻接矩阵的特征值提供了关于网络结构的一些额外信息，例如网络色数的上下界。（有关网络着色的更多信息，请参见*着色网络*教程。）有一个单独的例程用于计算邻接矩阵的特征值。例如，我们可以使用`adjacency_spectrum`例程生成网络的邻接矩阵的特征值。与网络相关的矩阵的特征值的方法通常被称为*谱方法*。
- en: There are other matrices associated with networks, such as the *incidence matrix*
    and the *Laplacian matrix*. The incidence matrix of a network is an *M × N* matrix,
    where *M* is the number of nodes and *N* is the number of edges. This has an *i-j*th
    entry of 1 if node *i* appears in edge *j* and 0 otherwise. The Laplacian matrix
    of a network is defined to be the *L = D - A* matrix, where *D* is the diagonal
    matrix containing the degrees of the nodes in the network and *A* is the adjacency
    matrix of the network. Both of these matrices are useful for analyzing networks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络相关的还有其他矩阵，如*关联矩阵*和*拉普拉斯矩阵*。网络的关联矩阵是一个*M × N*矩阵，其中*M*是节点数，*N*是边数。如果节点*i*出现在边*j*中，则该矩阵的第*i-j*个条目为1，否则为0。网络的拉普拉斯矩阵被定义为*L
    = D - A*矩阵，其中*D*是包含网络中节点度数的对角线矩阵，*A*是网络的邻接矩阵。这些矩阵对于分析网络很有用。
- en: Creating directed and weighted networks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建定向和加权网络
- en: Simple networks, such as those described in the previous recipes, are useful
    for describing networks where the direction of an edge is unimportant and where
    the edges carry equal weight. In practice, most networks carry additional information,
    such as weights or direction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的网络，比如前面的教程中描述的那些，用于描述边的方向不重要且边的权重相等的网络是有用的。实际上，大多数网络都携带额外的信息，比如权重或方向。
- en: In this recipe, we will create a directed and weighted network and explore some
    of the basic properties of such networks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将创建一个有向且带权重的网络，并探索这种网络的一些基本属性。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the NetworkX package, imported under the name
    `nx` (as usual), the Matplotlib `pyplot` module imported as `plt`, and the NumPy
    package imported as `np`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将需要NetworkX包，以通常的方式导入为“nx”，导入为“plt”的Matplotlib“pyplot”模块，以及导入为“np”的NumPy包。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps outline how to create a directed network with weights,
    as well as how to explore some of the properties and techniques we discussed in
    the previous recipes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何创建一个带权重的有向网络，以及如何探索我们在前面教程中讨论的一些属性和技术：
- en: 'To create a directed network, we use the `DiGraph` class from NetworkX rather
    than the simple `Graph` class:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个有向网络，我们使用NetworkX中的“DiGraph”类，而不是简单的“Graph”类：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As usual, we add nodes to the network using the `add_node` or `add_nodes_from`
    methods:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们使用“add_node”或“add_nodes_from”方法向网络添加节点：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To add weighted edges, we can use either the `add_edge` method and provide
    the `weight` keyword argument, or use the `add_weighted_edges_from` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加加权边，我们可以使用“add_edge”方法并提供“weight”关键字参数，或者使用“add_weighted_edges_from”方法：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we draw the network with arrows to indicate the direction of each edge.
    We also provide our own positions for this plot:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们用箭头绘制网络，以指示每条边的方向。我们还为这个图提供了自己的位置：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在下图中看到得到的图：
- en: '![](assets/6fc068a8-7008-4108-935e-59128098ca32.png)Figure 5.3: A weighted,
    directed network'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6fc068a8-7008-4108-935e-59128098ca32.png)图5.3：一个带权重的有向网络'
- en: 'The adjacency matrix of a directed matrix is created in the same way as a simple
    network, but the resulting matrix will not be symmetric:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有向矩阵的邻接矩阵的创建方式与简单网络相同，但是得到的矩阵不会是对称的：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `DiGraph` class represents a directed network, where the order of the nodes
    when adding an edge is important. In this recipe, we added two edges for connecting
    nodes 2 and 3, one in each direction. In a simple network (the `Graph` class),
    the addition of the second edge would not add an additional edge. However, for
    a directed network (the `DiGraph` class), the order that the nodes are given in
    when adding the edge determines the direction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: “DiGraph”类表示一个有向网络，其中在添加边时节点的顺序很重要。在这个教程中，我们添加了两条连接节点2和3的边，每个方向一条。在简单网络（“Graph”类）中，添加第二条边不会增加额外的边。然而，在有向网络（“DiGraph”类）中，添加边时给出的节点的顺序决定了方向。
- en: There is nothing special about weighted edges except for the addition of the
    `weight` attribute that's attached to the edge. (Arbitrary data can be attached
    to an edge or node in a network via keyword arguments.) The `add_weighted_edges_from`
    method simply adds the corresponding weight value (the third value in the tuple)
    to the edge in question. Weights can be added to any edge in any network, not
    just the directed networks shown in this recipe.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加权边，除了添加附加到边的“weight”属性之外，没有什么特别之处。（可以通过关键字参数向网络中的边或节点附加任意数据。）“add_weighted_edges_from”方法只是将相应的权重值（元组中的第三个值）添加到相关的边上。权重可以添加到任何网络中的任何边，而不仅仅是本教程中显示的有向网络。
- en: The `draw` routine automatically adds arrows to edges when drawing a directed
    network. This behavior can be turned off by passing the `arrows=False` keyword
    argument. The adjacency matrix for a directed or weighted network also differs
    from that of a simple network. In a directed network, the matrix is not generally
    symmetrical, because edges may exist in one direction but not the other. For a
    weighted network, the entries can be different from 1 or 0, and will instead be
    the weight of the corresponding edge.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制有向网络时，“draw”例程会自动向边添加箭头。可以通过传递“arrows=False”关键字参数来关闭这种行为。有向或带权重网络的邻接矩阵也与简单网络不同。在有向网络中，矩阵通常不对称，因为边可能只存在一个方向而不是另一个方向。对于带权重的网络，条目可以不同于1或0，而是对应边的权重。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Weighted networks appear in lots of applications, such as when describing transportation
    networks with distances or speeds. You can also use networks to examine flow through
    a network by providing a "capacity" for edges in the network (as a weight or as
    another attribute). NetworkX has several tools for analyzing flow through a network,
    such as finding the maximum flow through a network via the `nx.maximum_flow` routine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 带权重的网络出现在许多应用中，比如用距离或速度描述交通网络。您还可以使用网络来通过为网络中的边提供“容量”（作为权重或其他属性）来研究网络中的流动。NetworkX有几个工具用于分析网络中的流动，比如通过“nx.maximum_flow”例程找到网络中的最大流量。
- en: Directed networks add directional information to a network. Many real-world
    applications give rise to networks that have unidirectional edges, such as those
    in industrial processes or supply chain networks. This additional directional
    information has consequences for many of the algorithms for working with networks,
    as we'll see throughout this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有向网络为网络添加了方向信息。许多现实世界的应用产生了具有单向边的网络，比如工业流程或供应链网络中的网络。这种额外的方向信息对许多处理网络的算法都有影响，我们将在本章中看到。
- en: Finding the shortest paths in a network
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络中查找最短路径
- en: A common problem where networks make an appearance is in the problem of finding
    the shortest – or perhaps more precisely, the highest reward – route between two
    nodes in a network. For instance, this could be the shortest distance between
    two cities, where the nodes represent the cities and the edges are roads connecting
    pairs of cities. In this case, the weights of the edges would be their lengths.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 网络出现的一个常见问题是在网络中找到两个节点之间的最短路径或者更准确地说是最高奖励的路径。例如，这可能是两个城市之间的最短距离，其中节点代表城市，边代表连接城市对的道路。在这种情况下，边的权重将是它们的长度。
- en: In this recipe, we will find the shortest path between two nodes in a network
    with weights.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在一个带权重的网络中找到两个节点之间的最短路径。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NetworkX package imported, as usual, under
    the name `nx`, the Matplotlib `pyplot` module imported as `plt`, and a random
    number generator object from NumPy:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要导入NetworkX包，通常使用`nx`作为名称，导入Matplotlib的`pyplot`模块作为`plt`，以及从NumPy导入一个随机数生成器对象：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to find the shortest path between two nodes in a network:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在网络中找到两个节点之间的最短路径：
- en: 'First, we will create a random network using `gnm_random_graph` and a `seed`
    for this demonstration:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`gnm_random_graph`和一个`seed`创建一个随机网络，用于这个演示：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we''ll draw the network with a circular arrangement to see how the nodes
    connect to each other:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将以圆形排列的方式绘制网络，以查看节点之间的连接方式：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The resulting plot can be seen in the following image. Here, we can see that
    there is no direct edge from node 7 to node 9:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图可以在下面的图片中看到。在这里，我们可以看到从节点7到节点9没有直接的边：
- en: '![](assets/5fd59d73-0edf-44a2-b3bc-ad06f989d549.png)Figure 5.4: A randomly
    generated network with 10 nodes and 17 edges'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5fd59d73-0edf-44a2-b3bc-ad06f989d549.png)图5.4：一个随机生成的具有10个节点和17条边的网络'
- en: 'Now, we need to add a weight to each of the edges so that some routes are preferable
    to others in terms of the shortest path:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要给每条边添加权重，以便在最短路径方面有些路线更可取：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we will compute the shortest path from node 7 to node 9 using the `nx.shortest_path`
    routine:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`nx.shortest_path`例程计算从节点7到节点9的最短路径：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can find the length of this shortest path using the `nx.shortest_path_
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`nx.shortest_path_`来找到这条最短路径的长度
- en: 'length` routine:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 长度`routine`：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `shortest_path` routine computes the shortest path between each pair of
    nodes. Alternatively, when supplied with the source and destination node, which
    is what we did in this recipe, it computes the shortest path between the two specified
    nodes. We supplied the optional `weight` keyword argument, which makes the algorithm
    find the shortest path according to the "weight" attribute of the edge. This argument
    changes the meaning of "shortest", with the default being "fewest edges".
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortest_path`例程计算每对节点之间的最短路径。或者，当提供源节点和目标节点时，就像我们在这个示例中所做的那样，它计算两个指定节点之间的最短路径。我们提供了可选的`weight`关键字参数，这使算法根据边的“权重”属性找到最短路径。这个参数改变了“最短”的含义，默认是“最少的边”。'
- en: The default algorithm for finding the shortest path between two nodes is Dijkstra's
    algorithm, which is a staple of computer science and mathematics courses. It is
    a good general-purpose algorithm but is not particularly efficient. Other route-finding
    algorithms include the A* algorithm. Greater efficiency can be obtained by using
    the A* algorithm with additional heuristic information to guide node selection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 找到两个节点之间最短路径的默认算法是Dijkstra算法，这是计算机科学和数学课程的基础。它是一个很好的通用算法，但效率并不是特别高。其他寻路算法包括A*算法。使用A*算法并提供额外的启发式信息来指导节点选择可以获得更高的效率。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many algorithms for finding the shortest path between two nodes in
    a network. There are also variants for finding the maximum weighted path.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法可以在网络中找到两个节点之间的最短路径。还有一些变体用于找到最大加权路径。
- en: There are several related problems regarding finding the paths in a network,
    such as the *traveling salesperson problem* and the *route inspection problem*.
    In the traveling salesperson problem, we find a cycle (a path starting and ending
    at the same node) that visits every node in the network, with the smallest (or
    largest) total weight. In the route inspection problem, we seek the shortest cycle
    (by weight) that traverses every edge in the network and returns to the starting
    point. The traveling salesperson problem is known to be NP-hard, but the route
    inspection problem can be solved in polynomial time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在网络中找到路径的问题还有一些相关问题，比如*旅行推销员问题*和*路线检查问题*。在旅行推销员问题中，我们找到一个循环（从同一个节点开始和结束的路径），访问网络中的每个节点，总权重最小（或最大）。在路线检查问题中，我们寻找通过网络中每条边并返回到起点的最短循环（按权重计算）。已知旅行推销员问题是NP难题，但路线检查问题可以在多项式时间内解决。
- en: 'A famous problem in graph theory is the bridges at Königsberg, which asks to
    find a path in a network that traverses every edge in the network exactly once.
    It turns out, as proved by Euler, that finding such a path in the Königsberg bridges
    problem is impossible. A path that traverses every edge exactly once is called
    an *Eulerian circuit*. A network that admits an Eulerian circuit is called *Eulerian*.
    In fact, a network is Eulerian if and only if every node has an even degree. The
    network representation of the Königsberg bridge problem can be seen in the following
    image. The edges in this represent the different bridges over the rivers, while
    the nodes represent the different landmasses. We can see that all four of the
    nodes have an odd degree, which means that there cannot be a path that crosses
    every edge exactly once:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图论中一个著名的问题是Königsberg的桥，它要求在网络中找到一条路径，该路径恰好穿过网络中的每条边一次。事实证明，正如欧拉证明的那样，在Königsberg桥问题中找到这样的路径是不可能的。穿过每条边恰好一次的路径称为*欧拉回路*。如果一个网络允许欧拉回路，则称为*欧拉*。事实上，当且仅当每个节点的度都是偶数时，网络才是欧拉的。Königsberg桥问题的网络表示如下图所示。这里的边代表河流上的不同桥梁，而节点代表不同的陆地。我们可以看到所有四个节点的度都是奇数，这意味着不能有一条穿过每条边恰好一次的路径：
- en: '![](assets/7112954f-14cd-4a8f-bd16-4b169cb53854.png)Figure 5.5: A network representing
    the Königsberg bridge problem'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7112954f-14cd-4a8f-bd16-4b169cb53854.png)图5.5：表示Königsberg桥问题的网络'
- en: The edges represent the bridges between the different landmasses represented
    by the nodes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 边代表节点之间的桥梁。
- en: Quantifying clustering in a network
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络中量化聚类
- en: There are various quantities associated with networks that measure the characteristics
    of the network. For example, the clustering coefficient of a node measures the
    interconnectivity between the nodes nearby (here, nearby means connected by an
    edge). In effect, it measures how close the neighboring nodes are to forming a
    complete network or *clique*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络相关的各种量度可以衡量网络的特性。例如，节点的聚类系数衡量了附近节点之间的互连性（这里，附近意味着通过边连接）。实际上，它衡量了邻近节点接近形成一个完整网络或*团*的程度。
- en: 'The clustering coefficient of a node measures the proportion of the adjacent
    nodes that are connected by an edge; that is, two adjacent nodes form a triangle
    with the given node. We count the number of triangles and divide this by the total
    number of possible triangles that could be formed, given the degree of the node.
    Numerically, the clustering coefficient at a node, *u*, in a simple unweighted
    network is given by the following equation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的聚类系数衡量了与该节点相邻的节点之间通过边连接的比例；也就是说，两个相邻的节点与给定节点形成一个三角形。我们计算三角形的数量，并将其除以可能形成的总三角形数量，考虑到节点的度。从数值上看，简单无权重网络中节点*u*的聚类系数由以下方程给出：
- en: '![](assets/7175e9d6-ae3e-4e69-8065-dd93d7cc68a4.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7175e9d6-ae3e-4e69-8065-dd93d7cc68a4.png)'
- en: Here, *T[u]* is the number of triangles at *u* and the denominator is the total
    possible number of triangles at *u*. If the degree of *u (*the number of edges
    from *u)* is 0 or 1, then we set *c[u]* to 0.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*T[u]*是*u*处的三角形数，分母是*u*处可能的三角形总数。如果*u*的度（*u*的边数）为0或1，则将*c[u]*设为0。
- en: In this recipe, we will learn how to compute the clustering coefficient of a
    node in a network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何计算网络中节点的聚类系数。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will need the NetworkX package imported as `nx` and the
    Matplotlib `pyplot` module imported as `plt`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要导入NetworkX包作为`nx`，并导入Matplotlib `pyplot`模块作为`plt`。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you how to compute the clustering coefficient of a
    node in a network:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示了如何计算网络中节点的聚类系数：
- en: 'First, we need to create a sample network to work with:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个样本网络来使用：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we will draw the network so that we can compare the clustering coefficients
    that we''ll be calculating. This will allow us to see how these nodes appear in
    the network:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制网络，以便比较我们将要计算的聚类系数。这将使我们能够看到这些节点在网络中的出现方式：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图可以在下图中看到：
- en: '![](assets/7d9a21b9-1aff-4fe9-aef8-c38936faeb8f.png)Figure 5.6: Sample network
    for testing clustering'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7d9a21b9-1aff-4fe9-aef8-c38936faeb8f.png)图5.6：用于测试聚类的示例网络'
- en: 'Now, we can compute the clustering coefficients of the nodes in the network
    using the `nx.clustering` routine:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`nx.clustering`例程计算网络中节点的聚类系数：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the `nx.clustering` routine is a dictionary over the nodes in
    the network. So, we can print some selected nodes as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nx.clustering`例程的输出是网络中节点的字典。因此，我们可以按如下方式打印一些选定的节点：'
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The average clustering coefficient for all the nodes in the network can be
    computed using the `nx.average_clustering` routine:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`nx.average_clustering`例程计算网络中所有节点的平均聚类系数：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The clustering coefficient of a node measures how close the neighborhood of
    that node is to being a complete network (all the nodes are connected to one another).
    In this recipe, we can see that we have three different computed values: 0 has
    a clustering coefficient of 0.5, 2 has a clustering coefficient of 1.0, and 6
    has a clustering coefficient of 0\. This means that the nodes connected to node
    2 form a complete network, which is because we designed our network in this way.
    (Nodes 0-4 form a complete network by design.) The neighborhood of node 6 is very
    far from being complete since there are no interconnecting edges between either
    of its neighbors.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的聚类系数衡量了该节点的邻域接近形成一个完整网络（所有节点彼此连接）。在这个示例中，我们可以看到我们有三个不同的计算值：0的聚类系数为0.5，2的聚类系数为1.0，6的聚类系数为0。这意味着连接到节点2的节点形成了一个完整的网络，这是因为我们设计了我们的网络。
    （节点0-4按设计形成一个完整的网络。）节点6的邻域离完整很远，因为它的邻居之间没有相互连接的边。
- en: The average clustering value is a simple average of the clustering coefficients
    over all the nodes in the network. It is not quite the same as the global clustering
    coefficient (computed using the `nx.transitivity` routine in NetworkX), but it
    does give us an idea of how close the network as a whole is to being a complete
    network. The global clustering coefficient measures the ratio of the number of
    triangles to the number of triplets – a collection of three nodes that are connected
    by at least two edges – over the whole network.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 平均聚类值是网络中所有节点的聚类系数的简单平均值。它与全局聚类系数（使用NetworkX中的`nx.transitivity`例程计算）不完全相同，但它确实让我们了解整个网络接近完全网络的程度。全局聚类系数衡量了三角形的数量与三元组的数量之比
    - 由至少两条边连接的三个节点组成 - 在整个网络上。
- en: The difference between average clustering is quite subtle. The global clustering
    coefficient measures the clustering of the network as a whole, but the average
    clustering coefficient measures how much, on average, the network is locally clustered.
    The difference is best seen in a windmill network, which consists of a single
    node surrounded by a circle of an even number of nodes. All the nodes are connected
    to the center, but the nodes on the circle are only connected in an alternating
    pattern. The outer nodes have a local clustering coefficient of 1, while the center
    node has a local clustering coefficient of 1/(2*N - 1*), where *N*denotes the
    number of triangles joining to the center node.However, the global clustering
    coefficient is 3/(2*N*- 1).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 平均聚类之间的差异非常微妙。全局聚类系数衡量了整个网络的聚类程度，但平均聚类系数衡量了网络在局部平均聚类的程度。这种差异最好在风车网络中看到，它由一个单一节点围绕着偶数个节点的圆圈组成。所有节点都连接到中心，但圆圈上的节点只以交替模式连接。外部节点的局部聚类系数为1，而中心节点的局部聚类系数为1/(2*N-1*)，其中*N*表示连接到中心节点的三角形的数量。然而，全局聚类系数为3/(2*N*-1)。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Clustering coefficients are related to *cliques* in a network. A clique is a
    subnetwork that is complete (all the nodes are connected by an edge). An important
    problem in network theory is finding the maximal cliques in a network, which is
    a very difficult problem in general (here, maximal means "cannot be made larger").
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数与网络中的*团*相关。团是一个完全的子网络（所有节点都通过一条边连接）。网络理论中的一个重要问题是找到网络中的最大团，这在一般情况下是一个非常困难的问题（这里，最大意味着“不能再扩大”）。
- en: Coloring a network
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色网络
- en: Networks are also useful in scheduling problems, where you need to arrange activities
    into different slots so that there are no conflicts. For example, we could use
    networks to schedule classes to make sure that students who are taking different
    options do not have to be in two classes at once. In this scenario, the nodes
    will represent the different classes and the edges will indicate that there are
    students taking both classes. The process we use to solve these kinds of problems
    is called *network coloring*. This process involves assigning the fewest possible
    colors to the nodes in a network so that no two adjacent nodes have the same color.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 网络在调度问题中也很有用，您需要将活动安排到不同的时间段中，以确保没有冲突。例如，我们可以使用网络来安排课程，以确保选择不同选项的学生不必同时上两节课。在这种情况下，节点将代表不同的课程，边将指示有学生同时上两门课。我们用来解决这类问题的过程称为*网络着色*。这个过程涉及为网络中的节点分配尽可能少的颜色，以便相邻的两个节点没有相同的颜色。
- en: In this recipe, we will learn how to color a network to solve a simple scheduling
    problem.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何着色网络以解决简单的调度问题。
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need the NetworkX package imported as `nx` and the Matplotlib
    `pyplot` module imported as `plt`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要导入NetworkX包为`nx`，导入Matplotlib的`pyplot`模块为`plt`。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to solve a network coloring problem:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤解决网络着色问题：
- en: 'First, we will create a sample network to use in this recipe:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个示例网络，用于本教程：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will draw the network so that we can understand the coloring when
    it is generated. For this, we will use the `draw_circular` routine:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制网络，以便在生成着色时能够理解。为此，我们将使用`draw_circular`例程：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The resulting plot can be seen in the following figure:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的绘图如下图所示：
- en: '![](assets/fa56224e-7a2e-46d1-9e84-914d97c8c558.png)Figure 5.7: Example network
    for a simple scheduling problem'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fa56224e-7a2e-46d1-9e84-914d97c8c558.png)图5.7：简单调度问题的示例网络'
- en: 'We will generate the coloring using the `nx.greedy_color` routine:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`nx.greedy_color`例程生成着色：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To see the actual colors that were used in this coloring, we will generate
    a set of values from the `coloring` dictionary:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看此着色中使用的实际颜色，我们将从`coloring`字典生成一组值：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `nx.greedy_color` routine colors the network using one of a number of possible
    strategies. By default, it works in order of degree from largest to smallest.
    In our case, it started by assigning color 0 to node 2, which has a degree of
    6, then color 1 to node 0, which has a degree of 4, and so on. The first available
    color is chosen for each node in this sequence. This is not necessarily the most
    efficient algorithm for coloring a network.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`nx.greedy_color`例程使用多种可能的策略对网络进行着色。默认情况下，它按照从最大到最小的顺序按度数工作。在我们的情况下，它首先为度为6的节点2分配颜色0，然后为度为4的节点0分配颜色1，依此类推。对于这个序列中的每个节点，选择第一个可用的颜色。这不一定是着色网络的最有效算法。'
- en: Obviously, any network can be colored by assigning every node a different color,
    but in most cases, fewer colors are necessary. In the recipe, the network has
    seven nodes, but only four colors are required. The smallest number of colors
    necessary is called the *chromatic number* of the network.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过为每个节点分配不同的颜色，可以给任何网络上色，但在大多数情况下，需要更少的颜色。在本教程中，网络有七个节点，但只需要四种颜色。所需的最小颜色数称为网络的*色数*。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several variations of the coloring problem for networks. One such
    variation is the *list coloring problem*, in which we seek a coloring for a network
    where each node is given a color from a predefined list of possible colors. This
    problem is obviously more difficult than the general coloring problem.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的着色问题有几种变体。其中一种变体是*列表着色问题*，在这个问题中，我们寻找一个网络的着色，其中每个节点从可能颜色的预定义列表中选择一个颜色。这个问题显然比一般的着色问题更困难。
- en: The general coloring problem has surprising results. For example, every planar
    network can be colored by, at most, four different colors. This is a famous theorem
    from graph theory called the *four-color theorem*, and was proved by Appel and
    Haken in 1977\.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一般着色问题有一些令人惊讶的结果。例如，每个平面网络最多可以用四种不同的颜色着色。这是图论中著名的*四色定理*，由Appel和Haken在1977年证明。
- en: Finding minimal spanning trees and dominating sets
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到最小生成树和支配集
- en: Networks have applications for a wide variety of problems. Two obvious areas
    that see many applications are communication and distribution. For example, we
    might wish to find a way of distributing goods to a number of cities (nodes) in
    a road network that covers the smallest distance from a particular point. For
    problems like this, we need to look at minimal spanning trees and dominating sets.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 网络在各种问题中都有应用。两个明显的领域是通信和分配。例如，我们可能希望找到一种在覆盖从特定点到许多城市（节点）的道路网络中最小距离的分配方式。对于这样的问题，我们需要查看最小生成树和支配集。
- en: In this recipe, we will find a minimal spanning tree and a dominating set in
    a network.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将在网络中找到一个最小生成树和一个支配集。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to import the NetworkX package under the name `nx`
    and the Matplotlib `pyplot` module as `plt`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们需要将NetworkX包导入为`nx`，将Matplotlib的`pyplot`模块导入为`plt`。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to find a minimum spanning tree and dominating set for a
    network:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤找到网络的最小生成树和支配集：
- en: 'First, we will create a sample network to analyze:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个样本网络进行分析：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, as usual, we will draw the network before doing any analysis:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，和往常一样，在进行任何分析之前，我们将绘制网络：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The minimum spanning tree can be computed using the `nx.minimum_
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小生成树可以使用`nx.minimum_`来计算
- en: 'spanning_tree` routine:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 生成树`例程：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we will overlay the edges of the minimum spanning tree onto the plot:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在绘图上叠加最小生成树的边：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we will find a dominating set – a set where every node in the network
    is adjacent to at least one node from the set – for the network using the `nx.dominating_set`
    routine:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`nx.dominating_set`例程为网络找到一个支配集-一个集合，其中网络中的每个节点都与支配集中的至少一个节点相邻：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A plot of the network with the minimum spanning tree overlaid can be seen in
    the following figure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在下图中看到叠加了最小生成树的网络的绘图：
- en: '![](assets/3e8ca1be-4fd3-4ce2-9121-76182b51937e.png)Figure 5.8: The network
    drawn with the minimum spanning tree overlaid'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3e8ca1be-4fd3-4ce2-9121-76182b51937e.png)图5.8：叠加了最小生成树的网络绘制'
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A *spanning tree* of a network is a tree contained in the network that contains
    all the nodes. A *minimum* spanning tree is a spanning tree that contains the
    fewest edges possible – or, alternatively, has the lowest total weight. Minimum
    spanning trees are useful for distribution problems over a network. A simple algorithm
    for finding minimum spanning trees is to simply select edges (of smallest weight
    first, if the network is weighted) in such a way that it does not create cycles
    until this is no longer possible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*生成树*是网络中包含所有节点的树。*最小*生成树是包含尽可能少的边的生成树，或者说具有最低的总权重。最小生成树对于网络上的分配问题非常有用。一种简单的找到最小生成树的算法是简单地选择边（如果网络是加权的，则首先选择最小权重的边），以便不会创建循环，直到不再可能为止。
- en: A *dominating set* for a network is a set of vertices where every node in the
    network is adjacent to at least one node in the dominating set. Dominating sets
    have applications in communication networks. We are often interested in finding
    minimal dominating sets, but this is computationally difficult. In fact, testing
    whether there is a dominating set that's smaller than a given size is NP-complete.
    However, there are some efficient algorithms for finding the smallest dominating
    sets for certain classes of graphs. Informally speaking, the problem is that once
    you've identified a candidate for a minimum size dominating set, you have to verify
    that there are no dominating sets that are smaller in size. This is obviously
    very difficult if you do not know all the possible dominating sets in advance.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*支配集*是一个顶点集，其中网络中的每个节点都与支配集中的至少一个节点相邻。支配集在通信网络中有应用。我们经常有兴趣找到最小的支配集，但这在计算上是困难的。事实上，测试是否存在一个比给定大小更小的支配集是NP完全的。然而，对于某些类别的图形，有一些有效的算法可以找到最小的支配集。非正式地说，问题在于一旦你确定了一个最小大小支配集的候选者，你必须验证是否存在比它更小的支配集。如果你事先不知道所有可能的支配集，这显然是非常困难的。
- en: Further reading
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are several classical texts on graph theory, including books by Bollobás
    and Diestel:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有几本经典的图论著作，包括Bollobás和Diestel的书：
- en: '*Diestel, R., 2010\. Graph Theory. 3rd ed. Berlin: Springer.*'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* Diestel, R., 2010. Graph Theory. 3rd ed. Berlin: Springer.*'
- en: '*Bollobás, B., 2010\. Modern Graph Theory. New York, NY: Springer.***'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* Bollobás, B., 2010. Modern Graph Theory. New York, NY: Springer.***'
