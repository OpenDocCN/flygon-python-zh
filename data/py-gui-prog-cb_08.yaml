- en: Chapter 8. Internationalization and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this chapter, we will internationalize and test our Python GUI covering
    the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Displaying widget text in different languages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中国际化文本字符串的最简单方法是将它们移动到一个单独的Python模块中，然后通过向该模块传递参数来选择在我们的GUI中显示的语言。
- en: Changing the entire GUI language all at once
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过在标签、按钮、选项卡和其他小部件上显示文本来国际化我们的GUI，使用不同的语言。
- en: Localizing the GUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同语言中显示小部件文本
- en: Preparing the GUI for internationalization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为国际化准备GUI
- en: How to design a GUI in an agile fashion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以敏捷方式设计GUI
- en: Do we need to test the GUI code?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将国际化和测试我们的Python GUI，包括以下配方：
- en: Setting debug watches
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置调试监视
- en: Configuring different debug output levels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置不同的调试输出级别
- en: Creating self-testing code using Python's __main__ section
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Eclipse PyDev IDE编写单元测试
- en: Creating robust GUIs using unit tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何做...
- en: How to write unit tests using the Eclipse PyDev IDE
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要测试GUI代码吗？
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will internationalize our GUI by displaying text on labels,
    buttons, tabs, and other widgets, in different languages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will start simply and then explore how we can prepare our GUI for internationalization
    at the design level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章。国际化和测试
- en: We will also localize the GUI, which is slightly different from internationalization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将GUI与其显示的语言分开，这是一个面向对象的设计原则。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让我们改变我们以前的一行代码：
- en: As these words are long, they have been abbreviated to use the first character
    of the word, followed by the total number of characters in between the first and
    last character, followed by the last character of the word.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: So, internationalization becomes I18N and localization becomes L10N.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试创建健壮的GUI
- en: We will also test our GUI code and write unit tests and explore the value unit
    tests can provide in our development efforts which will lead us to the best practice
    of *refactoring* our code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个新的Python模块导入到我们的主要Python GUI代码中，然后使用它。
- en: Displaying widget text in different languages
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将从简单开始，然后探讨如何在设计级别准备我们的GUI进行国际化。
- en: The easiest way to internationalize text strings in Python is by moving them
    into a separate Python module and then selecting the language to be displayed
    in our GUI by passing in a parameter to this module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Python模块，并将其命名为`Resources.py`。接下来，让我们将我们的GUI标题的英文字符串移到这个模块中，然后将此模块导入到我们的GUI代码中。
- en: While this approach is not highly recommended, according to online search results,
    depending on the specific requirements of the application you are developing,
    this approach might still be the most pragmatic and fastest to implement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串硬编码到代码中从来都不是一个好主意，所以我们可以改进我们的代码的第一步是将所有在我们的GUI中可见的字符串分离到它们自己的Python模块中。这是国际化我们的GUI可见方面的开始。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性更改整个GUI语言
- en: We will reuse the Python GUI we created earlier. We have commented out one line
    of Python code that creates the MySQL tab because we do not talk to a MySQL database
    in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化GUI
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we will start to I18N our GUI by changing the Windows title
    from English to another language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将开始通过将Windows标题从英语更改为另一种语言来国际化我们的GUI。
- en: As the name "GUI" is the same in other languages, we will first expand the name
    that enables us to see the visual effects of our changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“GUI”在其他语言中是相同的，我们将首先扩展该名称，以便我们可以看到我们更改的视觉效果。
- en: 'Let''s change our previous line of code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们传递给I18N类的语言，我们的GUI将显示为该语言。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'to:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法并不是高度推荐的，但根据在线搜索结果，根据您正在开发的应用程序的具体要求，这种方法可能仍然是最实用和最快速实现的。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code change results in the following title for our GUI program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码更改导致我们的GUI程序的以下标题：
- en: '![How to do it...](graphics/B04829_08_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: 运行上述代码会给我们带来以下国际化的结果：
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这有效。
- en: In this chapter, we will use English and German to exemplify the principle of
    internationalizing our Python GUI.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测试我们的GUI代码并编写单元测试，并探索单元测试在我们的开发工作中可以提供的价值，这将使我们达到*重构*我们的代码的最佳实践。
- en: Hard-coding strings into code is never too good an idea, so the first step we
    can do to improve our code is to separate all the strings that are visible in
    our GUI into a Python module of their own. This is the beginning of internationalizing
    the visible aspects of our GUI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用英语和德语来举例说明国际化我们的Python GUI的原则。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的新Python模块，包含国际化的字符串，现在看起来像这样：
- en: While we are into I18N, we will do this very positive refactoring and the language
    translation all in one step.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些单词很长，它们已经被缩写为使用单词的第一个字符，后面跟着第一个和最后一个字符之间的总字符数，然后是单词的最后一个字符。
- en: Let's create a new Python module and name it `Resources.py`. Let's next move
    the English string of our GUI title into this module and then import this module
    into our GUI code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做...
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are separating the GUI from the languages it displays, which is an OOP design
    principle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，国际化变成了I18N，本地化变成了L10N。
- en: 'Our new Python module, containing internationalized strings, now looks like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将本地化GUI，这与国际化略有不同。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import this new Python module into our main Python GUI code, and then use
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的__main__部分创建自测试代码
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Depending on which language we pass into the I18N class, our GUI will be displayed
    in that language.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同语言中显示小部件文本
- en: 'Running the preceding code gives us the following internationalized result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到：
- en: '![How to do it...](graphics/B04829_08_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_08_02.jpg)'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将重用之前创建的Python GUI。我们已经注释掉了一个创建MySQL选项卡的Python代码行，因为在本章中我们不与MySQL数据库交谈。
- en: We are breaking out the hard-coded strings that are part of our GUI into their
    own separate modules. We do this by creating a class, and within the class's `__init__()`
    method, we select which language our GUI will display, depending on the passed
    in language argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将GUI中的硬编码字符串分解为它们自己的单独模块。我们通过创建一个类来实现这一点，并在类的`__init__()`方法中，根据传入的语言参数选择我们的GUI将显示哪种语言。
- en: This works.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行国际化时，我们将在一个步骤中进行这种积极的重构和语言翻译。
- en: We can further modularize our code by separating the internationalized strings
    into separate files, potentially in XML or another format. We could also read
    them in from a MySQL database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将国际化字符串分离到单独的文件中，可能是XML或其他格式，进一步模块化我们的代码。我们还可以从MySQL数据库中读取它们。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a "Separation of Concerns" coding approach, which is at the heart of
    OOP programming.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种“关注点分离”的编码方法，是面向对象编程的核心。
- en: Changing the entire GUI language all at once
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性更改整个GUI语言
- en: In this recipe, we will change the entire GUI display names all at once by refactoring
    all the previously hard-coded English strings into a separate Python module and
    then internationalizing those strings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过将以前硬编码的英文字符串重构到一个单独的Python模块中，然后国际化这些字符串，一次性更改整个GUI显示名称。
- en: This recipe shows that it is a good design principle to avoid hard-coding any
    strings that our GUI displays but to separate the GUI code from the text that
    the GUI displays.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例表明，避免硬编码GUI显示的任何字符串，而是将GUI代码与GUI显示的文本分开，是一个很好的设计原则。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Designing our GUI in a modular way makes internationalizing it much easier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以模块化的方式设计我们的GUI使得国际化变得更加容易。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to use the GUI from the previous recipe. In that recipe, we
    had already internationalized the title of the GUI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用上一个示例中开发的GUI。在那个示例中，我们已经国际化了GUI的标题。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In order to internationalize the text being displayed in all of our GUI widgets,
    we have to move all hard-coded strings into a separate Python module, and this
    is what we do next.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了国际化在我们的GUI小部件中显示的文本，我们必须将所有硬编码的字符串移到一个单独的Python模块中，这就是我们接下来要做的。
- en: Previously, strings of words that our GUI displayed were scattered all over
    our Python code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们的GUI显示的单词字符串分散在我们的Python代码中。
- en: Here is what our GUI looked like without I18N.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的GUI在没有I18N的情况下的样子。
- en: '![How to do it...](graphics/B04829_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_03.jpg)'
- en: Every single string of every widget, including the title of our GUI, the tab
    control names, and so on, were all hard-coded and intermixed with the code that
    creates the GUI.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小部件的每个字符串，包括我们的GUI的标题，选项卡控件名称等，都是硬编码的，并与创建GUI的代码混在一起。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good idea to think about how we can best internationalize our GUI at
    the design phase of our GUI software development process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI软件开发过程的设计阶段考虑如何最好地国际化我们的GUI是一个好主意。
- en: The following is an excerpt of what our code looks like.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们代码的摘录。
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this recipe, we are internationalizing all strings displayed in our GUI widgets.
    We are not internationalizing the text *entered* into our GUI, because this depends
    on the local settings on your PC.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在国际化我们的GUI小部件中显示的所有字符串。我们不会国际化*输入*到我们的GUI中的文本，因为这取决于您PC上的本地设置。
- en: 'The following is the code for the English internationalized strings:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是英文国际化字符串的代码：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our Python GUI module, all previously hard-coded strings are now replaced
    by an instance of our new I18N class, which resides in the `Resources.py` module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python GUI模块中，所有以前硬编码的字符串现在都被我们新的I18N类的实例所取代，该类位于`Resources.py`模块中。
- en: 'Here is an example from our refactored `GUI.py` module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们重构后的`GUI.py`模块的示例：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note how all of the previously hard-coded English strings have been replaced
    by calls to the instance of our new I18N class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以前所有的硬编码的英文字符串都已被我们新的I18N类的实例调用所取代。
- en: An example is `self.win.title(self.i18n.title)`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是`self.win.title(self.i18n.title)`。
- en: What this gives us is the ability to internationalize our GUI. We simply have
    to use the same variable names and combine them by passing in a parameter to select
    the language we wish to display.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们国际化GUI的能力。我们只需要使用相同的变量名，并通过传递参数来选择我们希望显示的语言。
- en: We could change languages on the fly as part of the GUI as well, or we could
    read the local PC settings and decide which language our GUI text should display
    according to those settings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在GUI的一部分中实时更改语言，或者我们可以读取本地PC设置，并根据这些设置决定我们的GUI文本应该显示哪种语言。
- en: We can now implement the translation to German by simply filling in the variable
    names with the corresponding words.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过简单地填写相应的单词来实现对德语的翻译。
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our GUI code, we can now change the entire GUI display language in one line
    of Python code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GUI代码中，我们现在可以通过一行Python代码更改整个GUI显示语言。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the preceding code creates the following internationalized GUI:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会创建以下国际化GUI：
- en: '![How to do it...](graphics/B04829_08_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_04.jpg)'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In order to internationalize our GUI, we refactored hard-coded strings into
    a separate module and then used the same class members to internationalize our
    GUI by passing in a string as the initializer of our I18N class, effectively controlling
    the language our GUI displays.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了国际化我们的GUI，我们将硬编码的字符串重构到一个单独的模块中，然后通过将字符串作为我们的I18N类的初始化器的参数来使用相同的类成员来国际化我们的GUI，从而有效地控制我们的GUI显示的语言。
- en: Localizing the GUI
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化GUI
- en: After the first step of internationalizing our GUI, the next step is to localize
    it. Why would we wish to do this?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在国际化我们的GUI的第一步之后，下一步是本地化。我们为什么要这样做呢？
- en: Well, here in the United States of America, we are all cowboys and we live in
    different time zones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在美利坚合众国，我们都是牛仔，我们生活在不同的时区。
- en: So while we are "internationalized" to the USA, our horses do wake up in different
    time zones (and do expect to be fed according to their own inner horse time zone
    schedule).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们在美国“国际化”，但我们的马在不同的时区醒来（并且期望根据它们自己的内部马时区时间表被喂食）。
- en: This is where localization comes in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本地化的作用。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are extending the GUI we developed in the previous recipe by localizing it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在通过本地化扩展我们在上一个示例中开发的GUI。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by first installing the Python pytz time zone module, using pip. We
    type the following command in a command processor prompt:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过pip安装Python pytz时区模块。我们在命令处理器提示中输入以下命令：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we are using Python 3.4, which comes with the `pip` module built-in.
    If you are using an older version of Python, then you might have to install the
    `pip` module first.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用的是Python 3.4，其中内置了`pip`模块。如果您使用的是较旧版本的Python，则可能需要先安装`pip`模块。
- en: When successful, we get the following result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，我们会得到以下结果。
- en: '![How to do it...](graphics/B04829_08_05.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_05.jpg)'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshot shows that the command downloaded the `.whl` format. If you have
    not done so, you might have to install the Python `wheel` module first.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示该命令下载了`.whl`格式。如果您还没有这样做，您可能需要先安装Python的`wheel`模块。
- en: This installed the Python `pytz` module into the `site-packages` folder, so
    now we can import this module from our Python GUI code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将Python的`pytz`模块安装到`site-packages`文件夹中，现在我们可以从Python GUI代码中导入这个模块。
- en: We can list all the existing time zones by running the following code, which
    will display the time zones in our `ScrolledText` widget. First we add a new `Button`
    widget to our GUI.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码列出所有现有的时区，在我们的`ScrolledText`小部件中显示时区。首先，我们向GUI添加一个新的`Button`小部件。
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Clicking our new `Button` widget results in the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击我们的新`Button`小部件会产生以下输出：
- en: '![How to do it...](graphics/B04829_08_06.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_06.jpg)'
- en: 'After we install the tzlocal Python module, we can print our current locale
    by running the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了tzlocal Python模块后，我们可以通过运行以下代码打印我们当前的区域设置：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have internationalized the strings of our two new action `Buttons` in `Resources.py`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`Resources.py`中国际化了我们两个新动作`Button`的字符串。
- en: 'English version:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 英文版本：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'German version:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 德语版本：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Clicking our new button now tells us which time zone we are in (hey, we didn't
    know that, didn't we…).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击我们的新按钮会告诉我们我们在哪个时区（嘿，我们不知道这个，是吧…）。
- en: '![How to do it...](graphics/B04829_08_07.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_07.jpg)'
- en: We can now translate our local time to a different time zone. Let's use USA
    Eastern Standard Time as an example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的本地时间转换为不同的时区。让我们以美国东部标准时间为例。
- en: We display our current local time in our unused Label 2 by improving our existing
    code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改进我们现有的代码，我们在未使用的标签2中显示我们当前的本地时间。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we run the code, our internationalized Label 2 (displayed as `Etikette
    2` in German) will display the current local time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们国际化的标签2（在德语中显示为`Etikette 2`）将显示当前的本地时间。
- en: '![How to do it...](graphics/B04829_08_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_08.jpg)'
- en: We can now change our local time to US EST by first converting it to **Coordinated
    Universal Time** (**UTC**) and then applying the `timezone` function from the
    imported `pytz` module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过首先将本地时间转换为**协调世界时**（**UTC**），然后应用从导入的`pytz`模块中的`timezone`函数来将本地时间更改为美国东部标准时间。
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Clicking the button now renamed as New York results in the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击重命名为纽约的按钮会产生以下输出：
- en: '![How to do it...](graphics/B04829_08_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_09.jpg)'
- en: Our Label 2 got updated with the current time in New York and we are printing
    the UTC times of the cities Los Angeles and New York with their respective time
    zone conversions, relative to UTC time to the Eclipse console, using a US date
    formatting string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标签2已更新为纽约的当前时间，并且我们正在使用美国日期格式字符串将洛杉矶和纽约的UTC时间及其相应的时区转换打印到Eclipse控制台。
- en: '![How to do it...](graphics/B04829_08_10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_10.jpg)'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: UTC never observes Daylight Saving Time. During **Eastern Daylight Time** (**EDT**)
    UTC is four hours ahead and during **Standard Time** (**EST**) it is five hours
    ahead of the local time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: UTC从不观察夏令时。在**东部夏令时**（**EDT**）期间，UTC比本地时间提前四个小时，在**标准时间**（**EST**）期间，UTC比本地时间提前五个小时。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: In order to localize date and time information, we first need to convert our
    local time to UTC time. We then apply `timezone` information and use the `astimezone`
    function from the `pytz` Python time zone module to convert to any time zone in
    the entire world!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本地化日期和时间信息，我们首先需要将我们的本地时间转换为UTC时间。然后，我们应用`时区`信息，并使用`pytz` Python时区模块中的`astimezone`函数将时间转换为世界上任何时区的时间！
- en: In this recipe, we have converted the local time of the USA west coast to UTC
    and then displayed the USA east coast time in Label 2 of our GUI.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们已经将美国西海岸的本地时间转换为UTC，然后在我们的GUI的标签2中显示了美国东海岸的时间。
- en: Preparing the GUI for internationalization
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为国际化准备GUI
- en: In this recipe, we will prepare our GUI for internationalization by realizing
    that not all is as easy as could be expected when translating English into foreign
    languages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过意识到将英语翻译成外语并不像预期的那样容易，来为我们的GUI准备国际化。
- en: We still have one problem to solve and that is how to properly display non-English
    Unicode characters from foreign languages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个问题要解决，那就是如何正确显示来自外语的非英语Unicode字符。
- en: One might expect that displaying the German ä, ö, and ü Unicode umlaut characters
    would be handled by Python 3 automatically, but this is not the case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能期望Python 3会自动处理德语ä、ö和ü的Unicode变音字符，但事实并非如此。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to use the Python GUI we developed in recent chapters. First,
    we will change the default language to German in the `GUI.py` initialization code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们在最近章节中开发的Python GUI。首先，我们将在`GUI.py`的初始化代码中将默认语言更改为德语。
- en: We do this by uncommenting the line `self.i18n = I18N('de')`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过取消注释`self.i18n = I18N('de')`这一行来实现这一点。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: When we change the word `Ueber` to the correct German `Űber` using the umlaut
    character, the Eclipse PyDev plugin is not too happy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用变音字符将单词`Ueber`更改为正确的德语`Űber`时，Eclipse PyDev插件并不太开心。
- en: '![How to do it...](graphics/B04829_08_11.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_11.jpg)'
- en: We get an error message, which is a little bit confusing, because when we run
    the same line of code from within the Eclipse PyDev Console, we get the expected
    result.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了一个错误消息，有点令人困惑，因为当我们在Eclipse PyDev控制台中运行相同的代码行时，我们得到了预期的结果。
- en: '![How to do it...](graphics/B04829_08_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_12.jpg)'
- en: When we ask for the Python default encoding, we get the expected result, which
    is UTF-8.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们询问Python的默认编码时，我们得到了预期的结果，即UTF-8。
- en: '![How to do it...](graphics/B04829_08_13.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_13.jpg)'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can, of course, always resort to the direct representation of Unicode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们总是可以直接表示Unicode。
- en: Using Windows' built-in character map, we can find the Unicode representation
    of the umlaut character, which is U+00DC for the capital U with an umlaut.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows内置的字符映射，我们可以找到umlaut字符的Unicode表示，大写U带有umlaut的Unicode是U+00DC。
- en: '![How to do it...](graphics/B04829_08_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_14.jpg)'
- en: While this workaround is truly ugly, it does the trick. Instead of typing in
    the literal character Ü, we can pass in the Unicode of \u00DC to get this character
    correctly displayed in our GUI.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种解决方法确实很丑陋，但它起到了作用。我们可以通过传递Unicode的\u00DC来正确显示这个字符，而不是输入文字字符Ü。
- en: '![How to do it...](graphics/B04829_08_15.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_15.jpg)'
- en: We can also just accept the change in the default encoding from Cp1252 to UTF-8
    using PyDev with Eclipse, but we might not always get the prompt to do so.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以接受从Cp1252到UTF-8的默认编码更改，使用PyDev与Eclipse，但我们可能并不总是会得到提示去这样做。
- en: 'Instead, we might see the following error message displayed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可能会看到显示以下错误消息：
- en: '![How to do it...](graphics/B04829_08_16.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_16.jpg)'
- en: The way to solve this problem is to change the PyDev project's **Text file encoding**
    property to UTF-8.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将PyDev项目的**文本文件编码**属性更改为UTF-8。
- en: '![How to do it...](graphics/B04829_08_17.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_17.jpg)'
- en: After changing the PyDev default encoding, we now can display those German umlaut
    characters. We also updated the title to use the correct German ä character.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 更改PyDev默认编码后，我们现在可以显示那些德语umlaut字符。我们还更新了标题，使用了正确的德语ä字符。
- en: '![How to do it...](graphics/B04829_08_18.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_18.jpg)'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Internationalization and working with foreign language Unicode characters is
    often not as straightforward as we would wish. Sometimes, we have to find workarounds
    and expressing Unicode characters via Python by using the direct representation
    by prepending `\u` can do the trick.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化和处理外语Unicode字符通常并不像我们希望的那样直接。有时，我们不得不找到解决方法，并通过在Python中使用直接表示的方式来表示Unicode字符，可以解决问题。
- en: At other times, we just have to find the settings of our development environment
    to adjust.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他时候，我们只需找到我们开发环境的设置进行调整。
- en: How to design a GUI in an agile fashion
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何以敏捷方式设计GUI
- en: The modern agile software development approach to design and coding came out
    of the lessons learned by software professionals. This method applies to a GUI
    as much as to any other code. One of the main keys of agile software development
    is the continuously applied process of refactoring.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现代敏捷软件开发方法的设计和编码是由软件专业人员的经验教训总结而来的。这种方法适用于GUI和其他任何代码。敏捷软件开发的主要关键之一是持续应用的重构过程。
- en: One practical example of how refactoring our code can help us in our software
    development work is by first implementing some simple functionality using functions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重构我们的代码可以通过首先使用函数实现一些简单功能来帮助我们进行软件开发工作的一个实际例子。
- en: As our code grows in complexity, we might want to refactor our functions into
    methods of a class. This approach would enable us to remove global variables and
    also be more flexible about where inside the class we place methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码复杂性的增加，我们可能希望将我们的函数重构为类的方法。这种方法可以让我们删除全局变量，并且更灵活地确定在类的哪个位置放置方法。
- en: While the functionality of our code has not changed, the structure has.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的代码的功能没有改变，但结构已经改变了。
- en: In this process, we code, test, refactor, and then test again. We do this in
    short cycles and often start with the minimum code required to get some functionality
    to work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们编写、测试、重构，然后再次测试。我们会在短周期内进行这些操作，通常从需要一些功能的最小代码开始。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Test-driven software development is one particular style of the agile development
    methodology.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动的软件开发是敏捷开发方法论的一种特定风格。
- en: While our GUI is working nicely, our main `GUI.py` code has been ever increasing
    in complexity and it has started to get a little bit harder to maintain an overview
    of our code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的GUI运行得很好，但我们的主要`GUI.py`代码的复杂性不断增加，开始变得有点难以维护。
- en: This means we need to refactor our code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要重构我们的代码。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will refactor the GUI we created in previous chapters. We will use the English
    version of the GUI.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构之前章节中创建的GUI。我们将使用GUI的英文版本。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We have already broken out all names our GUI displays when we internationalized
    it in the previous recipe. That was an excellent start to refactoring our code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们已经将GUI显示的所有名称都国际化了。这是重构我们的代码的一个很好的开始。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refactoring is the process of improving the structure, readability, and maintainability
    of existing code. We are not adding new functionality.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是改进现有代码的结构、可读性和可维护性的过程。我们不会添加新功能。
- en: In the previous chapters and recipes, we have been extending our GUI in a "Top-to-bottom"
    waterfall development approach, adding `import` to the top and code towards the
    bottom of the existing code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节和配方中，我们一直在以“自上而下”的瀑布式开发方法扩展我们的GUI，向现有代码的顶部添加`import`，并向底部添加代码。
- en: While this was useful when looking at the code it now looks a little bit messy
    and we can improve this to help our future development.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在查看代码时这很有用，但现在看起来有点凌乱，我们可以改进这一点，以帮助我们未来的开发。
- en: 'Let us first clean up our `import` statement section, which currently looks
    like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先清理我们的`import`语句部分，目前看起来是这样的：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By simply grouping related imports, we can reduce the number of lines of code,
    which improves the readability of our imports, making them appear less overwhelming.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地分组相关的导入，我们可以减少代码行数，从而提高导入的可读性，使其看起来不那么令人生畏。
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can further refactor our code by breaking out the callback methods into their
    own modules. This improves readability by separating the different import statements
    into the modules they are required in.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将回调方法分解成它们自己的模块来进一步重构我们的代码。这通过将不同的导入语句分离到它们所需的模块中来提高可读性。
- en: Let us rename our `GUI.py` as `GUI_Refactored.py` and create a new module, which
    we name `Callbacks_Refactored.py`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`GUI.py`重命名为`GUI_Refactored.py`，并创建一个新的模块，我们将其命名为`Callbacks_Refactored.py`。
- en: This gives us this new architecture.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们这种新的架构。
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how we are passing in an instance of our own GUI class (`self`) when calling
    the `Callbacks` initializer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在调用`Callbacks`初始化程序时是如何传入我们自己的GUI类实例（`self`）的。
- en: 'Our new `Callbacks` class is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`Callbacks`类如下：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the initializer of our new class, the passed-in GUI instance is saved under
    the name `self.oop` and used throughout this new Python class module.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新类的初始化程序中，传入的GUI实例被保存在名为`self.oop`的名称下，并在这个新的Python类模块中使用。
- en: Running the refactored GUI code still works. We have only increased readability
    and reduced the complexity of our code in preparation for further development
    work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行重构后的GUI代码仍然有效。我们只是增加了代码的可读性，并减少了代码的复杂性，为进一步的开发工作做准备。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have first improved the readability of our code by grouping related import
    statements. We next broke out the callback methods into their own class and module
    in order to further reduce the complexity of our code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过分组相关的导入语句来提高代码的可读性。接下来，我们将回调方法分解成它们自己的类和模块，以进一步减少代码的复杂性。
- en: We had already taken the same OOP approach by having the `ToolTip` class reside
    in its own module and by internationalizing all GUI strings in the previous recipes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采用了相同的面向对象编程方法，通过将`ToolTip`类驻留在自己的模块中，并在先前的示例中国际化了所有GUI字符串。
- en: In this recipe, we went one step further in refactoring by passing our own instance
    into the callback method's class our GUI relies upon.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过将我们自己的实例传递给GUI依赖的回调方法类，进一步进行了重构。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now that we better understand the value of a modular approach to software development,
    we will most likely start with this approach in our future software designs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更好地理解了模块化软件开发的价值，我们很可能会在未来的软件设计中采用这种方法。
- en: Do we need to test the GUI code?
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要测试GUI代码吗？
- en: Testing our software is an important activity during the coding phase, as well
    as when releasing service packs or bug fixes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码阶段以及发布服务包或修复错误时，测试我们的软件是一项重要的活动。
- en: There are different levels of testing. The first level is developer testing,
    which often starts with the compiler or interpreter not letting us run our buggy
    code forcing us to test small parts of our code on the level of individual methods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同级别的测试。第一级是开发人员测试，通常从编译器或解释器不让我们运行有错误的代码开始，迫使我们在单个方法的级别上测试我们的代码的小部分。
- en: This is the first level of defense.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一层防御。
- en: A second level of coding defensively is when our source code control system
    tells us about some conflicts to be resolved and does not let us check in our
    modified code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层防御性编码是当我们的源代码控制系统告诉我们有一些冲突需要解决，并且不让我们提交修改后的代码。
- en: This is very useful and absolutely necessary when we work professionally in
    a team of developers. The source code control system is our friend and points
    out changes that have been committed to a particular branch or top-of-tree either
    by ourselves or by our other developers, and tells us that our local version of
    the code is both outdated and has some conflicts that need to be resolved before
    we can submit our code into the repository.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发团队中进行专业工作时，这是非常有用且绝对必要的。源代码控制系统是我们的朋友，它指出了已经提交到特定分支或最新版本的更改，无论是我们自己提交的还是其他开发人员提交的，并告诉我们我们的本地代码版本已经过时，并且存在一些需要在提交代码到存储库之前解决的冲突。
- en: This part assumes you use a source control system to manage and store your code.
    Examples include git, mercurial, svn, and several others. Git is a very popular
    source control and it is free for a single user.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分假设您使用源代码控制系统来管理和存储您的代码。示例包括git、mercurial、svn和其他几种。Git是一个非常流行的源代码控制系统，对于单个用户是免费的。
- en: A third level is the level of APIs where we encapsulate potential future changes
    to our code by only allowing interactions with our code via published interfaces.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第三级是API级别，我们通过只允许通过已发布的接口与我们的代码进行交互来封装对我们代码的潜在未来更改。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to "Program to an Interface, never an Implementation", *Design
    Patterns*, Page 17.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考《面向接口编程，而不是实现》，*设计模式*，第17页。
- en: Another level of testing is integration testing, when half of the bridge we
    finally built meets the other half that the other development teams created and
    the two don't meet at the same height (say, one half ended up two meters or yards
    higher than the other half…).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试级别是集成测试，当我们最终构建的一半桥梁与其他开发团队创建的另一半桥梁相遇时，两者高度不一致（比如，一半比另一半高出两米或码...）。
- en: Then, there is end user testing. While we built what they specified, it is not
    really what they wanted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有最终用户测试。虽然我们构建了他们指定的内容，但实际上并不是他们想要的。
- en: Oh well…I guess all of the preceding examples are valid reasons why we need
    to test our code both in the design and implementation stages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，好吧...我想所有前面的例子都是我们需要在设计和实施阶段都测试我们的代码的有效原因。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will test the GUI we have created in recent recipes and chapters. We will
    also show some simple examples of what can go wrong and why we need to keep testing
    our code and code we do call via APIs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试我们在最近的示例和章节中创建的GUI。我们还将展示一些简单的例子，说明可能出现的问题以及为什么我们需要不断测试我们的代码和通过API调用的代码。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: While many experienced developers grew up sprinkling `printf()` statements all
    over their code while debugging, many developers in the 21st century are accustomed
    to modern IDE development environments that efficiently speed up development time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多经验丰富的开发人员在调试时会在他们的代码中撒上`printf()`语句，但21世纪的许多开发人员习惯于现代IDE开发环境，这些环境可以有效地加快开发时间。
- en: In this book, we are using the PyDev Python plug-in for the Eclipse IDE.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用Eclipse IDE的PyDev Python插件。
- en: If you are just starting using an IDE like Eclipse with the PyDev plug-in, it
    might be a little bit overwhelming at first. The Python IDLE tool that ships with
    Python 3 also has a simpler debugger and you might wish to explore that first.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚开始使用像Eclipse这样的IDE，并安装了PyDev插件，一开始可能会有点不知所措。Python 3附带的Python IDLE工具也有一个更简单的调试器，您可能希望先探索一下。
- en: Whenever something goes wrong in our code, we have to debug it. The first step
    in doing this is to set break points and then step through our code, line by line,
    or method by method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的代码出现问题时，我们都必须进行调试。这样做的第一步是设置断点，然后逐行或逐个方法地执行我们的代码。
- en: Stepping in and out of our code is a daily activity until the code runs smoothly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中进出是日常活动，直到代码顺利运行。
- en: In Python GUI programming, one of the first things that can go wrong is missing
    out on importing the required modules or importing existing modules.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python GUI编程中，出错的第一件事可能是遗漏导入所需的模块或导入现有模块。
- en: 'Here is a simple example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '![How to do it...](graphics/B04829_08_19.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_19.jpg)'
- en: We are trying to create an instance of the tkinter class but things don't work
    as expected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图创建一个tkinter类的实例，但事情并不如预期那样运行。
- en: Well, we simply forgot to import the module and we can fix this by adding a
    line of Python code above our class creation, where the import statements live.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们只是忘记导入模块，我们可以通过在我们的类创建之前添加一行Python代码来修复这个问题，导入语句就在那里。
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is an example in which our development environment does the testing for
    us. We just have to do the debugging and code fixing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，我们的开发环境为我们进行测试。我们只需要进行调试和修复代码。
- en: Another example more closely related to developer testing is when we code conditionals
    and, during our regular development, do not exercise all branches of logic.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与开发人员测试更相关的例子是，当我们编写条件语句时，在常规开发过程中没有执行所有逻辑分支。
- en: Using an example from the previous chapter, let's say we click on the **Get
    Quotes** button and this works, but we never clicked on the **Mody Quote** button.
    The first button click creates the desired result, but the second throws an exception
    (because we had not yet implemented this code and probably forgot all about it).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章的一个例子，假设我们点击**获取报价**按钮，这个操作成功了，但我们从未点击**修改报价**按钮。第一次按钮点击会创建期望的结果，但第二次会抛出异常（因为我们尚未实现此代码，可能已经完全忘记了）。
- en: '![How to do it...](graphics/B04829_08_20.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_20.jpg)'
- en: 'Clicking the **Mody Quote** button creates the following result:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**修改报价**按钮会创建以下结果：
- en: '![How to do it...](graphics/B04829_08_21.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_21.jpg)'
- en: Another potential area of bugs is when a function or method suddenly no longer
    returns the expected result. Let's say we are calling the following function,
    which returns the expected result.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的错误区域是当函数或方法突然不再返回预期的结果。假设我们正在调用以下函数，它返回了预期的结果。
- en: '![How to do it...](graphics/B04829_08_22.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_22.jpg)'
- en: Then, someone makes a mistake, and we no longer get the previous results.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有人犯了一个错误，我们不再得到以前的结果。
- en: '![How to do it...](graphics/B04829_08_23.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_23.jpg)'
- en: Instead of multiplying, we are raising by the power of the passed in number,
    and the result is no longer what it used to be.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在进行乘法，而是以传入数字的幂进行计算，结果不再是以前的样子了。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In software testing, this sort of bug is called regression.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件测试中，这种错误被称为回归。
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we emphasized the importance of software testing during several
    phases of the software development life cycle by showing several examples of where
    code can go wrong and introduce software defects (aka bugs).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们强调了在软件开发生命周期的几个阶段进行软件测试的重要性，通过展示代码可能出错并引入软件缺陷（也称为错误）的几个例子。
- en: Setting debug watches
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置调试监视
- en: In modern **Integrated Development Environments** (**IDEs**) like the PyDev
    plugin in Eclipse or another IDE such as NetBeans, we can set debug watches to
    monitor the state of our GUI during the execution of our code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代的集成开发环境（IDE）中，如Eclipse中的PyDev插件或其他IDE（如NetBeans），我们可以设置调试监视来监视我们的GUI在代码执行过程中的状态。
- en: This is very similar to the Microsoft IDEs of Visual Studio and the more recent
    versions of Visual Studio.NET.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Visual Studio和更近期的Visual Studio.NET的Microsoft IDE非常相似。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting debug watches is a very convenient way to help our development efforts.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 设置调试监视是帮助我们开发工作的一种非常方便的方式。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will reuse the Python GUI we developed in earlier recipes.
    We are stepping through the code we previously developed and setting debug watches.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将重用之前开发的Python GUI。我们正在逐步执行我们之前开发的代码并设置调试监视。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this recipe applies to the PyDev plugin in the Java-based Eclipse IDE,
    its principles also apply to many modern IDEs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例适用于基于Java的Eclipse IDE中的PyDev插件，但其原则也适用于许多现代IDE。
- en: The first position where we might wish to place a breakpoint is at the place
    where we make our GUI visible by calling the tkinter main event loop.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望设置断点的第一个位置是在我们通过调用tkinter主事件循环使我们的GUI可见的地方。
- en: The green balloon symbol on the left is a breakpoint in PyDev/Eclipse. When
    we execute our code in debug mode, once the execution reaches the breakpoint,
    the execution of the code will be halted. At this point, we can see the values
    of all variables that are currently in scope. We can also type expressions into
    one of the debugger windows which will execute them, showing us the results. If
    the result is what we want, we might decide to change our code using what we have
    just learned.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PyDev/Eclipse中左侧的绿色气球符号是一个断点。当我们以调试模式执行我们的代码时，一旦执行到达断点，代码的执行将停止。此时，我们可以看到当前作用域内的所有变量的值。我们还可以在调试器窗口中输入表达式，执行它们，显示结果。如果结果是我们想要的，我们可能决定使用我们刚学到的知识更改我们的代码。
- en: We normally step through the code by either clicking an icon in the toolbar
    of our IDE or by using a keyboard shortcut (like pressing *F5* to step into code,
    *F6* to step over, and *F7* to step out of the current method).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过单击IDE工具栏中的图标或使用键盘快捷键（例如按下*F5*进入代码，*F6*跳过，*F7*跳出当前方法）来逐步执行代码。
- en: '![How to do it...](graphics/B04829_08_24.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/B04829_08_24.jpg)'
- en: Placing the breakpoint where we did and then stepping into this code turns out
    to be a problem because we end up in some low-level tkinter code we really do
    not wish to debug right now. We get out of the low-level tkinter code by clicking
    the Step-Out toolbar icon (which is the third yellow arrow on the right below
    the project menu) or by pressing *F7* (assuming we are using PyDev in Eclipse).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们放置断点并进入此代码时，出现了问题，因为我们最终进入了一些我们现在不希望调试的低级tkinter代码。我们通过单击Step-Out工具栏图标（该图标位于项目菜单下方的第三个黄色箭头）或按下*F7*（假设我们在Eclipse中使用PyDev）来退出低级tkinter代码。
- en: We started the debugging session by clicking the bug toolbar icon towards the
    right of the screenshot. If we execute without debugging, we click the green circle
    with the white triangle inside it, which is the icon to the right of the bug icon.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过单击截图右侧的bug工具栏图标开始调试会话。如果我们在不调试的情况下执行，我们会单击绿色圆圈内部有白色三角形的图标，该图标位于bug图标右侧。
- en: '![How to do it...](graphics/B04829_08_25.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/B04829_08_25.jpg)'
- en: A better idea is to place our breakpoint closer to our own code in order to
    watch the values of some of our own Python variables.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的做法是将断点放置在我们自己的代码附近，以便观察一些我们自己的Python变量的值。
- en: In the event-driven world of modern GUIs, we have to place our breakpoints at
    code that gets invoked during events, for example button clicks.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代GUI的事件驱动世界中，我们必须将断点放置在在事件期间被调用的代码上，例如按钮单击。
- en: Currently, one of our main functionalities resides in a button click event.
    When we click the button labeled **New York**, we create an event that then results
    in something happening in our GUI.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的一个主要功能位于按钮单击事件中。当我们单击标记为**New York**的按钮时，我们创建一个事件，然后在我们的GUI中发生某些事情。
- en: Let's place a breakpoint at the **New York** button callback method, which we
    named `getDateTime()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在**New York**按钮回调方法上放置一个断点，我们将其命名为`getDateTime()`。
- en: When we now run a debug session, we will stop at the breakpoint and then we
    can enable watches of variables that are in scope.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行调试会话时，我们将在断点处停止，然后我们可以启用作用域内的变量观察。
- en: Using PyDev in Eclipse, we can right-click a variable and then select the watch
    command from the pop-up menu. The name of the variable, its type, and current
    value will be displayed in the expressions debug window shown in the next screenshot.
    We can also directly type into the expressions window.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中使用PyDev，我们可以右键单击一个变量，然后从弹出菜单中选择观察命令。变量的名称、类型和当前值将显示在下一个截图中显示的表达式调试窗口中。我们也可以直接在表达式窗口中输入。
- en: The variables we are watching are not limited to simple data types. We can watch
    class instances, lists, dictionaries, and so on.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察的变量不仅限于简单的数据类型。我们可以观察类实例、列表、字典等。
- en: When watching these more complex objects, we can expand them in the expressions
    window and drill down into all of the values of the class instances, dictionaries,
    and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察这些更复杂的对象时，我们可以在表达式窗口中展开它们，并深入了解类实例、字典等所有值。
- en: We do this by clicking on the triangle to the left of our watched variable that
    appears left-most under the **Name** column next to each variable.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过点击出现在每个变量**名称**列最左边的观察变量左侧的三角形来实现这一点。
- en: '![How to do it...](graphics/B04829_08_26.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/B04829_08_26.jpg)'
- en: While we are printing out the values of the different time zone locations, in
    the long term, it is much more convenient and efficient to set debug watches.
    We do not have to clutter our code with old-fashioned C-style `printf()` statements.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们正在打印出不同时区位置的值，但从长远来看，设置调试观察更方便、更高效。我们不必用老式的C风格的`printf()`语句来使我们的代码混乱。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in learning how to install Eclipse with the PyDev plugin
    for Python, there is a great tutorial that will get you started installing all
    the necessary free software and then introduce you to PyDev within Eclipse by
    creating a simple, working Python program. [http://www.vogella.com/tutorials/Python/article.html](http://www.vogella.com/tutorials/Python/article.html)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣学习如何为Python安装Eclipse和PyDev插件，有一个很好的教程可以帮助您开始安装所有必要的免费软件，然后通过创建一个简单的、可工作的Python程序来介绍您PyDev在Eclipse中的使用。[http://www.vogella.com/tutorials/Python/article.html](http://www.vogella.com/tutorials/Python/article.html)
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We use modern Integrated Development Environments (IDEs) in the 21st century
    that are freely available to help us to create solid code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在21世纪使用现代集成开发环境（IDE），这些IDE是免费提供的，可以帮助我们创建稳健的代码。
- en: This recipe showed how to set debug watches, which is a fundamental tool in
    every developer's skill set. Stepping through our own code even when not hunting
    down bugs ensures that we understand our code and can lead to improving our code
    via refactoring.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了如何设置调试观察，这是每个开发人员技能中的基本工具。即使在不追踪错误时，逐步执行我们自己的代码可以确保我们理解我们的代码，并可能通过重构改进我们的代码。
- en: The following is a quote from the first programming book I read, *Thinking in
    Java*, written by Bruce Eckel.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我读过的第一本编程书籍《Java编程思想》中的一句话，作者是Bruce Eckel。
- en: '|   | *"Resist the urge to hurry, it will only slow you down."* |   |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|   | *"抵制急躁的冲动，它只会减慢你的速度。"* |   |'
- en: '|   | --*Bruce Eckel* |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|   | --*Bruce Eckel* |'
- en: Almost two decades later, this advice has passed the test of time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将近20年后，这些建议经受住了时间的考验。
- en: Note
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Debug watches help us to create solid code and are not a waste of time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 调试观察有助于我们创建可靠的代码，不是浪费时间。
- en: Configuring different debug output levels
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置不同的调试输出级别
- en: In this recipe, we will configure different debug levels that we can select
    and change at runtime. This allows us to control how much we want to drill down
    into our code when debugging our code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将配置不同的调试级别，可以在运行时选择和更改。这使我们能够控制在调试代码时要深入到代码中的程度。
- en: We will create two new Python classes and place both of them into the same module.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个新的Python类，并将它们放入同一个模块中。
- en: We will use four different logging levels and we will write our debugging output
    to a log file we will create. If the log folder does not exist, we will create
    it automatically as well.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四种不同的日志级别，并将我们的调试输出写入我们将创建的日志文件中。如果日志文件夹不存在，我们也将自动创建它。
- en: The name of the log file is the name of the executing script which is our refactored
    `GUI.py`. We can also choose other names for our log files by passing in the full
    path to the initializer of our logger class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件的名称是执行脚本的名称，即我们重构的`GUI.py`。我们还可以通过将完整路径传递给我们的记录器类的初始化程序来选择其他日志文件的名称。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue to use our refactored `GUI.py` code from the previous recipe.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用上一个示例中的重构的`GUI.py`代码。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we create a new Python module into which we place two new `classes`.
    The first `class` is very simple and defines the logging levels. This is basically
    an `enumeration`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的Python模块，将两个新的`类`放入其中。第一个`类`非常简单，定义了日志级别。这基本上是一个`枚举`。
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second `class` creates a log file by using the passed in full path of the
    file name and places this into a `logs` folder. On first run, the `logs` folder
    might not exist so the code automatically creates the folder.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`类`通过使用传入的文件名的完整路径创建一个日志文件，并将其放入`logs`文件夹中。在第一次运行时，`logs`文件夹可能不存在，因此代码会自动创建该文件夹。
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to write to our log file, we use the `writeToLog()` method. Inside
    the method, the first thing we do is check if the message has a logging level
    higher than the limit we set our desired logging output to. If the message has
    a lower level, we discard it and immediately return from the method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写入我们的日志文件，我们使用`writeToLog()`方法。在方法内部，我们首先检查消息是否具有高于我们设置的期望日志输出的限制级别。如果消息级别较低，我们将丢弃它并立即从方法中返回。
- en: If the message has a logging level that we want to display, we then check if
    it starts with a newline character, and if it does, we discard the newline by
    slicing the method starting at index 1, using Python's slice operator (`msg =
    msg[1:]`).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息具有我们想要显示的日志级别，那么我们检查它是否以换行符开头，如果是，我们通过使用Python的切片运算符（`msg = msg[1:]`）来丢弃换行符。
- en: We then write one line to our log file consisting of the current date timestamp,
    two tab spaces, our message, and ending in a newline character.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将一行写入我们的日志文件，其中包括当前日期时间戳、两个制表符、我们的消息，并以换行符结尾。
- en: '[PRE23]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can now import our new Python module, and inside the `__init__` section of
    our GUI code, we can create an instance of the `Logger` class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以导入我们的新Python模块，并在GUI代码的`__init__`部分中创建`Logger`类的实例。
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are retrieving the full path to our running GUI script via `path.realpath(__file__)`
    and passing this into the initializer of the `Logger` class. If the `logs` folder
    does not exist, it will automatically get created by our Python code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`path.realpath(__file__)`获取正在运行的GUI脚本的完整路径，并将其传递给`Logger`类的初始化程序。如果`logs`文件夹不存在，我们的Python代码将自动创建它。
- en: 'This creates the following results:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下结果：
- en: '![How to do it...](graphics/B04829_08_27.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_27.jpg)'
- en: The preceding screenshot shows that we created an instance of our new `Logger`
    class and the screenshot below shows that both the `logs` folder as well as the
    log were created.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示我们创建了一个新的`Logger`类的实例，下面的截图显示`logs`文件夹和日志都已创建。
- en: '![How to do it...](graphics/B04829_08_28.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_28.jpg)'
- en: When we open up the log, we can see that the current date and time as well as
    a default string have been written into the log.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开日志时，我们可以看到当前日期和时间以及默认字符串已被写入日志。
- en: '![How to do it...](graphics/B04829_08_29.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_29.jpg)'
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created our own logging class. While Python ships with a
    Logging module, it is very easy to create our own, which gives us absolute control
    over our logging format. This is very useful when we combine our own logging output
    with MS Excel or the Matplotlib we explored in previous recipes in a previous
    chapter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们创建了自己的日志记录类。虽然Python附带了一个日志记录模块，但很容易创建我们自己的日志记录类，这使我们对日志格式有绝对控制。当我们将自己的日志输出与我们在上一章中探索的MS
    Excel或Matplotlib结合使用时，这非常有用。
- en: In the next recipe, we will use Python's built-in `__main__` functionality to
    use the four different logging levels we have just created.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用Python内置的`__main__`功能来使用我们刚刚创建的四个不同的日志级别。
- en: Creating self-testing code using Python's __main__ section
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的__main__部分创建自测试代码
- en: Python comes with a very nice feature that enables each module to self-test.
    Making use of this feature is a great way of making sure that changes to our code
    do not break existing code and, additionally, the `__main__` self-testing section
    can serve as documentation for how each module works.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有一个非常好的功能，可以使每个模块进行自我测试。利用这个功能是确保我们的代码更改不会破坏现有代码的一个很好的方法，此外，`__main__`自测试部分还可以作为每个模块工作方式的文档。
- en: Note
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After a few months or years, we sometimes forget what our code is doing, so
    having an explanation written in the code itself is indeed a great help.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月或几年后，我们有时会忘记我们的代码在做什么，因此在代码本身中写下解释确实是一个很大的帮助。
- en: It is a good idea to always add a self-testing section to every Python module,
    when possible. It is sometimes not possible, but, in most modules, it is possible
    to do so.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，为每个Python模块始终添加一个自测试部分是一个好主意。有时不可能，但在大多数模块中是可能的。
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will extend the previous recipe, so, in order to understand what the code
    in this recipe is doing, we have to first read and understand the code of the
    previous recipe.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展上一个配方，因此，为了理解本配方中的代码在做什么，我们必须先阅读并理解上一个配方中的代码。
- en: How to do it...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we will explore the power of the Python `__main__` self-testing section
    by adding this self-testing section to our `Resources.py` module. Whenever we
    run a module that has this self-testing section located at the bottom of the module,
    when the module is executed by itself, this code will run.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过向我们的`Resources.py`模块添加这个自测试部分来探索Python`__main__`自测试部分的功能。每当我们运行一个具有此自测试部分位于模块底部的模块时，当模块单独执行时，此代码将运行。
- en: When the module is imported and used from other modules, the code in the `__main__`
    self-testing section will not be executed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块被导入并从其他模块中使用时，`__main__`自测试部分中的代码将不会被执行。
- en: 'This is the code that is also shown in the screenshot that follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在随后的屏幕截图中显示的代码：
- en: '[PRE25]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After adding the self-testing section, we now can run this module by itself
    and it creates useful output, while, at the same time, showing us that our code
    works as intended.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了自测试部分后，我们现在可以单独运行此模块，并且它会创建有用的输出，同时还会显示我们的代码按预期工作。
- en: '![How to do it...](graphics/B04829_08_30.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_30.jpg)'
- en: We are first passing in English as the language to be displayed in our GUI,
    and then we pass in German as the language that our GUI will display.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先传入英语作为要在我们的GUI中显示的语言，然后传入德语作为我们的GUI将显示的语言。
- en: We are printing out the title of our GUI to show that our Python module works
    as we intended it to work.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出我们的GUI的标题，以显示我们的Python模块按我们的意图工作。
- en: Note
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The next step is to use our logging capabilities which we created in the previous
    recipe.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用我们在上一个配方中创建的日志功能。
- en: We do this by first adding a `__main__` self-testing section to our refactored
    `GUI.py` module and we then verify that we created an instance of our `Logger`
    class.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过向我们重构的`GUI.py`模块添加一个`__main__`自测试部分，然后验证我们创建了`Logger`类的实例。
- en: '![How to do it...](graphics/B04829_08_31.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_31.jpg)'
- en: We next write to our log file by using the command shown. We have designed our
    logging level to default to log every message, which is the DEBUG level and, because
    of this, we do not have to change anything. We just pass in the message to be
    logged to the `writeToLog` method.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用所示的命令写入我们的日志文件。我们已经设计了我们的日志级别默认记录每条消息，这是DEBUG级别，因此我们不必更改任何内容。我们只需将要记录到`writeToLog`方法的消息传入。
- en: '[PRE26]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This gets written to our log file, as can be seen in the following screenshot
    of the log:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这被写入我们的日志文件，如下面日志的屏幕截图所示：
- en: '![How to do it...](graphics/B04829_08_32.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_32.jpg)'
- en: Now we can control the logging by adding logging levels to our logging statements
    and set the level we wish to output. Let's add this capability to our New York
    button callback method in the `Callbacks.py` module which is the `getDateTime`
    method.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过向我们的日志语句添加日志级别并设置我们希望输出的级别来控制日志记录。让我们将这种能力添加到`Callbacks.py`模块中的`getDateTime`方法，这是`New
    York`按钮回调方法。
- en: We change the previous `print` statements to `log` statements using different
    debug levels.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同的调试级别将先前的`print`语句更改为`log`语句。
- en: In the `GUI.py`, we import both new classes from our logger module.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GUI.py`中，我们从我们的日志模块导入了两个新类。
- en: '[PRE27]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we create local instances of those classes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建这些类的本地实例。
- en: '[PRE28]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we are passing in an instance of the GUI class to the `Callbacks.py` initializer,
    we can use logging level constraints according to the `LogLevel` class we have
    created.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将GUI类的一个实例传递给`Callbacks.py`初始化程序，因此我们可以根据我们创建的`LogLevel`类对日志级别进行约束。
- en: '[PRE29]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we now click our New York button, depending upon the selected logging level,
    we get different output written to our log file. The default logging level is
    `DEBUG`, which means everything gets written to our log.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击我们的纽约按钮时，根据所选的日志级别，我们会得到不同的输出写入我们的日志文件。默认的日志级别是“DEBUG”，这意味着一切都会被写入我们的日志。
- en: '![How to do it...](graphics/B04829_08_33.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_33.jpg)'
- en: When we change the logging level, we control what gets written to our log. We
    do this by calling the `setLoggingLevel` method of the `Logger` class.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改日志级别时，我们控制写入我们的日志的内容。我们通过调用`Logger`类的`setLoggingLevel`方法来实现这一点。
- en: '[PRE30]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `__main__` section of our GUI, we change the logging level to `MINIMUM`,
    which results in reduced output written to our log file.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GUI的`__main__`部分中，我们将日志级别更改为“MINIMUM”，这将导致减少写入我们的日志文件的输出。
- en: '[PRE31]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, our log file no longer shows the `Test Message` and only shows messages
    that meet the set logging level.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的日志文件不再显示“Test Message”，只显示符合设置的日志级别的消息。
- en: '![How to do it...](graphics/B04829_08_34.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_34.jpg)'
- en: How it works...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we are making good use of Python's built-in `__main__` self-testing
    section. We introduced our own logging file and, at the same time, how to create
    different logging levels.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们充分利用了Python内置的`__main__`自测试部分。我们引入了自己的日志文件，同时也介绍了如何创建不同的日志级别。
- en: By doing this, we have full control over what gets written to our log files.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以完全控制写入日志文件的内容。
- en: Creating robust GUIs using unit tests
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试创建健壮的GUI
- en: Python comes with a built-in unit testing framework and, in this recipe, we
    will start to use this framework to test our Python GUI code.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个内置的单元测试框架，在这个示例中，我们将开始使用这个框架来测试我们的Python GUI代码。
- en: Before we start to write unit tests, we want to design our testing strategy.
    We could easily intermix the unit tests with the code they are testing, but a
    better strategy is to separate the application code from the unit test code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写单元测试之前，我们想要设计我们的测试策略。我们可以很容易地将单元测试与它们测试的代码混合在一起，但更好的策略是将应用程序代码与单元测试代码分开。
- en: Note
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PyUnit has been designed according to the principles of all the other xUnit
    testing Frameworks.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: PyUnit是根据所有其他xUnit测试框架的原则设计的。
- en: Getting ready
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will test the internationalized GUI we created earlier in this chapter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试本章前面创建的国际化GUI。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In order to use Python's built-in unit testing framework, we have to import
    the Python `unittest` module. Let's create a new module and name it `UnitTests.py`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Python的内置单元测试框架，我们必须导入Python的`unittest`模块。让我们创建一个新模块，命名为`UnitTests.py`。
- en: We first import the `unittest` module, then we create our own class and within
    this class we inherit and extend the `unittest.TestCase` class.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`unittest`模块，然后创建我们自己的类，在这个类中，我们继承并扩展`unittest.TestCase`类。
- en: 'The simplest code to do it looks like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 做到这一点的最简单的代码如下：
- en: '[PRE32]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code isn't doing much yet, but when we run it, we do not get any errors,
    which is a good sign.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还没有做太多事情，但当我们运行它时，我们没有得到任何错误，这是一个好迹象。
- en: '![How to do it...](graphics/B04829_08_35.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_35.jpg)'
- en: We actually do get an output written to the console stating that we successfully
    ran zero tests…
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们确实会在控制台上得到一个输出，说明我们成功地运行了零个测试...
- en: Hmm, that output is a bit misleading as all we have done so far is create a
    class that contains no actual testing methods.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这个输出有点误导，因为到目前为止我们只是创建了一个不包含任何实际测试方法的类。
- en: We add testing methods that do the actual unit testing by following the default
    naming for all test methods to start with the word "test". This is an option that
    can be changed but it seems to be much easier and clearer to stick to this naming
    convention.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了实际进行单元测试的测试方法，按照所有测试方法的默认命名以“test”开头。这是一个可以更改的选项，但坚持这种命名约定似乎更容易和更清晰。
- en: Let's add a test method that will test the title of our GUI. This will verify
    that, by passing in the expected arguments, we get the expected result.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个测试方法，测试我们的GUI的标题。这将验证通过传入预期的参数，我们得到了预期的结果。
- en: '[PRE33]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are importing our `I18N` class from our `Resources.py` module, passing in
    English as the language to be displayed in our GUI. As this is our first unit
    test, we are printing out the Title result as well, just to make sure we know
    what we are getting back. We next use the `unittest assertEqual` method to verify
    that our title is correct.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的`Resources.py`模块中导入我们的`I18N`类，将英语作为要在我们的GUI中显示的语言传入。由于这是我们的第一个单元测试，我们也打印出了标题的结果，只是为了确保我们知道我们得到了什么。接下来，我们使用`unittest
    assertEqual`方法来验证我们的标题是否正确。
- en: Running this code gives us an **OK**, which means that the unit test passed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会得到一个**OK**，这意味着单元测试通过了。
- en: '![How to do it...](graphics/B04829_08_36.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_36.jpg)'
- en: The unit test runs and succeeds, which is indicated by one dot and the word
    "OK". If it had failed or gotten an error we would not have got the dot but an
    "F" or "E" as the output.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试运行并成功，这由一个点和单词“OK”表示。如果它失败或出现错误，我们将不会得到点，而是得到“F”或“E”作为输出。
- en: We can now do the same automated unit testing check by verifying the title for
    the German version of our GUI.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过验证GUI的德语版本的标题来进行相同的自动化单元测试检查。
- en: We simply copy, paste, and modify our code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需复制，粘贴和修改我们的代码。
- en: '[PRE34]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we are testing our internationalized GUI title in two languages and getting
    the following result when running the code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在测试我们国际化的GUI标题，使用两种语言，并在运行代码时得到以下结果：
- en: '![How to do it...](graphics/B04829_08_37.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_37.jpg)'
- en: We ran two unit tests but, instead of an OK, we got a failure. What happened?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了两个单元测试，但是，我们没有得到一个OK，而是得到了一个失败。发生了什么？
- en: Our `assertion` failed for the German version of our GUI…
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的德语版本GUI的`assertion`失败了...
- en: While debugging our code, it turns out that in the copy, paste, and modify approach
    of our unit test code, we forgot to pass in German as the language. We can easily
    fix this.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试我们的代码时，结果表明在复制，粘贴和修改我们的单元测试代码时，我们忘记了将德语作为语言传入。我们可以很容易地修复这个问题。
- en: '[PRE35]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we rerun our unit tests, we again get the expected result of all tests
    passing.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新运行我们的单元测试时，我们再次得到了所有测试都通过的预期结果。
- en: '![How to do it...](graphics/B04829_08_38.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_08_38.jpg)'
- en: Note
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unit testing code is code and can have bugs too.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试代码也是代码，也可能存在bug。
- en: While the purpose of writing unit tests is really to test our application code,
    we have to make sure that our tests are written correctly. One approach from the
    **Test-Driven-Development** (**TDD**) methodology might help us.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编写单元测试的目的是真正测试我们的应用程序代码，但我们必须确保我们的测试写得正确。来自**测试驱动开发**（TDD）方法论的一种方法可能会帮助我们。
- en: Note
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In TDD, we develop the unit tests before we actually write the application code.
    Now, if a test passes for a method that does not even exist, something is wrong.
    The next step is to create the non-existing method and make sure it will fail.
    After that, we can write the minimum amount of code necessary to make the unit
    test pass.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，我们在实际编写应用程序代码之前先编写单元测试。现在，如果一个方法甚至不存在的测试通过了，那就有问题。下一步是创建不存在的方法，并确保它会失败。之后，我们可以编写最少量的代码来使单元测试通过。
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we have begun to test our Python GUI, writing unit tests in
    Python. We have seen that Python unit test code is just code and can contain mistakes
    that need to be corrected. In the next recipe, we will extend this recipe's code
    and use the graphical unit test runner that comes with the PyDev plugin for the
    Eclipse IDE.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们已经开始测试我们的Python GUI，编写Python单元测试。我们已经看到Python单元测试代码只是代码，可能包含需要纠正的错误。在下一篇中，我们将扩展本篇的代码，并使用随Eclipse
    IDE附带的PyDev插件的图形单元测试运行器。
- en: How to write unit tests using the Eclipse PyDev IDE
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Eclipse PyDev IDE编写单元测试
- en: In the previous recipe, we started to use Python's unit testing capabilities,
    and in this recipe, we will ensure the quality of our GUI code by further using
    this capability.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇中，我们开始使用Python的单元测试功能，而在本篇中，我们将进一步使用这一功能来确保我们的GUI代码的质量。
- en: We will unit test our GUI in order to make sure that the internationalized strings
    our GUI displays are as expected.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的GUI进行单元测试，以确保我们的GUI显示的国际化字符串符合预期。
- en: In the previous recipe, we encountered some bugs in our unit testing code but,
    typically, our unit tests will find regression bugs that are caused by modifying
    existing application code, not the unit test code. Once we have verified that
    our unit testing code is correct, we do not usually change it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇中，我们在单元测试代码中遇到了一些错误，但通常，我们的单元测试将发现由修改现有应用程序代码而引起的回归错误，而不是单元测试代码。一旦我们验证了我们的单元测试代码是正确的，通常不会再更改它。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our unit tests also serve as documentation of what we expect our code to do.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试也作为我们期望代码执行的文档。
- en: By default, Python's unit tests are executed with a textural unit test runner
    and we can run this in the PyDev plug-in from within the Eclipse IDE. We can also
    run the very same unit tests from a console window.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python的单元测试是使用文本单元测试运行器执行的，我们可以在Eclipse IDE的PyDev插件中运行它。我们也可以从控制台窗口运行完全相同的单元测试。
- en: In addition to the text runner in this recipe, we will explore PyDev's graphical
    unit test feature that can be used from within the Eclipse IDE.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本篇中的文本运行器，我们还将探讨PyDev的图形单元测试功能，该功能可以从Eclipse IDE内部使用。
- en: Getting ready
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are extending the previous recipe, in which we began to use Python unit tests.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在扩展之前的配方，其中我们开始使用Python单元测试。
- en: How to do it...
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: The Python unit testing framework comes with what are called fixtures.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Python单元测试框架配备了所谓的装置。
- en: 'Refer to the following URLs for a description of what a test fixture is:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下网址了解测试装置的描述：
- en: '[https://docs.python.org/3.4/library/unittest.html](https://docs.python.org/3.4/library/unittest.html)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3.4/library/unittest.html](https://docs.python.org/3.4/library/unittest.html)'
- en: '[https://en.wikipedia.org/wiki/Test_fixture](https://en.wikipedia.org/wiki/Test_fixture)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Test_fixture](https://en.wikipedia.org/wiki/Test_fixture)'
- en: '[http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html](http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html](http://www.boost.org/doc/libs/1_51_0/libs/test/doc/html/utf/user-guide/fixture.html)'
- en: What this means is that we can create `setup()` and `teardown()` unit testing
    methods so that the `setup()` method is called at the beginning before any single
    test is executed, and at the end of every single unit test, the `teardown()` method
    is called.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以创建`setup()`和`teardown()`单元测试方法，以便在执行任何单个测试之前调用`setup()`方法，并且在每个单元测试结束时调用`teardown()`方法。
- en: Note
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This fixture capability provides us with a very controlled environment in which
    we can run our unit tests. It is similar to using pre- and post-conditions.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这种装置功能为我们提供了一个非常受控的环境，我们可以在其中运行我们的单元测试。这类似于使用前置条件和后置条件。
- en: Let's set up our unit testing environment. We will create a new testing class
    which focuses on the previously mentioned correctness of code.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置我们的单元测试环境。我们将创建一个新的测试类，重点关注前面提到的代码正确性。
- en: Note
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`unittest.main()` runs any method that starts with the prefix "test", no matter
    how many classes we create within a given Python module.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.main()`运行任何以前缀"test"开头的方法，无论我们在给定的Python模块中创建了多少个类。'
- en: '[PRE36]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This creates the following output:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![How to do it...](graphics/B04829_08_39.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_08_39.jpg)'
- en: The preceding unit testing code shows that we can create several unit testing
    classes and they can all be run in the same module by calling `unittest.main`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的单元测试代码表明，我们可以创建几个单元测试类，并且可以通过调用`unittest.main`在同一个模块中运行它们。
- en: It also shows that the `setup()` method does not count as a test in the output
    of the unit test report (the count of tests is 3) while, at the same time, it
    did its intended job as we can now access our class instance variable `self.gui`
    from within the unit test method.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 它还显示`setup()`方法在单元测试报告的输出中不算作测试（测试数量为3），同时，它也完成了其预期的工作，因为我们现在可以从单元测试方法内部访问我们的类实例变量`self.gui`。
- en: We are interested in testing the correctness of all of our labels and especially
    catching bugs when we make changes to our code.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有兴趣测试所有标签的正确性，特别是在我们更改代码时捕捉错误。
- en: If we have copied and pasted strings from our application code to the testing
    code, it will catch any unintended changes with the click of a unit testing framework
    button.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从应用程序代码复制并粘贴字符串到测试代码中，它将在单元测试框架按钮的点击下捕捉到任何意外更改。
- en: We also want to test that invoking any of our `Radiobutton` widgets in any language
    results in the `labelframe` widget `text` being updated. In order to automatically
    test this, we have to do two things.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望测试在任何语言中调用任何`Radiobutton`小部件都会导致`labelframe`小部件的`text`被更新。为了自动测试这一点，我们必须做两件事。
- en: 'First, we have to retrieve the value of the `labelframe text` widget and assign
    the value to a variable we name `labelFrameText`. We have to use the following
    syntax because the properties of this widget are being passed in and retrieved
    via a dictionary data type:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须检索`labelframe text`小部件的值，并将该值分配给一个名为`labelFrameText`的变量。我们必须使用以下语法，因为该小部件的属性是通过字典数据类型传递和检索的：
- en: '[PRE37]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can now verify the default text and then the internationalized versions after
    clicking one of the Radiobutton widgets programmatically.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以验证默认文本，然后在以编程方式单击一个Radiobutton小部件后，验证国际化版本。
- en: '[PRE38]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After verifying the default `labelFrameText` we programmatically set the radio
    button to index 1 and then programmatically invoke the radio button's callback
    method.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证默认的`labelFrameText`之后，我们以编程方式将单选按钮设置为索引1，然后以编程方式调用单选按钮的回调方法。
- en: '[PRE39]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is basically the same action as clicking the radio button in the GUI but
    we do this button click event via code in the unit tests.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与在GUI中单击单选按钮相同，但我们是通过代码在单元测试中进行按钮单击事件。
- en: Then we verify that our text in the `labelframe` widget has changed as intended.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们验证`labelframe`小部件中的文本是否按预期更改了。
- en: When we run the unit tests from within Eclipse with the Python PyDev plugin,
    we get the following output written to the Eclipse console.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Eclipse中使用Python PyDev插件运行单元测试时，我们会得到以下输出写入Eclipse控制台。
- en: '![How to do it...](graphics/B04829_08_40.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_08_40.jpg)'
- en: Run from a command prompt, we get similar output once we navigate to the folder
    where our code currently resides.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令提示符运行时，一旦我们导航到当前代码所在的文件夹，我们会得到类似的输出。
- en: '![How to do it...](graphics/B04829_08_41.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_08_41.jpg)'
- en: Using Eclipse, we can also choose to run our unit tests, not as a simple Python
    script, but as a Python unit test script, which gives us some colorful output
    instead of the black and white world of the old DOS prompt.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eclipse，我们还可以选择运行我们的单元测试，不是作为简单的Python脚本，而是作为Python单元测试脚本，这样我们就可以得到一些丰富多彩的输出，而不是旧的DOS提示符的黑白世界。
- en: '![How to do it...](graphics/B04829_08_42.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_08_42.jpg)'
- en: 'The unit testing result bar is green, which means that all our unit tests have
    passed. The preceding screenshot also shows that the GUI test runner is much slower
    than the textual test runner: 1.01 seconds compared to 0.466 seconds in Eclipse.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试结果栏是绿色的，这意味着我们所有的单元测试都通过了。前面的截图还显示，GUI测试运行器比文本测试运行器慢得多：在Eclipse中为1.01秒，而文本测试运行器为0.466秒。
- en: How it works...
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We have extended our unit testing code by testing `labels`, programmatically
    invoking a `Radiobutton` and then verifying in our unit tests that the corresponding
    `text` property of the `labelframe` widget has changed as expected. We have tested
    two different languages.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过测试`labels`来扩展我们的单元测试代码，通过编程调用`Radiobutton`，然后在单元测试中验证`labelframe`小部件的相应`text`属性是否按预期更改。我们已经测试了两种不同的语言。
- en: We then moved on to use the built-in Eclipse/PyDev graphical unit test runner.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始使用内置的Eclipse/PyDev图形化单元测试运行器。
