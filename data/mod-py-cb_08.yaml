- en: Chapter 8. Functional and Reactive Programming Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。功能和反应式编程特性
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下食谱：
- en: Writing generator functions with the yield statement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用yield语句编写生成器函数
- en: Using stacked generator expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆叠的生成器表达式
- en: Applying transformations to a collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将转换应用于集合
- en: Picking a subset – three ways to filter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择子集-三种过滤方式
- en: Summarizing a collection – how to reduce
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结集合-如何减少
- en: Combining map and reduce transformations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合映射和减少转换
- en: Implementing "there exists" processing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现“存在”处理
- en: Creating a partial function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建部分函数
- en: Simplifying complex algorithms with immutable data structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变数据结构简化复杂算法
- en: Writing recursive generator functions with the yield from statement
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用yield from语句编写递归生成器函数
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The idea of **functional programming** is to focus on writing small, expressive
    functions that perform the required data transformations. Combining functions
    can often create code which is more succinct and expressive than long strings
    of procedural statements or the methods of complex, stateful objects. Python allows
    all three kinds of programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**的理念是专注于编写执行所需数据转换的小型、表达力强的函数。组合函数通常可以创建比长串过程语句或复杂、有状态对象的方法更简洁和表达力更强的代码。Python允许这三种编程方式。'
- en: 'Conventional mathematics defines many things as functions. Multiple functions
    are combined to build up a complex result from previous transformations. For example,
    we might have two functions, *f(x)* and *g(y)* , that need to be combined to create
    a useful result:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统数学将许多东西定义为函数。多个函数组合起来，从先前的转换中构建出复杂的结果。例如，我们可能有两个函数*f(x)*和*g(y)*，需要组合起来创建一个有用的结果：
- en: '*y = f(x)*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = f(x)*'
- en: '*z = g(y)*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = g(y)*'
- en: 'Ideally, we can create a composite function from these two functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们可以从这两个函数创建一个复合函数：
- en: '*z* = ( *g* ∘ *f* )( *x* )'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*z* = (*g* ∘ *f*)(*x*)'
- en: Using a composite function, ( *g* ∘ *f* ), can help to clarify how a program
    works. It allows us to take a number of small details and combine them into a
    larger knowledge chunk.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复合函数（*g* ∘ *f*）可以帮助澄清程序的工作方式。它允许我们将许多小细节组合成更大的知识块。
- en: Since programming often works with collections of data, we'll often be applying
    a function to a whole collection. This fits nicely with the mathematical idea
    of a **set builder** or **set comprehension** .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编程经常涉及数据集合，我们经常会将函数应用于整个集合。这与数学中的**集合构建器**或**集合理解**的概念非常契合。
- en: 'There are three common patterns for applying one function to a set of data:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见的模式可以将一个函数应用于一组数据：
- en: '**Mapping** : This applies a function to all elements of a collection { *M*
    ( *x* ): *x* ∈ *C* }. We apply some function, *M* , to each item, *x* , of a larger
    collection, *C* .'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：这将一个函数应用于集合中的所有元素{*M*(*x*): *x*∈*C*}。我们将一些函数*M*应用于较大集合*C*的每个项目*x*。'
- en: '**Filtering** : This uses a function to select elements from a collection.
    { *x* : *c* ∈ *C* **if** *F* ( *x* )}. We use a function, *F* , to determine whether
    to pass or reject an item, *x* , from a larger collection, *C* .'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：这使用一个函数从集合中选择元素。{*x*：*c*∈*C* **if** *F*(*x*)}。我们使用一个函数*F*来确定是否从较大的集合*C*中传递或拒绝项目*x*。'
- en: '**Reducing** : This summarizes a collection. The details vary, but one of the
    most common reductions is creating a sum of all items, *x* , in a collection,
    *C* : ![Introduction](Image00017.jpg)  .'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少**：这是对集合进行总结。细节各异，但最常见的减少之一是创建集合*C*中所有项目*x*的总和：![Introduction](Image00017.jpg)。'
- en: We'll often combine these patterns to create more complex applications. What's
    important here is that small functions, such as *M(x)* and *F(x)* , are combined
    via higher-order functions such as mapping and filtering. The combined operation
    can be sophisticated even though the individual pieces are quite simple.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将这些模式结合起来创建更复杂的应用程序。这里重要的是小函数，如*M(x)*和*F(x)*，通过映射和过滤等高阶函数进行组合。即使各个部分非常简单，组合操作也可以变得复杂。
- en: The idea of **reactive programming** is to have processing rules that are evaluated
    when the inputs become available or change. This fits with the idea of lazy programming.
    When we define lazy properties of a class definition, we've created reactive programs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应式编程**的理念是在输入可用或更改时评估处理规则。这符合惰性编程的理念。当我们定义类定义的惰性属性时，我们创建了反应式程序。'
- en: Reactive programming fits with functional programming because there may be multiple
    transformations required to react to a change in the input values. Often, this
    is most clearly expressed as functions that are combined or stacked into a composite
    function that responds to change. See the *Using properties for lazy attributes*
    recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , for some examples of reactive class design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程与函数式编程契合，因为可能需要多个转换来对输入值的变化做出反应。通常，这最清晰地表达为组合或堆叠成响应变化的复合函数。在[第6章](text00070.html#page
    "第6章。类和对象的基础")*类和对象的基础*中查看*使用惰性属性*食谱，了解一些反应式类设计的示例。
- en: Writing generator functions with the yield statement
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用yield语句编写生成器函数
- en: Most of the recipes we've looked at have been designed to work with all of the
    items in a single collection. The approach has been to use a `for` statement to
    step through each item within the collection, either mapping the value to a new
    item, or reducing the collection to some kind of summary value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看过的大多数食谱都是为了与单个集合中的所有项目一起使用而设计的。这种方法是使用`for`语句来遍历集合中的每个项目，要么将值映射到新项目，要么将集合减少到某种摘要值。
- en: Producing a single result from a collection is one of two ways to work with
    a collection. The alternative is to produce incremental results instead of a single
    result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合中产生单个结果是处理集合的两种方式之一。另一种方式是产生增量结果，而不是单个结果。
- en: This approach is very helpful in the cases where we can't fit an entire collection
    in memory. For example, analyzing gigantic web log files is best done in small
    doses rather than by creating an in-memory collection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在我们无法将整个集合放入内存的情况下非常有帮助。例如，分析庞大的网络日志文件最好是分批进行，而不是创建一个内存集合。
- en: Is there some way to disentangle the collection structure from the processing
    function? Can we yield results from processing as soon as each individual item
    is available?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有办法将集合结构与处理函数分离？我们是否可以在每个单独的项目可用时立即产生处理结果？
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll look at some web log data that has date-time string values. We need to
    parse these to create proper `datetime` objects. To keep things focused in this
    recipe, we'll use a simplified log produced by Flask.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一些具有日期时间字符串值的网络日志数据。我们需要解析这些数据以创建适当的`datetime`对象。为了保持本食谱的重点，我们将使用Flask生成的简化日志。
- en: 'The entries start out as lines of text that look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 条目最初是这样的文本行：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve seen other examples of working with this kind of log in the *Using more
    complex structures – maps of lists* recipe in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* . Using
    REs from the *String parsing with regular expressions* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") ,  *Numbers, Strings, and Tuples* ,
    we can decompose each line to look like the following collection of rows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在[第7章](text00079.html#page "Chapter 7. More Advanced Class Design")的*使用更复杂的结构——列表的映射*食谱中处理这种日志的其他示例，*更高级的类设计*。使用[第1章](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples")的*使用正则表达式进行字符串解析*食谱中的REs，*数字、字符串和元组*，我们可以将每行分解为以下行集合：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can't use ordinary string parsing to convert the complex date-time stamp
    into something more useful. We can, however, write a generator function which
    can process each row of the log, producing a more useful intermediate data structure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用普通的字符串解析将复杂的日期时间戳转换为更有用的形式。但是，我们可以编写一个生成器函数，它可以处理日志的每一行，产生一个更有用的中间数据结构。
- en: A generator function is a function that uses a `yield` statement. When a function
    has a yield, it builds the results incrementally, yielding each individual value
    in a way that can be consumed by a client. The consumer might be a `for` statement
    or it might be another function that needs a sequence of values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是使用`yield`语句的函数。当一个函数有一个yield时，它会逐渐构建结果，以一种可以被客户端消耗的方式产生每个单独的值。消费者可能是一个`for`语句，也可能是另一个需要一系列值的函数。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This requires the `datetime` module:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这需要`datetime`模块：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define a function that processes a source collection:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个处理源集合的函数：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've included the suffix `_iter` as a reminder that this function will be an
    iterable object, not a simple collection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在后缀`_iter`中包含了这个函数将是一个可迭代对象而不是一个简单集合的提醒。
- en: 'Include a `for` statement that visits each item in the source collection:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括一个`for`语句，访问源集合中的每个项目：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The body of the `for` statement can map the item to a new item:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`语句的主体可以将项目映射到一个新项目：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, we mapped a single field from string to `datetime` object. The
    variable `date` is built from the string in `item[0]` .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将一个字段从字符串映射到`datetime`对象。变量`date`是从`item[0]`中的字符串构建的。
- en: Then we mapped the log message three-tuple to a new tuple, replacing the date
    string with the proper `datetime` object. Since the value of the item is a tuple,
    we created a singleton tuple with `(date,)` and then concatenated this with the
    `item[1:]` tuple.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将日志消息的三元组映射到一个新的元组，用正确的`datetime`对象替换日期字符串。由于项目的值是一个元组，我们创建了一个带有`(date,)`的单例元组，然后将其与`item[1:]`元组连接起来。
- en: 'Yield the new item with a `yield` statement:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`yield`语句产生新项目：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The whole construct looks like this, properly indented:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 整个结构看起来是这样的，正确缩进：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `parse_date_iter()` function expects an iterable input object. A collection
    is an example of an iterable object. More importantly, though, other generators
    are also iterable. We can leverage this to build stacks of generators which process
    data from other generators.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_date_iter()`函数期望一个可迭代的输入对象。集合是可迭代对象的一个例子。然而更重要的是，其他生成器也是可迭代的。我们可以利用这一点构建处理来自其他生成器的数据的生成器堆栈。'
- en: This function doesn't create a collection. It yields each item, so that the
    items can be processed individually. The source collection is consumed in small
    pieces, allowing huge amounts of data to be processed. In some recipes, the data
    will start out from an in-memory collection. In later recipes, we'll work with
    data from external files—processing external files benefits the most from this
    technique.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不会创建一个集合。它会产生每个项目，以便可以单独处理这些项目。源集合会被分成小块进行处理，从而可以处理大量的数据。在一些示例中，数据将从内存集合开始。在后续的示例中，我们将处理来自外部文件的数据——处理外部文件最能从这种技术中获益。
- en: 'Here''s how we can use this function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用这个函数的方法：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've used a `for` statement to iterate through the results of the `parse_date_iter()`
    function, one item at a time. We've used the `pprint()` function to display each
    item.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`语句遍历`parse_date_iter()`函数的结果，一次处理一个项目。我们使用`pprint()`函数显示每个项目。
- en: 'We could also collect the items into a proper list using something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用类似这样的方法将项目收集到一个适当的列表中：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the `list()` function consumes all of the items produced by
    the `parse_date_iter()` function. It's essential to use a function such as `list()`
    or a `for` statement to consume all of the items from the generator. A generator
    is a relatively passive construct - until data is demanded, it doesn't do any
    work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`list()`函数消耗了`parse_date_iter()`函数产生的所有项目。使用`list()`或`for`语句来消耗生成器中的所有项目是至关重要的。生成器是一个相对被动的结构——直到需要数据时，它不会做任何工作。
- en: 'If we don''t actively consume the data, we''ll see something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不主动消耗数据，我们会看到类似这样的情况：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value of the `parse_date_iter()` function is a generator. It's not a collection
    of items, but a function that will produce items on demand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_date_iter()`函数的值是一个生成器。它不是一个项目的集合，而是一个能够按需生成项目的函数。'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Writing generator functions can change the way we perceive an algorithm. There
    are two common patterns: mappings and reductions. A mapping transforms each item
    to a new item, perhaps computing some derived value. A reduction accumulates a
    summary such as a sum, mean, variance, or hash from the source collection. These
    can be decomposed into the item-by-item transformation or filter, separate from
    the overall loop that handles the collection.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编写生成器函数可以改变我们对算法的理解方式。有两种常见的模式：映射和归约。映射将每个项目转换为一个新项目，可能计算一些派生值。归约从源集合中累积一个摘要，比如总和、平均值、方差或哈希。这些可以分解为逐项转换或过滤，与处理集合的整体循环分开。
- en: Python has a sophisticated construct called an **iterator** which lies at the
    heart of generators and collections. An iterator will provide each value from
    a collection while doing all of the internal bookkeeping required to maintain
    the state of the process. A generator function behaves like an iterator - it provides
    a sequence of values and maintains its own internal state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个复杂的构造叫做**迭代器**，它是生成器和集合的核心。迭代器会从集合中提供每个值，同时进行所有必要的内部记录以维护进程的状态。生成器函数的行为就像一个迭代器-它提供一系列的值并维护自己的内部状态。
- en: 'Consider the following common piece of Python code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面这段常见的Python代码：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Behind the scenes, something like the following is going on:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，类似以下的事情正在发生：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Python evaluates the `iter()` function on a collection to create an iterator
    object for that collection. The iterator is bound to the collection and maintains
    some internal state information. The code uses `next()` on the iterator to get
    each value. When there are no more values, the iterator raises the `StopIteration`
    exception.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python对集合上的`iter()`函数进行评估，以创建该集合的迭代器对象。迭代器绑定到集合并维护一些内部状态信息。代码在迭代器上使用`next()`来获取每个值。当没有更多的值时，迭代器会引发`StopIteration`异常。
- en: Each of Python's collections can produce an iterator. The iterator produced
    by a `Sequence` or `Set` will visit each item in the collection. The iterator
    produced by a `Mapping` will visit each key for the mapping. We can use the `values()`
    method of a mapping to iterate over the values instead of the keys. We can use
    the `items()` method of a mapping to visit a sequence of `(key, value)` two-tuples.
    The iterator for a `file` will visit each line in the file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python的每个集合都可以产生一个迭代器。`Sequence`或`Set`产生的迭代器会访问集合中的每个项。`Mapping`产生的迭代器会访问映射的每个键。我们可以使用映射的`values()`方法来迭代值而不是键。我们可以使用映射的`items()`方法来访问一个`(key,
    value)`两元组的序列。`file`的迭代器会访问文件中的每一行。
- en: The iterator concept can also be applied to functions. A function with a `yield`
    statement is called a **generator function** . It fits the template for an iterator.
    To do this, the generator returns itself in response to the `iter()` function.
    In response to the `next()` function, it yields the next value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的概念也可以应用到函数上。带有`yield`语句的函数被称为**生成器函数**。它符合迭代器的模板。为了实现这一点，生成器在响应`iter()`函数时返回自身。在响应`next()`函数时，它会产生下一个值。
- en: When we apply `list()` to a collection or a generator function, the same essential
    mechanism used by the `for` statement gets the individual values. The `iter()`
    and `next()` functions are used by `list()` to get the items. The items are then
    turned into a sequence.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对集合或生成器函数应用`list()`时，与`for`语句使用的相同的基本机制会得到各个值。`iter()`和`next()`函数被`list()`用来获取这些项。然后这些项被转换成一个序列。
- en: Evaluating `next()` on a generator function is interesting. The generator function
    is evaluated until it reaches a `yield` statement. This value is the result of
    `next()` . Each time `next()` is evaluated, the function resumes processing after
    the `yield` statement and continues to the next `yield` statement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 评估生成器函数的`next()`是有趣的。生成器函数会被评估，直到它达到一个`yield`语句。这个值就是`next()`的结果。每次评估`next()`时，函数会在`yield`语句之后恢复处理，并继续到下一个`yield`语句。
- en: 'Here''s a small function which yields two objects:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个产生两个对象的小函数：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s what happens when we evaluate `next()` . On the generator this function
    produces:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`next()`函数时会发生什么。在生成器上，这个函数会产生：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first time we evaluated `next()` , the first `print()` function was evaluated,
    then the `yield` statement produced a value. The function's processing was suspended
    and the `>>>` prompt was given. The second time we evaluated the `next()` function,
    the statements between the two `yield` statements were evaluated. The function
    was again suspended and a `>>>` prompt will be displayed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次评估`next()`时，第一个`print()`函数被评估，然后`yield`语句产生一个值。函数的处理被暂停，然后出现`>>>`提示符。第二次评估`next()`函数时，两个`yield`语句之间的语句被评估。函数再次被暂停，然后会显示一个`>>>`提示符。
- en: 'What happens next? We''re out of `yield` statements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么？我们已经没有`yield`语句了：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `StopIteration` exception is raised at the end of a generator function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成器函数的末尾会引发`StopIteration`异常。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The core value of generator functions comes from being able to break complex
    processing into two parts:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的核心价值在于能够将复杂的处理分解为两部分：
- en: The transformation or filter to apply
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要应用的转换或过滤
- en: The source set of data with which to work
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要处理的源数据集
- en: Here's an example of using a generator to filter data. In this case, we'll filter
    the input values and keep only the prime numbers, rejecting all composite numbers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用生成器来过滤数据的一个例子。在这种情况下，我们将过滤输入值，只保留质数，拒绝所有合数。
- en: 'We can write the processing out as a Python function like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将处理写成一个Python函数，像这样：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For each value in the source, we''ll evaluate the `prime()` function. If the
    result is `true` , we''ll yield the source value. If the result is `false` , the
    source value will be rejected. We can use `primeset()` like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于源中的每个值，我们将评估`prime()`函数。如果结果为`true`，我们将产生源值。如果结果为`false`，源值将被拒绝。我们可以像这样使用`primeset()`：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `primeset()` function will yield individual prime values from a source collection.
    The source collection will be the integers in the range of 2 to 2 million. The
    result is a `set` object built from the values provided.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`primeset()`函数将从源集合中产生单个素数值。源集合将是范围在2到200万之间的整数。结果是从提供的值构建的`set`对象。'
- en: All that's missing from this is the `prime()` function to determine whether
    a number is prime. We'll leave that as an exercise for the reader.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一缺少的是`prime()`函数，用于确定一个数字是否为素数。我们将把这留给读者作为练习。
- en: Mathematically, it's common to see *set builder* or *set comprehension* notation
    to specify a rule for building one set from another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，常见的是使用*集合生成器*或*集合推导*符号来指定从另一个集合构建一个集合的规则。
- en: 'We might see something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会看到类似这样的东西：
- en: '*P[10]* = { *i* : *i* ∈ *ℕ* ∧ 2 ≤ 1 < 2,000,000 **if** *P* ( *i* )}'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*P[10]* = {*i*：*i* ∈ *ℕ* ∧ 2 ≤ 1 < 2,000,000 **if** *P*（*i*）}'
- en: This tells us that *P[10]* is the set of all numbers, *i* , in the set of natural
    numbers, *ℕ* , and between 2 and 2 million if *P(i)* is `true` . This defines
    a rule for building a set.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们*P[10]*是所有数字*i*的集合，在自然数集*ℕ*中，并且在2到200万之间，如果*P(i)*为`true`。这定义了一个构建集合的规则。
- en: 'We can write this in Python too:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用Python写出这个：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is Python notation for the subset of prime numbers. The clauses are rearranged
    slightly from the mathematical abstraction, but all of the same essential parts
    of the expression are present.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是素数子集的Python表示。从数学抽象中略微重新排列了子句，但表达式的所有基本部分都存在。
- en: 'When we start looking at generator expressions like this, we can see that a
    great deal of programming fits some common overall patterns:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始看这样的生成器表达式时，我们会发现很多编程都符合一些常见的整体模式：
- en: '**Map** : { *m* ( *x* ): *x* ∈ *S* } becomes `(m(x) for x in S)` .'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Map**：*m*（*x*）：*x* ∈ *S*变为`(m(x) for x in S)`。'
- en: '**Filter** : { *x* : *x* ∈ *S* **if** *f* ( *x* )} becomes `(x for x in S if
    f(x))` .'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Filter**：*x*：*x* ∈ *S* **if** *f*（*x*）变为`(x for x in S if f(x))`。'
- en: '**Reduce** : This is a bit more complex, but common reductions include sums
    and counts. ![There''s more...](Image00018.jpg)  is `sum(x for x in S)` . Other
    common reductions include finding the maximum or the minimum of a set of data.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reduce**：这有点复杂，但常见的缩减包括求和和计数。![更多内容...](Image00018.jpg)是`sum(x for x in S)`。其他常见的缩减包括查找一组数据的最大值或最小值。'
- en: 'We can also write these various higher-level functions using the `yield` statement.
    Here''s the definition of a generic mapping:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`yield`语句编写这些不同的高级函数。以下是通用映射的定义：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function applies some other function, `m()` , to each data element in the
    source collection, `S` . The result of the mapping function is yielded as a sequence
    of result values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将某个其他函数`m()`应用于源集合`S`中的每个数据元素。映射函数的结果作为结果值的序列被产生。
- en: 'We can write a similar definition for a generic `filter` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为通用的`filter`函数编写类似的定义：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As with the generic mapping, we apply a function, `f()` , to each element in
    the source collection, `S` . Where the function is `true` , the values are yielded.
    Where the function is `false` , the values are rejected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与通用映射一样，我们将函数`f()`应用于源集合`S`中的每个元素。函数为`true`的地方，值被产生。函数为`false`的地方，值被拒绝。
- en: 'We can use this to create a set of primes like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它来创建一个素数集：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will apply the `prime()` function to the source range of data. Note that
    we write just `prime` —without `()` characters—because we're naming the function,
    not evaluating it. Each individual value will be checked by the `prime()` function.
    Those that pass will be yielded to be assembled into the final set. Those values
    which are composite will be rejected and won't wind up in the final set.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用`prime()`函数到数据源范围。请注意，我们只写`prime`，不带`()`字符，因为我们是在命名函数，而不是在评估它。每个单独的值将由`prime()`函数检查。通过的值将被产生以组装成最终集合。那些是合数的值将被拒绝，不会出现在最终集合中。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Using stacked generator expressions* recipe, we'll combine generator
    functions to build complex processing stacks from simple components.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*的示例中，我们将结合生成器函数，从简单组件构建复杂的处理堆栈。
- en: In the *Applying transformations to a collection* recipe, we'll see how the
    built-in `map()` function can be used to create complex processing from a simple
    function and an iterable source of data.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*对集合应用转换*的示例中，我们将看到内置的`map()`函数如何被用于从简单函数和可迭代的数据源创建复杂的处理。
- en: In the *Picking a subset – three ways to filter* recipe, we'll see how the built-in
    `filter()` function can also be used to build complex processing from a simple
    function and an iterable source of data.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*选择子集-三种过滤方式*的示例中，我们将看到内置的`filter()`函数也可以用于从简单函数和可迭代的数据源构建复杂的处理。
- en: See [https://projecteuler.net/problem=10](https://projecteuler.net/problem=10)
    for a challenging problem related to prime numbers less than 2 million. Parts
    of the problem seem obvious. It can be difficult, however, to test all of those
    numbers for being prime.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关小于200万的素数的具有挑战性的问题，请参阅[https://projecteuler.net/problem=10](https://projecteuler.net/problem=10)。问题的部分似乎是显而易见的。然而，测试所有这些数字是否为素数可能很困难。
- en: Using stacked generator expressions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用堆叠的生成器表达式
- en: In the *Writing generator functions with the yield statement* recipe, we created
    a simple generator function that performed a single transformation on a piece
    of data. As a practical matter, we often have several functions that we'd like
    to apply to incoming data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用yield语句编写生成器函数*的示例中，我们创建了一个简单的生成器函数，对数据进行了单一的转换。实际上，我们经常有几个函数，我们希望将其应用于传入的数据。
- en: How can we *stack* or combine multiple generator functions to create a composite
    function?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何*堆叠*或组合多个生成器函数以创建一个复合函数？
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大帆船燃油消耗的电子表格。它的行看起来像这样：
- en: '| **date** | **engine on** | **fuel height** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **启动引擎** | **燃油高度** |'
- en: '|  | **engine off** | **fuel height** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  | **关闭引擎** | **燃油高度** |'
- en: '|  | **Other notes** |  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  | **其他说明** |  |'
- en: '| 10/25/2013 | 08:24 | 29 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 10/25/2013 | 08:24 | 29 |'
- en: '|  | 13:15 | 27 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  | 13:15 | 27 |'
- en: '|  | calm seas - anchor solomon''s island |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  | 平静的海域 - 锚在所罗门岛 |  |'
- en: '| 10/26/2013 | 09:12 | 27 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 10/26/2013 | 09:12 | 27 |'
- en: '|  | 18:25 | 22 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  | 18:25 | 22 |'
- en: '|  | choppy - anchor in jackson''s creek |  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  | 波涛汹涌 - 锚在杰克逊溪 |  |'
- en: For more background on this data, see the *Slicing and dicing a list* recipe
    in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些数据的更多背景信息，请参阅[第4章](text00048.html#page "第4章 内置数据结构 - 列表、集合、字典")的*对列表进行切片和切块*，*内置数据结构
    - 列表、集合、字典*。
- en: 'As a sidebar, we can take the data like this. We''ll look at this in detail
    in the *Reading delimited files with the csv module* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* :'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个侧边栏，我们可以这样获取数据。我们将在[第9章](text00099.html#page "第9章 输入/输出、物理格式和逻辑布局")的*使用csv模块读取分隔文件*中详细讨论这个问题，*输入/输出、物理格式和逻辑布局*：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've used the `csv` module to read the log details. A `csv.reader()` is an
    iterable object. In order to collect the items into a single list, we applied
    the `list()` function to the generator function. We printed at the first and last
    item in the list to confirm that we really have a list-of-lists structure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`csv`模块来读取日志详情。`csv.reader()`是一个可迭代对象。为了将项目收集到一个单一列表中，我们对生成器函数应用了`list()`函数。我们打印了列表中的第一个和最后一个项目，以确认我们确实有一个列表的列表结构。
- en: 'We''d like to apply two transformations to this list-of-lists:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对这个列表的列表应用两个转换：
- en: Convert the date and two times into two date-time values
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日期和两个时间转换为两个日期时间值
- en: Merge three rows into one row so that we have a simple organization to the data
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将三行合并成一行，以便对数据进行简单的组织
- en: 'If we create a useful pair of generator functions, we can have software that
    looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一对有用的生成器函数，我们可以有这样的软件：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The combined generator functions, `date_conversion(row_merge(...))` , will yield
    a sequence of single rows with starting information, ending information, and notes.
    This structure can easily be summarized or analyzed to create simple statistical
    correlations and trends.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的生成器函数`date_conversion(row_merge(...))`将产生一系列单行，其中包含起始信息、结束信息和注释。这种结构可以很容易地总结或分析，以创建简单的统计相关性和趋势。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Define an initial reduce operation that combines rows. We have several ways
    to tackle this. One is to always group three rows together.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个初始的减少操作，将行组合在一起。我们有几种方法可以解决这个问题。一种方法是总是将三行组合在一起。
- en: 'An alternative is to note that column zero has data at the start of a group;
    it''s empty for the next two lines of a group. This gives us a slightly more general
    approach to creating groups of rows. This is a kind of **head-tail merge** algorithm.
    We''ll collect data and yield the data each time we get to the head of the next
    group:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是注意到第零列在组的开头有数据；在组的下两行为空。这给了我们一个稍微更一般的方法来创建行的组。这是一种**头尾合并**算法。我们将收集数据，并在到达下一个组的头部时每次产生数据：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This algorithm uses `len(row[0])` to determine whether this is the head of a
    group or a row in the tail of the group. In the case of a head row, any previous
    group is yielded. After that has been consumed, the value of the `group` collection
    is reset to be the column data from the head row.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法使用`len(row[0])`来确定这是一个组的头部还是组的尾部中的一行。在头部行的情况下，任何先前的组都会被产生。在那之后被消耗后，`group`集合的值将被重置为头部行的列数据。
- en: The rows in the tail of the group are simply appended to the `group` collection.
    When the data is exhausted, there will—generally—be one final group in the `group`
    variable. If there's no data at all, then the final value of `group` will also
    be a zero-length list, which should be ignored.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 组的尾部行简单地附加到`group`集合上。当数据耗尽时，`group`变量中通常会有一个最终组。如果根本没有数据，那么`group`的最终值也将是一个长度为零的列表，应该被忽略。
- en: We'll address the `copy()` method later. It's essential because we're working
    with a list of lists data structure and lists are mutable objects. We can write
    processing which changes the data structures, making some processing awkward to
    explain.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会讨论`copy()`方法。这是必不可少的，因为我们正在处理一个列表的列表数据结构，而列表是可变对象。我们可以编写处理改变数据结构的处理，使得一些处理难以解释。
- en: 'Define the various mapping operations that will be performed on the merged
    data. These apply to the data in the original row. We''ll use separate functions
    to convert each of the two time columns and merge the times with the date column:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将在合并后的数据上执行的各种映射操作。这些应用于原始行中的数据。我们将使用单独的函数来转换两个时间列，并将时间与日期列合并：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll combine the date in column zero with the time in column one to create
    a starting `datetime` object. Similarly, we'll combine the date in column zero
    with the time in column four to create an ending `datetime` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把第零列中的日期与第一列中的时间结合起来，创建一个起始`datetime`对象。同样，我们将把第零列中的日期与第四列中的时间结合起来，创建一个结束`datetime`对象。
- en: These two functions have a lot of overlaps and could be refactored into a single
    function with the column number as an argument value. For now, however, our goal
    is to write something that simply works. Refactoring for efficiency can come later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数有很多重叠之处，可以重构为一个带有列号作为参数值的单个函数。然而，目前我们的目标是编写一些简单有效的东西。效率的重构可以稍后进行。
- en: 'Define mapping operations that apply to the derived data. Columns eight and
    nine contain the date-time stamps:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义适用于派生数据的映射操作。第八和第九列包含日期时间戳：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've used the values created by `start_datetime` and `end_datetime` as inputs.
    We've computed the delta time, which provides a result in seconds. We converted
    seconds to hours, which is a more useful unit of time for this set of data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`start_datetime`和`end_datetime`创建的值作为输入。我们计算了时间差，这提供了以秒为单位的结果。我们将秒转换为小时，这是这组数据更有用的时间单位。
- en: 'Fold in any filters required to reject or exclude bad data. In this case, we
    have a header row that must be excluded:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并任何需要拒绝或排除坏数据的过滤器。在这种情况下，我们必须排除一个标题行：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function will reject any row that has `date` in the first column. The `continue`
    statement resumes the `for` statement, skipping all other statements in the body;
    it skips the `yield` statement. All other rows will be passed through this process.
    The input is an iterable and this generator will yield rows that have not been
    transformed in any way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将拒绝任何第一列中有`date`的行。`continue`语句恢复`for`语句，跳过体中的所有其他语句；它跳过`yield`语句。所有其他行将通过这个过程。输入是一个可迭代对象，这个生成器将产生没有以任何方式转换的行。
- en: 'Combine the operations. We can either write a sequence of generator expressions
    or use the built-in `map()` function. Here''s how it might look using generator
    expressions:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将操作组合起来。我们可以编写一系列生成器表达式，也可以使用内置的`map()`函数。以下是使用生成器表达式的示例：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This operation consists of a series of transformations. Each one does a small
    transformation on one value from the original collection of data. It''s relatively
    simple to add operations or change operations, since each one is defined independently:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作由一系列转换组成。每个转换对原始数据集中的一个值进行小的转换。添加或更改操作相对简单，因为每个操作都是独立定义的：
- en: The `tail_gen` generator yields rows after skipping the first row of the source
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tail_gen`生成器在跳过源的第一行后产生行'
- en: The `start_gen` generator appends a `datetime` object to the end of each row
    with the start time built from strings into source columns
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_gen`生成器将一个`datetime`对象附加到每一行的末尾，起始时间是从字符串构建到源列中的'
- en: The `end_gen` generator appends a `datetime` object to each row that has the
    end time built from strings
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_gen`生成器将一个`datetime`对象附加到每一行的末尾，结束时间是从字符串构建到源列中的'
- en: The `duration_gen` generator appends a `float` object with the duration of the
    leg
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duration_gen`生成器将一个`float`对象附加到每个腿的持续时间'
- en: The output from this overall `date_conversion()` function is a generator. It
    can be consumed with a `for` statement or a `list` can be built from the items.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 整体`date_conversion()`函数的输出是一个生成器。可以使用`for`语句消耗它，也可以从项目构建一个`list`。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we write a generator function, the argument value can be a collection,
    or it can be another kind of iterable. Since generator functions are iterables,
    it becomes possible to create a kind of *pipeline* of generator functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个生成器函数时，参数值可以是一个集合，也可以是另一种可迭代对象。由于生成器函数是可迭代的，因此可以创建一种生成器函数的*管道*。
- en: Each function can embody a small transformation that changes one feature of
    the input to create the output. We've then wrapped each of these small transformations
    in generator expressions. Because each transformation is reasonably well isolated
    from the others, we can make changes to one without breaking the entire processing
    pipeline.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数可以包含一个小的转换，改变输入的一个特征以创建输出。然后我们将每个小的转换包装在生成器表达式中。因为每个转换都相对独立于其他转换，所以我们可以对其中一个进行更改而不破坏整个处理流水线。
- en: 'The processing works incrementally. Each function is evaluated until it yields
    a single value. Consider this statement:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 处理是逐步进行的。每个函数都会被评估，直到产生一个单一的值。考虑这个陈述：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ve defined a composition of several generators. This composition uses a
    variety of techniques:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了几个生成器的组合。这个组合使用了各种技术：
- en: The `row_merge()` function is a generator which will yield rows of data. In
    order to yield one row, it will read four lines from the source, assemble a merged
    row, and yield it. Each time another row is required, it will read three more
    rows of input to assemble the output row.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row_merge()`函数是一个生成器，将产生数据行。为了产生一行，它将从源中读取四行，组装成一个合并的行，并产生它。每次需要另一行时，它将再读取三行输入来组装输出行。'
- en: The `date_conversion()` function is a complex generator built from multiple
    generators.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date_conversion()`函数是由多个生成器构建的复杂生成器。'
- en: '`skip_header_date()` is designed to yield a single value. Sometimes it will
    have to read two values from the source iterator. If an input row has `date` in
    column zero, the row is skipped. In that case, it will read the second value,
    getting another row from `row_merge()` ; which must, in turn, read three more
    lines of input to produce a merged line of output. We''ve assigned the generator
    to the `tail_gen` variable.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip_header_date()`旨在产生一个单一的值。有时它必须从源迭代器中读取两个值。如果输入行的第零列有`date`，则跳过该行。在这种情况下，它将读取第二个值，从`row_merge()`获取另一行；而`row_merge()`必须再读取三行输入来产生一个合并的输出行。我们将生成器分配给`tail_gen`变量。'
- en: The `start_gen` , `end_gen` , and `duration_gen` generator expressions will
    apply relatively simple functions such as `start_datetime()` and `end_datetime()`
    to each row of its input, yielding rows with more useful data.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_gen`、`end_gen`和`duration_gen`生成器表达式将对其输入的每一行应用相对简单的函数，例如`start_datetime()`和`end_datetime()`，产生具有更有用数据的行。'
- en: 'The final `for` statement shown in the example will be gathering values from
    the `date_conversion()` iterator by evaluating the `next()` function repeatedly.
    Here''s the step by step view of what will happen to create the needed result.
    Note that this works on a very small bit of data—each step makes one small change:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中显示的最终`for`语句将通过反复评估`next()`函数来从`date_conversion()`迭代器中收集值。以下是创建所需结果的逐步视图。请注意，这在一个非常小的数据量上运行——每个步骤都会做出一个小的改变：
- en: The `date_conversion()` function result was the `duration_gen` object. For this
    to return a value, it needs a row from its source, `end_gen` . Once it has the
    data, it can apply the `duration()` function and yield the row.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`date_conversion()` 函数的结果是 `duration_gen` 对象。为了返回一个值，它需要来自其源 `end_gen` 的一行。一旦有了数据，它就可以应用
    `duration()` 函数并产生该行。'
- en: The `end_gen` expression needs a row from its source, `start_gen` . It can then
    apply the `end_datetime()` function and yield the row.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_gen` 表达式需要来自其源 `start_gen` 的一行。然后它可以应用 `end_datetime()` 函数并产生该行。'
- en: The `start_gen` expression needs a row from its source, `tail_gen` . It can
    then apply the `start_datetime()` function and yield the row.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`start_gen` 表达式需要来自其源 `tail_gen` 的一行。然后它可以应用 `start_datetime()` 函数并产生该行。'
- en: The `tail_gen` expression is simply the generator `skip_header_date()` . This
    function will read as many rows as required from its source until it finds a row
    where column zero is not the column header `date` . It yields one non-date row.
    The source for this is the output from the `row_merge()` function.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tail_gen` 表达式只是生成器 `skip_header_date()` 。这个函数将从其源中读取所需的行，直到找到一行，其中第零列不是列标题
    `date`。它产生一个非日期行。其源是 `row_merge()` 函数的输出。'
- en: The `row_merge()` function will read multiple rows from its source until it
    can assemble a collection of rows that fits the required pattern. It will yield
    a combined row that has some text in column zero, followed by rows that have no
    text in column zero. The source for this is a list-of-lists collection of the
    raw data.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`row_merge()` 函数将从其源中读取多行，直到可以组装符合所需模式的行集合。它将产生一个组合行，该行在第零列中有一些文本，后面是没有文本的行。其源是原始数据的列表集合。'
- en: The collection of rows will be processed by a `for` statement inside the `row_merge()`
    function. This processing will implicitly create an iterator for the collection
    so that each individual row is yielded as needed by the body of the `row_merge()`
    function.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行集合将由 `row_merge()` 函数内的 `for` 语句处理。这个处理将隐式地为集合创建一个迭代器，以便 `row_merge()` 函数的主体根据需要产生每个单独的行。
- en: Each individual row of data will pass through this pipeline of steps. Some stages
    of the pipeline will consume multiple source rows for a single result row, restructuring
    the data as it is processed. Other stages consume a single value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的每个单独行将通过这些步骤的管道。管道的某些阶段将消耗多个源行以产生单个结果行，重组数据。其他阶段消耗单个值。
- en: This example relies on concatenating items into a long sequence of values. Items
    are identified by position. A small change to the order of the stages in the pipeline
    will alter the positions of the items. There are a number of ways to improve on
    this that we'll look at next.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子依赖于将项目连接成一个长序列的值。项目由位置标识。对管道中阶段顺序的小改动将改变项目的位置。有许多方法可以改进这一点，我们将在接下来看一下。
- en: What's central to this is that only individual rows are being processed. If
    the source is a gigantic collection of data, the processing can proceed very quickly.
    This technique allows a small Python program to process vast volumes of data quickly
    and simply.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个核心是只处理单独的行。如果源是一个庞大的数据集合，处理可以非常快速。这种技术允许一个小的Python程序快速而简单地处理大量的数据。
- en: There's more...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In effect, a set of interrelated generators is a kind of composite function.
    We might have several functions, defined separately like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一组相互关联的生成器是一种复合函数。我们可能有几个函数，像这样分别定义：
- en: '*y = f(x)*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = f(x)*'
- en: '*z = g(y)*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = g(y)*'
- en: 'We can combine them by applying the results of the first function to the second
    function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将第一个函数的结果应用到第二个函数来将它们组合起来：
- en: '*z = g(f(x))*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = g(f(x))*'
- en: This can become awkward as the number of functions grows. When we use this pair
    of functions in multiple places, we break the **Don't Repeat Yourself** ( **DRY**
    ) principle. Having multiple copies of this complex expression isn't ideal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 随着函数数量的增加，这可能变得笨拙。当我们在多个地方使用这对函数时，我们违反了**不要重复自己**（**DRY**）原则。拥有多个这种复杂表达式的副本并不理想。
- en: 'What we''d like to have is a way to create a composite function—something like
    this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一种方法来创建一个复合函数——类似于这样：
- en: '*z* = ( *g* ∘ *f* )( *x* )'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*z* = ( *g* ∘ *f* )( *x* )'
- en: Here, we've defined a new function, ( *g* ∘ *f* ), that combines the two original
    functions into a new, single, composite function. We can now modify this composite
    to add or change features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新函数（*g* ∘ *f*），将两个原始函数组合成一个新的、单一的复合函数。我们现在可以修改这个复合函数以添加或更改功能。
- en: This concept drives the definition of the composite `date_conversion()` function.
    This function is composed of a number of functions, each of which can be applied
    to items of collections. If we need to make changes, we can easily write more
    simple functions and drop them into the pipeline defined by the `date_conversion()`
    function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念推动了复合 `date_conversion()` 函数的定义。这个函数由许多函数组成，每个函数都可以应用于集合的项。如果我们需要进行更改，我们可以轻松地编写更多简单的函数并将它们放入
    `date_conversion()` 函数定义的管道中。
- en: We can see some slight differences among the functions in the pipeline. We have
    some type conversions. However, the duration calculation isn't really a type conversion.
    It's a separate computation that's based on the results of the date conversions.
    If we want to compute fuel use per hour, we'd need to add several more calculations.
    None of these additional summaries is properly part of date conversion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到管道中的函数之间存在一些细微差异。我们有一些类型转换。然而，持续时间计算并不真正是一种类型转换。它是一种基于日期转换结果的独立计算。如果我们想要计算每小时的燃料使用量，我们需要添加几个计算。这些额外的摘要都不是日期转换的正确部分。
- en: We should really break the high-level `data_conversion()` into two parts. We
    should write another function that does duration and fuel use calculations, named
    `fuel_use()` . This other function can then wrap `date_conversion()` .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的应该将高级 `data_conversion()` 分成两部分。我们应该编写另一个函数来进行持续时间和燃料使用计算，命名为 `fuel_use()`。然后这个其他函数可以包装
    `date_conversion()`。
- en: 'We might aim for something like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会朝着这样的目标努力：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now have a very sophisticated computation that's defined in a number of very
    small and (almost) completely independent chunks. We can modify one piece without
    having to think deeply about how the other pieces work.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常复杂的计算，它由许多非常小的（几乎）完全独立的部分定义。我们可以修改一个部分而不必深入思考其他部分的工作方式。
- en: Namespace instead of list
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间而不是列表
- en: An important change is to stop avoiding the use of a simple list for the data
    values. Doing computations on `row[10]` is a potential disaster in the making.
    We should properly convert the input data into some kind of namespace.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的改变是停止避免使用简单的列表来存储数据值。对`row[10]`进行计算可能是一场潜在的灾难。我们应该适当地将输入数据转换为某种命名空间。
- en: A `namedtuple` can be used. We'll look at that in the *Simplifying complex algorithms
    with immutable data structures* recipe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`namedtuple`。我们将在*Simplifying complex algorithms with immutable data structures*食谱中看到。
- en: A `SimpleNamespace` can, in some ways, further simplify this processing. A `SimpleNamespace`
    is a mutable object, and can be updated. It's not always the best idea to mutate
    an object. It has the advantage of being simple, but it can also be slightly more
    difficult to write tests for state changes in mutable objects.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，`SimpleNamespace`可以进一步简化这个处理过程。`SimpleNamespace`是一个可变对象，可以被更新。改变对象并不总是一个好主意。它的优点是简单，但对于可变对象的状态变化编写测试可能会稍微困难一些。
- en: 'A function such as `make_namespace()` can provide a set of names instead of
    positions. This is a generator that must be used after the rows are merged, but
    before any of the other processing:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`make_namespace()`这样的函数可以提供一组名称而不是位置。这是一个必须在行合并后但在任何其他处理之前使用的生成器：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will produce an object that allows us to write `row.date` instead of `row[0]`
    . This, of course, will change the definitions for the other functions, including
    `start_datetime()` , `end_datetime()` , and `duration()` .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个允许我们写`row.date`而不是`row[0]`的对象。当然，这将改变其他函数的定义，包括`start_datetime()`、`end_datetime()`和`duration()`。
- en: 'Each of these functions can emit a new `SimpleNamespace` object instead of
    updating the list of values that represents each row. We can then write functions
    that look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都可以发出一个新的`SimpleNamespace`对象，而不是更新表示每一行的值列表。然后我们可以编写以下样式的函数：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of processing a row as a `list` object, this function processes a row
    as a `SimpleNamespace` object. The columns have clear and meaningful names such
    as `row_ns.end_timestamp` instead of the cryptic `row[10]` .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数处理行作为`SimpleNamespace`对象，而不是`list`对象。列具有清晰而有意义的名称，如`row_ns.end_timestamp`，而不是晦涩的`row[10]`。
- en: 'There''s a three-part process to building a new `SimpleNamespace` from an old
    namespace:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 构建新的`SimpleNamespace`的三部曲如下：
- en: Use the `vars()` function to extract the dictionary inside the `SimpleNamespace`
    instance.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vars()`函数提取`SimpleNamespace`实例内部的字典。
- en: Use the `**vars(row_ns)` object to build a new namespace based on the old namespace.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`**vars(row_ns)`对象基于旧命名空间构建一个新的命名空间。
- en: Any additional keyword parameters such as `travel_hours = travel_hours` provides
    additional values that will load the new object.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何额外的关键字参数，如`travel_hours = travel_hours`，都提供了将加载新对象的额外值。
- en: 'The alternative is to update the namespace and return the updated object:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是更新命名空间并返回更新后的对象：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This has the advantage of being slightly simpler. The disadvantage is the small
    consideration that stateful objects can sometimes be confusing. When modifying
    an algorithm, it's possible to fail to set attributes in the proper order so that
    lazy (or reactive) programming operates properly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的优点是稍微简单。缺点是有时会让有状态的对象变得混乱。在修改算法时，可能会失败地按正确顺序设置属性，以便懒惰（或反应性）编程能够正常运行。
- en: While stateful objects are common, they should always be viewed as one of two
    alternatives. An immutable `namedtuple` might be a better choice than a mutable
    `SimpleNamespace` .
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有状态的对象很常见，但它们应该始终被视为两种选择之一。不可变的`namedtuple`可能比可变的`SimpleNamespace`更好。
- en: See also
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Writing generator functions with the yield statement* recipe for an
    introduction to generator functions
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Writing generator functions with the yield statement*食谱中，我们介绍了生成器函数
- en: See the *Slicing and dicing a list* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , for more information on the fuel consumption dataset
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构 - 列表、集合、字典")的*Slicing and dicing a list*食谱中，了解有关燃料消耗数据集的更多信息
- en: See the *Combining map and reduce transformations* recipe for another way to
    combine operations
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Combining map and reduce transformations*食谱中，还有另一种组合操作的方法
- en: Applying transformations to a collection
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对集合应用转换
- en: 'In the *Writing generator functions with the yield statement* recipe, we looked
    at writing a generator function. The examples we saw combined two elements: a
    transformation and a source of data. They generally look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Writing generator functions with the yield statement*食谱中，我们看到了编写生成器函数的例子。我们看到的例子结合了两个元素：转换和数据源。它们通常看起来像这样：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This template for writing a generator function isn't a requirement. It's merely
    a common pattern. There's a transformation process buried inside a `for` statement.
    The `for` statement is largely boilerplate code. We can refactor this to make
    the transformation function explicit and separate from the `for` statement.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编写生成器函数的这个模板并不是必需的。它只是一个常见的模式。在`for`语句中隐藏了一个转换过程。`for`语句在很大程度上是样板代码。我们可以重构这个代码，使转换函数明确且与`for`语句分离。
- en: In the *Using stacked generator expressions* recipe, we defined a `start_datetime()`
    function which computed a new `datetime` object from the string values in two
    separate columns of the source collection of data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Using stacked generator expressions*食谱中，我们定义了一个`start_datetime()`函数，它从数据源集合的两个单独列中的字符串值计算出一个新的`datetime`对象。
- en: 'We could use this function in a generator function''s body like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在生成器函数的主体中使用这个函数，就像这样：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function applies the `start_datetime()` function to each item in a source
    of data, `tail_gen` . Each resulting row is yielded so that another function or
    a `for` statement can consume it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将`start_datetime()`函数应用于数据源`tail_gen`中的每个项目。每个生成的行都被产生，以便另一个函数或`for`语句可以消耗它。
- en: 'In the *Using stacked generator expressions* recipe, we looked at another way
    to apply these transformation functions to a larger collection of data. In this
    example, we used a generator expression. The code looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*的示例中，我们看了另一种将这些转换函数应用于更大的数据集的方法。在这个例子中，我们使用了一个生成器表达式。代码看起来像这样：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This applies the `start_datetime()` function to each item in a source of data,
    `tail_gen` . Another function or `for` statement can consume the values available
    in the `start_gen` iterable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`start_datetime()`函数应用于数据源`tail_gen`中的每个项目。另一个函数或`for`语句可以消耗`start_gen`可迭代中可用的值。
- en: 'Both the complete generator function and the shorter generator expression are
    essentially the same thing with slightly different syntax. Both of these are parallel
    to the mathematical notion of a *set builder* or *set comprehension* . We could
    describe this operation mathematically as:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的生成器函数和较短的生成器表达式本质上是相同的，只是语法略有不同。这两者都与数学上的*集合构建器*或*集合推导*的概念相似。我们可以用数学方式描述这个操作：
- en: '*s* = [ *S* ( *r* ): *r* ∈ *T* ]'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*s* = [ *S* ( *r* ): *r* ∈ *T* ]'
- en: In this expression, *S* is the `start_datetime()` function and *T* is the sequence
    of values called `tail_gen` . The resulting sequence is the value of *S(r)* ,
    where each value for *r* is an element of the set *T* .
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，*S*是`start_datetime()`函数，*T*是称为`tail_gen`的值序列。结果序列是*S(r)*的值，其中*r*的每个值是集合*T*的一个元素。
- en: Both generator functions and generator expressions have similar boilerplate
    code. Can we simplify these?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数和生成器表达式都有类似的样板代码。我们能简化这些吗？
- en: Getting ready...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了...
- en: We'll look at the web log data from the *Writing generator functions with the
    yield statement* recipe. This had `date` as a string that we would like to transform
    into a proper timestamp.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看*使用带有yield语句的生成器函数*示例中的web日志数据。这里有一个`date`作为一个字符串，我们想要将其转换为一个合适的时间戳。
- en: 'Here''s the example data:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例数据：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can write a function like this to transform the data:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个这样的函数来转换数据：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function will examine each item in the source using a `for` statement.
    The value in column zero is a `date` string, which can be transformed into a proper
    `datetime` object. A new item, `new_item` , is built from the `datetime` object
    and the remaining items starting with column one.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将使用`for`语句检查源中的每个项目。第零列的值是一个`date`字符串，可以转换为一个合适的`datetime`对象。从`datetime`对象和从第一列开始的剩余项目构建一个新项目`new_item`。
- en: 'Because the function uses the `yield` statement to produce results, it''s a
    generator function. We use it with a `for` statement like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数使用`yield`语句产生结果，所以它是一个生成器函数。我们可以像这样使用它与`for`语句：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This statement will gather each value as it's produced by the generator function
    and print two of the selected values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句将收集生成器函数产生的每个值，并打印两个选定的值。
- en: 'The `parse_date_iter()` function has two essential elements combined into a
    single function. The outline looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_date_iter()`函数将两个基本元素合并到一个函数中。大纲看起来像这样：'
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `for` and `yield` statements are largely boilerplate code. The `transformation()`
    function is a really useful and interesting part of this.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`和`yield`语句在很大程度上是样板代码。`transformation()`函数是这个非常有用和有趣的部分。'
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Write the transformation function that applies to a single row of the data.
    This is not a generator, and doesn''t use the `yield` statement. It simply revises
    a single item from a collection:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写应用于数据单行的转换函数。这不是一个生成器，也不使用`yield`语句。它只是修改集合中的单个项目：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This can be used in three ways: statements, expressions, and the `map()` function.
    Here''s the explicit `for...yield` pattern of statements:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用三种方式：语句、表达式和`map()`函数。这是语句的显式`for...yield`模式：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This uses a `for` statement to process each item in the collection using the
    isolated `parse_date()` function. The second choice is a generator expression
    that looks like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个`for`语句来使用孤立的`parse_date()`函数处理集合中的每个项目。第二个选择是一个生成器表达式，看起来像这样：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is a generator expression that applies the `parse_date()` function to each
    item. The third choice is the `map()` function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器表达式，将`parse_date()`函数应用于每个项目。第三个选择是`map()`函数。
- en: Use the `map()` function to apply the transformation to the source data.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map()`函数将转换应用于源数据。
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We provide the name of the function, `parse_date` , without any `()` after the
    name. We aren't applying the function at this time. We're providing the name of
    the object to the `map()` function to apply the `parse_date()` function to the
    iterable source of data, `data` .
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供函数名`parse_date`，在名称后面没有任何`()`。我们此时不应用函数。我们提供对象名给`map()`函数，以将`parse_date()`函数应用于可迭代的数据源`data`。
- en: 'We can use this as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `map()` function creates an iterable object that applies the `parse_date()`
    function to each item in the data iterable. It yields each individual item. It
    saves us from having to write a generator expression or a generator function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数创建一个可迭代对象，将`parse_date()`函数应用于数据可迭代中的每个项目。它产生每个单独的项目。它使我们不必编写生成器表达式或生成器函数。'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `map()` function replaces some common boilerplate code. We can imagine
    that the definition looks something like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数替换了一些常见的样板代码。我们可以想象定义看起来像这样：'
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or, we can imagine that it looks like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以想象它看起来像这样：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Both of these definitions summarize the core feature of the `map()` function.
    It's handy shorthand that eliminates some boilerplate code for applying a function
    to an iterable source of data.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义总结了`map()`函数的核心特性。它是一个方便的简写，可以消除一些样板代码，用于将函数应用于可迭代的数据源。
- en: There's more...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we've used the `map()` function to apply a function that takes
    a single parameter to each individual item of a single iterable. It turns out
    that the `map()` function can do a bit more than this.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`map()`函数来将一个接受单个参数的函数应用到单个可迭代对象的每个项目上。原来`map()`函数可以做的事情比这更多。
- en: 'Consider this function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And these two sources of data:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 还有这两个数据来源：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can apply the `mul()` function to pairs drawn from each source of data:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`mul()`函数应用于从每个数据源中提取的对：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This allows us to merge two sequences of values using different kinds of operators.
    We can, for example, build a mapping that behaves like the built-in `zip()` function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用不同类型的运算符合并两个值序列。例如，我们可以构建一个行为类似于内置的`zip()`函数的映射。
- en: 'Here''s a mapping:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个映射：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We needed to define a small helper function, `bundle()` , that takes any number
    of arguments, and creates a tuple out of them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个小的辅助函数，`bundle()`，它接受任意数量的参数，并将它们创建为一个元组。
- en: 'Here''s the `zip` function for comparison:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`zip`函数进行比较：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: See also...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: In the *Using stacked generator expressions* recipe, we looked at stacked generators.
    We built a composite function from a number of individual mapping operations written
    as generator functions. We also included a single filter in the stack.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*示例中，我们研究了堆叠生成器。我们从许多单独的映射操作中构建了一个复合函数，这些操作被编写为生成器函数。我们还在堆栈中包含了一个单一的过滤器。
- en: Picking a subset - three ways to filter
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择子集-三种过滤方式
- en: 'In the *Using stacked generator expressions* recipe, we wrote a generator function
    that excluded some rows from a set of data. We defined a function like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*示例中，我们编写了一个生成器函数，它从一组数据中排除了一些行。我们定义了这样一个函数：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the condition is `true` —`row[0]` is `date` —the `continue` statement will
    skip the rest of the statements in the body of the `for` statement. In this case,
    there's only a single statement, `yield row` .
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件为`true`——`row[0]`是`date`——`continue`语句将跳过`for`语句体中的其余语句。在这种情况下，只有一个语句`yield
    row`。
- en: 'There are two conditions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个条件：
- en: '`row[0] == ''date''` : The `yield` statement is skipped; the row is rejected
    from further processing'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row[0] == ''date''`：`yield`语句被跳过；该行被拒绝进一步处理'
- en: '`row[0] != ''date''` : The `yield` statement means that the row will be passed
    on to the function or statement that''s consuming the data'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row[0] != ''date''`：`yield`语句意味着该行将被传递给消耗数据的函数或语句'
- en: At four lines of code, this seems long-winded. The `for...if...yield` pattern
    is clearly boilerplate, and only the condition is really material in this kind
    of construct.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在四行代码中，这似乎有点冗长。`for...if...yield`模式显然是样板文件，只有条件在这种结构中才是真正的材料。
- en: Can we express this more succinctly?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更简洁地表达这个吗？
- en: Getting ready...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好...
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大帆船燃料消耗的电子表格。它的行看起来像这样：
- en: '| **date** | **engine on** | **fuel height** |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **引擎开启** | **燃料高度** |'
- en: '|  | **engine off** | **fuel height** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  | **关闭引擎** | **燃料高度** |'
- en: '|  | **Other notes** |  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  | **其他说明** |  |'
- en: '| 10/25/2013 | 08:24 | 29 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 10/25/2013 | 08:24 | 29 |'
- en: '|  | 13:15 | 27 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  | 13:15 | 27 |'
- en: '|  | calm seas - anchor solomon''s island |  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  | 平静的海域 - 锚定所罗门岛 |  |'
- en: '| 10/26/2013 | 09:12 | 27 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 10/26/2013 | 09:12 | 27 |'
- en: '|  | 18:25 | 22 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|  | 18:25 | 22 |'
- en: '|  | choppy - anchor in jackson''s creek |  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  | 波涛汹涌 - 锚定在杰克逊溪 |  |'
- en: For more background on this data, see the *Slicing and dicing a list* recipe.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些数据的更多背景信息，请参阅*切片和切块列表*示例。
- en: 'In the *Using stacked generator expressions* recipe, we defined two functions
    to reorganize this data. The first combined each three-row group into a single
    row with a total of eight columns of data:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*示例中，我们定义了两个函数来重新组织这些数据。第一个将每个三行组合并为一个具有八列数据的单行：
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is a variation on the **head-tail** algorithm. When `len(row[0]) != 0`
    , this is the header row for a new group—any previously complete group is yielded,
    and then the working value of the `group` variable is reset to a fresh, new list
    based on this header row. A `copy()` is made so that we can avoid mutating the
    list object later on. When `len(row[0]) == 0` , this is the tail of the group;
    the row is appended to the working value of the `group` variable. At the end of
    the source of data, there's generally a complete group that needs to be processed.
    There's an edge case where there's no data at all; in which case, there's no final
    group to yield, either.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**头尾**算法的变体。当`len(row[0]) != 0`时，这是一个新组的标题行——任何先前完整的组都会被产生，然后`group`变量的工作值将根据这个标题行重置为一个新的、包含此标题行的列表。进行`copy()`操作，以便我们以后可以避免对列表对象进行变异。当`len(row[0])
    == 0`时，这是组的尾部；该行被附加到`group`变量的工作值上。在数据源的末尾，通常有一个需要处理的完整组。有一个边缘情况，即根本没有数据；在这种情况下，也没有最终的组需要产生。
- en: 'We can use this function to transform the data from many confusing rows to
    single rows of useful information:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数将数据从许多令人困惑的行转换为有用信息的单行：
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We see that the first row is just the spreadsheet headers. We'd like to skip
    this row. We'll create a generator expression to handle the filtering and reject
    this extra row.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到第一行只是电子表格的标题。我们想跳过这一行。我们将创建一个生成器表达式来处理过滤，并拒绝这一额外的行。
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Write the predicate function that tests an item to see whether it should be
    passed through the filter for further processing. In some cases, we''ll have to
    start with a reject rule and then write the inverse to make it into a pass rule:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写谓词函数，测试一个项目是否应该通过过滤器进行进一步处理。在某些情况下，我们将不得不从拒绝规则开始，然后编写反向规则，使其成为通过规则：
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This can be used in three ways: statements, expressions, and the `filter()`
    function. Here is an example of an explicit `for...if...yield` pattern of statements
    for passing rows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用三种方式来使用：语句、表达式和`filter()`函数。这是一个显式的`for...if...yield`模式的语句示例，用于传递行：
- en: '[PRE57]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This uses a `for` statement to process each item in the collection using the
    filter function. Selected items are yielded. Other items are rejected.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用一个`for`语句来使用过滤函数处理集合中的每个项目。选择的项目被产生。其他项目被拒绝。
- en: 'The second way to use this function is in a generator expression like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数的第二种方式是在生成器表达式中使用它：
- en: '[PRE58]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This generator expressions applies the `filter` function, `pass_non_date()`
    , to each item. The third choice is the `filter()` function.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式应用了`filter`函数`pass_non_date()`到每个项目。第三种选择是`filter()`函数。
- en: 'Use the `filter()` function to apply the function to the source data:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter()`函数将函数应用于源数据：
- en: '[PRE59]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We've provided the name of the function, `pass_non_date` . We don't use `()`
    characters after the function name because this expression doesn't evaluate the
    function. The `filter()` function will apply the given function to the iterable
    source of data, `data` . In this case, `data` is a collection, but it can be any
    iterable, including the results of a previous generator expression. Each item
    for which the `pass_non_date()` function is `true` will be passed by the filter;
    all other values are rejected.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了函数名`pass_non_date`。我们在函数名后面不使用`()`字符，因为这个表达式不会评估函数。`filter()`函数将给定的函数应用于可迭代的数据源`data`。在这种情况下，`data`是一个集合，但它可以是任何可迭代的对象，包括以前生成器表达式的结果。`pass_non_date()`函数为`true`的每个项目将被过滤器传递；所有其他值都被拒绝。
- en: 'We can use this as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `filter()` function creates an iterable object that applies the `pass_non_date()`
    function as a rule to pass or reject each item in the `row_merge(data)` iterable.
    It yields the rows that don't have `date` in column zero.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数创建一个可迭代对象，将`pass_non_date()`函数作为规则应用于`row_merge(data)`可迭代对象中的每个项目，它产生了在第零列中没有`date`的行。'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `filter()` function replaces some common boilerplate code. We can imagine
    that the definition looks something like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数替换了一些常见的样板代码。我们可以想象定义看起来像这样：'
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Or, we can imagine that it looks like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以想象它看起来像这样：
- en: '[PRE62]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Both of these definitions summarize the core feature of the `filter()` function:
    some data is passed and some data is rejected. This is a handy shorthand that
    eliminates some boilerplate code for applying a function to an iterable source
    of data.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义总结了`filter()`函数的核心特性：一些数据被传递，一些数据被拒绝。这是一个方便的简写，消除了一些应用函数到可迭代数据源的样板代码。
- en: There's more...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Sometimes it''s difficult to write a simple rule to pass data. It may be clearer
    if we write a rule to reject data. For example, this might make more sense:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候很难编写一个简单的规则来传递数据。如果我们编写一个拒绝数据的规则，可能会更清晰。例如，这可能更有意义：
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can use a reject rule in a number of ways. Here''s a `for...if...continue...yield`
    pattern of statements. This will use continue to skip the rejected rows, and yield
    the remaining rows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式使用拒绝规则。这是一个`for...if...continue...yield`语句的模式。这将使用continue跳过被拒绝的行，并产生剩下的行：
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can also use this variation. For some programmers, the not reject concept
    can become confusing. It might seem like a double negative:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这种变体。对于一些程序员来说，不拒绝的概念可能会变得令人困惑。这可能看起来像一个双重否定：
- en: '[PRE65]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can also use a generator expression like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用类似这样的生成器表达式：
- en: '[PRE66]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We can't, however, easily use the `filter()` function with a rule that's designed
    to reject data. The `filter()` function is designed to work with pass rules only.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能轻松地使用`filter()`函数来拒绝数据的规则。`filter()`函数只能用于传递规则。
- en: 'We have two essential choices for dealing with this kind of logic. We can wrap
    the logic in another expression, or we use a function from the `itertools` module.
    When it comes to wrapping, we have two further choices. We can wrap a reject function
    to create a pass function from it. We can use something like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在处理这种逻辑时有两种基本选择。我们可以将逻辑包装在另一个表达式中，或者使用`itertools`模块中的函数。当涉及到包装时，我们还有两种选择。我们可以包装一个拒绝函数以创建一个传递函数。我们可以使用类似这样的东西：
- en: '[PRE67]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This makes it possible to create a simple reject rule and use it in the `filter()`
    function. Another way to wrap the logic is to create a `lambda` object:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以创建一个简单的拒绝规则，并在`filter()`函数中使用它。包装逻辑的另一种方法是创建一个`lambda`对象：
- en: '[PRE68]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `lambda` function is a small, anonymous function. It''s a function that''s
    been reduced to just two elements: the parameter list and a single expression.
    We''ve wrapped the `reject_date()` function to create a kind of `not_reject_date`
    function via the `lambda` object.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`函数是一个小的匿名函数。它是一个被简化为只有两个元素的函数：参数列表和一个单一的表达式。我们用`lambda`对象包装了`reject_date()`函数，以创建一种`not_reject_date`函数。'
- en: In the `itertools` module, we use the `filterfalse()` function. We can import
    `filterfalse()` and use this instead of the built-in `filter()` function.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在`itertools`模块中，我们使用`filterfalse()`函数。我们可以导入`filterfalse()`并使用它来代替内置的`filter()`函数。
- en: See also...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: In the *Using stacked generator expressions* recipe, we placed a function like
    this in a stack of generators. We built a composite function from a number of
    individual mapping and filtering operations written as generator functions.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*配方中，我们将这样的函数放在一堆生成器中。我们从许多单独的映射和过滤操作中构建了一个复合函数，这些操作被编写为生成器函数。
- en: Summarizing a collection – how to reduce
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结一个集合-如何减少
- en: 'In the introduction to this chapter, we noted that there are three common processing
    patterns: map, filter, and reduce. We''ve seen examples of mapping in the *Applying
    transformations to a collection* recipe, and examples of filtering in the *Picking
    a subset – three ways to filter* recipe. It''s relatively easy to see how these
    become very generic operations.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，我们注意到有三种常见的处理模式：映射、过滤和减少。我们在*将变换应用到集合*配方中看到了映射的例子，在*挑选子集-三种过滤方式*配方中看到了过滤的例子。很容易看出这些是如何变得非常通用的。
- en: 'Mapping applies a simple function to all elements of a collection. { *M* (
    *x* ): *x* ∈ *C* } applies a function, *M* , to each item, *x* , of a larger collection,
    *C* . In Python, it can look like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '映射将一个简单的函数应用于集合的所有元素。{*M*(*x*): *x* ∈ *C*}将函数*M*应用于较大集合*C*的每个项目*x*。在Python中，它可以看起来像这样：'
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Or, we can use the built-in `map()` function to remove the boilerplate and
    simplify it to this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用内置的`map()`函数来消除样板代码，并简化为这样：
- en: '[PRE70]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Similarly, filtering uses a function to select elements from a collection. {
    *x* : *x* ∈ *C* **if** *F* ( *x* )} uses a function, *F* , to determine whether
    to pass or reject an item, *x* , from a larger collection, *C* . We can express
    this in a variety of ways in Python, one of which is like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '类似地，过滤使用一个函数从集合中选择元素。{*x*: *x* ∈ *C* **if** *F*(*x*)}使用函数*F*来确定是否传递或拒绝来自较大集合*C*的项目*x*。我们可以用各种方式在Python中表达这一点，其中之一就像这样：'
- en: '[PRE71]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This applies a predicate function, `F()` , to a collection, `c` .
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个谓词函数`F()`应用于集合`c`。
- en: 'The third common pattern is reduction. In the *Designing classes with lots
    of processing* and *Extending a collection: a list that does statistics* recipes,
    we looked at class definitions that computed a number of statistical values. These
    definitions relied—almost exclusively—on the built-in `sum()` function. This is
    one of the more common reductions.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种常见的模式是缩减。在*设计具有大量处理的类*和*扩展集合：执行统计的列表*的示例中，我们看到了计算许多统计值的类定义。这些定义几乎完全依赖于内置的`sum()`函数。这是比较常见的缩减之一。
- en: Can we generalize summation in a way that allows us to write a number of different
    kinds of reductions? How can we define the concept of reduction in a more general
    way?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将求和概括为一种允许我们编写多种不同类型的缩减的方式？我们如何以更一般的方式定义缩减的概念？
- en: Getting ready
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: One of the most common reductions is the sum. Other reductions include a product,
    minimum, maximum, average, variance, and even a simple count of values.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的缩减之一是求和。其他缩减包括乘积、最小值、最大值、平均值、方差，甚至是简单的值计数。
- en: 'Here''s a way to think of the mathematical definition of the sum function,
    +, applied to values in a collection, *C* :'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种将数学定义的求和函数+应用于集合*C*中的值的方式：
- en: '![Getting ready](Image00019.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00019.jpg)'
- en: We've expanded the definition of sum by inserting the + operator into the sequence
    of values, *C = c[0] , c[1] , c[2] , ..., c[n]* . This idea of *folding* in the
    + operator captures the meaning of the built-in `sum()` function.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在值序列*C=c[0], c[1], c[2], ..., c[n]*中插入+运算符来扩展了求和的定义。这种在+运算符中进行*fold*的想法捕捉了内置的`sum()`函数的含义。
- en: 'Similarly, the definition of product looks like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，乘积的定义如下：
- en: '![Getting ready](Image00020.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00020.jpg)'
- en: 'Here, too, we''ve performed a different *fold* on a sequence of values. Expanding
    a reduction by folding involves two items: a binary operator and a base value.
    For sum, the operator was + and the base value is zero. For product, the operator
    is × and the base value is one.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对一系列值进行了不同的*fold*。通过fold扩展缩减涉及两个项目：一个二元运算符和一个基本值。对于求和，运算符是+，基本值是零。对于乘积，运算符是×，基本值是一。
- en: 'We could define a generic higher-level function, *F* [(⋄, ⊥)] , that captures
    the ideal of a fold. The fold function definition includes a placeholder for an
    operator, ⋄, and a placeholder for a base value, ⊥. The function''s value for
    a given collection, *C* , can be defined with this recursive rule:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个通用的高级函数*F*[(⋄, ⊥)]，它捕捉了fold的理想。fold函数定义包括一个运算符⋄的占位符和一个基本值⊥的占位符。给定集合*C*的函数值可以用这个递归规则来定义：
- en: '![Getting ready](Image00021.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00021.jpg)'
- en: If the collection, *C* , is empty, the value is the base value, ⊥. When defining
    `sum()` , the base value would be zero. If *C* is not empty, then we'll first
    compute the fold of everything but the last value in the collection, F[◊, ⊥] (C[0
    *..n* -1] ). Then we'll apply the operator—for example, addition—between the previous
    fold result and the final value in the collection, *C[n-]* [1] . For `sum()` ,
    the operator is +.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合*C*为空，则值为基本值⊥。当定义`sum()`时，基本值将为零。如果*C*不为空，则我们首先计算集合中除最后一个值之外的所有值的fold，F[◊,
    ⊥](C[0*..n*-1])。然后我们将运算符（例如加法）应用于前一个fold结果和集合中的最后一个值*C[n-]*[1]。对于`sum()`，运算符是+。
- en: 'We''ve used the notation *C* [0.. *n*] in the Pythonic sense of an open-ended
    range. The values at indices 0 to *n-* 1 are included, but the value of index
    *n* is not included. This means that *C* [0..0] = ∅: there are no elements in
    this range *C[0..0]* .'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在Pythonic意义上使用了*C*[0..*n*]的符号。包括索引0到*n*-1的值，但不包括索引*n*的值。这意味着*C*[0..0]=∅：这个范围*C[0..0]*中没有元素。 '
- en: This definition is called a **fold left** operation because the net effect of
    this definition is to perform the underlying operations from left to right in
    the collection. This could be changed to also define a **fold right** operation.
    Since Python's `reduce()` function is a fold left, we'll stick with that.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义被称为**fold left**操作，因为这个定义的净效果是在集合中从左到右执行基础操作。这可以改为定义一个**fold right**操作。由于Python的`reduce()`函数是一个fold
    left，我们将坚持使用它。
- en: 'We''ll define a `prod()` function that can be used to compute factorial values:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`prod()`函数，用于计算阶乘值：
- en: '![Getting ready](Image00022.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00022.jpg)'
- en: The value of *n* factorial is the product of all of the numbers between 1 and
    *n* inclusive. Since Python uses half-open ranges, it's a little more Pythonic
    to use or define a range using *1* ≤ *x* < *n* + *1* . This definition fits the
    built-in `range()` function better.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*的阶乘的值是1到*n*之间所有数字的乘积。由于Python使用半开区间，使用*1* ≤ *x* < *n* + *1*来定义范围更符合Python的风格。这个定义更适合内置的`range()`函数。'
- en: 'Using the fold operator that we defined earlier, we have this. We''ve defined
    a fold (or reduce) using an operator of multiplication, *, and a base value of
    one:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前定义的fold操作符，我们有这个。我们使用乘法*的操作符和基本值为1来定义了一个fold（或者reduce）：
- en: '![Getting ready](Image00023.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](Image00023.jpg)'
- en: The idea of folding is the generic concept that underlies Python's concept of
    `reduce()` . We can apply this to many algorithms, potentially simplifying the
    definition.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠的概念是Python的`reduce()`概念的通用概念。我们可以将这应用于许多算法，可能简化定义。
- en: How to do it...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `reduce()` function from the `functools` module:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`functools`模块导入`reduce()`函数：
- en: '[PRE72]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Pick the operator. For sum, it''s `+` . For product, it''s `*` . These can
    be defined in a variety of ways. Here''s the long version. Other ways to define
    the necessary binary operator will be shown later:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择运算符。对于求和，是`+`。对于乘积，是`*`。这些可以以多种方式定义。这是长版本。其他定义必要的二进制运算符的方法将在后面展示：
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Pick the base value required. For sum, it''s zero. For product, it''s one.
    This allows us to define a `prod()` function that computes a generic product:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的基值。对于求和，它是零。对于乘积，它是一。这使我们能够定义一个计算通用乘积的`prod()`函数：
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For factorial, we need to define the sequence of values that will be reduced:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于阶乘，我们需要定义将被减少的数值序列：
- en: '[PRE75]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here''s how this works with the `prod()` function:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`prod()`函数的工作原理：
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here''s the whole factorial function:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个阶乘函数：
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here''s the number of ways that a 52-card deck can be arranged. This is the
    value *52!* :'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一副52张牌的排列方式。这是值*52!*：
- en: '[PRE78]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: There are a lot of a ways a deck can be shuffled.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 一副牌可以被洗牌的方式有很多种。
- en: 'How many 5-card hands are possible? The binomial calculation uses factorial:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少种5张牌的可能手牌？二项式计算使用阶乘：
- en: '![How to do it...](Image00024.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](Image00024.jpg)'
- en: '[PRE79]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: For any given shuffle, there are about 2.6 million different possible poker
    hands. (And yes, this is a terribly inefficient way to compute the binomial.)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的洗牌，大约有260万种不同的可能扑克手牌。（是的，这是一种计算二项式的非常低效的方法。）
- en: How it works...
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `reduce()` function behaves as though it had this definition:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`函数的行为就好像它有这个定义：'
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This will iterate through the values from left to right. It will apply the given
    binary function between the previous set of values and the next item from the
    iterable collection.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从左到右迭代数值。它将在可迭代集合中的前一组数值和下一个项目之间应用给定的二进制函数。
- en: When we look at the *Recursive functions and Python's stack limits* recipe,
    we can see that the recursive definition of fold can be optimized to this `for`
    statement.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看*递归函数和Python的堆栈限制*这个教程时，我们可以看到fold的递归定义可以优化为这个`for`语句。
- en: There's more...
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When designing a `reduce()` function, we need to provide a binary operator.
    There are three ways to define the necessary binary operator. We used a complete
    function definition like this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计`reduce()`函数时，我们需要提供一个二进制运算符。有三种方法来定义必要的二进制运算符。我们使用了一个完整的函数定义，如下所示：
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'There are two other choices. We can use a `lambda` object instead of a complete
    function:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个选择。我们可以使用`lambda`对象而不是完整的函数：
- en: '[PRE82]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A `lambda` function is an anonymous function boiled down to just two essential
    elements: the parameters and the return expression. There are no statements inside
    a lambda, only a single expression. In this case, the expression simply uses the
    desired operator.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`函数是一个匿名函数，只包含两个基本元素：参数和返回表达式。lambda内部没有语句，只有一个表达式。在这种情况下，表达式只是使用所需的运算符。'
- en: 'We can use it like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它：
- en: '[PRE83]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This provides the multiplication function as a `lambda` object without the overhead
    of a separate function definition.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了乘法函数作为一个`lambda`对象，而不需要额外的函数定义开销。
- en: 'We can also import the definition from the `operator` module:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`operator`模块导入定义：
- en: '[PRE84]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This works nicely for all of the built-in arithmetic operators.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这对所有内置的算术运算符都适用。
- en: 'Note that logical reductions using the logic operators **AND** and **OR** are
    a little different from other arithmetic reductions. These operators short-circuit:
    once the value is `false` , an **and-reduce** can stop processing. Similarly,
    once the value is `True` , an **or-reduce** can stop processing. The built-in
    functions `any()` and `all()` embody this nicely. The short-circuit feature is
    difficult to capture using the built-in `reduce()` .'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用逻辑运算符**AND**和**OR**的逻辑归约与其他算术归约有所不同。这些运算符会短路：一旦值为`false`，**and-reduce**就可以停止处理。同样，一旦值为`True`，**or-reduce**就可以停止处理。内置函数`any()`和`all()`很好地体现了这一点。使用内置的`reduce()`很难捕捉到这种短路特性。
- en: Maxima and minima
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大值和最小值
- en: How can we use `reduce()` to compute a maximum or minimum? This is a little
    more complex because there's no trivial base value that can be used. We cannot
    start with zero or one because these values might be outside the range of values
    being minimized or maximized.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`reduce()`来计算最大值或最小值？这更复杂一些，因为没有可以使用的平凡基值。我们不能从零或一开始，因为这些值可能超出被最小化或最大化的值范围。
- en: Also, the built-in `max()` and `min()` must raise an exception for an empty
    sequence. These functions can't fit perfectly with the way the `sum()` function
    and `reduce()` functions work.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内置的`max()`和`min()`必须对空序列引发异常。这些函数无法完全适应`sum()`函数和`reduce()`函数的工作方式。
- en: 'We have to use something like this to provide the expected feature set:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用类似这样的东西来提供期望的功能集：
- en: '[PRE85]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This function will pick the first value from the sequence as a base value. It
    creates a `lambda` object, named `max_rule` , which selects the larger of the
    two argument values. We can then use this base value located in the data, and
    the `lambda` object. The `reduce()` function will then locate the largest value
    in a non-empty collection. We've captured the `IndexError` exception so that an
    empty collection will raise a `ValueError` exception.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将从序列中选择第一个值作为基值。它创建了一个名为`max_rule`的`lambda`对象，它选择两个参数值中较大的那个。然后我们可以使用数据中的这个基值和`lambda`对象。`reduce()`函数将在非空集合中找到最大的值。我们捕获了`IndexError`异常，以便一个空集合会引发`ValueError`异常。
- en: This example shows how we can invent a more complex or sophisticated minimum
    or maximum function that is still based on the built-in `reduce()` function. The
    advantage of this is replacing the boilerplate `for` statement when reducing a
    collection to a single value.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了我们如何发明一个更复杂或精密的最小值或最大值函数，它仍然基于内置的`reduce()`函数。这样做的好处是可以替换减少集合到单个值时的样板`for`语句。
- en: Potential for abuse
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滥用的潜力
- en: Note that a fold (or `reduce()` as it's called in Python) can be abused, leading
    to poor performance. We have to be cautious about simply using a `reduce()` function
    without thinking carefully about what the resulting algorithm might look like.
    In particular, the operator being folded into the collection should be a simple
    process such as adding or multiplying. Using `reduce()` changes the complexity
    of an **O** (1) operation into **O** ( *n* ).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，折叠（或在Python中称为`reduce()`）可能会被滥用，导致性能不佳。我们必须谨慎使用`reduce()`函数，仔细考虑最终算法可能是什么样子。特别是，被折叠到集合中的运算符应该是一个简单的过程，比如加法或乘法。使用`reduce()`会将**O**（1）操作的复杂性改变为**O**（*n*）。
- en: Imagine what would happen if the operator being applied during the reduction
    involved a sort over a collection. A complex operator—with **O** ( *n* log *n*
    ) complexity—being used in a `reduce()` would change the complexity of the overall
    `reduce()` to *O* ( *n²* log *n* ).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果在减少过程中应用的运算符涉及对集合进行排序会发生什么。在`reduce()`中使用复杂的运算符-具有**O**（*n* log *n*）复杂度-会将整体`reduce()`的复杂度改变为*O*（*n²*
    log *n*）。
- en: Combining map and reduce transformations
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合映射和减少转换
- en: 'In the other recipes in this chapter, we''ve been looking at map, filter, and
    reduce operations. We''ve looked at each of these in isolation:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其他配方中，我们一直在研究映射、过滤和减少操作。我们分别研究了这三个操作：
- en: The *Applying transformations to a collection* recipe shows the `map()` function
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对集合应用转换*配方显示`map()`函数'
- en: The *Picking a subset – three ways to filter* recipe shows the `filter()` function
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择子集-三种过滤方法*配方显示`filter()`函数'
- en: The *Summarizing a collection – how to reduce* recipe shows the `reduce()` function
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总结集合-如何减少*配方显示`reduce()`函数'
- en: 'Many algorithms will involve combinations of functions. We''ll often use mapping,
    filtering, and a reduction to produce a summary of available data. Additionally,
    we''ll need to look at a profound limitation of working with iterators and generator
    functions. Namely this limitation:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 许多算法将涉及函数的组合。我们经常使用映射、过滤和减少来生成可用数据的摘要。此外，我们需要看一下使用迭代器和生成器函数的一个深刻限制。即这个限制：
- en: Tip
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An iterator can only produce values once.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器只能产生一次值。
- en: If we create an iterator from a generator function and a collection data, the
    iterator will only produce the data one time. After that, it will appear to be
    an empty sequence.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从生成器函数和集合数据创建一个迭代器，那么迭代器只会产生数据一次。之后，它将看起来是一个空序列。
- en: 'Here''s an example:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE86]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We created an iterator over a sequence of values by manually applying the `iter()`
    function to a literal list object. The first time that the `sum()` function used
    the value of `typical_iterator` , it consumed all five values. The next time we
    tried to apply any function to the `typical_iterator` , there will be no more
    values to be consumed - the iterator appears empty.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过手动将`iter()`函数应用于文字列表对象来创建了一个值序列的迭代器。`sum()`函数第一次使用`typical_iterator`的值时，它消耗了所有五个值。下一次我们尝试将任何函数应用于`typical_iterator`时，将不会有更多的值被消耗-迭代器看起来是空的。
- en: This basic one-time-only restriction drives some of the design considerations
    when working with multiple kinds of generator functions in conjunction with map,
    filter, and reduce. We'll often need to cache intermediate results so that we
    can perform multiple reductions on the data.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本的一次性限制驱动了在使用多种类型的生成器函数与映射、过滤和减少一起工作时的一些设计考虑。我们经常需要缓存中间结果，以便我们可以对数据执行多次减少。
- en: Getting ready
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: In the *Using stacked generator expressions* recipe, we looked at data that
    required a number of processing steps. We merged rows with a generator function.
    We filtered some rows to remove them from the resulting data. Additionally, we
    applied a number of mappings to the data to convert dates and times to more useful
    information.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用堆叠的生成器表达式*配方中，我们研究了需要多个处理步骤的数据。我们使用生成器函数合并了行。我们过滤掉了一些行，将它们从结果数据中删除。此外，我们对数据应用了许多映射，将日期和时间转换为更有用的信息。
- en: We'd like to supplement this with two more reductions to get some average and
    variance information. These statistics will help us understand the data more fully.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要通过两次减少来补充这一点，以获得一些平均值和方差信息。这些统计数据将帮助我们更充分地理解数据。
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大帆船燃料消耗的电子表格。它的行看起来像这样：
- en: '| **date** | **engine on** | **fuel height** |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **引擎开启** | **燃料高度** |'
- en: '|  | **engine off** | **fuel height** |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|  | **关闭引擎** | **燃料高度** |'
- en: '|  | **Other notes** |  |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '|  | **其他说明** |  |'
- en: '| 10/25/2013 | 08:24 | 29 |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 10/25/2013 | 08:24 | 29 |'
- en: '|  | 13:15 | 27 |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|  | 13:15 | 27 |'
- en: '|  | calm seas - anchor solomon''s island |  |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '|  | 平静的海洋-锚所罗门岛 |  |'
- en: '| 10/26/2013 | 09:12 | 27 |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 10/26/2013 | 09:12 | 27 |'
- en: '|  | 18:25 | 22 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '|  | 18:25 | 22 |'
- en: '|  | choppy - anchor in jackson''s creek |  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|  | 波涛汹涌-锚在杰克逊溪 |  |'
- en: The initial processing was a sequence of operations to change the organization
    of the data, filter out the headings, and compute some useful values.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的处理是一系列操作，改变数据的组织，过滤掉标题，并计算一些有用的值。
- en: How to do it...
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Start with the goal. In this case, we''d like a function we can use like this:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从目标开始。在这种情况下，我们想要一个可以像这样使用的函数：
- en: '[PRE87]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This shows a three-step pattern for this kind of processing. These three steps
    will define our approach to creating the various parts of this reduction:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了这种处理的三步模式。这三步将定义我们创建减少的各个部分的方法：
- en: First, transform the data organization. This is sometimes called normalizing
    the data. In this case, we'll use a function called `row_merge()` . See the *Using
    stacked generator expressions* recipe for more information on this.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转换数据组织。有时这被称为数据规范化。在这种情况下，我们将使用一个名为`row_merge()`的函数。有关此信息，请参阅*使用堆叠的生成器表达式*食谱。
- en: Second, use mapping and filtering to clean and enrich the data. This is defined
    as a single function, `clean_data()` .
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，使用映射和过滤来清洁和丰富数据。这被定义为一个单一函数，`clean_data()`。
- en: Finally, reduce the data to a sum with `sum_fuel()` . There are a variety of
    other reductions that make sense. We might compute averages, or sums of other
    values. There are a lot of reductions we might want to apply.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`sum_fuel()`将数据减少到总和。还有各种其他减少的方法是有意义的。我们可能计算平均值，或其他值的总和。我们可能想应用很多减少。
- en: 'If needed, define the data structure normalization function. This almost always
    has to be a generator function. A structural change can''t be applied via `map()`
    :'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义数据结构规范化函数。这几乎总是必须是一个生成器函数。结构性的改变不能通过`map()`应用：
- en: '[PRE88]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As shown in the *Using stacked generator expressions* recipe, this generator
    function will restructure the data from three rows per each leg of the voyage
    to one row per leg. When all of the columns are in a single row, the data is much
    easier to work with.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如*使用堆叠的生成器表达式*食谱所示，此生成器函数将把每次航行的三行数据重组为每次航行的一行数据。当所有列都在一行中时，数据处理起来更容易。
- en: 'Define the overall data cleansing and enrichment data function. This is a generator
    function that''s built from simpler functions. It''s a stack of `map()` and `filter()`
    operations that will derive data from the source fields:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义整体数据清洗和增强数据函数。这是一个由简单函数构建的生成器函数。它是一系列`map()`和`filter()`操作，将从源字段派生数据：
- en: '[PRE89]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Each of the `map()` and `filter()` operations involves a small function to do
    a single conversion or computation on the data.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`map()`和`filter()`操作都涉及一个小函数，对数据进行单个转换或计算。
- en: Define the individual functions that are used for cleansing and deriving additional
    data.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于清洗和派生其他数据的单个函数。
- en: 'Convert the merged rows of data into a `SimpleNamespace` . This will allow
    us to use names such as `start_time` instead of `row[1]` :'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将合并的数据行转换为`SimpleNamespace`。这将允许我们使用名称，如`start_time`，而不是`row[1]`：
- en: '[PRE90]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This function builds a `SimpleNamspace` from selected columns of the source
    data. Columns three and six were omitted because they were always zero-length
    strings, `''` .
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从源数据的选定列构建一个`SimpleNamspace`。第三列和第六列被省略，因为它们始终是零长度的字符串，`''`。
- en: 'Here''s the function used by the `filter()` to remove the heading rows. If
    needed, this can be expanded to remove blank lines or other bad data from the
    source. The idea is to remove bad data as soon as possible in the processing:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是由`filter()`用于删除标题行的函数。如果需要，这可以扩展到从源数据中删除空行或其他不良数据。想法是尽快在处理中删除不良数据：
- en: '[PRE91]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Convert data to a usable form. First, we''ll convert strings to dates. The
    next two functions depend on this `timestamp()` function that converts a `date`
    string from one column plus a `time` string from another column into a proper
    `datetime` instance:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据转换为可用形式。首先，我们将字符串转换为日期。接下来的两个函数依赖于这个`timestamp()`函数，它将一个列中的`date`字符串加上另一个列中的`time`字符串转换为一个适当的`datetime`实例：
- en: '[PRE92]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This allows us to do simple date calculations based on the `datetime` library.
    In particular, subtracting two timestamps will create a `timedelta` object that
    has the exact number of seconds between any two dates.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够根据`datetime`库进行简单的日期计算。特别是，减去两个时间戳将创建一个`timedelta`对象，其中包含任何两个日期之间的确切秒数。
- en: 'Here''s how we''ll use this function to create a proper timestamp for the start
    of the leg and the end of the leg:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将如何使用此函数为航行的开始和结束创建适当的时间戳：
- en: '[PRE93]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Both of these functions will add a new attribute to the `SimpleNamespace` and
    also return the namespace object. This allows these functions to be used in a
    stack of `map()` operations. We can also rewrite these functions to replace the
    mutable `SimpleNamespace` with an immutable `namedtuple()` and still preserve
    the stack of `map()` operations.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都将向`SimpleNamespace`添加一个新属性，并返回命名空间对象。这允许这些函数在`map()`操作的堆栈中使用。我们还可以重写这些函数，用不可变的`namedtuple()`替换可变的`SimpleNamespace`，并仍然保留`map()`操作的堆栈。
- en: 'Compute derived time data. In this case, we can compute a duration too. Here''s
    a function which must be performed after the previous two:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算派生时间数据。在这种情况下，我们也可以计算持续时间。这是一个必须在前两个之后执行的函数：
- en: '[PRE94]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This will convert the difference in seconds into a value in hours. It will also
    round to the nearest tenth of an hour. Any more accuracy than this is largely
    noise. The departure and arrival times are (generally) off by at least a minute;
    they depend on when the skipper remembered to look at her watch. In some cases,
    she may have estimated the time.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把秒数差转换为小时值。它还会四舍五入到最接近的十分之一小时。比这更精确的信息基本上是噪音。出发和到达时间（通常）至少相差一分钟；它们取决于船长记得看手表的时间。在某些情况下，她可能已经估计了时间。
- en: 'Compute other metrics that are needed for the analyses. This includes creating
    the height values that are converted to float numbers. The final calculation is
    based on two other calculated results:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算分析所需的其他指标。这包括创建转换为浮点数的高度值。最终的计算基于另外两个计算结果：
- en: '[PRE95]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The fuel per hour calculation depends on the entire preceding stack of calculations.
    The travel hours comes from the start and end timestamps which are computed separately.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 每小时燃料消耗量取决于整个前面的计算堆栈。旅行小时数来自分别计算的开始和结束时间戳。
- en: How it works...
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The idea is to create a composite operation that follows a common template:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建一个遵循常见模板的复合操作：
- en: 'Normalize the structure: This often requires a generator function to read data
    in one structure and yield data in a different structure.'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规范化结构：这通常需要一个生成器函数，以在不同结构中读取数据并产生数据。
- en: 'Filter and cleanse: This may involve a simple filter as shown in this example.
    We''ll look at more complex filters later.'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤和清洗：这可能涉及一个简单的过滤，就像这个例子中所示的那样。我们稍后会看到更复杂的过滤器。
- en: 'Derive data via mappings or via lazy properties of class definitions: A class
    with lazy properties is a reactive object. Any change to the source property should
    cause changes to the computed properties.'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过映射或类定义的惰性属性派生数据：具有惰性属性的类是一个反应式对象。对源属性的任何更改都应该导致计算属性的更改。
- en: In some cases, we may want to combine the basic facts with other dimensional
    descriptions. For example, we might need to look up reference data, or decode
    coded fields.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要将基本事实与其他维度描述相结合。例如，我们可能需要查找参考数据，或解码编码字段。
- en: 'Once we''ve done the preliminary steps, we have data which is usable for a
    variety of analyses. Many times, this is a reduce operation. The initial example
    computes a sum of fuel use. Here are two other examples:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了初步步骤，我们就有了可用于各种分析的数据。很多时候，这是一个减少操作。初始示例计算了燃料使用量的总和。这里还有另外两个例子：
- en: '[PRE96]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: These functions apply the `mean()` and `stdev()` functions to the `fuel_per_hour`
    attribute of each row of the enriched data.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将`mean()`和`stdev()`函数应用于丰富数据的每一行的`fuel_per_hour`属性。
- en: 'We might use this as follows:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE97]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We've used the `clean_data(row_merge(log_rows))` mapping pipeline to cleanse
    and enrich the raw data. Then we applied a reduction to this data to get the value
    we're interested in.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`clean_data(row_merge(log_rows))`映射管道来清理和丰富原始数据。然后我们对这些数据应用了减少以获得我们感兴趣的值。
- en: We now know that our 30" tall tank is good for about 60 hours of motoring. At
    6 knots, we can go about 360 nautical miles on a full tank of fuel.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的30英寸高的油箱可以支持大约60小时的动力。以6节的速度，我们可以在满油箱的情况下行驶大约360海里。
- en: There's more...
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we noted, we can only perform one reduction on an iterable source of data.
    If we want to compute several averages, or the average and the variance, we'll
    need to use a slightly different pattern.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所指出的，我们只能对可迭代的数据源执行一次减少。如果我们想要计算多个平均值，或者平均值和方差，我们将需要使用稍微不同的模式。
- en: 'In order to compute multiple summaries of the data, we''ll need to create a
    sequence object of some kind that can be summarized repeatedly:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算数据的多个摘要，我们需要创建一种可以重复进行摘要的序列对象：
- en: '[PRE98]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Here, we've created a `tuple` from the cleaned and enriched data. This `tuple`
    will produce an iterable, but unlike a generator function, it can produce this
    iterable many times. We can compute two summaries by using the `tuple` object.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从清理和丰富的数据中创建了一个`tuple`。这个`tuple`将产生一个可迭代对象，但与生成器函数不同，它可以多次产生这个可迭代对象。我们可以使用`tuple`对象计算两个摘要。
- en: This design involves a large number of transformations of source data. We've
    built it using a stack of map, filter, and reduce operations. This provides a
    great deal of flexibility.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计涉及大量的源数据转换。我们使用了一系列map、filter和reduce操作来构建它。这提供了很大的灵活性。
- en: The alternative approach is to create a class definition. A class can be designed
    with lazy properties. This would create a kind of reactive design embodied in
    a single block of code. See the *Using properties for lazy attributes* recipe
    for examples of this.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个类定义。一个类可以设计为具有惰性属性。这将创建一种反应式设计，体现在单个代码块中。请参阅*使用属性进行惰性属性*配方，了解这方面的示例。
- en: 'We can also use the `tee()` function in the `itertools` module for this kind
    of processing:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`itertools`模块中使用`tee()`函数进行这种处理：
- en: '[PRE99]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We've used `tee()` to create two clones of the iterable output from `clean_data(row_merge(log_rows))`
    . We can use these two clones to compute a mean and a standard deviation.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tee()`创建了`clean_data(row_merge(log_rows))`的可迭代输出的两个克隆。我们可以使用这两个克隆来计算平均值和标准差。
- en: See also
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We looked at how to combine mapping and filtering in the *Using stacked generator
    expressions* recipe.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看过如何在*使用堆叠的生成器表达式*配方中结合映射和过滤。
- en: We looked at lazy properties in the *Using properties for lazy attributes* recipe.
    Also, this recipe looks at some important variations on map-reduce processing.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在*使用属性进行惰性属性*配方中看过懒惰属性。此外，这个配方还涉及map-reduce处理的一些重要变化。
- en: Implementing "there exists" processing
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现“存在”处理
- en: 'The processing patterns we''ve been looking at can all be summarized with the
    quantifier *for all* . It''s been an implicit part of all of the processing definitions:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究的处理模式都可以用量词*对于所有*来总结。这已经是所有处理定义的一个隐含部分：
- en: '**Map** : For all items in the source, apply the map function. We can use the
    quantifier to make this explicit: { *M* ( *x* ) ∀ *x* : *x* ∈ *C* }'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：对于源中的所有项目，应用映射函数。我们可以使用量词来明确这一点：{ *M* ( *x* ) ∀ *x* : *x* ∈ *C* }'
- en: '**Filter** : For all items in the source, pass those for which the filter function
    is `true` . Here also, we''ve used the quantifier to make this explicit. We want
    all values, *x* , from a set, *C* , if some function, *F(x)* , is `true` : { *x*
    ∀ *x* : *x* ∈ *C* **if** *F* ( *x* )}'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：对于源中的所有项目，传递那些过滤函数为`true`的项目。这里也使用了量词来明确这一点。如果某个函数*F(x)*为`true`，我们希望从集合*C*中获取所有值*x*：{
    *x* ∀ *x* : *x* ∈ *C* **if** *F* ( *x* )}'
- en: '**Reduce** : For all items in the source, use the given operator and base value
    to compute a summary. The rule for this is a recursion that clearly works for
    all values of the source collection or iterable: ![Implementing "there exists"
    processing](Image00025.jpg)  .'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少**：对于源中的所有项目，使用给定的运算符和基本值来计算摘要。这个规则是一个递归，对于源集合或可迭代的所有值都清晰地适用：![实现“存在”处理](Image00025.jpg)。'
- en: We've used the notation *C[0..n]* in the Pythonic sense of an open-ended range.
    Values with index positions of 0 and *n-1* are included, but the value at index
    position *n* is not included. This means that there are no elements in this range.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Pythonic意义上使用了*C[0..n]*的符号。索引位置为0和*n-1*的值是包括在内的，但索引位置为*n*的值不包括在内。这意味着这个范围内没有元素。
- en: What's more important is that *C[0..n-1 ]* ∪ *C[n-1]* = *C* . That is, when
    we take the last item from the range, no items are lost—we're always processing
    all the items in the collection. Also, we aren't processing item *C[n-1]* twice.
    It's not part of the *C[0..n-1]* range, but it is a standalone item *C[n-1]* .
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是*C[0..n-1 ]* ∪ *C[n-1]* = *C* 。也就是说，当我们从范围中取出最后一项时，不会丢失任何项——我们总是在处理集合中的所有项。此外，我们不会两次处理项*C[n-1]*。它不是*C[0..n-1]*范围的一部分，而是一个独立的项*C[n-1]*。
- en: How can we write a process using generator functions that stops when the first
    value matches some predicate? How do we avoid *for all* and quantify our logic
    with *there exists* ?
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用生成器函数编写一个进程，当第一个值匹配某个谓词时停止？我们如何避免*对于所有*并用*存在*量化我们的逻辑？
- en: Getting ready
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There's another quantifier that we might need— *there exists* , ∃. Let's look
    at an example of an existence test.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要另一个量词——*存在*，∃。让我们看一个存在性测试的例子。
- en: We might want to know whether a number is prime or composite. We don't need
    all of the factors of a number to know it's not prime. It's sufficient to show
    that a factor exists to know that a number is not prime.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想知道一个数是素数还是合数。我们不需要知道一个数的所有因子就能知道它不是素数。只要证明存在一个因子就足以知道一个数不是素数。
- en: 'We can define a prime predicate, *P(n)* , like this:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个素数谓词*P(n)*，如下所示：
- en: '*P* ( *n* ) = ¬∃ *i* : 2 ≤ *i* < *n* **if** *n* mod *i* = 0'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* ( *n* ) = ¬∃ *i* : 2 ≤ *i* < *n* **if** *n* mod *i* = 0'
- en: 'A number, *n* , is prime if there does not exist a value of *i* (between 2
    and the number) that divides the number evenly. We can move the negation around
    and rephrase this as follows:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数*n*，如果不存在一个值*i*（在2和这个数之间），能够整除这个数，那么它是素数。我们可以将否定移到周围，并重新表述如下：
- en: '*¬P* ( *n* ) = ∃ *i* : 2 ≤ *i* < *n* **if** *n* mod *i* = 0'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '*¬P* ( *n* ) = ∃ *i* : 2 ≤ *i* < *n* **if** *n* mod *i* = 0'
- en: A number, *n* , is composite (non-prime) if there exists a value, *i* , between
    2 and the number itself, that divides the number evenly. We don't need to know
    **all** such values. The existence of one value that satisfies the predicate is
    sufficient.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数*n*，如果存在一个值*i*，在2和这个数本身之间，能够整除这个数，那么它是合数（非素数）。我们不需要知道**所有**这样的值。满足谓词的一个值的存在就足够了。
- en: Once we've found such a number, we can break early from any iteration. This
    requires the `break` statement inside `for` and `if` statements. Because we're
    not processing all values, we can't easily use a higher-order function such as
    `map()` , `filter()` , or `reduce()` .
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到这样的数字，我们可以从任何迭代中提前中断。这需要在`for`和`if`语句中使用`break`语句。因为我们不处理所有的值，所以我们不能轻易使用高阶函数，比如`map()`、`filter()`或`reduce()`。
- en: How to do it...
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define a generator function template that will skip items until the required
    one is found. This will yield only one value that passes the predicate test:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个生成器函数模板，它将跳过项目，直到找到所需的项目。这将产生只有一个通过谓词测试的值：
- en: '[PRE100]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Define a predicate function. For our purposes, a simple `lambda` object will
    do. Also, a lambda allows us to work with a variable bound to the iteration and
    a variable that''s free from the iteration. Here''s the expression:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个谓词函数。对于我们的目的，一个简单的`lambda`对象就可以了。此外，lambda允许我们使用一个绑定到迭代的变量和一个自由于迭代的变量。这是表达式：
- en: '[PRE101]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We're relying on a non-local value, `n` , in this lambda. This will be *global*
    to the lambda, but still local to the overall function. If `n % i` is `0` , then
    `i` is a factor of `n` , and `n` is not prime.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个lambda中，我们依赖一个非局部值`n`。这将是lambda的*全局*值，但仍然是整个函数的局部值。如果`n % i`是`0`，那么`i`是`n`的一个因子，`n`不是素数。
- en: 'Apply the function with the given range and predicate:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的范围和谓词应用该函数：
- en: '[PRE102]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: If the `factors` iterable has an item, then `n` is composite. Otherwise, there
    are no values in the `factors` iterable, which means `n` is a prime number.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`factors`可迭代对象有一个项，那么`n`是合数。否则，`factors`可迭代对象中没有值，这意味着`n`是一个素数。
- en: As a practical matter, we don't need to test every single number between two
    and `n` to see whether `n` is prime. It's only necessary to test values, `i` ,
    such that *2* ≤ *i* < √ *n* .
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要测试两个和`n`之间的每一个数字，以确定`n`是否是素数。只需要测试值`i`，使得*2* ≤ *i* < √ *n*。
- en: How it works...
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `find_first()` function, we introduce a `break` statement to stop processing
    the source iterable. When the `for` statement stops, the generator will reach
    the end of the function, and return normally.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在`find_first()`函数中，我们引入了一个`break`语句来停止处理源可迭代对象。当`for`语句停止时，生成器将到达函数的末尾，并正常返回。
- en: The process which is consuming values from this generator will be given the
    `StopIteration` exception. This exception means the generator will produce no
    more values. The `find_first()` function raises as an exception, but it's not
    an error. It's the normal way to signal that an iterable has finished processing
    the input values.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个生成器中消耗值的进程将得到`StopIteration`异常。这个异常意味着生成器不会再产生值。`find_first()`函数会引发一个异常，但这不是一个错误。这是信号一个可迭代对象已经完成了输入值的处理的正常方式。
- en: 'In this case, the signal means one of two things:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，信号意味着两种可能：
- en: If a value has been yielded, the value is a factor of `n`
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果产生了一个值，那么这个值是`n`的一个因子
- en: If no value was yielded, then `n` is prime
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有产生值，那么`n`是素数
- en: This small change of breaking early from the `for` statement makes a dramatic
    difference in the meaning of the generator function. Instead of processing **all**
    values from the source, the `find_first()` generator will stop processing as soon
    as the predicate is `true` .
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 从`for`语句中提前中断的这个小改变，使得生成器函数的含义发生了巨大的变化。与处理源的**所有**值不同，`find_first()`生成器将在谓词为`true`时停止处理。
- en: This is different from a filter, where all of the source values will be consumed.
    When using the `break` statement to leave the `for` statement early, some of the
    source values may not be processed.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这与过滤器不同，过滤器会消耗所有的源值。当使用`break`语句提前离开`for`语句时，一些源值可能不会被处理。
- en: There's more...
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the `itertools` module, there is an alternative to this `find_first()` function.
    The `takewhile()` function uses a predicate function to keep taking values from
    the input. When the predicate becomes `false` , then the function stops processing
    values.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在`itertools`模块中，有一个替代`find_first()`函数的方法。`takewhile()`函数使用一个谓词函数来保持从输入中获取值。当谓词变为`false`时，函数停止处理值。
- en: 'We can easily change the lambda from `lambda i: n % i == 0` to `lambda i: n
    % i != 0` . This will allow the function to take values while they are not factors.
    Any value that is a factor will stop the processing by ending the `takewhile()`
    process.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以很容易地将lambda从`lambda i: n % i == 0`改为`lambda i: n % i != 0`。这将允许函数在它们不是因子时接受值。任何是因子的值都会通过结束`takewhile()`过程来停止处理。'
- en: 'Let''s look at two examples. We''ll test `13` for being prime. We need to check
    numbers in the range. We''ll also test `15` for being prime:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看两个例子。我们将测试`13`是否为质数。我们需要检查范围内的数字。我们还将测试`15`是否为质数：
- en: '[PRE103]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: For a prime number, all of the test values pass the `takewhile()` predicate.
    The result is a list of non-factors of the given number, *n* . If the set of non-factors
    is the same as the set of values being tested, then `n` is prime. In the case
    of `13` , both collections of values are `[2, 3]` .
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对于质数，所有的测试值都通过了`takewhile()`谓词。结果是给定数字*n*的非因子列表。如果非因子的集合与被测试的值的集合相同，那么`n`是质数。在`13`的情况下，两个值的集合都是`[2,
    3]`。
- en: For a composite number, some values pass the `takewhile()` predicate. In this
    example, `2` is not a factor of `15` . However, `3` is a factor; this does not
    pass the predicate. The collection of non-factors, `[2]` , is not the same as
    the set of values collection that was tested, `[2, 3]` .
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合数，一些值通过了`takewhile()`谓词。在这个例子中，`2`不是`15`的因子。然而，`3`是一个因子；这不符合谓词。非因子的集合`[2]`与被测试的值的集合`[2,
    3]`不同。
- en: 'We wind up with a function that looks like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到的函数看起来像这样：
- en: '[PRE104]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This creates two intermediate set objects, `tests` and `non_factors` . If all
    of the tested values are not factors, the number is prime. The function shown
    previously, based on `find_first()` only creates one intermediate list object.
    That list will have at most one member, making the data structure much smaller.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个中间集合对象`tests`和`non_factors`。如果所有被测试的值都不是因子，那么这个数就是质数。之前展示的函数，基于`find_first()`只创建了一个中间列表对象。那个列表最多只有一个成员，使得数据结构更小。
- en: The itertools module
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: itertools模块
- en: 'There are a number of additional functions in the `itertools` module that we
    can use to simplify complex map-reduce applications:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块中还有许多其他函数，我们可以用来简化复杂的映射-归约应用：'
- en: '`filterfalse()` : It is the companion to the built-in `filter()` function.
    It inverts the predicate logic of the `filter()` function; it rejects items for
    which the predicate is `true` .'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterfalse()`：它是内置`filter()`函数的伴侣。它颠倒了`filter()`函数的谓词逻辑；它拒绝谓词为`true`的项目。'
- en: '`zip_longest()` : It is the companion to the built-in `zip()` function. The
    built-in `zip()` function stops merging items when the shortest iterable is exhausted.
    The `zip_longest()` function will supply a given fill value to pad short iterables
    to match the longest.'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_longest()`：它是内置`zip()`函数的伴侣。内置的`zip()`函数在最短的可迭代对象耗尽时停止合并项目。`zip_longest()`函数将提供一个给定的填充值，以使短的可迭代对象与最长的可迭代对象匹配。'
- en: '`starmap()` : It is a modification to the essential `map()` algorithm. When
    we perform `map(function, iter1, iter2)` , then an item from each iterable is
    provided as two positional arguments to the given function. The `starmap()` expects
    an iterable to provide a tuple that contains the argument values. In effect:'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`starmap()`：这是对基本`map()`算法的修改。当我们执行`map(function, iter1, iter2)`时，每个可迭代对象中的一个项目将作为给定函数的两个位置参数提供。`starmap()`期望一个可迭代对象提供一个包含参数值的元组。实际上：'
- en: '[PRE105]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'There are still others that we might use, too:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些我们可能也会用到的：
- en: '`accumulate()` : This function is a variation on the built-in `sum()` function.
    This will yield each partial total that''s produced before reaching the final
    sum.'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate()`：这个函数是内置`sum()`函数的一个变体。它会产生在达到最终总和之前产生的每个部分总和。'
- en: '`chain()` : This function will combine iterables in order.'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chain()`：这个函数将按顺序合并可迭代对象。'
- en: '`compress()` : This function uses one iterable as a source of data and the
    other as a source of selectors. When the item from the selector is true, the corresponding
    data item is passed. Otherwise, the data item is rejected. This is an item-by-item
    filter based on true-false values.'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress()`：这个函数使用一个可迭代对象作为数据源，另一个可迭代对象作为选择器的数据源。当选择器的项目为true时，相应的数据项目被传递。否则，数据项目被拒绝。这是基于真假值的逐项过滤器。'
- en: '`dropwhile()` : While the predicate to this function is `true` , it will reject
    values. Once the predicate becomes `false` , it will pass all remaining values.
    See `takewhile()` .'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropwhile()`：只要这个函数的谓词为`true`，它就会拒绝值。一旦谓词变为`false`，它就会传递所有剩余的值。参见`takewhile()`。'
- en: '`groupby()` : This function uses a key function to control the definition of
    groups. Items with the same key value are grouped into separate iterators. For
    the results to be useful, the original data should be sorted into order by the
    keys.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupby()`：这个函数使用一个键函数来控制组的定义。具有相同键值的项目被分组到单独的迭代器中。为了使结果有用，原始数据应该按键的顺序排序。'
- en: '`islice()` : This function is like a slice expression, except it applies to
    an iterable, not a list. Where we use `list[1:]` to discard the first row of a
    list, we can use `islice(iterable, 1)` to discard the first item from an iterable.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`islice()`：这个函数类似于切片表达式，只不过它适用于可迭代对象，而不是列表。当我们使用`list[1:]`来丢弃列表的第一行时，我们可以使用`islice(iterable,
    1)`来丢弃可迭代对象的第一个项目。'
- en: '`takewhile()` : While the predicate is `true` , this function will pass values.
    Once the predicate becomes `false` , stop processing any remaining values. See
    `dropwhile()` .'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takewhile()`：只要谓词为`true`，这个函数就会传递值。一旦谓词变为`false`，就停止处理任何剩余的值。参见`dropwhile()`。'
- en: '`tee()` : This splits a single iterable into a number of clones. Each clone
    can then be consumed separately. This is a way to perform multiple reductions
    on a single iterable source of data.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tee()`：这将单个可迭代对象分成多个克隆。然后可以单独消耗每个克隆。这是在单个可迭代数据源上执行多个减少的一种方法。'
- en: Creating a partial function
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个部分函数
- en: 'When we look at functions such as `reduce()` , `sorted()` , `min()` , and `max()`
    , we see that we''ll often have some *permanent* argument values. For example,
    we might find a need to write something like this in several places:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`reduce()`、`sorted()`、`min()`和`max()`等函数时，我们会发现我们经常有一些*永久*参数值。例如，我们可能会发现需要在几个地方写类似这样的东西：
- en: '[PRE106]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Of the three parameters to `reduce()` , only one - the iterable to process -
    actually changes. The operator and the base value arguments are essentially fixed
    at `operator.mul` and `1` .
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`reduce()`的三个参数，只有一个-要处理的可迭代对象-实际上会改变。运算符和基本值参数基本上固定为`operator.mul`和`1`。
- en: 'Clearly, we can define a whole new function for this:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以为此定义一个全新的函数：
- en: '[PRE107]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: However, Python has a few ways to simplify this pattern so that we don't have
    to repeat the boilerplate `def` and `return` statements.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python有一些简化这种模式的方法，这样我们就不必重复使用样板`def`和`return`语句。
- en: How can we define a function that has some parameters provided in advance?
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义一个具有预先提供一些参数的函数？
- en: Note that the goal here is different from providing default values. A partial
    function doesn't provide a way to override the defaults. Instead, we want to create
    as many partial functions as we need, each with specific parameters bound in advance.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的目标与提供默认值不同。部分函数不提供覆盖默认值的方法。相反，我们希望创建尽可能多的部分函数，每个函数都提前绑定了特定的参数。
- en: Getting ready
  id: totrans-592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some statistical modeling is done with standard scores, sometimes called **z-scores**
    . The idea is to standardize a raw measurement onto a value that can be easily
    compared to a normal distribution, and easily compared to related numbers that
    are measured in different units.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 一些统计建模是用标准分数来完成的，有时被称为**z分数**。其想法是将原始测量标准化到一个可以轻松与正态分布进行比较的值，并且可以轻松与以不同单位测量的相关数字进行比较。
- en: 'The calculation is this:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 计算如下：
- en: '*z* = ( *x* - μ)/σ'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '*z* = ( *x* - μ)/σ'
- en: Here, *x* is the raw value, μ is the population mean, and σ is the population
    standard deviation. The value *z* will have a mean of 0 and a standard deviation
    of 1\. This makes it particularly easy to work with.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*x*是原始值，μ是总体均值，σ是总体标准差。值*z*的均值为0，标准差为1。这使得它特别容易处理。
- en: We can use this value to spot **outliers** - values which are suspiciously far
    from the mean. We expect that (about) 99.7% of our *z* values will be between
    -3 and +3.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个值来发现**异常值**-与均值相距甚远的值。我们期望我们的*z*值(大约)99.7%会在-3和+3之间。
- en: 'We could define a function like this:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个这样的函数：
- en: '[PRE108]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This `standardize()` function will compute a z-score from a raw score, *x*
    . This function has two kinds of parameters:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`standardize()`函数将从原始分数*x*计算出z分数。这个函数有两种类型的参数：
- en: The values for `mean` and `stdev` are essentially fixed. Once we've computed
    the population values, we'll have to provide them to the `standardize()` function
    over and over again.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mean`和`stdev`的值基本上是固定的。一旦我们计算出总体值，我们将不断地将它们提供给`standardize()`函数。'
- en: The value for `x` is more variable.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`的值更加可变。'
- en: 'Let''s say we''ve got a collection of data samples in big blocks of text:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一系列大块文本中的数据样本：
- en: '[PRE109]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We''ve defined two small functions to convert this data to pairs of numbers.
    The first simply breaks each block of text to a sequence of lines, and then breaks
    each line into a pair of text items:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了两个小函数来将这些数据转换为数字对。第一个简单地将每个文本块分解为一系列行，然后将每行分解为一对文本项：
- en: '[PRE110]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We've used the `splitlines()` method of the text block to create a sequence
    of lines. We put this into a generator function so that each individual line could
    be assigned to `r` . Using `r.split()` separates the two blocks of text in each
    row.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用文本块的`splitlines()`方法创建了一系列行。我们将其放入生成器函数中，以便每个单独的行都可以分配给`r`。使用`r.split()`将每行中的两个文本块分开。
- en: 'If we use `list(text_parse(text_1))` , we''ll see data like this:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`list(text_parse(text_1))`，我们会看到这样的数据：
- en: '[PRE111]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We need to further enrich this data to make it more usable. We need to convert
    the strings to proper float values. While doing that, we''ll create `SimpleNamespace`
    instances from each item:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进一步丰富这些数据，使其更易于使用。我们需要将字符串转换为适当的浮点值。在这样做的同时，我们将从每个项目创建`SimpleNamespace`实例：
- en: '[PRE112]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `lambda` object creates a `SimpleNamespace` instance by applying the `float()`
    function to each string item in each row. This gives us data we can work with.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`对象通过将`float()`函数应用于每行中的每个字符串项来创建`SimpleNamespace`实例。这给了我们可以处理的数据。'
- en: 'We can apply these two `lambda` objects to the data to create some usable datasets.
    Earlier, we showed `text_1` . We''ll assume that we have a second, similar set
    of data assigned to `text_2` :'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个`lambda`对象应用于数据，以创建一些可用的数据集。之前，我们展示了`text_1`。我们假设我们有一个类似的第二组数据分配给`text_2`：
- en: '[PRE113]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This creates data from two blocks of similar text. Each has pairs of data points.
    The `SimpleNamespace` object has two attributes, `x` and `y` , assigned to each
    row of the data.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就创建了两个类似文本块的数据。每个都有数据点对。`SimpleNamespace`对象有两个属性，`x`和`y`，分配给数据的每一行。
- en: Note that this process creates instances of `types.SimpleNamespace` . When we
    print them, they will be displayed using the class `namespace` . These are mutable
    objects, so that we can update each one with the standardized z-score.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个过程创建了`types.SimpleNamespace`的实例。当我们打印它们时，它们将使用`namespace`类显示。这些是可变对象，因此我们可以用标准化的z分数更新每一个。
- en: 'Printing `data_1` looks like this:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`data_1`看起来像这样：
- en: '[PRE114]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'As an example, we''ll compute a standardized value for the `x` attribute. This
    means getting mean and standard deviation. Then we''ll need to apply these values
    to standardize data in both of our collections. It looks like this:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将计算`x`属性的标准化值。这意味着获取均值和标准差。然后我们需要将这些值应用于标准化我们两个集合中的数据。看起来是这样的：
- en: '[PRE115]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Providing the `mean_v1` , `stdev_v1` values each time we evaluate `standardize()`
    can clutter an algorithm with details that aren't deeply important. In some rather
    complex algorithms, the clutter can lead to more confusion than clarity.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 每次评估`standardize()`时提供`mean_v1`，`stdev_v1`值可能会使算法混乱，因为这些细节并不是非常重要。在一些相当复杂的算法中，这种混乱可能导致更多的困惑而不是清晰。
- en: How to do it...
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In addition to simply using the `def` statement to create a function that has
    a partial set of argument values, we have two other ways to create a partial function:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地使用`def`语句创建具有部分参数值的函数之外，我们还有两种其他方法来创建部分函数：
- en: Using the `partial()` function from the `functools` module
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`functools`模块的`partial()`函数
- en: Creating a `lambda` object
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`lambda`对象
- en: Using functools.partial()
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用functools.partial()
- en: 'Import the `partial` function from `functools` :'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`functools`导入`partial`函数：
- en: '[PRE116]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Create an object using `partial()` . We provide the base function, plus the
    positional arguments that need to be included. Any parameters which are not supplied
    when the partial is defined must be supplied when the partial is evaluated:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`partial()`创建对象。我们提供基本函数，以及需要包括的位置参数。在定义部分时未提供的任何参数在评估部分时必须提供：
- en: '[PRE117]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We've provided values for the first two positional parameters, `mean` and `stdev`
    . The third positional parameter, `x` , must be supplied in order to compute a
    value.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已为前两个位置参数`mean`和`stdev`提供了值。第三个位置参数`x`必须在计算值时提供。
- en: Creating a lambda object
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建`lambda`对象
- en: 'Define a `lambda` object that binds the fixed parameters:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义绑定固定参数的`lambda`对象：
- en: '[PRE118]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create an object using `lambda` :'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lambda`创建对象：
- en: '[PRE119]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: How it works...
  id: totrans-637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Both techniques create a callable object - a function - named `z()` that has
    the values for `mean_v1` and `stdev_v1` already bound to the first two positional
    parameters. With either approach, we have processing that can look like this:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都创建了一个可调用对象——一个名为`z()`的函数，其值为`mean_v1`和`stdev_v1`已经绑定到前两个位置参数。使用任一方法，我们的处理看起来可能是这样的：
- en: '[PRE120]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We've applied the `z()` function to each set of data. Because the function has
    some parameters already applied, its use here looks very simple.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`z()`函数应用于每组数据。因为函数已经应用了一些参数，所以在这里使用看起来非常简单。
- en: 'We can also do the following because each row is a mutable object:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以这样做，因为每行都是一个可变对象：
- en: '[PRE121]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We've updated the row to include a new attribute, `z` , with the value of the
    `z()` function. In a complex algorithm, tweaking the row objects like this may
    be a helpful simplification.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更新行，包括一个新属性`z`，其值为`z()`函数。在复杂的算法中，调整行对象可能是一个有用的简化。
- en: 'There''s a significant difference between the two techniques for creating the
    `z()` function:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`z()`函数的两种技术之间存在显着差异：
- en: The `partial()` function binds the actual values of the parameters. Any subsequent
    change to the variables that were used doesn't change the definition of the partial
    function that's created. After creating `z = partial(standardize(mean_v1, stdev_v1))`
    , changing the value of `mean_v1` or `stdev_v1` doesn't have an impact on the
    partial function, `z()` .
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial()`函数绑定参数的实际值。对使用的变量进行的任何后续更改都不会改变创建的部分函数的定义。创建`z = partial(standardize(mean_v1,
    stdev_v1))`后，更改`mean_v1`或`stdev_v1`的值不会对部分函数`z()`产生影响。'
- en: 'The `lambda` object binds the variable name, not the value. Any subsequent
    change to the variable''s value will change the way the lambda behaves. After
    creating `z = lambda x: standardize(mean_v1, stdev_v1, x)` , changing the value
    of `mean_v1` or `stdev_v1` changes the values used by the `lambda` object, `z()`
    .'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda`对象绑定变量名，而不是值。对变量值的任何后续更改都将改变lambda的行为方式。创建`z = lambda x: standardize(mean_v1,
    stdev_v1, x)`后，更改`mean_v1`或`stdev_v1`的值将改变`lambda`对象`z()`使用的值。'
- en: 'We can modify the lambda slightly to bind values instead of names:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微修改lambda以绑定值而不是名称：
- en: '[PRE122]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This extracts the values of `mean_v1` and `stdev_v1` to create default values
    for the `lambda` object. The values of `mean_v1` and `stdev_v1` are now irrelevant
    to proper operation of the `lambda` object, `z()` .
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取`mean_v1`和`stdev_v1`的值以创建`lambda`对象的默认值。`mean_v1`和`stdev_v1`的值现在与`lambda`对象`z()`的正常操作无关。
- en: There's more...
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can provide keyword argument values as well as positional argument values
    when creating a partial function. In many cases, this works nicely. There are
    a few cases where it doesn't work.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建部分函数时，我们可以提供关键字参数值以及位置参数值。在许多情况下，这很好用。也有一些情况不适用。
- en: 'The `reduce()` function, specifically, can''t be trivially turned into a partial
    function. The parameters aren''t in the ideal order for creating a partial. The
    `reduce()` function has the following notional definition. This is not how it''s
    defined - this is how it *appears* to be defined:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是`reduce()`函数不能简单地转换为部分函数。参数的顺序不是创建部分的理想顺序。`reduce()`函数具有以下概念定义。这不是它的定义方式——这是它*看起来*的定义方式：
- en: '[PRE123]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If this was the actual definition, we could do this:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是实际定义，我们可以这样做：
- en: '[PRE124]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Practically, we can''t do this because the definition of `reduce()` is a bit
    more complex than it might appear. The `reduce()` function doesn''t permit named
    argument values. This means that we''re forced to use the lambda technique:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们无法这样做，因为`reduce()`的定义比看起来更复杂一些。`reduce()`函数不允许命名参数值。这意味着我们被迫使用lambda技术：
- en: '[PRE125]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We've used a `lambda` object to define a function, `prod()` , with only one
    parameter. This function uses `reduce()` with two fixed parameters, and one variable
    parameter.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`lambda`对象定义了一个只有一个参数`prod()`函数。这个函数使用两个固定参数和一个可变参数与`reduce()`一起使用。
- en: 'Given this definition for `prod()` , we can define other functions that rely
    on computing products. Here''s a definition of the `factorial` function:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`prod()`的定义，我们可以定义依赖于计算乘积的其他函数。下面是`factorial`函数的定义：
- en: '[PRE126]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The definition of `factorial()` depends on `prod()` . The definition of `prod()`
    is a kind of partial function that uses `reduce()` with two fixed parameter values.
    We've managed to use a few definitions to create a fairly sophisticated function.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial()`的定义取决于`prod()`。`prod()`的定义是一种使用`reduce()`和两个固定参数值的部分函数。我们设法使用了一些定义来创建一个相当复杂的函数。'
- en: In Python, a function is an object. We've seen numerous ways that functions
    can be an argument to a function. A function that accepts another function as
    an argument is sometimes called a **higher-order function** .
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数是一个对象。我们已经看到了函数可以作为参数传递的多种方式。接受另一个函数作为参数的函数有时被称为**高阶函数**。
- en: 'Similarly, functions can also return a function object as a result. This means
    that we can create a function like this:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，函数也可以返回一个函数对象作为结果。这意味着我们可以创建一个像这样的函数：
- en: '[PRE127]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We''ve defined a function over a set of ( *x* , *y* ) samples. We''ve computed
    the mean and standard deviation of the *x* attribute of each sample. We''ve then
    created a partial function which can standardize scores based on the computed
    statistics. The result of this function is a function we can use for data analysis:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个在一组（*x*，*y*）样本上的函数。我们计算了每个样本的*x*属性的均值和标准差。然后我们创建了一个可以根据计算出的统计数据标准化得分的部分函数。这个函数的结果是一个我们可以用于数据分析的函数：
- en: '[PRE128]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: When we evaluated the `prepare_z()` function, it returned a function. We assigned
    this function to a variable, `z` . This variable is a callable object; it's the
    function `z()` that will standardize a score based on the sample mean and standard
    deviation.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`prepare_z()`函数时，它返回了一个函数。我们将这个函数赋给一个变量`z`。这个变量是一个可调用对象；它是函数`z()`，它将根据样本均值和标准差标准化得分。
- en: Simplifying complex algorithms with immutable data structures
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变数据结构简化复杂算法
- en: The concept of a stateful object is a common feature of object-oriented programming.
    We looked at a number of techniques related to objects and state in [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , and [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* . A great deal of the emphasis of object-oriented
    design is creating methods that mutate an object's state.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态对象的概念是面向对象编程的一个常见特性。我们在[第6章](text00070.html#page "第6章 类和对象的基础")和[第7章](text00079.html#page
    "第7章 更高级的类设计")中看过与对象和状态相关的一些技术，*类和对象的基础*和*更高级的类设计*。面向对象设计的重点之一是创建能够改变对象状态的方法。
- en: We've also looked at some stateful functional programming techniques in the
    *Using stacked generator expressions* , *Combining map and reduce transformations*
    , and *Creating a partial function* recipes. We've used `types.SimpleNamespace`
    because it creates a simple, stateful object with easy to use attribute names.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在*使用堆叠的生成器表达式*、*组合map和reduce转换*和*创建部分函数*配方中看过一些有状态的函数式编程技术。我们使用`types.SimpleNamespace`，因为它创建了一个简单的、有状态的对象，具有易于使用的属性名称。
- en: In most of these cases, we've been working with objects that have a Python `dict`
    object that defines the attributes. The one exception is the *Optimizing small
    objects with __slots__* recipe, where the attributes are fixed by the `__slots__`
    attribute definition.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们一直在处理具有Python `dict`对象定义属性的对象。唯一的例外是*使用__slots__优化小对象*配方，其中属性由`__slots__`属性定义固定。
- en: 'Using a `dict` object to store an object''s attributes has several consequences:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dict`对象存储对象的属性有几个后果：
- en: We can trivially add and remove attributes. We're not limited to simply setting
    and getting defined attributes; we can create new attributes too.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加和删除属性。我们不仅仅局限于设置和获取已定义的属性；我们也可以创建新属性。
- en: Each object uses a somewhat larger amount of memory than is minimally necessary.
    This is because dictionaries use a hashing algorithm to locate keys and values.
    The hash processing generally requires more memory than other structures such
    as a `list` or a `tuple` . For very large amounts of data, this can become a problem.
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象使用的内存量比最小必要量稍微大一些。这是因为字典使用哈希算法来定位键和值。哈希处理通常需要比其他结构（如`list`或`tuple`）更多的内存。对于非常大量的数据，这可能会成为一个问题。
- en: The most significant issue with stateful object-oriented programming is that
    it can sometimes be challenging to write clear assertions about state change of
    an object. Rather than defining assertions about state change, it's much easier
    to create entirely new objects with a state that can be simply mapped to the object's
    type. This, coupled with Python type hints, can sometimes create more reliable,
    and easier to test, software.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的面向对象编程最重要的问题是有时很难对对象的状态变化写出清晰的断言。与其定义关于状态变化的断言，更容易的方法是创建完全新的对象，其状态可以简单地映射到对象的类型。这与Python类型提示结合使用，有时可以创建更可靠、更易于测试的软件。
- en: When we create new objects, the relationships between data items and computations
    can be captured explicitly. The `mypy` project provides tools that can analyze
    those type hints to provide some confirmation that the objects used in a complex
    algorithm are used properly.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建新对象时，数据项和计算之间的关系可以被明确捕获。`mypy`项目提供了工具，可以分析这些类型提示，以确认复杂算法中使用的对象是否被正确使用。
- en: 'In some cases, we can also reduce the amount of memory by avoiding stateful
    objects in the first place. We have two techniques for doing this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们也可以通过避免首先使用有状态对象来减少内存的使用量。我们有两种技术可以做到这一点：
- en: 'Using class definitions with `__slots__` : See the *Optimizing small objects
    with __slots__* recipe for this. These objects are mutable, so we can update attributes
    with new values.'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有`__slots__`的类定义：有关此内容，请参阅*使用__slots__优化小对象*的示例。这些对象是可变的，因此我们可以使用新值更新属性。
- en: 'Using immutable `tuples` or `namedtuples` : See the *Designing classes with
    little unique processing* recipe for some background on this. These objects are
    immutable. We can create new objects, but we can''t change the state of an object.
    The cost savings from less memory overall have to be balanced against the additional
    costs of creating new objects.'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变的`tuples`或`namedtuples`：有关此内容，请参阅*设计具有少量独特处理的类*的示例。这些对象是不可变的。我们可以创建新对象，但无法更改对象的状态。整体内存的成本节约必须平衡创建新对象的额外成本。
- en: Immutable objects can be somewhat faster that mutable objects. The more important
    benefit is to algorithm design. In some cases, writing functions that create new
    immutable objects from old immutable objects can be simpler, and easier to test
    and debug, than algorithms that work with stateful objects. Writing type hints
    can help this process.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象可能比可变对象稍快。更重要的好处是算法设计。在某些情况下，编写函数从旧的不可变对象创建新的不可变对象可能比处理有状态对象的算法更简单、更容易测试和调试。编写类型提示可以帮助这个过程。
- en: Getting ready
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we noted in the *Using stacked generator expressions* and *Implementing "there
    exists" processing* recipes, we can only process a generator once. If we need
    to process it more than one time, the iterable sequence of objects must be transformed
    into a complete collection like a list or tuple.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*使用堆叠的生成器表达式*和*实现“存在”处理*的示例中所指出的，我们只能处理生成器一次。如果我们需要多次处理它，可迭代对象的序列必须转换为像列表或元组这样的完整集合。
- en: 'This often leads to a multi-phase process:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会导致一个多阶段的过程：
- en: '**Initial extract of the data** : This might involve a database query, or reading
    a `.csv` file. This phase can be implemented as a function that yields rows or
    even returns a generator function.'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始提取数据**：这可能涉及数据库查询或读取`.csv`文件。这个阶段可以被实现为一个产生行或甚至返回生成器函数的函数。'
- en: '**Cleansing and filtering the data** : This may involve a stack of generator
    expressions that can process the source just once. This phase is often implemented
    as a function that includes several map and filter operations.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清洗和过滤数据**：这可能涉及一系列生成器表达式，可以仅处理一次源。这个阶段通常被实现为一个包含多个映射和过滤操作的函数。'
- en: '**Enriching the data** : This, too, may involve a stack of generator expressions
    that can process the data one row at a time. This is typically a series of map
    operations to create new, derived data from existing data.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富数据**：这也可能涉及一系列生成器表达式，可以一次处理一行数据。这通常是一系列的映射操作，用于从现有数据中创建新的派生数据。'
- en: '**Reducing or summarizing the data** : This may involve multiple summaries.
    In order for this to work, the output from the enrichment phase needs to be a
    collection object that can be processed more than one time.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少或总结数据**：这可能涉及多个摘要。为了使其工作，丰富阶段的输出需要是可以多次处理的集合对象。'
- en: In some cases, the enrichment and summary processes may be interleaved. As we
    saw in the *Creating a partial function* recipe, we might do some summarization
    followed by more enrichment.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，丰富和总结过程可能会交错进行。正如我们在*创建部分函数*示例中看到的，我们可能会先进行一些总结，然后再进行更多的丰富。
- en: 'There are two common strategies for handling the enriching phase:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 处理丰富阶段有两种常见策略：
- en: '**Mutable objects** : This means that enrichment processing adds or sets values
    of attributes. This can be done with eager calculations as attributes are set.
    See the *Using settable properties to update eager attributes* recipe. It can
    also be done with lazy properties. See the *Using properties for lazy attributes*
    recipe. We''ve shown examples using `types.SimpleNamespace` where the computation
    is done in functions separate from the class definition.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变对象**：这意味着丰富处理会添加或设置属性的值。可以通过急切计算来完成，因为属性被设置。请参阅*使用可设置属性更新急切属性*的示例。也可以使用惰性属性来完成。请参阅*使用惰性属性*的示例。我们已经展示了使用`types.SimpleNamespace`的示例，其中计算是在与类定义分开的函数中完成的。'
- en: '**Immutable objects** : This means that the enrichment process creates new
    objects from old objects. Immutable objects are derived from `tuple` or are a
    type created by `namedtuple()` . These objects have the advantage of being very
    small and very fast. Also, the lack of any internal state change can make them
    very simple.'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变对象**：这意味着丰富过程从旧对象创建新对象。不可变对象源自`tuple`或由`namedtuple()`创建的类型。这些对象的优势在于非常小且非常快。此外，缺乏任何内部状态变化使它们非常简单。'
- en: 'Let''s say we''ve got a collection of data samples in big blocks of text:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一系列大块文本中的数据样本：
- en: '[PRE129]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Our goal is a three-step process that includes the `get` , `cleanse` , and
    `enrich` operations:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是一个包括`get`、`cleanse`和`enrich`操作的三步过程：
- en: '[PRE130]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `get()` function acquires the data from a source; in this case, it would
    parse the big block of text. The `cleanse()` function would remove blank lines
    and other unusable data. The `enrich()` function would do the final calculation
    on the cleaned data. We'll look at each phase of this pipeline separately.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`函数从源获取数据；在这种情况下，它会解析大块文本。`cleanse()`函数将删除空行和其他无法使用的数据。`enrich()`函数将对清理后的数据进行最终计算。我们将分别查看此管道的每个阶段。'
- en: 'The `get()` function is limited to pure text processing, doing as little filtering
    as possible:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`函数仅限于纯文本处理，尽量少地进行过滤：'
- en: '[PRE131]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: In order to write type hints, we've imported the `typing` module. This allows
    us to make an explicit declaration about the inputs and outputs of this function.
    The `get()` function accepts a string, `str` . It yields a `List[str]` structure.
    Each line of input is decomposed to a sequence of values.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写类型提示，我们已导入了`typing`模块。这使我们能够对此函数的输入和输出进行明确声明。`get()`函数接受一个字符串`str`。它产生一个`List[str]`结构。输入的每一行都被分解为一系列值。
- en: This function will generate all non-empty lines of data. There is a small filtering
    feature to this, but it's related to a small technical issue around data serialization,
    not an application-specific filtering rule.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将生成所有非空数据行。这里有一个小的过滤功能，但它与数据序列化的一个小技术问题有关，而不是一个特定于应用程序的过滤规则。
- en: 'The `cleanse()` function will generate named tuples of data. This will apply
    a number of rules to assure that the data is valid:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '`cleanse()`函数将生成命名元组的数据。这将应用一些规则来确保数据是有效的：'
- en: '[PRE132]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We've defined a `namedtuple` with the uninformative name of `DataPair` . This
    item has two attributes, `x` , and `y` . If the two text values can be properly
    converted to `float` , then this generator will yield a useful `DataPair` instance.
    If the two text values cannot be converted, this will display an error for the
    offending pair.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`namedtuple`，名为`DataPair`。这个项目有两个属性，`x`和`y`。如果这两个文本值可以正确转换为`float`，那么这个生成器将产生一个有用的`DataPair`实例。如果这两个文本值无法转换，这将显示一个错误，指出有问题的对。
- en: Note the technical subtlety that's part of the `mypy` project's type hints.
    A function with a `yield` statement is an iterator. We can use it as if it's an
    iterable object because of a formal relationship that says iterators are a kind
    of iterable.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`mypy`项目类型提示中的技术细微之处。带有`yield`语句的函数是一个迭代器。由于正式关系，我们可以将其用作可迭代对象，这种关系表明迭代器是可迭代对象的一种。
- en: Additional cleansing rules could be applied here. For example, `assert` statements
    could be added inside the `try` statement. Any exception raised by unexpected
    or invalid data will stop processing the given row of input.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以应用额外的清洗规则。例如，`assert`语句可以添加到`try`语句中。任何由意外或无效数据引发的异常都将停止处理给定输入行。
- en: 'Here''s the result of this initial `cleanse()` and `get()` processing:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始的`cleanse()`和`get()`处理的结果如下：
- en: '[PRE133]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In this example, we'll rank order by the `y` value of each pair. This requires
    sorting the data first, and then yielding the sorted values with an additional
    attribute value, the `y` rank order.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将按每对的`y`值进行排名。这需要首先对数据进行排序，然后产生排序后的值，并陦一个额外的属性值，即`y`排名顺序。
- en: How to do it...
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the enriched `namedtuple` :'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义丰富的`namedtuple`：
- en: '[PRE134]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Note that we've specifically included the original pair as a data item in this
    new data structure. We don't want to copy the individual fields; instead, we've
    incorporated the original object as a whole.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们特意在这个新的数据结构中将原始对作为数据项包含在内。我们不想复制各个字段；相反，我们将原始对象作为一个整体合并在一起。
- en: 'Define the enrichment function:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义丰富函数：
- en: '[PRE135]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: We've included type hints on this function to make it clear precisely what types
    are expected and returned by this enrichment function. We defined the type hints
    separately so that they're shorter and so that they can be reused in other functions.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个函数中包含了类型提示，以清楚地表明这个丰富函数期望和返回的类型。我们单独定义了类型提示，这样它们会更短，并且可以在其他函数中重复使用。
- en: 'Write the body of the enrichment. In this case, we''re going to be rank ordering,
    so we''ll need sorted data, using the original `y` attribute. We''re creating
    new objects from the old objects, so the function yields instances of `RankYDataPair`
    :'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写丰富的主体。在这种情况下，我们将进行排名排序，因此我们需要使用原始`y`属性进行排序。我们从旧对象创建新对象，因此函数会生成`RankYDataPair`的实例：
- en: '[PRE136]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We've used `enumerate()` to create the rank order numbers to each value. The
    starting value of `1` is sometimes handy for some statistical processing. In other
    cases, the default starting value of `0` will work out well.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`enumerate()`为每个值创建排名顺序号。对于一些统计处理来说，起始值为`1`有时很方便。在其他情况下，默认的起始值`0`也能很好地工作。
- en: 'Here''s the whole function:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数如下：
- en: '[PRE137]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: We can use this in a longer expression to get, cleanse, and then rank. The use
    of type hints can make this clearer than an alternative involving stateful objects.
    In some cases, there can be a very helpful improvement in the clarity of the code.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个更长的表达式中使用它来获取、清洗，然后排名。使用类型提示可以使这一点比涉及有状态对象的替代方案更清晰。在某些情况下，代码的清晰度可能会有很大的改进。
- en: How it works...
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The result of the `rank_by_y()` function is a new object which contains the
    original object, plus the result of the enrichment. Here''s how we''d use this
    stacked sequence of generators: `rank_by_y()` , `cleanse()` , and `get()` :'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`rank_by_y()`函数的结果是一个包含原始对象和丰富结果的新对象。这是我们如何使用这个堆叠的生成器序列的：`rank_by_y()`，`cleanse()`和`get()`：'
- en: '[PRE138]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The data is in ascending order by the `y` value. We can now use these enriched
    data values for further analysis and calculation.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 数据按`y`值升序排列。我们现在可以使用这些丰富的数据值进行进一步的分析和计算。
- en: Creating new objects can - in many cases - be more expressive of the algorithm
    than changing the state of objects. This is often a subjective judgement.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，创建新对象可能更能表达算法，而不是改变对象的状态。这通常是一个主观的判断。
- en: The Python type hints work best with the creation of new objects. Consequently,
    this technique can provide strong evidence that a complex algorithm is correct.
    Using `mypy` makes immutable objects more appealing.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型提示最适合用于创建新对象。因此，这种技术可以提供强有力的证据，证明复杂的算法是正确的。使用`mypy`可以使不可变对象更具吸引力。
- en: 'Finally, we may sometimes see a small speed-up when we use immutable objects.
    This relies on a balance between three features of Python to be effective:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们使用不可变对象时，有时会看到一些小的加速。这依赖于Python的三个特性之间的平衡才能有效：
- en: Tuples are small data structures. Using these can improve performance.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组是小型数据结构。使用它们可以提高性能。
- en: Any relationship between objects in Python involves creating an object reference,
    a data structure that's also very small. A number of related immutable objects
    might be smaller than a mutable object.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中对象之间的任何关系都涉及创建对象引用，这是一个非常小的数据结构。一系列相关的不可变对象可能比一个可变对象更小。
- en: Object creation can be costly. Creating too many immutable objects outweighs
    the benefits.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的创建可能是昂贵的。创建太多不可变对象会超过其好处。
- en: The memory savings from the first two features must be balanced against the
    processing cost from the third feature. Memory savings can lead to better performance
    when there's a huge volume of data that constrains processing speeds.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个功能带来的内存节省必须与第三个功能带来的处理成本相平衡。当存在大量数据限制处理速度时，内存节省可以带来更好的性能。
- en: For small examples like this one, the volume of data is so tiny that the object
    creation cost is large compared with any cost savings from reducing the volume
    of memory in use. For larger sets of data, the object creation cost may be less
    than the cost of running low on memory.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的小例子，数据量非常小，对象创建成本与减少内存使用量的任何成本节省相比都很大。对于更大的数据集，对象创建成本可能小于内存不足的成本。
- en: There's more...
  id: totrans-734
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `get()` and `cleanse()` functions in this recipe both refer to a similar
    data structure: `Iterable[List[str]]` and `Iterator[List[str]]` . In the `collections.abc`
    module, we see that `Iterable` is the generic definition, and `Iterator` is a
    special case of `Iterable` .'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的`get()`和`cleanse()`函数都涉及到类似的数据结构：`Iterable[List[str]]`和`Iterator[List[str]]`。在`collections.abc`模块中，我们看到`Iterable`是通用定义，而`Iterator`是`Iterable`的特殊情况。
- en: The `mypy` release used for this book—`mypy 0.2.0-dev` —is very particular about
    functions with the `yield` statement being defined as an `Iterator` . A future
    release may relax this strict check of the subclass relationship, allowing us
    to use one definition for both cases.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 用于本书的`mypy`版本——`mypy 0.2.0-dev`——对具有`yield`语句的函数被定义为`Iterator`非常严格。未来的版本可能会放宽对子类关系的严格检查，允许我们在两种情况下使用同一定义。
- en: 'The `typing` module includes an alternative to the `namedtuple()` function:
    `NamedTuple()` . This allows specification of a data type for the various items
    within the tuple.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块包括`namedtuple()`函数的替代品：`NamedTuple()`。这允许对元组中的各个项目进行数据类型的指定。'
- en: 'It looks like this:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是这样的：
- en: '[PRE139]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We use `typing.NamedTuple()` almost exactly the same way we use `collection.namedtuple()`
    . The definition of the attributes uses a list of two-tuples instead of a list
    of names. The two-tuples have a name and a type definition.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以像使用`collection.namedtuple()`一样使用`typing.NamedTuple()`。属性的定义使用了一个两元组的列表，而不是名称的列表。两元组有一个名称和一个类型定义。
- en: This supplemental type definition is used by `mypy` to determine whether the
    `NamedTuple` objects are being populated correctly. It can also be used by other
    people to understand the code and make proper modifications or extensions.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补充类型定义被`mypy`用来确定`NamedTuple`对象是否被正确填充。其他人也可以使用它来理解代码并进行适当的修改或扩展。
- en: In Python, we can replace some stateful objects with immutable objects. There
    are a number of limitations, though. The collections such as list, set, and dict,
    must remain as mutable objects. Replacing these collections with immutable monads
    can work out well in other programming languages, but it's not a part of Python.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以用不可变对象替换一些有状态的对象。但是有一些限制。例如，列表、集合和字典等集合必须保持为可变对象。在其他编程语言中，用不可变的单子替换这些集合可能效果很好，但在Python中不是这样的。
- en: '![](image/614271.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Writing recursive generator functions with the yield from statement
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用yield from语句编写递归生成器函数
- en: There are a number of algorithms that can be expressed neatly as recursions.
    In the *Designing recursive functions around Python's stack limits* recipe, we
    looked at some recursive functions that could be optimized to reduce the number
    of function calls.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法可以清晰地表达为递归。在*围绕Python的堆栈限制设计递归函数*配方中，我们看了一些可以优化以减少函数调用次数的递归函数。
- en: When we look at some data structures, we see that they involve recursion. In
    particular, JSON documents (as well as XML and HTML documents) can have a recursive
    structure. A JSON document might include a complex object that contains other
    complex objects within it.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看一些数据结构时，我们发现它们涉及递归。特别是，JSON文档（以及XML和HTML文档）可以具有递归结构。JSON文档可能包含一个包含其他复杂对象的复杂对象。
- en: In many cases, there are advantages to using generators for processing these
    kinds of structures. How can we write generators that work with recursion? How
    does the `yield from` statement save us from writing an extra loop?
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用生成器处理这些类型的结构有很多优势。我们如何编写能够处理递归的生成器？`yield from`语句如何避免我们编写额外的循环？
- en: Getting ready
  id: totrans-748
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll look at a way to search an ordered collection for all matching values
    in a complex data structure. When working with complex JSON documents, we'll often
    model them as dict-of-dict, and dict-of-list structures. Of course, a JSON document
    is not a two-level thing; dict-of-dict really means dict-of-dict-of.... Similarly,
    dict-of-list really means dict-of-list-of... These are recursive structures, which
    means a search must descend through the entire structure looking for a particular
    key or value.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一种在复杂数据结构中搜索有序集合的所有匹配值的方法。在处理复杂的JSON文档时，我们经常将它们建模为字典-字典和字典-列表结构。当然，JSON文档不是一个两级的东西；字典-字典实际上意味着字典-字典-字典...同样，字典-列表实际上意味着字典-列表-...这些都是递归结构，这意味着搜索必须遍历整个结构以寻找特定的键或值。
- en: 'A document with this complex structure might look like this:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种复杂结构的文档可能如下所示：
- en: '[PRE140]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This shows a document that has four keys, `field` , `field2` , `array` , and
    `object` . Each of these keys has a distinct data structure as its associated
    value. Some of the values are unique, and some are duplicated. This duplication
    is the reason why our search must find **all** instances inside the overall document.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个具有四个键`field`、`field2`、`array`和`object`的文档。每个键都有一个不同的数据结构作为其关联值。一些值是唯一的，一些是重复的。这种重复是我们的搜索必须在整个文档中找到**所有**实例的原因。
- en: The core algorithm is a depth-first search. The output from this function will
    be a list of paths that identify the target value. Each path will be a sequence
    of field names or field names mixed with index positions.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 核心算法是深度优先搜索。这个函数的输出将是一个标识目标值的路径列表。每个路径将是一系列字段名或字段名与索引位置混合的序列。
- en: 'In the previous example, the value `value` can be found in three places:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，值`value`可以在三个地方找到：
- en: '`["array", 0, "array_item_key1"]` : This path starts with the top-level field
    named `array` , then visits item zero of a list, then a field named `array_item_key1`'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`["array", 0, "array_item_key1"]`：这个路径从名为`array`的顶级字段开始，然后访问列表的第零项，然后是一个名为`array_item_key1`的字段'
- en: '`["field2"]` : This path has just a single field name where the value is found'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`["field2"]`：这个路径只有一个字段名，其中找到了值'
- en: '`["object", "attribute1"]` : This path starts with the top-level field named
    `object` , then the child `attribute1` of that field'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`["object", "attribute1"]`：这个路径从名为`object`的顶级字段开始，然后是该字段的子`attribute1`'
- en: 'The `find_value()` function yield both of these paths when it searches the
    overall document for the target value. Here''s the conceptual overview of this
    search function:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_value()`函数在搜索整个文档寻找目标值时，会产生这两个路径。这是这个搜索函数的概念概述：'
- en: '[PRE141]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'There are three alternatives in the `find_path()` process:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在`find_path()`过程中有三种选择：
- en: When the node is a dictionary, the value of each key must be examined. The values
    may be any kind of data, so we'll use the `find_path()` function recursively on
    each value. This will yield a sequence of matches.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当节点是一个字典时，必须检查每个键的值。值可以是任何类型的数据，因此我们将对每个值递归使用`find_path()`函数。这将产生一系列匹配。
- en: If node is a list, the items for each index position must be examined. The items
    may be any kind of data, so we'll use the `find_path()` function recursively on
    each value. This will yield a sequence of matches.
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点是一个列表，必须检查每个索引位置的项目。项目可以是任何类型的数据，因此我们将对每个值递归使用`find_path()`函数。这将产生一系列匹配。
- en: The other choice is for the node to be a primitive value. The JSON specification
    lists a number of primitives that may be present in a valid document. If the node
    value is the target value, we've found one instance, and can yield this single
    match.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种选择是节点是一个原始值。JSON规范列出了可能出现在有效文档中的许多原始值。如果节点值是目标值，我们找到了一个实例，并且可以产生这个单个匹配。
- en: 'There are two ways to handle the recursion. One is like this:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 处理递归有两种方法。一种是这样的：
- en: '[PRE142]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This seems to have too much boilerplate for such a simple idea. The other way
    is simpler and a bit clearer.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的想法来说，这似乎有太多的样板。另一种方法更简单，也更清晰一些。
- en: How to do it...
  id: totrans-767
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Write out the complete `for` statement:'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出完整的`for`语句：
- en: '[PRE143]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: For debugging purposes, we might insert a `print()` function inside the body
    of the `for` statement.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的，我们可以在`for`语句的主体中插入一个`print()`函数。
- en: 'Replace this with a `yield from` statement once we''re sure things work:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定事情运行正常，就用`yield from`语句替换这个：
- en: '[PRE144]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The complete depth-first `find_value()` search function will look like this:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的深度优先`find_value()`搜索函数将如下所示：
- en: '[PRE145]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'When we use the `find_path()` function, it looks like this:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`find_path()`函数时，它看起来像这样：
- en: '[PRE146]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The `find_path()` function is iterable. It can yield a number of values. We
    consumed all of the results to create a list. In this example, the list had one
    item, `['array', 1, 'array_item_key2']` . This item has the path to the matching
    item.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_path()`函数是可迭代的。它可以产生许多值。我们消耗了所有的结果来创建一个列表。在这个例子中，列表只有一个项目，`[''array'',
    1, ''array_item_key2'']`。这个项目有指向匹配项的路径。'
- en: We can then evaluate `document['array'][1]['array_item_key2']` to find the referenced
    value.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以评估`document['array'][1]['array_item_key2']`来找到被引用的值。
- en: 'When we look for a non-unique value, we might see a list like this:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们寻找非唯一值时，我们可能会看到这样的列表：
- en: '[PRE147]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The resulting list has three items. Each of these provides the path to an item
    with the target value of `value` .
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 结果列表有三个项目。每个项目都提供了指向目标值`value`的路径。
- en: How it works...
  id: totrans-782
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `yield from X` statement is shorthand for:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from X`语句是以下内容的简写：'
- en: '[PRE148]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This lets us write a succinct recursive algorithm that will behave as an iterator
    and properly yield multiple values.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够编写一个简洁的递归算法，它将作为迭代器运行，并正确地产生多个值。
- en: This can also be used in contexts that don't involve a recursive function. It's
    entirely sensible to use a `yield from` statement anywhere that an iterable result
    is involved. It's a big simplification for recursive functions, however, because
    it preserves a clearly recursive structure.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在不涉及递归函数的情况下使用。在涉及可迭代结果的任何地方使用`yield from`语句都是完全合理的。然而，对于递归函数来说，这是一个很大的简化，因为它保留了一个明确的递归结构。
- en: There's more...
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another common style of definition assembles a list using append operations.
    We can rewrite this into an iterator and avoid the overhead of building a list
    object.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的定义风格是使用追加操作组装列表。我们可以将这个重写为迭代器，避免构建列表对象的开销。
- en: 'When factoring a number, we can define the set of prime factors like this:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 当分解一个数字时，我们可以这样定义质因数集：
- en: '![There''s more...](Image00026.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](Image00026.jpg)'
- en: If the value, *x* , is prime, it has only itself in the set of prime factors.
    Otherwise, there must be some prime number, *n* , which is the least factor of
    *x* . We can assemble a set of factors starting with *n* and including all factors
    of *x/n* . In order to be sure that only prime factors are found, then *n* must
    be prime. If we search in ascending order, we'll find prime factors before finding
    composite factors.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值*x*是质数，它在质因数集中只有自己。否则，必须存在某个质数*n*，它是*x*的最小因数。我们可以从*n*开始组装一个因数集，并包括*x/n*的所有因数。为了确保只找到质因数，*n*必须是质数。如果我们按升序搜索，我们会在找到复合因数之前找到质因数。
- en: 'We have two ways to implement this in Python: one builds a list, the other
    generates factors. Here''s a list-building function:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法在Python中实现这个：一种是构建一个列表，另一种是生成因数。这是一个构建列表的函数：
- en: '[PRE149]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This `factor_list()` function will search all numbers, *n* , such that 2 ≤ *n*
    < √ *x* . The first number that's a factor of *x* will be the least factor. It
    will also be prime. We'll—of course—search a number of composite values, wasting
    time. For example, after testing two and three, we'll also test values for line
    four and six, even though they're composite and all of their factors have already
    been tested.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`factor_list()`函数将搜索所有数字*n*，使得2 ≤ *n* < √ *x*。找到*x*的第一个因子的数字将是最小的因子。它也将是质数。当然，我们会搜索一些复合值，浪费时间。例如，在测试了二和三之后，我们还将测试四和六这样的值，尽管它们是复合数，它们的所有因子都已经被测试过了。
- en: This function builds a `list` object. If a factor, `n` , is found, it will start
    a list with that factor. It will append factors from `x // n` . If there are no
    factors of `x` , then the value is prime, and we return a list with just that
    value.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数构建了一个`list`对象。如果找到一个因子`n`，它将以该因子开始一个列表。它将从`x // n`添加因子。如果没有`x`的因子，那么这个值是质数，我们将返回一个只包含该值的列表。
- en: 'We can rewrite this to be an iterator by replacing the recursive calls with
    `yield from` . The function will look like this:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用`yield from`替换递归调用来将其重写为迭代器。函数将看起来像这样：
- en: '[PRE150]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: As with the list-building version, this will search numbers, *n* , such that
    . When a factor is found, then the function will yield the factor, followed by
    any other factors found by a recursive call to `factor_iter()` . If no factors
    are found, the function will yield just the prime number and nothing more.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建列表版本一样，这将搜索数字*n*，使得。当找到一个因子时，函数将产生该因子，然后通过对`factor_iter()`的递归调用找到任何其他因子。如果没有找到因子，函数将只产生质数，没有其他东西。
- en: 'Using an iterator allows us to build any kind of collection from the factors.
    Instead of being limited to always creating a *list* , we can create a multiset
    using the `collection.Counter` class. It would look like this:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迭代器可以让我们从因子构建任何类型的集合。我们不再局限于总是创建一个*list*，而是可以使用`collection.Counter`类创建一个多重集。它看起来像这样：
- en: '[PRE151]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'This shows us that:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明：
- en: 384 = 2⁷ × 3
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 384 = 2⁷ × 3
- en: In some cases, this kind of multiset is easier to work with than the list of
    factors.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种多重集比因子列表更容易处理。
- en: See also
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Designing recursive functions around Python's stack limits* recipe,
    we cover the core design patterns for recursive functions. This recipe provides
    an alternative way to create the results.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*围绕Python的堆栈限制设计递归函数*的配方中，我们涵盖了递归函数的核心设计模式。这个配方提供了创建结果的另一种方法。
