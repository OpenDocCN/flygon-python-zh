- en: Chapter 5. Interacting with Remote Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。与远程系统交互
- en: 'If your computer is connected to the Internet or a **local area network** (**LAN**),
    then it''s time to talk to the other computers on the network. In a typical home,
    office, or campus LAN, you will find that many different types of computers are
    connected to the network. Some computers act as the servers for specific services,
    such as a file server, a print server, a user authentication management server,
    and so on. In this chapter, we will explore how the computers in a network can
    interact with each other and how they can access a few services through the Python
    scripts. The following task list will give you an overview of the topics that
    will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机连接到互联网或**局域网**（**LAN**），那么现在是时候与网络上的其他计算机进行通信了。在典型的家庭、办公室或校园局域网中，您会发现许多不同类型的计算机连接到网络上。一些计算机充当特定服务的服务器，例如文件服务器、打印服务器、用户认证管理服务器等。在本章中，我们将探讨网络中的计算机如何相互交互以及如何通过Python脚本访问一些服务。以下任务列表将为您提供本章涵盖的主题的概述：
- en: Accessing SSH terminals with `paramiko`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`paramiko`访问SSH终端
- en: Transferring files through SFTP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SFTP传输文件
- en: Transferring files with the help of FTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过FTP传输文件
- en: Reading the SNMP packets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读SNMP数据包
- en: Reading the LDAP packets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读LDAP数据包
- en: Sharing the files with the help of SAMBA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SAMBA共享文件
- en: 'This chapter requires quite a few third-party packages, such as `paramiko`,
    `pysnmp`, and so on. You can use your operating system''s package management tool
    for installing them. Here''s a quick how-to on installing the `paramiko` module
    in Ubuntu 14, python3, and the other modules that are required for understanding
    the topics covered in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章需要一些第三方软件包，如`paramiko`、`pysnmp`等。您可以使用操作系统的软件包管理工具进行安装。以下是在Ubuntu 14、python3中安装`paramiko`模块以及本章涵盖的其他主题的理解所需的其他模块的快速操作指南：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Secure shell – access using Python
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行安全外壳访问
- en: 'SSH has become a very popular network protocol for performing secure data communication
    between two computers. It provides an excellent cryptographic support, so that
    unrelated third-parties cannot see the content of the data during the transmission
    process. Details of the SSH protocol can be found in these RFC documents: RFC4251-RFC4254,
    available at [http://www.rfc-editor.org/rfc/rfc4251.txt](http://www.rfc-editor.org/rfc/rfc4251.txt).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SSH已经成为一种非常流行的网络协议，用于在两台计算机之间进行安全数据通信。它提供了出色的加密支持，使得无关的第三方在传输过程中无法看到数据的内容。SSH协议的详细信息可以在这些RFC文档中找到：RFC4251-RFC4254，可在[http://www.rfc-editor.org/rfc/rfc4251.txt](http://www.rfc-editor.org/rfc/rfc4251.txt)上找到。
- en: 'Python''s `paramiko` library provides a very good support for the SSH-based
    network communication. You can use Python scripts to benefit from the advantages
    of SSH-based remote administration, such as the remote command-line login, command
    execution, and the other secure network services between two networked computers.
    You may also be interested in using the `pysftp` module, which is based on `paramiko`.
    More details regarding this package can be found at PyPI: [https://pypi.python.org/pypi/pysftp/](https://pypi.python.org/pypi/pysftp/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`paramiko`库为基于SSH的网络通信提供了非常好的支持。您可以使用Python脚本来从SSH-based远程管理中获益，例如远程命令行登录、命令执行以及两台网络计算机之间的其他安全网络服务。您可能还对使用基于`paramiko`的`pysftp`模块感兴趣。有关此软件包的更多详细信息可以在PyPI上找到：[https://pypi.python.org/pypi/pysftp/](https://pypi.python.org/pypi/pysftp/)。
- en: The SSH is a client/server protocol. Both of the parties use the SSH key pairs
    to encrypt the communication. Each key pair has one private and one public key.
    The public key can be published to anyone who may be interested in that. The private
    key is always kept private and secure from everyone except the owner of the key.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SSH是一种客户端/服务器协议。双方都使用SSH密钥对加密通信。每个密钥对都有一个私钥和一个公钥。公钥可以发布给任何可能感兴趣的人。私钥始终保持私密，并且除了密钥所有者之外，不允许任何人访问。
- en: The SSH public and private keys can be generated and digitally signed by an
    external or an internal certificate authority. But that brings a lot of overhead
    to a small organization. So, alternatively, the keys can be generated randomly
    by utility tools, such as `ssh-keygen`. The public key needs to be available to
    all participating parties. When the SSH client connects to the server for the
    first time, it registers the public key of the server on a special file called
    `~/.ssh/known_hosts` file. So, the subsequent connection to the server ensures
    that the client is talking to the same server as it spoke to before. On the server
    side, if you would like to restrict access to certain clients who have certain
    IP addresses, then the public keys of the permitted hosts can be stored to another
    special file called `ssh_known_hosts` file. Of course, if you re-build the machines,
    such as the server machine, then the old public key of the server won't match
    with that of the one stored in the `~/.ssh/known_hosts` file. So, the SSH client
    will raise an exception and prevent you from connecting to it. You can delete
    the old key from that file and then try to re-connect, as if for the first time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SSH公钥和私钥可以由外部或内部证书颁发机构生成并进行数字签名。但这给小型组织带来了很多额外开销。因此，作为替代，可以使用`ssh-keygen`等实用工具随机生成密钥。公钥需要提供给所有参与方。当SSH客户端首次连接到服务器时，它会在一个名为`~/.ssh/known_hosts`的特殊文件上注册服务器的公钥。因此，随后连接到服务器可以确保客户端与之前通话的是同一台服务器。在服务器端，如果您希望限制对具有特定IP地址的某些客户端的访问，则可以将允许主机的公钥存储到另一个名为`ssh_known_hosts`的特殊文件中。当然，如果重新构建机器，例如服务器机器，那么服务器的旧公钥将与`~/.ssh/known_hosts`文件中存储的公钥不匹配。因此，SSH客户端将引发异常并阻止您连接到它。您可以从该文件中删除旧密钥，然后尝试重新连接，就像第一次一样。
- en: We can use the `paramiko` module to create an SSH client and then connect it
    to the SSH server. This module will supply the `SSHClient()` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`paramiko`模块创建一个SSH客户端，然后将其连接到SSH服务器。这个模块将提供`SSHClient()`类。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, the instance of this client class will reject the unknown host keys.
    So, you can set up a policy for accepting the unknown host keys. The built-in
    `AutoAddPolicy()` class will add the host keys as and when they are discovered.
    Now, you need to run the `set_missing_host_key_policy()` method along with the
    following argument on the `ssh_client` object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此客户端类的实例将拒绝未知的主机密钥。因此，您可以设置接受未知主机密钥的策略。内置的`AutoAddPolicy()`类将在发现时添加主机密钥。现在，您需要在`ssh_client`对象上运行`set_missing_host_key_policy()`方法以及以下参数。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If, you want to restrict connecting only to certain hosts, then you can define
    your own policy and replace it with the `AutoAddPolicy()` class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要限制仅连接到某些主机，那么您可以定义自己的策略并将其替换为`AutoAddPolicy()`类。
- en: You may also be interested in adding the system host keys by using the `load_system_host_keys()`
    method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望使用`load_system_host_keys()`方法添加系统主机密钥。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, we have discussed how to encrypt the connection. However, SSH needs
    your authentication credentials. This means that the client needs to prove to
    the server that a specific user is talking, not someone else. This can be done
    in a few ways. The simplest way is by using the username and the password combination.
    Another popular way is by using the key-based authentication method. This means
    that the user's public key can be copied to the server. There's a specific tool
    for doing that. This comes with the later versions of the SSH. Here's an example
    of how to use `ssh-copy-id`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何加密连接。然而，SSH需要您的身份验证凭据。这意味着客户端需要向服务器证明特定用户在交谈，而不是其他人。有几种方法可以做到这一点。最简单的方法是使用用户名和密码组合。另一种流行的方法是使用基于密钥的身份验证方法。这意味着用户的公钥可以复制到服务器上。有一个专门的工具可以做到这一点。这是随后版本的SSH附带的。以下是如何使用`ssh-copy-id`的示例。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command will copy the SSH public key of the faruq user to a machine, `debian6box.localdomain.loc`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将faruq用户的SSH公钥复制到`debian6box.localdomain.loc`机器：
- en: Here, we can simply call the `connect()` method along with the target hostname
    and the SSH login credentials. To run any command on the target host, we need
    to invoke the `exec_command()` method by passing the command as its argument.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以简单地调用`connect()`方法以及目标主机名和SSH登录凭据。要在目标主机上运行任何命令，我们需要通过将命令作为其参数来调用`exec_command()`方法。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code listing shows how to do SSH login to a target host and then
    run a simple `ls` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码清单显示了如何对目标主机进行SSH登录，然后运行简单的`ls`命令：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before running it, we need to ensure that the SSH server daemon is running
    on the target host (which in this case is the localhost). As shown in the following
    screenshot, we can use the `netstat` command for doing that. This command will
    show all the running services that are listening to a particular port:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，我们需要确保目标主机（在本例中为本地主机）上运行SSH服务器守护程序。如下面的截图所示，我们可以使用`netstat`命令来执行此操作。此命令将显示所有监听特定端口的运行服务：
- en: '![Secure shell – access using Python](graphics/6008OS_05_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![使用Python访问安全外壳](graphics/6008OS_05_01.jpg)'
- en: 'The preceding script will make an SSH connection to the localhost and the run
    the `ls -l /dev/` command. The output of this script will be similar to the following
    screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本将与本地主机建立SSH连接，然后运行`ls -l /dev/`命令。此脚本的输出将类似于以下截图：
- en: '![Secure shell – access using Python](graphics/6008OS_05_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![使用Python访问安全外壳](graphics/6008OS_05_02.jpg)'
- en: Inspecting the SSH packets
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查SSH数据包
- en: 'It would be very interesting to see the network packet exchange between the
    client and the server. We can use either the native `tcpdump` command or the third-party
    Wireshark tool to capture network packets. With `tcpdump`, you can specify the
    target network interface ( `-i lo`) and the port number (port `22`) options. In
    the following packet capture session, five packet exchanges have been shown during
    an SSH client/server communication session:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 看到客户端和服务器之间的网络数据包交换将会非常有趣。我们可以使用本机`tcpdump`命令或第三方Wireshark工具来捕获网络数据包。使用`tcpdump`，您可以指定目标网络接口（`-i
    lo`）和端口号（端口`22`）选项。在以下数据包捕获会话中，在SSH客户端/服务器通信会话期间显示了五次数据包交换：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although, it''s very quick and easy to run `tcpdump`, the command does not
    interpret it in the same way as the other GUI tools, such as Wireshark, interpret
    it. The preceding session can be captured in Wireshark, as shown in the following
    screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`tcpdump`非常快速和简单，但该命令不会像其他GUI工具（如Wireshark）那样解释它。前面的会话可以在Wireshark中捕获，如下面的截图所示：
- en: '![Inspecting the SSH packets](graphics/6008OS_05_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![检查SSH数据包](graphics/6008OS_05_03.jpg)'
- en: This clearly shows how the first three packets complete the TCP handshake process.
    Then, the subsequent SSH packets negotiate the connection between the client and
    the server. It's interesting to see how the client and the server negotiate the
    encryption protocols. In this example, the client port is `50768` and the server
    port is `22`. The client first initiates the SSH packet exchange and then indicates
    that it would like to talk over the `SSHv2` protocol. Then, the server agrees
    on that and continues the packet exchange.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地显示了前三个数据包如何完成TCP握手过程。然后，随后的SSH数据包协商了客户端和服务器之间的连接。看到客户端和服务器如何协商加密协议是很有趣的。在这个例子中，客户端端口是`50768`，服务器端口是`22`。客户端首先启动SSH数据包交换，然后指示它想要使用`SSHv2`协议进行通信。然后，服务器同意并继续数据包交换。
- en: Transferring files through SFTP
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过SFTP传输文件
- en: SSH can be used effectively for securely transferring files between two computer
    nodes. The protocol used in this case is the **secure file transfer protocol**
    (**SFTP**). The Python `paramiko` module will supply the classes required for
    creating the SFTP session. This session can then perform a regular SSH login.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SSH可以有效地用于在两个计算机节点之间安全地传输文件。在这种情况下使用的协议是**安全文件传输协议**（**SFTP**）。Python的`paramiko`模块将提供创建SFTP会话所需的类。然后，此会话可以执行常规的SSH登录。
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The SFTP session can be created from the SSH transport. The paramiko's working
    in the SFTP session will support the normal FTP commands such as `get()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SFTP会话可以从SSH传输中创建。paramiko在SFTP会话中的工作将支持诸如`get()`之类的正常FTP命令。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, the SFTP `get` command requires the source file''s path and
    the target file''s path. In the following example, the script will download a
    `test.txt` file, which is located on the user''s home directory, through SFTP:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，SFTP的`get`命令需要源文件的路径和目标文件的路径。在下面的示例中，脚本将通过SFTP下载位于用户主目录中的`test.txt`文件：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, a file has been downloaded with the help of SFTP. Notice, how
    `paramiko` has created the SFTP session by using the `SFTPClient.from_transport(ssh_transport)`
    class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用SFTP下载了一个文件。请注意，`paramiko`使用`SFTPClient.from_transport(ssh_transport)`类创建了SFTP会话。
- en: The script can be run as shown in the following screenshot. Here, we will first
    create a temporary file called `/tmp/test.txt`, then complete the SSH login, and
    then download that file by using SFTP. Lastly, we will check the content of the
    file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以按照以下截图所示运行。在这里，我们将首先创建一个名为`/tmp/test.txt`的临时文件，然后完成SSH登录，然后使用SFTP下载该文件。最后，我们将检查文件的内容。
- en: '![Transferring files through SFTP](graphics/6008OS_05_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![通过SFTP传输文件](graphics/6008OS_05_04.jpg)'
- en: Transferring files with FTP
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FTP传输文件
- en: Unlike SFTP, FTP uses the plain-text file transfer method. This means any username
    or password transferred through the wire can be detected by an unrelated third-party.
    Even though FTP is a very popular file transfer protocol, people frequently use
    this for transferring a file from their PCs to the remote servers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与SFTP不同，FTP使用明文文件传输方法。这意味着通过网络传输的任何用户名或密码都可以被不相关的第三方检测到。尽管FTP是一种非常流行的文件传输协议，但人们经常使用它将文件从他们的个人电脑传输到远程服务器。
- en: In Python, `ftplib` is a built-in module used for transferring the files to
    and from the remote machines. You can create an anonymous FTP client connection
    with the `FTP()` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`ftplib`是一个用于在远程机器之间传输文件的内置模块。您可以使用`FTP()`类创建一个匿名FTP客户端连接。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then you can invoke the normal FTP commands, such as `CWD`. In order to download
    a binary file, you need to create a file-handler such as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以调用正常的FTP命令，例如`CWD`。为了下载二进制文件，您需要创建一个文件处理程序，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to retrieve the binary file from the remote host, the syntax shown
    here can be used along with the `RETR` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从远程主机检索二进制文件，可以使用此处显示的语法以及`RETR`命令：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following code snippet, an example of a full FTP file download can be
    seen:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，可以看到完整的FTP文件下载示例：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code illustrates how an anonymous FTP can be downloaded from [ftp.kernel.org](http://ftp.kernel.org),
    which is the official website that hosts the Linux kernel. The `FTP()` class takes
    three arguments, such as the initial filesystem path on the remote server, the
    username, and the email address of the `ftp` user. For anonymous downloads, no
    username and password is required. So, the script can be downloaded from the `tftp-hpa-0.11.tar.gz`
    file, which can be found on the `/pub/software/network/tftp` path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码说明了如何从[ftp.kernel.org](http://ftp.kernel.org)下载匿名FTP，这是托管Linux内核的官方网站。`FTP()`类接受三个参数，如远程服务器上的初始文件系统路径、用户名和`ftp`用户的电子邮件地址。对于匿名下载，不需要用户名和密码。因此，可以从`/pub/software/network/tftp`路径上找到的`tftp-hpa-0.11.tar.gz`文件中下载脚本。
- en: Inspecting FTP packets
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查FTP数据包
- en: 'If we capture the FTP session in Wireshark on port `21` of the public network
    interface, then we can see how the communication happens in plain-text. This will
    show you why SFTP should be preferred. In the following figure, we can see that,
    after successfully establishing connection with a client the server sends the
    banner message: `220` Welcome to kernel.org. Following this, the client will anonymously
    send a request for login. In response, the server will ask for a password. The
    client can send the user''s e-mail address for authentication.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在公共网络接口的端口`21`上在Wireshark中捕获FTP会话，那么我们可以看到通信是如何以明文形式进行的。这将向您展示为什么应该优先使用SFTP。在下图中，我们可以看到，在成功与客户端建立连接后，服务器发送横幅消息:`220`
    欢迎来到kernel.org。随后，客户端将匿名发送登录请求。作为回应，服务器将要求密码。客户端可以发送用户的电子邮件地址进行身份验证。
- en: '![Inspecting FTP packets](graphics/6008OS_05_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: 检查FTP数据包
- en: To your surprise, you can see that the password has been sent in clear-text.
    In the following screenshot, the contents of the password packet have been displayed.
    It shows the supplied fake e-mail address, `nobody@nourl.com`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，您会发现密码已经以明文形式发送。在下面的截图中，显示了密码数据包的内容。它显示了提供的虚假电子邮件地址`nobody@nourl.com`。
- en: '![Inspecting FTP packets](graphics/6008OS_05_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![检查FTP数据包](graphics/6008OS_05_06.jpg)'
- en: Fetching Simple Network Management Protocol data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取简单网络管理协议数据
- en: SNMP is a ubiquitous network protocol that is used by the network routers, such
    as switches, servers, and so on, for communicating the device's configuration,
    performance data, and the commands that are meant for the control devices. Although
    SNMP starts with the word *simple*, it's not a simple protocol. Internally, each
    device's information is stored in a sort of a database of information called the
    **management information base** (**MIB**). The SNMP protocol offers varying levels
    of security depending on the protocol version number. In SNMP `v1` and `v2c`,
    the data is protected by a pass phrase known as the community string. In SNMP
    `v3`, a username and a password are required for storing the data. And, the data
    can be encrypted with the help of SSL. In our example, we will use the `v1` and
    `v2c` versions of the SNMP protocol.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP是一种广泛使用的网络协议，用于网络路由器（如交换机、服务器等）通信设备的配置、性能数据和控制设备的命令。尽管SNMP以“简单”一词开头，但它并不是一个简单的协议。在内部，每个设备的信息都存储在一种称为**管理信息库**（**MIB**）的信息数据库中。SNMP协议根据协议版本号提供不同级别的安全性。在SNMP
    `v1`和`v2c`中，数据受到称为community字符串的密码短语的保护。在SNMP `v3`中，需要用户名和密码来存储数据。并且，数据可以通过SSL进行加密。在我们的示例中，我们将使用SNMP协议的`v1`和`v2c`版本。
- en: 'SNMP is a client/server-based network protocol. The server daemon provides
    the requested information to the clients. In your machine, if SNMP has been installed
    and configured properly, then you can use the `snmpwalk` utility command to query
    the basic system information by using the following syntax:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP是一种基于客户端/服务器的网络协议。服务器守护程序向客户端提供请求的信息。在您的计算机上，如果已安装和配置了SNMP，则可以使用`snmpwalk`实用程序命令通过以下语法查询基本系统信息：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding command will show the MIB number and its values.
    For example, the MIB number `iso.3.6.1.2.1.1.1.0` shows that it''s a string type
    value, such as `Linux debian6box 2.6.32-5-686 #1 SMP Tue May 13 16:33:32 UTC 2014
    i686`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '上述命令的输出将显示MIB编号及其值。例如，MIB编号`iso.3.6.1.2.1.1.1.0`显示它是一个字符串类型的值，如`Linux debian6box
    2.6.32-5-686 #1 SMP Tue May 13 16:33:32 UTC 2014 i686`。'
- en: In Python, you can use a third-party library called `pysnmp` for interfacing
    with the `snmp` daemon. You can install the `pysnmp` module by using pip.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，您可以使用一个名为`pysnmp`的第三方库来与`snmp`守护程序进行交互。您可以使用pip安装`pysnmp`模块。
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This module provides a useful wrapper for the `snmp` commands. Let's learn how
    to create an `snmpwalk` command. To begin, import a command generator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块为`snmp`命令提供了一个有用的包装器。让我们学习如何创建一个`snmpwalk`命令。首先，导入一个命令生成器。
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then define the necessary default values for the connection assuming that the
    `snmpd` daemon has been running on port `161` of the local machine and the community
    string has been set to public.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后假定`snmpd`守护程序在本地机器的端口`161`上运行，并且community字符串已设置为public，定义连接的必要默认值。
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now invoke the `getCmd()` method with the help of the necessary data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用必要的数据调用`getCmd()`方法。
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can see that `cmdgen` takes the following parameters:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`cmdgen`接受以下参数：
- en: '`CommunityData()`: Set the community string as public.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommunityData()`: 将community字符串设置为public。'
- en: '`UdpTransportTarget()`: This is the host target, where the `snmp` agent is
    running. This is specified in a pair of the hostname and the UDP port.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UdpTransportTarget()`: 这是主机目标，`snmp`代理正在运行的地方。这是由主机名和UDP端口组成的一对。'
- en: '`MibVariable`: This is a tuple of values that includes the MIB version number
    and the MIB target string (which in this case is `sysDescr`; this refers to the
    description of the system).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MibVariable`: 这是一个值元组，包括MIB版本号和MIB目标字符串（在本例中为`sysDescr`；这是指系统的描述）。'
- en: The output of this command consists of a four-value tuple. Out of those, three
    are related to the errors returned by the command generator, and the fourth one
    is related to the actual variables that bind the returned data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出由一个四值元组组成。其中三个与命令生成器返回的错误有关，第四个与绑定返回数据的实际变量有关。
- en: 'The following example shows how the preceding method can be used for fetching
    the SNMP host description string from a running SNMP daemon:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用前面的方法从运行的SNMP守护程序中获取SNMP主机描述字符串：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After running the preceding example, an output similar to the following will
    appear:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述示例后，将出现类似以下的输出：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inspecting SNMP packets
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查SNMP数据包
- en: 'We can inspect the SNMP packet by capturing the packets on port 161 of your
    network interface. If the server is running locally, then listening on the `loopbook`
    interface is sufficient. The `snmp-get` request format and the `snmp-get` response
    packet formats, which are produced by Wireshak, is shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过捕获网络接口的端口161上的数据包来检查SNMP数据包。如果服务器在本地运行，则仅需监听`loopbook`接口即可。Wireshak生成的`snmp-get`请求格式和`snmp-get`响应数据包格式如下截图所示：
- en: '![Inspecting SNMP packets](graphics/6008OS_05_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![检查SNMP数据包](graphics/6008OS_05_07.jpg)'
- en: 'In response to the SNMP get request from the client, an SNMP get response will
    be generated by the server. This can be seen in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对客户端的SNMP获取请求的响应，服务器将生成一个SNMP获取响应。这可以在以下截图中看到：
- en: '![Inspecting SNMP packets](graphics/6008OS_05_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![检查SNMP数据包](graphics/6008OS_05_08.jpg)'
- en: Reading Light-weight Directory Access Protocol data
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取轻量级目录访问协议数据
- en: LDAP has been used for a long time for accessing and managing distributed directory
    information. This is an application level protocol that works over the IP network.
    Directory service is heavily used in organizations for managing the information
    about the users, the computer systems, the networks, the applications, and so
    on. The LDAP protocol contains plenty of technical jargon. It is a client/server-based
    protocol. So, the LDAP client will make a request to a properly configured LDAP
    server. After initializing the LDAP connection, the connection will need to be
    authenticated by using a few parameters. A simple BIND operation will establish
    an LDAP session. In a simple case, you can set up a simple anonymous BIND that
    would not need no password or any other credentials.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，LDAP一直被用于访问和管理分布式目录信息。这是一个在IP网络上运行的应用级协议。目录服务在组织中被广泛用于管理有关用户、计算机系统、网络、应用程序等信息。LDAP协议包含大量的技术术语。它是基于客户端/服务器的协议。因此，LDAP客户端将向正确配置的LDAP服务器发出请求。在初始化LDAP连接后，连接将需要使用一些参数进行身份验证。简单的绑定操作将建立LDAP会话。在简单情况下，您可以设置一个简单的匿名绑定，不需要密码或其他凭据。
- en: 'If you a run a simple LDAP query with the help of `ldapsearch`, then you will
    see results such as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`ldapsearch`运行简单的LDAP查询，那么您将看到如下结果：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding communication can be captured with the help of Wireshark. You
    need to capture the packets on port 389\. As shown in the following screenshot,
    the LDAP client-server communication will be established after a `bindRequest`
    has been successfully sent. It's not secure to communicate anonymously with the
    LDAP server. For the sake of simplicity, in the following example the search has
    been done without binding with any of the credentials.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的通信可以通过Wireshark来捕获。您需要在端口389上捕获数据包。如下截图所示，在成功发送`bindRequest`之后，LDAP客户端-服务器通信将建立。以匿名方式与LDAP服务器通信是不安全的。为了简单起见，在下面的示例中，搜索是在不绑定任何凭据的情况下进行的。
- en: '![Reading Light-weight Directory Access Protocol data](graphics/6008OS_05_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![阅读轻量级目录访问协议数据](graphics/6008OS_05_09.jpg)'
- en: The Python's third-party `python-ldap` package provides the necessary functionality
    for interacting with an LDAP server. You can install this package with the help
    of `pip`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python的第三方`python-ldap`软件包提供了与LDAP服务器交互所需的功能。您可以使用`pip`安装此软件包。
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To begin with, you will have to initialize the LDAP connection:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要初始化LDAP连接：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then the following code will show how a simple BIND operation can be performed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以下代码将展示如何执行简单的绑定操作：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then you can perform an ldap search. It requires you to specify the necessary
    parameters, such as base DN, filter, and attributes. Here is an example of the
    syntax that is required for searching for the users on an LDAP server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以执行LDAP搜索。您需要指定必要的参数，如基本DN、过滤器和属性。以下是在LDAP服务器上搜索用户所需的语法示例：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is a complete example for finding user information by using the LDAP protocol:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用LDAP协议查找用户信息的完整示例：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code will search the LDAP directory subtree with the `ou=users,dc=localdomain,dc=loc`
    base `DN` and the `[sn]` attributes. The search is limited to the person objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将搜索LDAP目录子树，使用`ou=users,dc=localdomain,dc=loc`基本`DN`和`[sn]`属性。搜索限定为人员对象。
- en: Inspecting LDAP packets
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查LDAP数据包
- en: If we analyze the communication between the LDAP client and the server, then
    we can see the format of the LDAP search request and response. The parameters
    that we have used in our code have a direct relationship with the `searchRequest`
    section of an LDAP packet. As shown in the following screenshot produced by Wireshark,
    it contains data, such as `baseObject`, `scope` and `Filter`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析LDAP客户端和服务器之间的通信，我们可以看到LDAP搜索请求和响应的格式。我们在我们的代码中使用的参数与LDAP数据包的`searchRequest`部分有直接关系。如Wireshark生成的以下截图所示，它包含数据，如`baseObject`、`scope`和`Filter`。
- en: '![Inspecting LDAP packets](graphics/6008OS_05_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![检查LDAP数据包](graphics/6008OS_05_10.jpg)'
- en: 'The LDAP search request generates a server response, which has been shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP搜索请求生成服务器响应，如下所示：
- en: '![Inspecting LDAP packets](graphics/6008OS_05_11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![检查LDAP数据包](graphics/6008OS_05_11.jpg)'
- en: When the LDAP server returns the search response, we can see the format of the
    response. As shown in the preceding screenshot, it contains the result of the
    search and the associated attributes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当LDAP服务器返回搜索响应时，我们可以看到响应的格式。如前面的截图所示，它包含了搜索结果和相关属性。
- en: 'Here is an example of searching a user from an LDAP server:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从LDAP服务器搜索用户的示例：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In a properly configured LDAP machine, the preceding script will return a result
    that will be similar to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确配置的LDAP机器中，前面的脚本将返回类似以下的结果：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sharing files with SAMBA
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SAMBA共享文件
- en: In a LAN environment, you will often need to share the files between different
    types of machines, such as Windows and Linux machines. The protocol used for sharing
    the files and the printers among these machines is either the **Server Message
    Block** (**SMB**) protocol or its enhanced version called the **Common Internet
    File System** (**CIFS**) protocol. CIFS runs over TCP/IP and it is used by the
    SMB clients and servers. In Linux, you will find a package called Samba, which
    implements the `SMB` protocol.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在局域网环境中，您经常需要在不同类型的机器之间共享文件，例如Windows和Linux机器。用于在这些机器之间共享文件和打印机的协议是**服务器消息块**（**SMB**）协议或其增强版本称为**公共互联网文件系统**（**CIFS**）协议。CIFS运行在TCP/IP上，由SMB客户端和服务器使用。在Linux中，您会发现一个名为Samba的软件包，它实现了`SMB`协议。
- en: 'If you are running a Linux virtual machine within a Windows box with the help
    of software, such as VirtualBox, then we can test file sharing among the Windows
    and the Linux machines. Let us create a folder at `C:\share` on the Windows machine
    as you can see in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows框中运行Linux虚拟机，并借助软件（如VirtualBox）进行文件共享测试，则可以在Windows机器上创建一个名为`C:\share`的文件夹，如下屏幕截图所示：
- en: '![Sharing files with SAMBA](graphics/6008OS_05_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用SAMBA共享文件](graphics/6008OS_05_12.jpg)'
- en: 'Now, right-click on the folder and then go to the **Sharing** tab. There are
    two buttons: **Share** and **Advanced sharing**. You can click on the latter and
    it will open the advanced sharing dialog box. Now you can adjust the share permissions.
    If this share is active, then you will be able to see this share from your Linux
    virtual machine. If you run the following command on your Linux box, then you
    will see the previously defined file-share:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键单击文件夹，然后转到**共享**选项卡。有两个按钮：**共享**和**高级共享**。您可以单击后者，它将打开高级共享对话框。现在您可以调整共享权限。如果此共享处于活动状态，则您将能够从Linux虚拟机中看到此共享。如果在Linux框中运行以下命令，则将看到先前定义的文件共享：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following screenshot shows how you can share a folder under Windows 7 as
    discussed previously:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何在Windows 7下共享文件夹，如前所述：
- en: '![Sharing files with SAMBA](graphics/6008OS_05_13.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用SAMBA共享文件](graphics/6008OS_05_13.jpg)'
- en: 'The preceding file share can be accessed from your Python script by using a
    third-party module called `pysmb`. You can use the `pip` command-line tool for
    installing `pysmb`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用第三方模块`pysmb`从Python脚本访问前面的文件共享。您可以使用`pip`命令行工具安装`pysmb`：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This module provides an `SMBConnection` class, where you can pass the necessary
    parameters for accessing an SMB/CIFS share. For example, the following code will
    help you to access a file-share:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块提供了一个`SMBConnection`类，您可以通过该类传递必要的参数来访问SMB/CIFS共享。例如，以下代码将帮助您访问文件共享：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the preceding works, then the following assertion will be true:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的工作正常，则以下断言将为真：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can list the shared files by using the `listShares()` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`listShares()`方法列出共享文件：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you can use the `tmpfile` module copying a file from your windows share.
    For example, if you create a file in the `C:\Share\test.rtf` path, then the additional
    code shown here will copy that file by using the SMB protocol:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以使用`tmpfile`模块从Windows共享复制文件。例如，如果您在`C:\Share\test.rtf`路径中创建一个文件，则以下附加代码将使用SMB协议复制该文件：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we put the entire code into a single source file, then it will look like
    the following listing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将整个代码放入单个源文件中，它将如下所示：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inspecting SAMBA packets
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查SAMBA数据包
- en: 'If we capture the SMABA packets on port `445`, then we can see how the Windows
    Server communicates with the Linux SAMBA client over the CIFS protocol. In the
    following two screenshots, a detailed communication between the client and the
    server, has been presented. The connection setup has been shown in the following
    screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在端口`445`上捕获SMABA数据包，则可以看到Windows服务器如何通过CIFS协议与Linux SAMBA客户端进行通信。在以下两个屏幕截图中，已呈现了客户端和服务器之间的详细通信。连接设置如下截图所示：
- en: '![Inspecting SAMBA packets](graphics/6008OS_05_14.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![检查SAMBA数据包](graphics/6008OS_05_14.jpg)'
- en: 'The following screenshot shows how a file copy session is performed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何执行文件复制会话：
- en: '![Inspecting SAMBA packets](graphics/6008OS_05_15.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![检查SAMBA数据包](graphics/6008OS_05_15.jpg)'
- en: 'A typical SAMBA packet format has been shown in the following screenshot. The
    important field of this packet is the `NT_STATUS` field. Typically, if the connection
    is successful, then it will show `STATUS_SUCESS`. Otherwise, it will print a different
    code. This is shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了典型的SAMBA数据包格式。此数据包的重要字段是`NT_STATUS`字段。通常，如果连接成功，则会显示`STATUS_SUCESS`。否则，它将打印不同的代码。如下屏幕截图所示：
- en: '![Inspecting SAMBA packets](graphics/6008OS_05_16.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![检查SAMBA数据包](graphics/6008OS_05_16.jpg)'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have come across several network protocols and Python libraries,
    which are used for interacting with remote systems. SSH and SFTP are used for
    securely connecting and transferring files to the remote hosts. FTP is still used
    as a simple file transfer mechanism. However, it's not secure due to user credentials
    being transferred over the wire as plain-text. We also examined Python libraries
    for dealing with SNMP, LDAP, and SAMBA packets.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经接触了几种网络协议和Python库，用于与远程系统进行交互。SSH和SFTP用于安全连接和传输文件到远程主机。FTP仍然用作简单的文件传输机制。但是，由于用户凭据以明文形式传输，因此不安全。我们还研究了处理SNMP、LDAP和SAMBA数据包的Python库。
- en: In the next chapter, one of the most common networking protocols—that is, DNS
    and IP—will be discussed. We will explore TCP/IP networking using Python scripts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将讨论最常见的网络协议之一，即DNS和IP。我们将使用Python脚本探索TCP/IP网络。
