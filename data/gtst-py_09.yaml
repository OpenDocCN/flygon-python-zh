- en: Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: A tree is a hierarchical form of data structure. When we dealt with lists, queues,
    and stacks, items followed each other. But in a tree, there is a *parent-child*
    relationship between items.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种分层的数据结构。当我们处理列表、队列和栈时，项目是相互跟随的。但在树中，项目之间存在着*父子*关系。
- en: To visualize what trees look like, imagine a tree growing up from the ground.
    Now remove that image from your mind. Trees are normally drawn downward, so you
    would be better off imagining the root structure of the tree growing downward.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形象化树的外观，想象一棵树从地面长出。现在把这个形象从你的脑海中移除。树通常是向下绘制的，所以你最好想象树的根结构向下生长。
- en: At the top of every tree is the so-called *root node*. This is the ancestor
    of all other nodes in the tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在每棵树的顶部是所谓的*根节点*。这是树中所有其他节点的祖先。
- en: Trees are used for a number of things, such as parsing expressions, and searches.
    Certain document types, such as XML and HTML, can also be represented in a tree
    form. We shall look at some of the uses of trees in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 树被用于许多事情，比如解析表达式和搜索。某些文档类型，如XML和HTML，也可以以树形式表示。在本章中，我们将看一些树的用途。
- en: 'In this chapter, we will cover the following areas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下领域：
- en: Terms and definitions of trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的术语和定义
- en: Binary trees and binary search trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树和二叉搜索树
- en: Tree traversal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的遍历
- en: Terminology
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Let's consider some terms associated with trees.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些与树相关的术语。
- en: To understand trees, we need to first understand the basic ideas on which they
    rest. The following figure contains a typical tree consisting of character nodes
    lettered **A** through to **M**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解树，我们首先需要理解它们所依赖的基本思想。下图包含了一个典型的树，由字母A到M的字符节点组成。
- en: '![](assets/ecea614b-c914-4a6d-a097-aa3b3f11da67.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ecea614b-c914-4a6d-a097-aa3b3f11da67.png)'
- en: 'Here is a list of terms associated with a Tree:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与树相关的术语列表：
- en: '**Node**: Each circled alphabet represents a node. A node is any structure
    that holds data.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：每个圈起来的字母代表一个节点。节点是任何包含数据的结构。'
- en: '**Root node**: The root node is the only node from which all other nodes come.
    A tree with an undistinguishable root node cannot be considered as a tree. The
    root node in our tree is the node A.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**：根节点是所有其他节点都来自的唯一节点。一个没有明显根节点的树不能被认为是一棵树。我们树中的根节点是节点A。'
- en: '**Sub-tree**: A sub-tree of a tree is a tree with its nodes being a descendant
    of some other tree. Nodes F, K, and L form a sub-tree of the original tree consisting
    of all the nodes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子树**：树的子树是一棵树，其节点是另一棵树的后代。节点F、K和L形成了原始树的子树，包括所有节点。'
- en: '**Degree**: The number of sub-trees of a given node. A tree consisting of only
    one node has a degree of 0\. This one tree node is also considered as a tree by
    all standards. The degree of node A is 2.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度**：给定节点的子树数。只有一个节点的树的度为0。这个单个树节点也被所有标准视为一棵树。节点A的度为2。'
- en: '**Leaf node**: This is a node with a degree of 0\. Nodes J, E, K, L, H, M,
    and I are all leaf nodes.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**：这是一个度为0的节点。节点J、E、K、L、H、M和I都是叶节点。'
- en: '**Edge**: The connection between two nodes. An edge can sometimes connect a
    node to itself, making the edge appear as a loop.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：两个节点之间的连接。有时边可以将一个节点连接到自身，使边看起来像一个循环。'
- en: '**Parent**: A node in the tree with other connecting nodes is the parent of
    those nodes. Node B is the parent of nodes D, E, and F.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**：树中具有其他连接节点的节点是这些节点的父节点。节点B是节点D、E和F的父节点。'
- en: '**Child**: This is a node connected to its parent. Nodes B and C are children
    of node A, the parent and root node.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**：这是一个连接到其父节点的节点。节点B和C是节点A的子节点和根节点。'
- en: '**Sibling**: All nodes with the same parent are siblings. This makes the nodes
    B and C siblings.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟节点**：所有具有相同父节点的节点都是兄弟节点。这使得节点B和C成为兄弟节点。'
- en: '**Level**: The level of a node is the number of connections from the root node.
    The root node is at level 0\. Nodes B and C are at level 1.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别**：节点的级别是从根节点到节点的连接数。根节点位于级别0。节点B和C位于级别1。'
- en: '**Height of a tree**: This is the number of levels in a tree. Our tree has
    a height of 4.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树的高度**：这是树中的级别数。我们的树的高度为4。'
- en: '**Depth**: The depth of a node is the number of edges from the root of the
    tree to that node. The depth of node H is 2.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：节点的深度是从树的根到该节点的边数。节点H的深度为2。'
- en: We shall begin our treatment of trees by considering the node in a tree and
    abstracting a class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从考虑树中的节点并抽象一个类开始对树的处理。
- en: Tree nodes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树节点
- en: Just as was the case with other data structures that we encountered, such as
    lists and stacks, trees are built up of nodes. But the nodes that make up a tree
    need to contain data about the parent-child relationship that we mentioned earlier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们遇到的其他数据结构一样，如列表和栈，树是由节点构建而成的。但构成树的节点需要包含我们之前提到的关于父子关系的数据。
- en: 'Let us now look at how to build a binary tree `node` class in Python:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在Python中构建一个二叉树`node`类：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just like in our previous implementations, a node is a container for data and
    holds references to other nodes. Being a binary tree node, these references are
    to the left and the right children.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们以前的实现一样，一个节点是一个包含数据并持有对其他节点的引用的容器。作为二叉树节点，这些引用是指左右子节点。
- en: 'To test this class out, we first create a few nodes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，我们首先创建了一些节点：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we connect the nodes to each other. We let `n1` be the root node with
    `n2` and `n3` as its children. Finally, we hook `n4` as the left child to `n2`,
    so that we get a few iterations when we traverse the left sub-tree:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点连接到彼此。我们让`n1`成为根节点，`n2`和`n3`成为它的子节点。最后，我们将`n4`作为`n2`的左子节点连接，这样当我们遍历左子树时，我们会得到一些迭代：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have our tree structure set up, we are ready to traverse it. As mentioned
    previously, we shall traverse the left sub-tree. We print out the node and move
    down the tree to the next left node. We keep doing this until we have reached
    the end of the left sub-tree:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置好了树的结构，我们就准备好遍历它了。如前所述，我们将遍历左子树。我们打印出节点并向下移动树到下一个左节点。我们一直这样做，直到我们到达左子树的末尾：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you will probably have noticed, this requires quite a bit of work in the
    client code, as you have to manually build up the tree structure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这需要客户端代码中相当多的工作，因为你必须手动构建树结构。
- en: Binary trees
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: A binary tree is one in which each node has a maximum of two children. Binary
    trees are very common and we shall use them to build up a BST implementation in
    Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是每个节点最多有两个子节点的树。二叉树非常常见，我们将使用它们来构建Python中的BST实现。
- en: 'The following figure is an example of a binary tree with 5 being the root node:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是一个以5为根节点的二叉树的示例：
- en: '![](assets/24dfae79-0a28-407a-af32-db8491f991a7.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/24dfae79-0a28-407a-af32-db8491f991a7.jpg)'
- en: Each child is identified as being the right or left child of its parent. Since
    the parent node is also a node by itself, each node will hold a reference to a
    right and left node even if the nodes do not exist.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子节点都被标识为其父节点的右子节点或左子节点。由于父节点本身也是一个节点，即使节点不存在，每个节点也会保存对右子节点和左子节点的引用。
- en: A regular binary tree has no rules as to how elements are arranged in the tree.
    It only satisfies the condition that each node should have a maximum of two children.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 常规二叉树没有关于如何排列树中元素的规则。它只满足每个节点最多有两个子节点的条件。
- en: Binary search trees
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: A **binary search tree** (**BST**) is a special kind of a binary tree. That
    is, it is a tree that is structurally a binary tree. Functionally, it is a tree
    that stores its nodes in such a way to be able to search through the tree efficiently.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树**（BST）是一种特殊类型的二叉树。也就是说，它在结构上是一棵二叉树。在功能上，它是一棵以一种能够高效搜索树的方式存储其节点的树。'
- en: 'There is a structure to a BST. For a given node with a value, all the nodes
    in the left sub-tree are less than or equal to the value of that node. Also, all
    the nodes in the right sub-tree of this node are greater than that of the parent
    node. As an example, consider the following tree:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BST有一种结构。对于具有值的给定节点，左子树中的所有节点都小于或等于该节点的值。此外，该节点的右子树中的所有节点都大于父节点的值。例如，考虑以下树：
- en: '![](assets/c7916505-4ac0-48c2-af08-e7759443935c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c7916505-4ac0-48c2-af08-e7759443935c.png)'
- en: 'This is an example of a BST. Testing our tree for the properties of a BST,
    you realize that all the nodes in the left sub-tree of the root node have a value
    less than 5\. Likewise, all the nodes in the right sub-tree have a value that
    is greater than 5\. This property applies to all the nodes in a BST, with no exceptions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是BST的一个示例。测试我们的树是否具有BST的属性，你会意识到根节点左子树中的所有节点的值都小于5。同样，右子树中的所有节点的值都大于5。这个属性适用于BST中的所有节点，没有例外：
- en: '![](assets/1d79ef04-0fb1-4ad6-ac1b-adcfbb3ab621.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d79ef04-0fb1-4ad6-ac1b-adcfbb3ab621.png)'
- en: Despite the fact that the preceding figure looks similar to the previous figure,
    it does not qualify as a BST. Node 7 is greater than the root node 5; however,
    it is located to the left of the root node. Node 4 is to the right sub-tree of
    its parent node 7, which is incorrect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的图看起来与之前的图相似，但它并不符合BST的条件。节点7大于根节点5；然而，它位于根节点的左侧。节点4位于其父节点7的右子树中，这是不正确的。
- en: Binary search tree implementation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树实现
- en: 'Let us begin our implementation of a BST. We will want the tree to hold a reference
    to its own root node:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现BST。我们希望树能够保存对其自己根节点的引用：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's all that is needed to maintain the state of a tree. Let's examine the
    main operations on the tree in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是维护树状态所需的全部内容。让我们在下一节中检查树上的主要操作。
- en: Binary search tree operations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树操作
- en: There are essentially two operations that are needful for having a usable BST.
    These are the `insert` and `remove` operations. These operations must occur with
    the one rule that they must maintain the principle that gives the BST its structure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两个操作对于使用BST是必要的。这些是“插入”和“删除”操作。这些操作必须遵循一个规则，即它们必须保持给BST赋予结构的原则。
- en: Before we tackle the insertion and removal of nodes, let's discuss some equally
    important operations that will help us better understand the `insert` and `remove`
    operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理节点的插入和删除之前，让我们讨论一些同样重要的操作，这些操作将帮助我们更好地理解“插入”和“删除”操作。
- en: Finding the minimum and maximum nodes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最小和最大节点
- en: The structure of the BST makes looking for the node with the maximum and minimum
    values very easy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: BST的结构使得查找具有最大和最小值的节点非常容易。
- en: 'To find the node with smallest value, we start our traversal from the root
    of the tree and visit the left node each time we reach a sub-tree. We do the opposite
    to find the node with the biggest value in the tree:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到具有最小值的节点，我们从树的根开始遍历，并在到达子树时每次访问左节点。我们做相反的操作来找到树中具有最大值的节点：
- en: '![](assets/c229180d-2172-4729-bdfb-c90772604353.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c229180d-2172-4729-bdfb-c90772604353.png)'
- en: We move down from node 6 to 3 to 1 to get to the node with smallest value. Likewise,
    we go down 6, 8 to node 10, which is the node with the largest value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从节点6到3到1向下移动，以找到具有最小值的节点。同样，我们向下移动6、8到节点10，这是具有最大值的节点。
- en: This same means of finding the minimum and maximum nodes applies to sub-trees
    too. The minimum node in the sub-tree with root node 8 is 7\. The node within
    that sub-tree with the maximum value is 10.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查找最小和最大节点的相同方法也适用于子树。具有根节点8的子树中的最小节点是7。该子树中具有最大值的节点是10。
- en: 'The method that returns the minimum node is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回最小节点的方法如下：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `while` loop continues to get the left node and visits it until the last
    left node points to `None`. It is a very simple method. The method to return the
    maximum node does the opposite, where `current.left_child` now becomes `current.right_child`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环继续获取左节点并访问它，直到最后一个左节点指向`None`。这是一个非常简单的方法。返回最大节点的方法相反，其中`current.left_child`现在变为`current.right_child`。'
- en: It takes **O**(*h*) to find the minimum or maximum value in a BST, where *h*
    is the height of the tree.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在BST中查找最小值或最大值需要**O**(*h*)，其中*h*是树的高度。
- en: Inserting nodes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入节点
- en: One of the operations on a BST is the need to insert data as nodes. Whereas
    in our first implementation, we had to insert the nodes ourselves, here we are
    going to let the tree be in charge of storing its data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: BST的操作之一是需要将数据插入为节点。在我们的第一个实现中，我们必须自己插入节点，但在这里，我们将让树负责存储其数据。
- en: In order to make a search possible, the nodes must be stored in a specific way.
    For each given node, its left child node will hold data that is less than its
    own value, as already discussed. That node's right child node will hold data greater
    than that of its parent node.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使搜索成为可能，节点必须以特定的方式存储。对于每个给定的节点，其左子节点将保存小于其自身值的数据，如前所述。该节点的右子节点将保存大于其父节点的数据。
- en: We are going to create a new BST of integers by starting with the data 5\. To
    do this, we will create a node with its data attribute set to 5.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用数据5来创建一个新的整数BST。为此，我们将创建一个数据属性设置为5的节点。
- en: 'Now, to add the second node with value 3, 3 is compared with 5, the root node:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要添加值为3的第二个节点，3与根节点5进行比较：
- en: '![](assets/d212c46e-6046-4151-bb46-cf1ed26e4051.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d212c46e-6046-4151-bb46-cf1ed26e4051.jpg)'
- en: 'Since 5 is greater than 3, it will be put in the left sub-tree of node 5\.
    Our BST will look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于5大于3，它将放在节点5的左子树中。我们的BST将如下所示：
- en: '![](assets/0e1ead82-8fb4-4ae6-a8de-d0b1578f7bf9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0e1ead82-8fb4-4ae6-a8de-d0b1578f7bf9.jpg)'
- en: The tree satisfies the BST rule, where all the nodes in the left sub-tree are
    less than its parent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 树满足BST规则，左子树中的所有节点都小于其父节点。
- en: 'To add another node of value 7 to the tree, we start from the root node with
    value 5 and do a comparison:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要向树中添加值为7的另一个节点，我们从值为5的根节点开始比较：
- en: '![](assets/b0225066-e12d-48d9-8d42-cd8da6f62f91.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0225066-e12d-48d9-8d42-cd8da6f62f91.jpg)'
- en: Since 7 is greater than 5, the node with value 7 is situated to the right of
    this root.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于7大于5，值为7的节点位于此根节点的右侧。
- en: What happens when we want to add a node that is equal to an existing node? We
    will simply add it as a left node and maintain this rule throughout the structure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要添加一个等于现有节点的节点时会发生什么？我们将简单地将其添加为左节点，并在整个结构中保持此规则。
- en: If a node already has a child in the place where the new node goes, then we
    have to move down the tree and attach it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点已经有一个子节点在新节点应该放置的位置，那么我们必须沿着树向下移动并将其附加。
- en: 'Let''s add another node with value 1\. Starting from the root of the tree,
    we do a comparison between 1 and 5:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个值为1的节点。从树的根开始，我们比较1和5：
- en: '![](assets/13de8d9e-97ba-4834-9756-cf31e34a95eb.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13de8d9e-97ba-4834-9756-cf31e34a95eb.jpg)'
- en: 'The comparison reveals that 1 is less than 5, so we move our attention to the
    left node of 5, which is the node with value 3:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 比较表明1小于5，因此我们将注意力转向5的左节点，即值为3的节点：
- en: '![](assets/3621290e-d166-4e10-9c5f-824992152daa.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3621290e-d166-4e10-9c5f-824992152daa.png)'
- en: 'We compare 1 with 3 and since 1 is less than 3, we move a level below node
    3 and to its left. But there is no node there. Therefore, we create a node with
    the value 1 and associate it with the left pointer of node 3 to obtain the following
    structure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将1与3进行比较，由于1小于3，我们向下移动到节点3的下一级并向左移动。但那里没有节点。因此，我们创建一个值为1的节点，并将其与节点3的左指针关联，以获得以下结构：
- en: '![](assets/e9c6c705-4546-4627-9866-f3c30baf1fae.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9c6c705-4546-4627-9866-f3c30baf1fae.jpg)'
- en: So far, we have been dealing only with nodes that contain only integers or numbers.
    For numbers, the idea of greater than and lesser than are clearly defined. Strings
    would be compared alphabetically, so there are no major problems there either.
    But if you want to store your own custom data types inside a BST, you would have
    to make sure that your class supports ordering.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理包含整数或数字的节点。对于数字，大于和小于的概念是清晰定义的。字符串将按字母顺序比较，因此在那里也没有太大的问题。但是，如果您想在BST中存储自定义数据类型，您必须确保您的类支持排序。
- en: 'Let''s now create a function that enables us to add data as nodes to the BST.
    We begin with a function declaration:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个函数，使我们能够将数据作为节点添加到BST中。我们从函数声明开始：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By now, you will be used to the fact that we encapsulate the data in a node.
    This way, we hide away the `node` class from the client code, who only needs to
    deal with the tree:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经习惯了我们将数据封装在节点中的事实。这样，我们将`node`类隐藏在客户端代码中，客户端代码只需要处理树：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A first check will be to find out whether we have a root node. If we don''t,
    the new node becomes the root node (we cannot have a tree without a root node):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查是否有根节点。如果没有，新节点将成为根节点（我们不能没有根节点的树）：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we walk down the tree, we need to keep track of the current node we are
    working on, as well as its parent. The variable `current` is always used for this
    purpose:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们沿着树走时，我们需要跟踪我们正在处理的当前节点以及其父节点。变量`current`始终用于此目的：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we must perform a comparison. If the data held in the new node is less
    than the data held in the current node, then we check whether the current node
    has a left child node. If it doesn''t, this is where we insert the new node. Otherwise,
    we keep traversing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须进行比较。如果新节点中保存的数据小于当前节点中保存的数据，则我们检查当前节点是否有左子节点。如果没有，这就是我们插入新节点的地方。否则，我们继续遍历：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we take care of the greater than or equal case. If the current node doesn''t
    have a right child node, then the new node is inserted as the right child node.
    Otherwise, we move down and continue looking for an insertion point:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理大于或等于的情况。如果当前节点没有右子节点，则新节点将插入为右子节点。否则，我们继续向下移动并继续寻找插入点：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Insertion of a node in a BST takes **O**(*h*), where h is the height of the
    tree.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在BST中插入一个节点需要**O**(*h*)，其中*h*是树的高度。
- en: Deleting nodes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: 'Another important operation on a BST is the `deletion` or `removal` of nodes.
    There are three scenarios that we need to cater for during this process. The node
    that we want to remove might have the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: BST上的另一个重要操作是节点的`删除`或`移除`。在此过程中，我们需要考虑三种情况。我们要删除的节点可能有以下情况：
- en: No children
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有子节点
- en: One child
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个子节点
- en: Two children
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个子节点
- en: 'The first scenario is the easiest to handle. If the node about to be removed
    has no children, we simply detach it from its parent:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是最容易处理的。如果要删除的节点没有子节点，我们只需将其与其父节点分离：
- en: '![](assets/226a56a7-c9ba-47f9-b04b-e7cd9aff5349.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/226a56a7-c9ba-47f9-b04b-e7cd9aff5349.png)'
- en: Because node A has no children, we will simply dissociate it from its parent,
    node Z.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为节点A没有子节点，所以我们只需将其与其父节点节点Z分离。
- en: 'On the other hand, when the node we want to remove has one child, the parent
    of that node is made to point to the child of that particular node:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们想要删除的节点有一个子节点时，该节点的父节点将指向该特定节点的子节点：
- en: '![](assets/b0c13358-279e-485a-8d1f-1ea43fe7e18e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0c13358-279e-485a-8d1f-1ea43fe7e18e.png)'
- en: In order to remove node 6, which has as its only child, node 5, we point the
    left pointer of node 9 to node 5\. The relationship between the parent node and
    child has to be preserved. That is why we need to take note of how the child node
    is connected to its parent (which is the node about to be deleted). The child
    node of the deleted node is stored. Then we connect the parent of the deleted
    node to that child node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除只有一个子节点节点5的节点6，我们将节点9的左指针指向节点5。父节点和子节点之间的关系必须得到保留。这就是为什么我们需要注意子节点如何连接到其父节点（即要删除的节点）。存储要删除节点的子节点。然后我们将要删除节点的父节点连接到该子节点。
- en: 'A more complex scenario arises when the node we want to delete has two children:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要删除的节点有两个子节点时，会出现一个更复杂的情况：
- en: '![](assets/42141387-d400-4f4b-8ea8-774c2df6d9f0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/42141387-d400-4f4b-8ea8-774c2df6d9f0.png)'
- en: We cannot simply replace node 9 with either node 6 or 13\. What we need to do
    is to find the next biggest descendant of node 9\. This is node 12\. To get to
    node 12, we move to the right node of node 9\. And then move left to find the
    leftmost node. Node 12 is called the in-order successor of node 9\. The second
    step resembles the move to find the maximum node in a sub-tree.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地用节点6或13替换节点9。我们需要找到节点9的下一个最大后代。这是节点12。要到达节点12，我们移动到节点9的右节点。然后向左移动以找到最左节点。节点12被称为节点9的中序后继。第二步类似于查找子树中的最大节点。
- en: We replace the value of node 9 with the value 12 and remove node 12\. In removing
    node 12, we end up with a simpler form of node removal that has been addressed
    previously. Node 12 has no children, so we apply the rule for removing nodes without
    children accordingly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用节点9的值替换节点9的值，并删除节点12。删除节点12后，我们得到了一个更简单的节点删除形式，这已经在之前进行过处理。节点12没有子节点，因此我们相应地应用删除没有子节点的节点的规则。
- en: 'Our `node` class does not have reference to a parent. As such, we need to use
    a helper method to search for and return the node with its parent node. This method
    is similar to the `search` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`node`类没有父引用。因此，我们需要使用一个辅助方法来搜索并返回具有其父节点的节点。该方法类似于`search`方法：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only difference is that before we update the current variable inside the
    loop, we store its parent with `parent = current`. The method to do the actual
    removal of a node begins with this search:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，在我们更新循环内的当前变量之前，我们使用`parent = current`存储其父级。执行实际删除节点的方法始于这个搜索：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We pass the parent and the found node to `parent` and `node` respectively with
    the line `parent, node = self.get_node_with_parent(data)`. It is helpful to know
    the number of children that the node we want to delete has. That is the purpose
    of the `if` statement.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将父节点和找到的节点传递给`parent`和`node`，代码为`parent, node = self.get_node_with_parent(data)`。了解要删除的节点有多少子节点是有帮助的。这就是`if`语句的目的。
- en: 'After this, we need to begin handling the various conditions under which a
    node can be deleted. The first part of the `if` statement handles the case where
    the node has no children:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要开始处理节点可以被删除的各种条件。`if`语句的第一部分处理节点没有子节点的情况：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`if parent:` is used to handle cases where there is a BST that has only one
    node in the whole of the three.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`if parent:` 用于处理只有一个节点的BST的情况。'
- en: 'In the case where the node about to be deleted has only one child, the `elif`
    part of the `if` statement does the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在要删除的节点只有一个子节点的情况下，`if`语句的`elif`部分执行以下操作：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`next_node` is used to keep track of where the single node pointed to by the
    node we want to delete is. We then connect `parent.left_child` or `parent.right_child`
    to `next_node`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_node`用于跟踪节点指向的单个节点的位置。然后我们将`parent.left_child`或`parent.right_child`连接到`next_node`。'
- en: 'Lastly, we handle the condition where the node we want to delete has two children:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理了要删除的节点有两个子节点的情况：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In finding the in-order successor, we move to the right node with `leftmost_node
    = node.right_child`. As long as there exists a left node, `leftmost_node.left_child`
    will evaluate to `True` and the `while` loop will run. When we get to the leftmost
    node, it will either be a leaf node (meaning that it will have no child node)
    or have a right child.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找中序后继时，我们使用`leftmost_node = node.right_child`移动到右节点。只要存在左节点，`leftmost_node.left_child`将计算为`True`，`while`循环将运行。当我们到达最左节点时，它要么是叶节点（意味着它没有子节点），要么有一个右子节点。
- en: 'We update the node about to be removed with the value of the in-order successor
    with `node.data = leftmost_node.data`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`node.data = leftmost_node.data`更新即将被移除的节点的值：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding statement allows us to properly attach the parent of the leftmost
    node with any child node. Observe how the right-hand side of the equals sign stays
    unchanged. That is because the in-order successor can only have a right child
    as its only child.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的陈述使我们能够正确地将最左节点的父节点与任何子节点正确连接。请注意等号右侧保持不变。这是因为中序后继只能有一个右子节点作为其唯一子节点。
- en: The `remove` operation takes **O**(*h*), where h is the height of the tree.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`操作的时间复杂度为**O**(*h*),其中*h*是树的高度。'
- en: Searching the tree
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索树
- en: 'Since the `insert` method organizes data in a specific way, we will follow
    the same procedure to find the data. In this implementation, we will simply return
    the data if it was found or `None` if the data wasn''t found:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`insert`方法以特定方式组织数据，我们将遵循相同的过程来查找数据。在这个实现中，如果找到了数据，我们将简单地返回数据，如果没有找到数据，则返回`None`：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to start searching at the very top, that is, at the root node:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从最顶部开始搜索，也就是从根节点开始：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We may have passed a leaf node, in which case the data doesn''t exist in the
    tree and we return `None` to the client code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经经过了一个叶节点，这种情况下数据不存在于树中，我们将返回`None`给客户端代码：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We might also have found the data, in which case we return it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能已经找到了数据，这种情况下我们会返回它：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As per the rules for how data is stored in the BST, if the data we are searching
    for is less than that of the current node, we need to go down the tree to the
    left:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据BST中数据存储的规则，如果我们正在搜索的数据小于当前节点的数据，我们需要向树的左侧移动：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we only have one option left: the data we are looking for is greater than
    the data held in the current node, which means we go down the tree to the right:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下一个选择：我们正在寻找的数据大于当前节点中保存的数据，这意味着我们需要向树的右侧移动：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we can write some client code to test how the BST works. We create
    a tree and insert a few numbers between 1 and 10\. Then we search for all the
    numbers in that range. The ones that exist in the tree get printed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写一些客户端代码来测试BST的工作原理。我们创建一棵树，并在1到10之间插入一些数字。然后我们搜索该范围内的所有数字。存在于树中的数字将被打印出来：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tree traversal
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的遍历
- en: Visiting all the nodes in a tree can be done depth first or breadth first. These
    modes of traversal are not peculiar to only binary search trees but trees in general.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 访问树中的所有节点可以通过深度优先或广度优先完成。这种遍历方式不仅适用于二叉搜索树，而是适用于树的一般情况。
- en: Depth-first traversal
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先遍历
- en: In this traversal mode, we follow a branch (or edge) to its limit before recoiling
    upwards to continue traversal. We will be using the recursive approach for the
    traversal. There are three forms of depth-first traversal, namely `in-order`,
    `pre-order`, and `post-order`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历方式中，我们会在向上继续遍历之前，沿着一个分支（或边）到达其极限。我们将使用递归方法进行遍历。深度优先遍历有三种形式，即`中序`、`前序`和`后序`。
- en: In-order traversal and infix notation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中序遍历和中缀表示法
- en: 'Most of us are probably used to this way of representing an arithmetic expression,
    since this is the way we are normally taught in schools. The operator is inserted
    (infixed) between the operands, as in `3 + 4`. When necessary, parentheses can
    be used to build a more complex expression: `(4 + 5) * (5 - 3)`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人可能习惯用这种方式表示算术表达式，因为这是我们通常在学校里学到的方式。操作符被插入（中缀）在操作数之间，如`3 + 4`。必要时，可以使用括号来构建更复杂的表达式：`(4
    + 5) * (5 - 3)`。
- en: In this mode of traversal, you would visit the left sub-tree, the parent node,
    and finally the right sub-tree.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历方式中，您将访问左子树、父节点，最后是右子树。
- en: 'The recursive function to return an in-order listing of nodes in a tree is
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回树中节点的中序列表的递归函数如下：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We visit the node by printing the node and making two recursive calls with `current.left_child`
    and `current.right_child`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印节点并使用`current.left_child`和`current.right_child`进行两次递归调用来访问节点。
- en: Pre-order traversal and prefix notation
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前序遍历和前缀表示法
- en: 'Prefix notation is commonly referred to as Polish notation. Here, the operator
    comes before its operands, as in `+ 3 4`. Since there is no ambiguity of precedence,
    parentheses are not required: `* + 4 5 - 5 3`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示法通常被称为波兰表示法。在这里，操作符在其操作数之前，如`+ 3 4`。由于没有优先级的歧义，因此不需要括号：`* + 4 5 - 5 3`。
- en: To traverse a tree in pre-order mode, you would visit the node, the left sub-tree,
    and the right sub-tree node, in that order.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要以前序方式遍历树，您将按照节点、左子树和右子树节点的顺序访问。
- en: Prefix notation is well known to LISP programmers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示法是LISP程序员所熟知的。
- en: 'The recursive function for this traversal is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此遍历的递归函数如下：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the order in which the recursive call is made.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意递归调用的顺序。
- en: Post-order traversal and postfix notation.
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后序遍历和后缀表示法。
- en: 'Postfix or **reverse Polish notation** (**RPN**) places the operator after
    its operands, as in `3 4 +`. As is the case with Polish notation, there is never
    any confusion over the precedence of operators, so parentheses are never needed:
    `4 5 + 5 3 - *`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀或**逆波兰表示法**（**RPN**）将操作符放在其操作数之后，如`3 4 +`。与波兰表示法一样，操作符的优先级永远不会引起混淆，因此不需要括号：`4
    5 + 5 3 - *`。
- en: In this mode of traversal, you would visit the left sub-tree, the right sub-tree,
    and lastly the root node.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种遍历方式中，您将访问左子树、右子树，最后是根节点。
- en: 'The `post-order` method is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`后序遍历`方法如下：'
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Breadth-first traversal
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: 'This kind of traversal starts from the root of a tree and visits the node from
    one level of the tree to the other:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历方式从树的根开始，并从树的一个级别访问节点到另一个级别：
- en: '![](assets/798e2ee2-65c7-4c0a-bfea-165a880ed447.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/798e2ee2-65c7-4c0a-bfea-165a880ed447.png)'
- en: The node at level 1 is node 4\. We visit this node by printing out its value.
    Next, we move to level 2 and visit the nodes on that level, which are nodes 2
    and 8\. On the last level, level 3, we visit nodes 1, 3, 5, and 10.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第1级的节点是节点4。我们通过打印其值来访问此节点。接下来，我们移动到第2级并访问该级别上的节点，即节点2和8。在最后一级，第3级，我们访问节点1、3、5和10。
- en: The complete output of such a traversal is 4, 2, 8, 1, 3, 5, and 10.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历的完整输出是4、2、8、1、3、5和10。
- en: This mode of traversal is made possible by using a queue data structure. Starting
    with the root node, we push it into a queue. The node at the front of the queue
    is accessed (dequeued) and either printed and stored for later use. The left node
    is added to the queue followed by the right node. Since the queue is not empty,
    we repeat the process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历模式是通过使用队列数据结构实现的。从根节点开始，我们将其推入队列。队列前端的节点被访问（出队），然后打印并存储以备后用。左节点被添加到队列中，然后是右节点。由于队列不为空，我们重复这个过程。
- en: A dry run of the algorithm will enqueue the root node 4, dequeue, and access,
    or visit the node. Nodes 2 and 8 are enqueued as they are the left and right nodes
    respectively. Node 2 is dequeued in order to be visited. Its left and right nodes,
    1 and 3, are enqueued. At this point, the node at the front of the queue is 8\.
    We dequeue and visit node 8, after which we enqueue its left and right nodes.
    So the process continues until the queue is empty.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的干运行将根节点4入队，出队并访问节点。节点2和8被入队，因为它们分别是左节点和右节点。节点2被出队以进行访问。它的左节点和右节点，即1和3，被入队。此时，队列前端的节点是8。我们出队并访问节点8，之后我们入队其左节点和右节点。因此，这个过程一直持续，直到队列为空。
- en: 'The algorithm is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 算法如下：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We enqueue the root node and keep a list of the visited nodes in the `list_of_nodes`
    list. The `dequeue` class is used to maintain a queue:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根节点入队，并在`list_of_nodes`列表中保留一个访问过的节点列表。`dequeue`类用于维护队列：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the number of elements in the `traversal_queue` is greater than zero, the
    body of the loop is executed. The node at the front of the queue is popped off
    and appended to the `list_of_nodes` list. The first `if` statement will `enqueue`
    the left child node of the `node` provided a left node exists. The second `if`
    statement does the same for the right child node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`traversal_queue`中的元素数量大于零，则执行循环体。队列前端的节点被弹出并附加到`list_of_nodes`列表。第一个`if`语句将`node`的左子节点入队，如果存在左节点。第二个`if`语句对右子节点执行相同的操作。
- en: The `list_of_nodes` is returned in the last statement.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of_nodes`在最后一个语句中返回。'
- en: Benefits of a binary search tree
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树的好处
- en: 'We shall now briefly look at what makes a BST a better idea than using a list
    for data that needs to be searched. Let us assume that we have the following dataset:
    5, 3, 7, 1, 4, 6, and 9\. Using a list, the worst-case scenario would require
    you to search through the entire list of seven elements before finding the search
    term:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在简要地看一下，为什么使用BST比使用列表进行搜索更好。假设我们有以下数据集：5、3、7、1、4、6和9。使用列表，最坏的情况需要在找到搜索项之前搜索整个包含七个元素的列表：
- en: '![](assets/720691f5-6681-473f-a80c-1f1cdba24822.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/720691f5-6681-473f-a80c-1f1cdba24822.jpg)'
- en: Searching for 9 requires six jumps.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索`9`需要六次跳跃。
- en: 'With a tree, the worst-case scenario is three comparisons:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用树，最坏的情况是三次比较：
- en: '![](assets/ace39d6e-f99f-432c-96fa-258b74bd400c.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ace39d6e-f99f-432c-96fa-258b74bd400c.jpg)'
- en: Searching for 9 requires two steps.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索`9`需要两步。
- en: 'Notice, however, that if you insert the elements into the tree in the order
    1, 2, 3, 5, 6, 7, 9, then the tree would not be more efficient than the list.
    We would have to balance the tree first:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而请注意，如果你按照1、2、3、5、6、7、9的顺序将元素插入树中，那么这棵树将不会比列表更有效。我们需要首先平衡树：
- en: '![](assets/260a95e2-481f-4441-b0dc-991d1aafed8b.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/260a95e2-481f-4441-b0dc-991d1aafed8b.jpg)'
- en: So not only is it important to use a BST but choosing a self-balancing tree
    helps to improve the `search` operation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，重要的不仅是使用BST，而且选择自平衡树有助于改进`search`操作。
- en: Expression trees
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式树
- en: 'The tree structure is also used to parse arithmetic and Boolean expressions.
    For example, the expression tree for `3 + 4` would look as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构也用于解析算术和布尔表达式。例如，`3 + 4`的表达式树如下所示：
- en: '![](assets/d3bff613-f1df-495f-8f23-3b101b9b8633.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d3bff613-f1df-495f-8f23-3b101b9b8633.jpg)'
- en: 'For a slightly more complex expression, `(4 + 5) * (5-3)`, we would get the
    following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于稍微复杂的表达式`(4 + 5) * (5-3)`，我们将得到以下结果：
- en: '![](assets/bf51f42d-d166-483b-93ff-0c22004c45da.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf51f42d-d166-483b-93ff-0c22004c45da.jpg)'
- en: Parsing a reverse Polish expression
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析逆波兰表达式
- en: 'Now we are going to build up a tree for an expression written in postfix notation.
    Then we will calculate the result. We will use a simple tree implementation. To
    keep it really simple, since we are going to grow the tree by merging smaller
    trees, we only need a tree node implementation:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为后缀表示法中的表达式构建一棵树。然后我们将计算结果。我们将使用一个简单的树实现。为了保持简单，因为我们将通过合并较小的树来增长树，我们只需要一个树节点实现：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to build the tree, we are going to enlist the help of a stack. You
    will see why soon. But for the time being, let us just create an arithmetic expression
    and set up our stack:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建树，我们将寻求栈的帮助。很快你就会明白为什么。但目前，让我们创建一个算术表达式并设置我们的栈：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since Python is a language that tries hard to have sensible defaults, its `split()`
    method splits on whitespace by default. (If you think about it, this is most likely
    what you would expect as well.) The result is going to be that expr is a list
    with the values 4, 5, +, 5, 3, - and *.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是一种试图具有合理默认值的语言，它的`split()`方法默认情况下会在空格上拆分。（如果你仔细想想，这很可能也是你期望的。）结果将是`expr`是一个包含值4、5、+、5、3、-和*的列表。
- en: Each element of the expr list is going to be either an operator or an operand.
    If we get an operand then we embed it in a tree node and push it onto the stack.
    If we get an operator, on the other hand, then we embed the operator into a tree
    node and pop its two operands into the node's left and right children. Here we
    have to take care to ensure that the first pop goes into the right child, otherwise
    we will have problems with subtraction and division.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: expr列表的每个元素都可能是操作符或操作数。如果我们得到一个操作数，那么我们将其嵌入到一个树节点中并将其推入堆栈。另一方面，如果我们得到一个操作符，那么我们将操作符嵌入到一个树节点中，并将其两个操作数弹出到节点的左右子节点中。在这里，我们必须小心确保第一个弹出的操作数进入右子节点，否则我们将在减法和除法中出现问题。
- en: 'Here is the code to build the tree:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建树的代码：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that we perform a conversion from string to int in the case of an operand.
    You could use `float()` instead, if you wanted to support floating point operands.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在操作数的情况下，我们执行了从字符串到整数的转换。如果需要支持浮点数操作数，可以使用`float()`。
- en: At the end of this operation, we should have one single element in the stack,
    and that holds the full tree.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作结束时，我们应该在堆栈中只有一个元素，它包含了完整的树。
- en: 'We may now want to be able to evaluate the expression. We build the following
    little function to help us:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可能想要评估表达式。我们构建了以下小函数来帮助我们：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function is very simple. We pass in a node. If the node contains an operand,
    then we simply return that value. If we get an operator, however, then we perform
    the operation that the operator represents, on the node's two children. However,
    since one or more of the children could also contain either operators or operands,
    we call the `calc()` function recursively on the two child nodes (bearing in mind
    that all the children of every node are also nodes).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。我们传入一个节点。如果节点包含一个操作数，那么我们就简单地返回该值。然而，如果我们得到一个操作符，那么我们就对节点的两个子节点执行操作符代表的操作。然而，由于一个或多个子节点也可能包含操作符或操作数，我们在两个子节点上递归调用`calc()`函数（要记住每个节点的所有子节点也都是节点）。
- en: 'Now we just need to pop the root node off the stack and pass it into the `calc()`
    function and we should have the result of the calculation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要从堆栈中弹出根节点并将其传递给`calc()`函数，我们就应该得到计算的结果：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running this program should yield the result 18, which is the result of `(4
    + 5) * (5 - 3)`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序应该得到结果18，这是`(4 + 5) * (5 - 3)`的结果。
- en: Balancing trees
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡树
- en: Earlier, we mentioned that if nodes are inserted into the tree in a sequential
    order, then the tree behaves more or less like a list, that is, each node has
    exactly one child node. We normally would like to reduce the height of the tree
    as much as possible, by filling up each row in the tree. This process is called
    balancing the tree.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，如果节点按顺序插入树中，那么树的行为就更像是一个列表，也就是说，每个节点恰好有一个子节点。我们通常希望尽量减少树的高度，填满树中的每一行。这个过程称为平衡树。
- en: There are a number of types of self-balancing trees, such as red-black trees,
    AA trees, and scapegoat trees. These balance the tree during each operation that
    modifies the tree, such as insert or delete.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的自平衡树，例如红黑树、AA树和替罪羊树。这些树在修改树的每个操作（如插入或删除）期间平衡树。
- en: There are also external algorithms that balance a tree. The benefit of these
    is that you wouldn't need to balance the tree on every single operation, but could
    rather leave balancing to the point when you need it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些外部算法可以平衡树。这样做的好处是你不需要在每次操作时都平衡树，而是可以在需要时才进行平衡。
- en: Heaps
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: At this point, we shall briefly introduce the heap data structure. A heap is
    a specialization of a tree in which the nodes are ordered in a specific way. Heaps
    are divided into max and min heaps. In a max heap, each parent node must always
    be greater than or equal to its children. It follows that the root node must be
    the greatest value in the tree. A min heap is the opposite. Each parent node must
    be less than or equal to both its children. As a consequence, the root node holds
    the lowest value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们简要介绍堆数据结构。堆是树的一种特殊形式，其中节点以特定的方式排序。堆分为最大堆和最小堆。在最大堆中，每个父节点必须始终大于或等于其子节点。因此，根节点必须是树中最大的值。最小堆则相反。每个父节点必须小于或等于其两个子节点。因此，根节点保存最小的值。
- en: Heaps are used for a number of different things. For one, they are used to implement
    priority queues. There is also a very efficient sorting algorithm, called heap
    sort, that uses heaps. We are going to study these in depth in subsequent chapters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 堆用于许多不同的事情。首先，它们用于实现优先队列。还有一种非常高效的排序算法，称为堆排序，使用了堆。我们将在后续章节中深入研究这些内容。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at tree structures and some example uses of
    them. We studied binary trees in particular, which is a subtype of trees where
    each node has at most two children.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了树结构和它们的一些示例用途。我们特别研究了二叉树，这是树的一个子类型，其中每个节点最多有两个子节点。
- en: We looked at how a binary tree can be used as a searchable data structure with
    a BST. We saw that, in most cases, finding data in a BST is faster than in a linked
    list, although this is not the case if the data is inserted sequentially, unless
    of course the tree is balanced.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了二叉树如何作为可搜索的数据结构与BST一起使用。我们发现，在大多数情况下，在BST中查找数据比在链表中更快，尽管如果数据按顺序插入，情况就不同了，除非树是平衡的。
- en: The breadth- and depth-first search traversal modes were also implemented using
    queue recursion.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先和深度优先搜索遍历模式也使用队列递归实现了。
- en: We also looked at how a binary tree can be used to represent an arithmetic or
    a Boolean expression. We built up an expression tree to represent an arithmetic
    expression. We showed how to use a stack to parse an expression written in RPN,
    build up the expression tree, and finally traverse it to get the result of the
    arithmetic expression.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了二叉树如何用来表示算术或布尔表达式。我们构建了一个表达式树来表示算术表达式。我们展示了如何使用栈来解析以逆波兰表示法编写的表达式，构建表达式树，最后遍历它以获得算术表达式的结果。
- en: Finally, we mentioned heaps, a specialization of a tree structure. We have tried
    to at least lay down the theoretical foundation for the heap in this chapter,
    so that we can go on to implement heaps for different purposes in upcoming chapters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了堆，这是树结构的一种特殊形式。在本章中，我们试图至少奠定堆的理论基础，以便在接下来的章节中为不同的目的实现堆。
