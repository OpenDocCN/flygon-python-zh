- en: Creating Automated Tests with unittest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用unittest创建自动化测试
- en: With the size and complexity of your application rapidly expanding, you've become
    nervous about making changes. What if you break something? How will you know?
    You need a reliable way to make sure your program is working properly as the code
    changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的规模和复杂性迅速扩大，您开始对进行更改感到紧张。如果你弄坏了什么？你怎么知道？您需要一种可靠的方法来确保您的程序在代码更改时正常工作。
- en: 'Fortunately, we have a way: automated testing. In this chapter, you''ll cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一种方法：自动化测试。在本章中，您将涵盖以下主题：
- en: Learning the basics of automated testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习自动化测试的基础知识
- en: Learning specific strategies for testing Tkinter applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习测试Tkinter应用程序的具体策略
- en: Applying this knowledge to our data entry application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些知识应用于我们的数据输入应用程序
- en: Automated testing basics
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试基础
- en: Up until now, testing our application has been a process of launching it, running
    it through a few basic procedures, and verifying that it did what we expected
    it to do. This approach works acceptably on a very small script, but, as our application
    grows, it becomes an increasingly time-consuming and error-prone process to verify
    the application's behavior. Using automated testing, we can consistently verify
    our application logic within seconds.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，测试我们的应用程序一直是一个启动它，运行它通过一些基本程序，并验证它是否按我们预期的那样工作的过程。这种方法在一个非常小的脚本上可以接受，但随着应用程序的增长，验证应用程序行为变得越来越耗时和容易出错。使用自动化测试，我们可以在几秒钟内始终验证我们的应用逻辑。
- en: There are several forms of automated testing, but the two most common are **unit
    testing** and **integration testing**. Unit tests work with discrete pieces of
    code in isolation, allowing us to quickly verify the behavior of specific sections.
    Integration tests verify the interactions of multiple units of code. We'll be
    writing both kinds of tests to verify the behavior of our application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试有几种形式，但最常见的两种是**单元测试**和**集成测试**。单元测试与隔离的代码片段一起工作，允许我们快速验证特定部分的行为。集成测试验证多个代码单元的交互。我们将编写这两种测试来验证我们应用程序的行为。
- en: A simple unit test
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的单元测试
- en: At its most basic, a unit test is just a short program that runs a unit of code
    under different conditions and compares its output against expected results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的层面上，单元测试只是一个短小的程序，它在不同条件下运行代码单元，并将其输出与预期结果进行比较。
- en: 'Consider the following calculation class:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下计算类：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class is initialized with two numbers and can then perform a variety of
    arithmetic methods on them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用两个数字进行初始化，然后可以对它们执行各种算术方法。
- en: 'Let''s create a naive test for this function as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的对该函数的测试：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our test code creates a `MyCalc` object and then uses `assert` statements to
    check the output of `add()` and `mod_divide()` against expected values. The `assert`
    keyword in Python is a special statement that raises an `AssertionError` exception
    if the statement that follows it evaluates to `False`. The message string after
    the comma is the error string that will be passed to the `AssertionError` exception.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试代码创建了一个`MyCalc`对象，然后使用`assert`语句来检查`add()`和`mod_divide()`的输出是否符合预期值。Python中的`assert`关键字是一个特殊语句，如果其后的语句评估为`False`，则会引发`AssertionError`异常。逗号后的消息字符串是将传递给`AssertionError`异常的错误字符串。
- en: 'The code `assert statement, "message"` is essentially equivalent to this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`assert statement, "message"`本质上等同于这个：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Currently, all tests pass if you run the test script for `MyCalc`. Let''s try
    changing the `add()` method as follows to make it fail:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果运行`MyCalc`的测试脚本，所有测试都会通过。让我们尝试更改`add()`方法如下以使其失败：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, running the test gives this error:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试会出现以下错误：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What is the value of such tests? Suppose someone decides to refactor our `mod_divide()`
    method as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的价值是什么？假设有人决定对我们的`mod_divide()`方法进行重构：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since this passes our tests, we can be pretty sure this algorithm is correct,
    even if we didn't understand the code. If there were a problem with the refactor,
    our tests should show that fairly quickly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试通过了，我们可以相当肯定这个算法是正确的，即使我们不理解这段代码。如果重构出现问题，我们的测试应该能够很快地显示出来。
- en: Testing pure mathematical functions is fairly simple; unfortunately, testing
    real application code presents us with some challenges that demand a more sophisticated
    approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试纯数学函数相当简单；不幸的是，测试真实应用代码给我们带来了一些需要更复杂方法的挑战。
- en: 'Consider these issues:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些问题：
- en: Code units often rely on a pre-existing state that must be set up before the
    test and cleared up afterwards.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码单元通常依赖于必须在测试之前设置并在测试之后清除的现有状态。
- en: Code may have side effects that change objects outside the code unit.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能具有改变代码单元外部对象的副作用。
- en: Code may interact with resources that are slow, unreliable, or unpredictable.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能会与慢速、不可靠或不可预测的资源进行交互。
- en: Real applications contain many functions and classes that require testing, and
    ideally we'd like to be alerted to all problems at once. Our tests, as written,
    would stop on the first failed assertion, so we'd only get alerted to one problem
    at a time.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实应用包含许多需要测试的函数和类，理想情况下，我们希望一次性提醒所有问题。我们目前编写的测试会在第一个失败的断言上停止，因此我们只会一次性提醒一个问题。
- en: To address these issues and others, programmers rely on **testing frameworks**
    to make writing and executing automated tests as simple and reliable as possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题和其他问题，程序员依赖于**测试框架**，以使编写和执行自动化测试尽可能简单和可靠。
- en: The unittest module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unittest模块
- en: The `unittest` module is  the Python standard library's automated testing framework.
    It provides us with some powerful tools to make testing our code reasonably easy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块是Python标准库的自动化测试框架。它为我们提供了一些强大的工具，使得测试我们的代码相当容易。'
- en: '`unittest` is based on these standard unit testing concepts found in many test
    frameworks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`基于许多测试框架中发现的这些标准单元测试概念：'
- en: '**Test**: A **test** is a single method that will either finish or raise an
    exception. Tests generally focus on one unit of code, such as a function, method,
    or process. A test can either pass, meaning the test was successful; fail, meaning
    the code failed the test; or error, meaning the test itself encountered a problem'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：一个**测试**是一个单独的方法，要么完成，要么引发异常。测试通常专注于代码的一个单元，比如一个函数、方法或过程。一个测试可以通过，意味着测试成功；失败，意味着代码未通过测试；或者错误，意味着测试本身遇到了问题。'
- en: '**Test case**: A test case is a collection of tests which should be run together
    and contain similar setup and tear-down requirements, typically corresponding
    to a class or module. Test cases can have fixtures, which are items that need
    to be set up before each test and torn down after each test to provide a clean,
    predictable environment in which the test can run'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：一个测试用例是一组应该一起运行的测试，包含类似的设置和拆卸要求，通常对应一个类或模块。测试用例可以有夹具，这些夹具需要在每个测试之前设置并在每个测试之后拆卸，以提供一个干净、可预测的环境，让测试可以运行。'
- en: '**Test suite**: A test suite is a collection of test cases which cover all
    the code for an application or module.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：一个测试套件是一组覆盖应用程序或模块所有代码的测试用例。'
- en: '**Mock**: A mock is an object that stands in for an external resource, such
    as a file or database. Mocks are patched over those resources during the test.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**：模拟是一个代表外部资源（比如文件或数据库）的对象。在测试期间，模拟会被覆盖到这些资源上。'
- en: To explore these concepts in depth, let's test our `MyCalc` class using `unittest`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入探讨这些概念，让我们使用`unittest`来测试我们的`MyCalc`类。
- en: Writing a test case
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'Let''s create a test case for the `MyCalc` class in the `test_mycalc.py` as
    follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`test_mycalc.py`中为`MyCalc`类创建一个测试用例，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The names of both your test modules and your test methods should be prefixed
    with `test_`. Doing so allows the `unittest` runner to automatically find test
    modules and distinguish test methods from other methods in your test case classes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试模块和测试方法的名称都应该以`test_`为前缀。这样做可以让`unittest`运行程序自动找到测试模块，并区分测试方法和测试用例类中的其他方法。
- en: As you probably guessed, the `TestCase` class represents a test case. To make
    our test case for `MyCalc`, we subclass `TestCase` and start adding the `test_`
    methods to test various aspects of our class. Our `test_add()` method creates
    a `MyCalc` object, then makes an assertion about the output of `add()`. To run
    the test case, we add a call to `unittest.main()` at the end of the file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，`TestCase`类代表一个测试用例。为了创建我们的`MyCalc`测试用例，我们继承`TestCase`并开始添加`test_`方法来测试我们类的各个方面。我们的`test_add()`方法创建一个`MyCalc`对象，然后对`add()`的输出进行断言。为了运行测试用例，我们在文件末尾添加一个对`unittest.main()`的调用。
- en: 'If you run your test file at the command line, you should get the following
    output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行上运行你的测试文件，你应该会得到以下输出：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The single dot on the first line represents our test (`test_add()`). For each
    test method, `unittest.main()` will output a dot for passing, `F` for failure,
    or `E` for error. At the end, we get a summary of what happened.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行上的单个点代表我们的测试（`test_add()`）。对于每个测试方法，`unittest.main()`会输出一个点表示通过，`F`表示失败，或`E`表示错误。最后，我们会得到一个总结。
- en: 'To see what happens when a test fails, let''s alter our test to be incorrect:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看测试失败时会发生什么，让我们改变我们的测试使其不正确：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now when you run the test module, you should see a failure as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行测试模块时，你应该会看到以下失败：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the single `F` at the top, representing our failed test. After all the
    tests have run, we get the full traceback of any failed tests, so that we can
    easily locate the failing code and correct it. This traceback output isn't very
    ideal, though; we can see that `mc.add()` didn't equal `12`, but we don't know
    what it was equal to. We could add a comment string to our `assert` call, but
    `unittest` provides a nicer method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意顶部的单个`F`，代表我们的测试失败了。所有测试运行完毕后，我们会得到任何失败测试的完整回溯，这样我们就可以轻松定位失败的代码并进行修正。不过，这个回溯输出并不是非常理想；我们可以看到`mc.add()`不等于`12`，但我们不知道它等于什么。我们可以在我们的`assert`调用中添加一个注释字符串，但`unittest`提供了一个更好的方法。
- en: TestCase assertion methods
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestCase断言方法
- en: '`TestCase` objects have a number of assertion methods that provide a cleaner
    and more robust way to run various tests on our code output.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase`对象有许多断言方法，可以提供一种更清晰、更健壮的方式来运行我们代码的各种测试输出。'
- en: 'For example, there is the `TestCase.assertEqual()` method to test equality,
    which we can use as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有`TestCase.assertEqual()`方法来测试相等性，我们可以这样使用：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run our tests with this code, you can see that the traceback is improved:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用这段代码运行我们的测试时，你会看到回溯得到了改进：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we can see the value that `mc.add()` created, which is much more helpful
    for debugging. `TestCase` contains more than 20 assertion methods that can simplify
    testing for a variety of conditions such as class inheritance, raised exceptions,
    and sequence membership.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到`mc.add()`创建的值，这对于调试来说更有帮助。`TestCase`包含了20多个断言方法，可以简化对各种条件的测试，比如类继承、引发异常和序列成员资格。
- en: 'Some more commonly used ones are listed in the following table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的方法列在下表中：
- en: '| **Method** | **Tests** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **测试** |'
- en: '| `assertEqual(a, b)` | `a == b` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `assertEqual(a, b)` | `a == b` |'
- en: '| `assertTrue(a)` | `a` is `True` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `assertTrue(a)` | `a`是`True` |'
- en: '| `assertFalse(a)` | `a` is `False` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `assertFalse(a)` | `a`是`False` |'
- en: '| `assertIn(item, sequence)` | `item` is in `sequence` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `assertIn(item, sequence)` | `item`在`sequence`中 |'
- en: '| `assertRaises(exception, callable, args)` | `callable` called with `args`
    raises `exception` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `assertRaises(exception, callable, args)` | `callable`用`args`调用引发`exception`
    |'
- en: '| `assertGreater(a, b)` | `a` is greater than `b` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `assertGreater(a, b)` | `a`大于`b` |'
- en: '| `assertLess(a, b)` | `a` is less than `b` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `assertLess(a, b)` | `a`小于`b` |'
- en: You can easily add your own custom assertion methods to your test case as well;
    it's simply a matter of creating a method that raises an `AssertionError` exception
    under some condition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以轻松地向你的测试用例中添加自定义的断言方法；只需要创建一个在某些条件下引发`AssertionError`异常的方法。
- en: 'Let''s use an assertion method to test that `mod_divide()` raises `ValueError`
    when `b` is `0`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个断言方法来测试`mod_divide()`在`b`为`0`时是否引发`ValueError`：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`assertRaises` passes if the function raises the given assertion when called.
    If we need to pass any arguments into the tested function, they can be specified
    as additional arguments to `assertRaises()`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRaises`在调用时，如果函数引发给定的断言，则通过。如果我们需要将任何参数传递到被测试的函数中，它们可以作为额外的参数指定给`assertRaises()`。'
- en: '`assertRaises()` can also be used as a context manager like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRaises()`也可以像这样用作上下文管理器：'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code accomplishes the exact same thing, but is a little clearer and more
    flexible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实现了完全相同的功能，但更清晰、更灵活。
- en: Fixtures
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定装置
- en: Rather than perform the tedious task of creating the `MyCalc` objects in every
    test, our `TestCase` object can have a `setUp()` method that automatically creates
    any resources our tests need.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TestCase`对象可以具有一个`setUp()`方法，自动创建我们的测试需要的任何资源，而不必在每个测试中执行创建`MyCalc`对象的繁琐任务。
- en: 'For example, take a look at the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下代码：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, every test case can use these objects to run its tests. The `setUp()` method
    will be rerun before every test, so these objects will always be reset between
    test methods. If we have items that need to cleaned up after each test, we can
    define a `tearDown()` method, which will be run after each test (in this case,
    it's not necessary).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个测试用例都可以使用这些对象来运行其测试。`setUp()`方法将在每个测试之前重新运行，因此这些对象将始终在测试方法之间重置。如果我们有需要在每个测试后清理的项目，我们可以定义一个`tearDown()`方法，在每个测试后运行（在这种情况下，这是不必要的）。
- en: 'Now, for example, our `test_add()` method can be much simpler:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`test_add()`方法可以更简单：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In addition to the instance methods `setUp()` and `tearDown()`, `TestCase` has
    class methods for setup and tear down as well, namely `setUpClass()` and `tearDownClass()`.
    These can be used for slower operations that can be run when the test case is
    created and destroyed, rather than needing to be refreshed between each test method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例方法`setUp()`和`tearDown()`之外，`TestCase`还有用于设置和拆卸的类方法，即`setUpClass()`和`tearDownClass()`。这些可以用于较慢的操作，可以在测试用例创建和销毁时运行，而不需要在每个测试方法之间刷新。
- en: Using Mock and patch
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mock和patch
- en: The `rand_between()` method generates a random number between `a` and `b`. Because
    we can't possibly predict its output, we can't provide a fixed value to test it
    against. How can we test this method?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand_between()`方法生成`a`和`b`之间的随机数。因为我们不可能预测它的输出，所以我们无法提供一个固定值来测试它。我们如何测试这个方法？'
- en: 'A naive approach is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法如下：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This test passes if our code is correct, but it doesn't necessarily fail if
    the code is wrong; in fact, if the code is wrong, it may pass or fail unpredictably.
    For example, if `MyCalc(1, 10).rand_between()` was incorrectly returning values
    between 2 and 11, there is only a 10% chance that the test would fail on each
    run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码正确，这个测试通过，但如果代码错误，它不一定会失败；事实上，如果代码错误，它可能会以不可预测的方式通过或失败。例如，如果`MyCalc(1,
    10).rand_between()`错误地返回2到11之间的值，那么每次运行测试的机会只有10%。
- en: We can safely assume that a standard library function such `random()` works
    correctly, so our unit test should really test whether our method correctly handles
    the number provided to it by `random()`. If we could temporarily replace `random()`
    with a function that returns a fixed value, it would be simple to test the correctness
    of our subsequent calculations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地假设标准库函数`random()`工作正常，因此我们的单元测试应该真正测试我们的方法是否正确处理`random()`提供给它的数字。如果我们可以暂时用返回固定值的函数替换`random()`，那么测试后续计算的正确性就会变得简单。
- en: The `unittest.mock` module provides us with the `Mock` class for this purpose.
    `Mock` objects can be used to predictably simulate the behavior of another class,
    method, or library. We can give our `Mock` objects return values, side effects,
    properties, methods, and other features needed to fake the behavior of another
    object, then drop it in place of that object before running our tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`模块为我们提供了`Mock`类，用于此目的。`Mock`对象可用于可预测地模拟另一个类、方法或库的行为。我们可以给我们的`Mock`对象返回值、副作用、属性、方法和其他需要模拟另一个对象行为的特性，然后在运行测试之前将其放在该对象的位置。'
- en: 'Let''s create a fake `random()` function using `Mock` as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Mock`创建一个虚假的`random()`函数，如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Mock` object's `return_value` argument allows us to hard code a value to
    be returned whenever it's called as a function. Here,  `fakerandom` will always
    return `0.5`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`对象的`return_value`参数允许我们在被调用为函数时硬编码一个值。在这里，`fakerandom`将始终返回`0.5`。'
- en: 'Now we can put `fakerandom` in place of `random()` as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`fakerandom`放在`random()`的位置：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We start by saving a reference to `mycalc.random.random` before replacing it.
    Note that we're specifically replacing only the version of `random` being used
    in `mycalc.py` so that we don't affect `random` anywhere else. It's a best practice
    to be as specific as possible when patching libraries to avoid unforeseen side
    effects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换之前，我们首先保存对`mycalc.random.random`的引用。请注意，我们只替换`mycalc.py`中使用的`random`版本，以便不影响其他任何地方的`random`。在修补库时尽可能具体是最佳实践，以避免意外的副作用。
- en: With `fakerandom` in place, we call our method and test the output. Because
    `fakerandom` will always return `0.5`, we know that the answer should be (0.5
    × 1 + 0)  or `0.5` when `a` is `1` and `b` is `0`. Any other value would indicate
    an error in our algorithm.  Last of all, we revert `random` to the original function
    so that other tests don't accidentally use the mock.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`fakerandom`，我们调用我们的方法并测试输出。因为`fakerandom`将始终返回`0.5`，所以我们知道当`a`为`1`，`b`为`0`时，答案应该是（0.5
    × 1 + 0）或`0.5`。任何其他值都会表明我们的算法存在错误。最后，我们将`random`恢复为原始函数，以便其他测试不会意外使用模拟。
- en: Having to store or revert the original library each time is an annoyance we
    can do without, so `unittest.mock` provides a cleaner approach using `patch`.
    The `patch` command can be used as either a context manager or a decorator, and
    either approach makes patching a `Mock` object into our code much cleaner.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都必须存储或恢复原始库是一个麻烦，所以`unittest.mock`提供了一个更清晰的方法，使用`patch`。`patch`命令可以作为上下文管理器或装饰器使用，无论哪种方法都可以将`Mock`对象补丁到我们的代码中，使其更加清晰。
- en: 'Using our mock `random()` using `patch` as a context manager looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的模拟`random()`，使用`patch`作为上下文管理器看起来像这样：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`The patch()` command takes an import path string and provides us with a `Mock`
    object that it has patched in. We can set methods and properties on the `Mock` object
    and run our actual tests in the block, and the patched library will be reverted
    when the block ends.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch()`命令接受一个导入路径字符串，并为我们提供一个已经补丁的`Mock`对象。我们可以在`Mock`对象上设置方法和属性，并在块中运行我们的实际测试，当块结束时，补丁的库将被恢复。'
- en: 'Using `patch()` as a decorator is similar:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`patch()`作为装饰器是类似的：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, the mock object created by `patch` is passed as an argument to
    our test method and will remain patched for the duration of the decorated function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由`patch`创建的模拟对象作为参数传递给我们的测试方法，并将在装饰函数的持续时间内保持补丁状态。
- en: Running multiple unit tests
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个单元测试
- en: While we can run our unit tests by including a call to `unittest.main()` at
    the end, that approach doesn't scale well. As our application grows, we're going
    to write many test files, which we'll want to run in groups or all at once.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在最后包含一个调用`unittest.main()`来运行单元测试，但这种方法不太适用。随着应用程序的增长，我们将编写许多测试文件，我们希望以组或全部运行。
- en: 'Fortunately, `unittest` can discover and run all tests in a project with one
    command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`unittest`可以通过一个命令发现并运行项目中的所有测试：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So long as you have followed the recommended naming scheme of prefixing your
    test modules with `test_`, running this command in your project's root directory
    should run all your tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你遵循了推荐的命名方案，将测试模块以`test_`为前缀，运行这个命令在项目的根目录中应该可以运行所有的测试。
- en: Testing Tkinter code
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Tkinter代码
- en: Testing Tkinter code presents us with a few particular challenges. First, Tkinter
    handles many callbacks and methods **asynchronously**, meaning that we can't count
    on the results of some code to be apparent immediately. Also, testing GUI behaviors
    often relies on external factors such as window management or visual cues that
    our tests cannot detect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Tkinter代码会带来一些特殊的挑战。首先，Tkinter处理许多回调和方法是**异步**的，这意味着我们不能指望某些代码的结果立即显现。此外，测试GUI行为通常依赖于诸如窗口管理或视觉提示之类的外部因素，而我们的测试无法检测到。
- en: We're going to learn some tools and strategies that will help you craft tests
    for your Tkinter code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习一些工具和策略，帮助你为Tkinter代码编写测试。
- en: Managing asynchronous code
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理异步代码
- en: Whenever you interact with a Tkinter UI—whether it's clicking a button, typing
    in a field, or raising a window, for example—the response is not executed immediately
    in-place. Instead, these actions are placed in a to-do list, called an **event
    queue**, to be handled later while your code execution continues. While these
    actions seem instant to users, test code cannot count on a requested action being
    completed before the next line of code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每当与Tkinter UI交互时，无论是点击按钮、在字段中输入，还是提升窗口，例如，响应都不会立即执行。相反，这些操作被放在一个待办事项列表中，称为**事件队列**，稍后处理，而您的代码执行则继续。虽然这些操作对用户来说似乎是瞬间发生的，但测试代码不能指望请求的操作在下一行代码执行之前完成。
- en: 'To solve this problem, we can use these special widget methods that allow us
    to manage the event queue:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用这些特殊的小部件方法来管理事件队列：
- en: '`wait_visibility()`: This method causes the program to wait until a widget
    is fully drawn on-screen before executing the next line of code.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_visibility()`: 这个方法会导致程序等待，直到小部件完全绘制在屏幕上，然后再执行下一行代码。'
- en: '`update_idletasks()`: This method forces Tkinter to process any idle tasks
    currently outstanding on the widget. Idle tasks are low-priority tasks such as
    drawing and rendering.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_idletasks()`: 这个方法强制Tkinter处理小部件上当前未完成的任何空闲任务。空闲任务是低优先级的任务，如绘图和渲染。'
- en: '`update()`: This method forces Tkinter to process all events which are outstanding
    on a widget, including calling callbacks, redraws, and geometry management. It
    includes everything that `update_idletasks()` does and more.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`: 这个方法强制Tkinter处理小部件上未完成的所有事件，包括调用回调、重绘和几何管理。它包括`update_idletasks()`的所有功能以及更多。'
- en: Simulating user actions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟用户操作
- en: When automating GUI tests, we may wish to know what happens when a user clicks
    on a certain widget, or types a certain keystroke. When these actions happen in
    the GUI, Tkinter generates an `Event` object for the widget and passes it to the
    event queue. We can do the same thing in code, using a widget's `event_generate()`
    method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化GUI测试时，我们可能希望知道当用户点击某个小部件或键入某个按键时会发生什么。当这些操作在GUI中发生时，Tkinter会为小部件生成一个`Event`对象并将其传递给事件队列。我们可以在代码中做同样的事情，使用小部件的`event_generate()`方法。
- en: Specifying an event sequence
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定事件序列
- en: To create an event with `event_generate()`, we need to pass in an event sequence
    string, in the format `<EventModifier-EventType-EventDetail>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`event_generate()`创建一个事件，我们需要传入一个事件序列字符串，格式为`<EventModifier-EventType-EventDetail>`。
- en: '**Event type** specifies the kind of event we''re sending, such as a keystroke,
    mouse click, windowing event, and so on.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型指定了我们发送的事件类型，比如按键、鼠标点击、窗口事件等。
- en: 'Tkinter has around 30 event types, but you will typically only need to work
    with the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter大约有30种事件类型，但通常只需要处理以下几种：
- en: '| **Event types** | **Description** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **事件类型** | **描述** |'
- en: '| `ButtonPress` | Also `Button`, represents a mouse button click |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `ButtonPress` | 也是`Button`，表示鼠标按钮点击 |'
- en: '| `ButtonRelease` | Represents lifting off a mouse button |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `ButtonRelease` | 表示释放鼠标按钮 |'
- en: '| `KeyPress` | Also `Key`, represents pressing a keyboard key |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `KeyPress` | 也是`Key`，表示按下键盘按键 |'
- en: '| `KeyRelease` | Represents lifting off a keyboard key |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `KeyRelease` | 表示释放键盘键 |'
- en: '| `FocusIn` | Represents giving focus to a widget |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `FocusIn` | 表示将焦点放在小部件上 |'
- en: '| `FocusOut` | Represents exiting a widget |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `FocusOut` | 表示退出小部件 |'
- en: '| `Enter` | Represents the mouse cursor entering a widget |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Enter` | 表示鼠标光标进入小部件 |'
- en: '| `Leave` | Represents the mouse cursor moving off a widget |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Leave` | 表示鼠标光标移出小部件 |'
- en: '| `Configure` | Called when the widget''s configuration changes, either by
    a `.config()` call or user action (resize, for example) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Configure` | 当小部件的配置发生变化时调用，可以是`.config()`调用或用户操作（例如调整大小） |'
- en: '**Event modifiers** are optional words that can alter the event type; for example,
    `Control`, `Alt`, and `Shift` can be used to indicate that one of those modifier
    keys is held down; `Double` or `Triple` can be used to indicate a double or triple
    click of the described button. Multiple modifiers can be strung together if required.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件修饰符**是可以改变事件类型的可选词语；例如，`Control`，`Alt`和`Shift`可以用来指示其中一个修改键被按下；`Double`或`Triple`可以用来指示所描述按钮的双击或三击。如果需要，可以将多个修饰符串在一起。'
- en: '**Event detail**, only valid for keyboard or mouse events, describes which
    key or button was pressed. For example, `<Button-1>` refers to the left mouse
    button, while `<Button-3>` refers to the right. For letter and number keys, the
    literal letter or number can be used; most symbols, however, are described by
    a word (`minus`, `colon`, `semicolon`, and so on) to avoid syntactic clashes.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件详情**，仅适用于键盘或鼠标事件，描述了按下哪个键或按钮。例如，`<Button-1>`指的是鼠标左键，而`<Button-3>`指的是右键。对于字母和数字键，可以使用字面上的字母或数字；然而，大多数符号是用单词（`minus`，`colon`，`semicolon`等）来描述，以避免语法冲突。'
- en: For button presses and key presses, the event type is technically optional;
    however, it's probably a good idea to leave it in for the sake of clarity. For
    example, `<1>` is a valid event, but does it refer to the left mouse button or
    typing the `1` key? You may be surprised to find that it's the mouse button.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮按下和键盘按下，事件类型在技术上是可选的；然而，出于清晰起见，最好将其保留。例如，`<1>`是一个有效的事件，但它是指鼠标左键还是按下`1`键？您可能会惊讶地发现它是鼠标按钮。
- en: 'The following table shows some examples of valid event sequences:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些有效事件序列的示例：
- en: '| **Sequence** | **Meaning** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **序列** | **意义** |'
- en: '| `<Double-Button-3>` | Double-clicking the right mouse button |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `<Double-Button-3>` | 双击鼠标右键 |'
- en: '| `<Alt-KeyPress-exclam>` | Holding `Alt` and typing an exclamation point |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `<Alt-KeyPress-exclam>` | 按住`Alt`并输入感叹号 |'
- en: '| `<Control-Alt-Key-m>` | Holding `Control` and `Alt` and pressing the `m`
    key |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `<Control-Alt-Key-m>` | 按住`Control`和`Alt`并按下`m`键 |'
- en: '| `<KeyRelease-minus>` | Lifting off a pressed minus key |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `<KeyRelease-minus>` | 释放按下的减号键 |'
- en: In addition to the sequence, we can pass other arguments to `event_generate()`
    which describe various aspects of the event.  Many of these are redundant, but,
    in some cases, we need to provide extra information for the event to have any
    meaning; for example, mouse button events need to include the `x` and `y` arguments
    that specify the coordinates of the click.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了序列，我们还可以向`event_generate()`传递其他参数，这些参数描述事件的各个方面。其中许多是多余的，但在某些情况下，我们需要提供额外的信息，以使事件具有任何意义；例如，鼠标按钮事件需要包括指定单击坐标的`x`和`y`参数。
- en: Managing focus and grab
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理焦点和抓取
- en: Focus refers to the widget or window which is currently receiving keyboard input.
    Widgets can also grab focus, preventing mouse movements or keystrokes outside
    their bounds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点指的是当前接收键盘输入的小部件或窗口。小部件还可以抓取焦点，防止鼠标移动或超出其范围的按键。
- en: 'Tkinter gives us these widget methods for managing focus and grab, some of
    which are useful for running tests:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter为我们提供了这些小部件方法来管理焦点和抓取，其中一些对于运行测试非常有用：
- en: '| **Method** | **Description** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `focus_set()` | Focuses the widget whenever its window next gains focus |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `focus_set()` | 在其窗口下次获得焦点时，将焦点设置到小部件 |'
- en: '| `focus_force()` | Focuses a widget and the window it''s in, immediately |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `focus_force()` | 立即将焦点设置到小部件和其所在的窗口 |'
- en: '| `grab_set()` | The widget grabs all events for the application |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `grab_set()` | 小部件抓取应用程序的所有事件 |'
- en: '| `grab_set_global()` | The widget grabs all screen events |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `grab_set_global()` | 小部件抓取所有屏幕事件 |'
- en: '| `grab_release()` | The widget relinquishes its grab |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `grab_release()` | 小部件放弃抓取 |'
- en: In a test environment, we can use these methods to make sure that our generated
    keyboard and mouse events are going to the correct widget or window.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中，我们可以使用这些方法来确保我们生成的键盘和鼠标事件发送到正确的小部件或窗口。
- en: Getting widget information
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取小部件信息
- en: Tkinter widgets have a set of `winfo_` methods that give us access to information
    about the widget. While this set of methods leaves much to be desired, it does
    provide a few methods we can use in tests to provide feedback about the state
    of a given widget.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter小部件有一组`winfo_`方法，可以让我们访问有关小部件的信息。虽然这组方法还有很多不足之处，但它确实提供了一些方法，我们可以在测试中使用这些方法来提供有关给定小部件状态的反馈。
- en: 'The following are a few `winfo_` methods that we will find useful:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我们会发现有用的`winfo_`方法：
- en: '| **Method** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `winfo_height()`, `winfo_width()` | Get the height and width of the widget
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_height()`，`winfo_width()` | 获取小部件的高度和宽度 |'
- en: '| `winfo_children()` | Get a list of child widgets |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_children()` | 获取子小部件列表 |'
- en: '| `winfo_geometry()` | Get the size and location of the widget |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_geometry()` | 获取小部件的大小和位置 |'
- en: '| `winfo_ismapped()` | Determine whether the widget is mapped, meaning it''s
    been added to a layout using `pack()` or `grid()`, for instance |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_ismapped()` | 确定小部件是否已映射，意味着它已被添加到布局中，例如使用`pack()`或`grid()` |'
- en: '| `winfo_viewable()` | Determine whether a widget is viewable, meaning it and
    all its parents have been mapped |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_viewable()` | 确定小部件是否可见，意味着它和所有父级都已被映射 |'
- en: '| `winfo_x()`, `winfo_y()` | Get the `x` or `y` coordinate of the widget''s
    top left corner |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `winfo_x()`，`winfo_y()` | 获取小部件左上角的`x`或`y`坐标 |'
- en: Writing tests for our application
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用编写测试
- en: Let's put our knowledge of `unittest` to work and write some tests for our application.
    To get started, we need to create a test module for our application. Make a directory
    called `test` inside the `abq_data_entry` package, and create the customary empty
    `__init__.py` file inside. We'll create all of our test modules inside this directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用`unittest`的知识，为我们的应用程序编写一些测试。要开始，我们需要为我们的应用程序创建一个测试模块。在`abq_data_entry`包内创建一个名为`test`的目录，并在其中创建习惯的空`__init__.py`文件。我们将在这个目录内创建所有的测试模块。
- en: Testing our model
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的模型
- en: Our `CSVModel` code is fairly self-contained apart from its need to read and
    write files. Since file operations are one of the more common things that need
    to be mocked out in a test, the `mock` module provides `mock_open`, a `Mock` subclass
    ready-made to replace Python's `open` method. When called, a `mock_open` object
    returns a `mock` file handle object, complete with support for the `read()`, `write()`,
    and `readlines()` methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CSVModel`代码相当自包含，除了需要读写文件。由于文件操作是测试中需要模拟的常见事物之一，`mock`模块提供了`mock_open`，这是一个准备好替换Python的`open`方法的`Mock`子类。当调用时，`mock_open`对象返回一个`mock`文件句柄对象，支持`read()`、`write()`和`readlines()`方法。
- en: 'Let''s begin creating our test case class in `test/test_models.py` as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的测试用例类，位于`test/test_models.py`中：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `mock_open` and `read_data` arguments allows us to specify a string that
    will be returned when its file handle is read. We've created two `mock_open` objects,
    one containing a CSV header and two lines of data, and the other containing nothing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock_open`和`read_data`参数允许我们指定一个字符串，当文件句柄被读取时将返回该字符串。我们创建了两个`mock_open`对象，一个包含CSV标题和两行数据，另一个什么都没有。'
- en: We've also created two `CSVModel` objects, one with a filename of `file1` and
    the other with a filename of `file2`. It's worth mentioning that there's no actual
    connection between our models and our `mock_open` objects. The choice of the `mock_open`
    object, rather than the filename, will determine what data will be returned
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了两个`CSVModel`对象，一个文件名为`file1`，另一个文件名为`file2`。值得一提的是，我们的模型和`mock_open`对象之间实际上没有任何连接。选择`mock_open`对象，而不是文件名，将决定返回什么数据。
- en: Testing file reading in get_all_records()
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`get_all_records()`中测试文件读取
- en: 'To see how we use these, let''s start a test for the `get_all_records()` method
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用这些，让我们从`get_all_records()`方法的测试开始：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since our filenames don't actually exist, we're using the decorator version
    of `patch` to patch `os.path.exists` with a mock function that always returns
    `True`. We can later change the `return_value` value if we want to test a scenario
    where the file doesn't exist.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的文件名实际上并不存在，我们使用`patch`的装饰器版本来将`os.path.exists`补丁为一个总是返回`True`的模拟函数。如果我们想测试文件不存在的情况，我们可以稍后更改`return_value`的值。
- en: 'To run the `get_all_records()` method, we''ll use the context manager form
    of `patch()` as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行`get_all_records()`方法，我们将使用`patch()`的上下文管理器形式如下：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Any call to `open()` inside the `models.py` file which has been initiated inside
    the context manager block will be replaced by our `mock_open` object, and the
    file handle returned will contain `read_data` we specified. However, before we
    can go on, there's an unfortunate shortcoming in `mock_open` that we'll need to
    work around. While it implements most file methods, it doesn't implement the iterator
    methods that the `csv` library requires to read data from the file handler.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`models.py`文件中任何在上下文管理器块内启动的`open()`调用都将被我们的`mock_open`对象替换，并且返回的文件句柄将包含我们指定的`read_data`。然而，在我们继续之前，`mock_open`存在一个不幸的缺陷，我们需要解决。虽然它实现了大多数文件方法，但它没有实现`csv`库需要从文件处理程序中读取数据的迭代器方法。'
- en: 'A slight alteration to our `models.py` code will fix this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的`models.py`代码进行轻微修改将解决这个问题：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Instead of simply passing `fh` into `DictReader`, we need to call `readlines()`
    and cast it to `list`. This won't affect the program in any way, but it will allow
    `mock_open()` to work correctly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用`readlines()`并将其转换为`list`，而不是简单地将`fh`传递给`DictReader`。这不会以任何方式影响程序，但它将允许`mock_open()`正常工作。
- en: There's nothing wrong with making adjustments to your code to accommodate tests;
    in many cases, the code will even be better for it! However, if you make an unintuitive
    change such as the previous one, be sure to add a comment to your code to explain
    why. Otherwise, someone is likely to factor it out at some point in the future.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调整代码以适应测试没有任何问题；在许多情况下，代码甚至会因此变得更好！然而，如果您进行了不直观的更改，比如前面的更改，请确保在代码中添加注释以解释原因。否则，有人很可能会在将来的某个时候将其删除。
- en: 'Now we can start making assertions about the records which have been returned:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始对返回的记录进行断言：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we're checking that `records` contains two lines (since our read data
    contained two `csv` records), that it's a `list` object, and that its first member
    is a `dict` object (or subclass of `dict`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查`records`是否包含两行（因为我们的读取数据包含两个`csv`记录），它是一个`list`对象，并且它的第一个成员是一个`dict`对象（或`dict`的子类）。
- en: 'Next, let''s make sure all our fields made it through and that our Boolean
    conversion worked:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保所有字段都通过了，并且我们的布尔转换起作用：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By iterating a tuple of all our field names, we can check that all our fields
    are present in the record output.  Don't be afraid to use loops in a test this
    way to check a large amount of content quickly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代所有字段名称的元组，我们可以检查记录输出中是否存在所有字段。不要害怕在测试中使用循环来快速检查大量内容。
- en: A `Mock` object can do more than just stand in for another class or function;
    it also has its own assertion methods that can tell us if it's been called, how
    many times, and with what arguments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`对象不仅可以代替另一个类或函数；它还有自己的断言方法，可以告诉我们它是否被调用，调用了多少次，以及使用了什么参数。'
- en: 'For example, we can check our `mock_open` object to make sure it was called
    with the expected arguments:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以检查我们的`mock_open`对象，确保它被调用时带有预期的参数：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`assert_called_with()` takes a set of arguments and checks if the last call
    to the `mock` object used those arguments. We expected `file1_open` to be called
    with the filename `file1`, a mode of `r`, and an encoding of `utf-8`. By confirming
    that a mocked function was called with the correct arguments, and assuming the
    correctness of the real function (the built-in `open()` function, in this case),
    we can avoid having to test the actual outcome.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_called_with()`接受一组参数，并检查对`mock`对象的最后一次调用是否使用了这些参数。我们期望`file1_open`被调用时使用文件名`file1`，模式为`r`，编码为`utf-8`。通过确认模拟函数是否使用了正确的参数进行了调用，并假设真实函数的正确性（在本例中是内置的`open()`函数），我们可以避免测试实际结果。'
- en: Testing file saving in save_record()
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试`save_record()`中的文件保存
- en: 'To demonstrate how to test file-writing with `mock_open`, let''s test `save_record()`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`mock_open`测试文件写入，让我们测试`save_record()`：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To test the conversion from a `dict` to a `csv` string, we''ll need a sample
    record in both formats:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试从`dict`到`csv`字符串的转换，我们需要两种格式的样本记录：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You may be tempted to generate either the record or its expected output using
    code, but it's always better to stick to literals in tests; doing so makes the
    expectations of the test explicit and avoids logic errors in your tests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被诱惑使用代码生成记录或其预期输出，但在测试中最好坚持使用文字；这样做可以使测试的期望明确，并避免测试中的逻辑错误。
- en: 'For our first scenario, let''s simulate writing to an empty but existing file
    by using `file2_open` and `model2` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个场景，让我们通过使用`file2_open`和`model2`来模拟向一个空但已存在的文件写入：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting our `mock_exists.return_value` to `True` to tell our method that the
    file already exists, we then patch over `open()` with our second `mock_open` object
    and call the `save_record()` method. Since we passed in a record with no row number
    (which indicates a record insert), this should result in our code trying to open
    `file2` in append mode and writing in the CSV-formatted record.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`mock_exists.return_value`设置为`True`，告诉我们的方法文件已经存在，然后用第二个`mock_open`对象覆盖`open()`，并调用`save_record()`方法。由于我们传入的记录没有行号（表示记录插入），这应该导致我们的代码尝试以追加模式打开`file2`并在CSV格式的记录中写入。
- en: '`assert_called_with()` will test that assumption as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_called_with()`将测试这一假设，如下所示：'
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`file2_open` can tell us that it was called with the expected parameters, but
    how do we access its file handler so that we can see what was written to it?'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`file2_open`可以告诉我们它是否使用了预期的参数进行了调用，但我们如何访问它的文件处理程序，以便我们可以看到写入了什么？'
- en: 'It turns out we can just call our `mock_open` object and retrieve the `mock`
    file handle object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们可以直接调用我们的`mock_open`对象并检索`mock`文件处理程序对象：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once we have the `mock` file handle (which is itself a `Mock`), we can run test
    methods on it to find out if it was called with the CSV data as expected. In this
    case, the file handle's `write` method should have been called with the CSV-format
    record string.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`mock`文件处理程序（它本身是一个`Mock`），我们可以对其运行测试方法，以找出它是否按预期被调用。在这种情况下，文件处理程序的`write`方法应该被调用，并传入CSV格式的记录字符串。
- en: 'Let''s do a similar set of tests, passing in a row number to simulate a record
    update:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一组类似的测试，传入一个行号来模拟记录更新：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Checking that our update was done correctly presents a problem: `assert_called_with()` only
    checks the last call made to the mock function. When we update our CSV file, the
    entire CSV file is updated, with one `write()` call per row. We can''t just check
    that the last call was correct; we need to make sure the `write()` calls for all
    the row*s* were correct. To accomplish this, `Mock` provides us with `assert_has_calls()`,
    to which we can pass a list of `Call` objects to compare against the object''s
    call history.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的更新是否正确完成存在一个问题：`assert_called_with()`只检查对模拟函数的最后一次调用。当我们更新CSV文件时，整个CSV文件都会被更新，每行一个`write()`调用。我们不能只检查最后一次调用是否正确；我们需要确保所有行的`write()`调用都是正确的。为了实现这一点，`Mock`为我们提供了`assert_has_calls()`，我们可以向其传递一个`Call`对象的列表，以与对象的调用历史进行比较。
- en: 'We create `Call` objects using the `mock.call()` function as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mock.call()`函数创建`Call`对象，如下所示：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The arguments to `call()` represent the arguments that were passed to the function
    call. The list of `Call` objects we pass to `assert_has_calls()` represents each
    call that should have been made to `write()` in order. The keyword argument `in_order`
    can also be set to `False`, in which case the order won't need to match. In this
    case, order matters, since a wrong order would result in a corrupt CSV file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`的参数表示传递给函数调用的参数。我们向`assert_has_calls()`传递的`Call`对象列表表示应该按顺序进行的每次对`write()`的调用。关键字参数`in_order`也可以设置为`False`，在这种情况下，顺序不需要匹配。在这种情况下，顺序很重要，因为错误的顺序会导致损坏的CSV文件。'
- en: More tests
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多测试
- en: Testing the remainder of the `CSVModel` class and the `SettingsModel` class
    methods should be essentially along the same lines as these two methods. A few
    more tests are included in the sample code, but see if you can come up with some
    of your own as well.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`CSVModel`类和`SettingsModel`类方法的其余部分应该基本上与这两个方法相同。示例代码中包含了一些额外的测试，但看看你是否也能想出一些自己的测试。
- en: Testing our application
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的应用程序
- en: 'We''ve implemented our application as a `Tk` object that acts not only as a
    main window but as a controller, patching together models and views defined elsewhere
    in the application. As you may expect, `patch()` is going to figure heavily into
    our testing code as we mock out all of those other components to isolate `Application`.
    Let''s take a look at how this is done:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的应用程序实现为一个`Tk`对象，它不仅充当主窗口，还充当控制器，将在应用程序的其他地方定义的模型和视图进行拼接。正如你可能期望的那样，`patch()`将在我们的测试代码中大量出现，因为我们模拟了所有其他组件，以隔离`Application`。让我们看看这是如何完成的：
- en: 'In a new file called `test_application.py`, import `unittest` and `application`.
    Now start a test case as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`test_application.py`的新文件中，导入`unittest`和`application`。现在开始一个测试用例，如下所示：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our `TestApplication` class will be using mocks in place of our data and settings
    models, so we've created some class properties to store samples of the data which `Application`
    expects to retrieve from those models. The `setUp()` method is going to patch
    out all the external classes with mocks, configure the mocked models to return
    our sample data, and then create an `Application` instance that our tests can
    use.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TestApplication`类将使用模拟数据和设置模型的替代品，因此我们创建了一些类属性来存储`Application`期望从这些模型中检索的数据样本。`setUp()`方法将使用模拟数据替换所有外部类，配置模拟模型以返回我们的样本数据，然后创建一个`Application`实例，供我们的测试使用。
- en: 'Let''s start by using `patch()` as a context manager  to replace all the external
    resources as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用`patch()`作为上下文管理器来替换所有外部资源，如下所示：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we've created a `with` block using five `patch()` context managers, one
    for each library we're mocking out. Notice that we're only creating aliases for
    the model mocks, since we'll want to do some extra configuration on them. The
    view mocks won't really need to do much except be imported or called, and we can
    access them as properties of our `Application` object anyway.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`with`块，使用了五个`patch()`上下文管理器，每个库都有一个。请注意，我们只为模型模拟创建别名，因为我们希望对它们进行一些额外的配置。视图模拟不需要做太多事情，只需要被导入或调用，而且我们可以将它们作为`Application`对象的属性访问。
- en: Since Python 3.2, you can create a block with multiple context managers by separating
    each context manager call with a comma. Unfortunately, you can't put them in parenthesis,
    so we're using the comparatively ugly escaped-newline method of breaking this
    gigantic call into multiple lines.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.2以来，您可以通过使用逗号分隔每个上下文管理器调用来创建具有多个上下文管理器的块。不幸的是，您不能将它们放在括号中，因此我们使用了相对丑陋的转义换行方法，将这个巨大的调用分成多行。
- en: 'Inside the block, we''ll need to configure our model mocks to return the appropriate
    data as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在块内，我们需要配置我们的模型模拟以返回适当的数据，如下所示：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that we're instantiating our `settingsmodel` and `csvmodel` objects and
    configuring methods on the return values rather than the mocks themselves. Remember
    that our mocks are replacing the *classes*, not the *objects*, and it is the objects
    which will contain the methods our `Application` object will be calling. Therefore,
    we need to call them to access the actual `Mock` object that will be used by `Application`
    as the data or settings model.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在实例化我们的`settingsmodel`和`csvmodel`对象，并配置返回值上的方法，而不是在模拟对象本身上配置。请记住，我们的模拟对象替换的是*类*，而不是*对象*，而是包含`Application`对象将要调用的方法的对象。因此，我们需要调用它们来访问`Application`将用作数据或设置模型的实际`Mock`对象。
- en: Unlike the actual class that it stands in for, a `Mock` object called as a function
    will return the same object every time it's called. Thus, we don't have to save
    a reference to the object created by calling a mocked class; we can just call
    the mocked class repeatedly to access that object. Note, however, that the `Mock`
    class will return a unique `Mock` object each time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与其代表的实际类不同，作为函数调用的`Mock`对象每次被调用时都会返回相同的对象。因此，我们不必保存通过调用模拟类创建的对象的引用；我们只需重复调用模拟类以访问该对象。但是，请注意，`Mock`类每次都会返回一个唯一的`Mock`对象。
- en: 'This takes care of our mocks, so let''s create an `Application` object:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样我们的模拟就处理好了，让我们创建一个`Application`对象：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Because `Application` is a subclass of Tk, it''s a good idea for us to safely
    dispose of it after each use; even though we''re reassigning its variable name,
    it will go on existing and cause problems with our tests. To solve this, create
    a `tearDown()` method:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`Application`是`Tk`的子类，所以我们最好在每次使用后安全地处理它；即使我们重新分配了它的变量名，它仍将继续存在并在我们的测试中造成问题。为了解决这个问题，创建一个`tearDown()`方法：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice the call to `app.update()`. If we don't call this before destroying `app`
    , there may be tasks in the event queue that will try to access it after it's
    gone. This won't break our code, but it will clutter up our test output with error
    messages.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意对`app.update()`的调用。如果我们在销毁`app`之前不调用它，可能会有任务在事件队列中尝试在它消失后访问它。这不会破坏我们的代码，但会在我们的测试输出中产生错误消息。
- en: 'Now that our fixtures are taken care of, let''s write a test:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的固定装置已经处理好了，让我们写一个测试：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Application.show_recordlist()` contains one line of code, which is merely
    a call to `recordlist.tkraise()`. Because we made `recordlist` a mock object,
    `tkraise` is also a mock object, and we can check to see that it was called. `assert_called()`
    merely checks that a method was called, without checking arguments, which is appropriate
    in this case because `tkraise()` takes none.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.show_recordlist()`包含一行代码，只是调用`recordlist.tkraise()`。因为我们将`recordlist`设置为模拟对象，`tkraise`也是模拟对象，我们可以检查它是否被调用。`assert_called()`只是检查方法是否被调用，而不检查参数，在这种情况下是合适的，因为`tkraise()`不需要参数。'
- en: 'We can use a similar technique to check `populate_recordlist()` as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用类似的技术来检查`populate_recordlist()`，如下所示：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Under some circumstances, `get_all_records()` can raise an exception, in which
    case we''re supposed to show an error message box. But since we''ve mocked out
    our data model, how can we get it to raise an exception? The solution is to use
    mock''s `side_effect` property as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些情况下，`get_all_records()`可能会引发异常，在这种情况下，我们应该显示一个错误消息框。但是，由于我们模拟了我们的数据模型，我们如何让它引发异常呢？解决方案是使用模拟的`side_effect`属性，如下所示：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`side_effect` can be used to simulate more complex functionality in a mocked
    callable. It can be set to a function, in which case the mock will run that function
    and return the results when called; it can be set to an iterable, in which case
    the mock will return the next item in the iterable each time it''s called; or,
    as in this case, it can be set to an exception, which will be raised when the
    mock is called.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`side_effect`可用于模拟可调用的更复杂功能。它可以设置为一个函数，这样当调用时，模拟将运行该函数并返回结果；它可以设置为一个可迭代对象，这样当调用时，模拟将返回可迭代对象中的下一个项目；或者，就像在这种情况下一样，它可以设置为一个异常，当调用模拟时将引发该异常。'
- en: 'Before we can use this, we''ll need to patch out `messagebox` as follows:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用之前，我们需要按照以下方式修补`messagebox`：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This time when we call `populate_recordlist()`, it throws an exception, prompting
    the method to call `messagebox.showerror()`. Since we've mocked `showerror()`,
    we can assert that it was called with the expected arguments.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次当我们调用`populate_recordlist()`时，它会抛出一个异常，促使该方法调用`messagebox.showerror()`。由于我们已经模拟了`showerror()`，我们可以断言它是否以预期的参数被调用。
- en: Clearly, the hardest part of testing our `Application` object is patching in
    all the mocked components and making sure they behave enough like the real thing
    to satisfy `Application`. Once we've done that, writing the actual tests is fairly
    straightforward.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，测试我们的`Application`对象最困难的部分是补丁所有模拟的组件，并确保它们的行为足够像真实的东西，以满足`Application`。一旦我们做到了这一点，编写实际的测试就相当简单了。
- en: Testing our widgets
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的小部件
- en: So far, we've done well with `patch`, `Mock`, and the default `TestCase`, but
    testing our widgets module is going to present some new challenges. To begin with,
    our widgets will need a `Tk` instance to be their root window. We can create this
    in each case's `setUp()` method, but this will slow down the tests considerably,
    and it isn't really necessary; our tests aren't going to modify the root window,
    so one root window will suffice for each test case. We can take advantage of the
    `setUpClass()` method to create a single instance of Tk just once at class instantiation.
    Secondly, we have a large number of widgets to test, which means we have a large
    number of test cases requiring the same boilerplate `Tk()` setup and tear down.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在`patch`、`Mock`和默认的`TestCase`方面做得很好，但是测试我们的小部件模块将带来一些新的挑战。首先，我们的小部件将需要一个`Tk`实例作为它们的根窗口。我们可以在每个案例的`setUp()`方法中创建这个实例，但这将大大减慢测试的速度，并且并不是真正必要的；我们的测试不会修改根窗口，因此一个根窗口对于每个测试案例就足够了。我们可以利用`setUpClass()`方法，在类实例化时只创建一个Tk的单个实例。其次，我们有大量的小部件需要测试，这意味着我们有大量的测试案例需要相同的样板`Tk()`设置和拆卸。
- en: 'To address this, let''s start our `test_widgets.py` module with a custom `TestCase`
    class as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们从一个自定义的`TestCase`类开始我们的`test_widgets.py`模块，如下所示：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `setUpClass()` method creates the `Tk()` object and calls `wait_visibility()`
    just to make sure our window is visible before our tests start working with it.
    Just as we did with our `Application` test, we also supply a complimentary tear-down
    method that updates the Tk instance and destroys it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUpClass()`方法创建`Tk()`对象并调用`wait_visibility()`，只是为了确保我们的窗口在我们的测试开始使用它之前是可见的。就像我们在`Application`测试中所做的那样，我们还提供了一个补充的拆卸方法，更新`Tk`实例并销毁它。'
- en: Unit testing the ValidatedSpinbox widget
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试ValidatedSpinbox小部件
- en: '`ValidatedSpinbox` is one of the more complicated widgets we created for our
    application, so it''s a good place to start writing tests.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidatedSpinbox`是我们为应用程序创建的较复杂的小部件之一，因此它是编写测试的好地方。'
- en: 'Subclass the `TkTestCase` class to create a test case for `ValidatedSpinbox` as
    follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化`TkTestCase`类以创建`ValidatedSpinbox`的测试案例，如下所示：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our setup method creates a variable in which to store the widget''s value,
    then creates an instance of the `ValidatedSpinbox` widget with some basic settings:
    a minimum value of -10, a maximum of 10, and an increment of 1\. After creating
    it, we pack it and wait for it to become visible. For our tear-down method, we
    simply destroy the widget.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置方法创建一个变量来存储小部件的值，然后使用一些基本设置创建`ValidatedSpinbox`小部件的实例：最小值为-10，最大值为10，增量为1。创建后，我们将其打包并等待它变得可见。对于我们的拆卸方法，我们只是销毁小部件。
- en: There are a couple of approaches we can take in testing our widget. The first
    approach is a unit testing-oriented approach, in which we focus on the actual
    method code, simply mocking out any external functionality.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的小部件时，我们可以采取几种方法。第一种方法是面向单元测试的方法，我们专注于实际的方法代码，简单地模拟任何外部功能。
- en: 'Let''s try that with the `_key_validate()` method as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`_key_validate()`方法如下：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We're simply iterating from 0 to 9 and testing both the positive and negative
    of the number against `_key_validate()`, which should return `True` for all of
    these values. The `_key_validate()` method takes a lot of positional arguments,
    and most of them are redundant; it might be nice to have a wrapper method that
    makes it easier to call, since our test case is potentially going to call it dozens
    of times.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从0到9进行迭代，并测试数字的正负值对`_key_validate()`的输出，这些值都应该返回`True`。`_key_validate()`方法需要很多位置参数，大部分是多余的；可能会很好地有一个包装方法，使其更容易调用，因为我们的测试案例可能会多次调用它。
- en: 'Let''s call that method `key_validate()` and add it to our `TestValidatedSpinbox`
    class as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将该方法称为`key_validate()`并将其添加到我们的`TestValidatedSpinbox`类中，如下所示：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will make future calls to the method shorter and less error-prone.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使将来对该方法的调用更短，更不容易出错。
- en: 'Let''s use it now to test some invalid input as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用它来测试一些无效的输入，如下所示：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the first example, we're entering `a`; in the second, `1` when `0.` is already
    in the box, resulting in `0.1`; in the third, `0` when `10` is in the box, resulting
    in `100`. All of these scenarios should fail the validation method.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们输入`a`；在第二个示例中，当框中已经有`0.`时，我们输入`1`，结果为`0.1`；在第三个示例中，当框中已经有`10`时，我们输入`0`，结果为`100`。所有这些情况都应该使验证方法失败。
- en: Integration testing the ValidatedSpinbox widget
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试ValidatedSpinbox小部件
- en: In the preceding tests, we weren't actually entering any data into the widget;
    we were simply calling the key validation method directly and evaluating its output.
    This is good unit testing, but it isn't quite satisfying as a test of this code.
    Since our custom widget is so deeply dependent on Tkinter's validation API, we'd
    like to test that we've actually implemented this API correctly. After all, that
    aspect of the code was more challenging than the actual logic in our validation
    methods.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们实际上并没有向小部件输入任何数据；我们只是直接调用键验证方法并评估其输出。这是很好的单元测试，但作为对这段代码的测试来说并不够令人满意。由于我们的自定义小部件非常依赖于Tkinter的验证API，我们希望测试我们是否正确地实现了这个API。毕竟，代码的这一方面比我们的验证方法中的实际逻辑更具挑战性。
- en: We can accomplish this by creating some integration tests that simulate actual
    user actions and then check the results of those actions. To do this cleanly,
    we'll first need to create some supporting methods.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一些集成测试来实现这一点，这些测试模拟了实际用户操作，然后检查这些操作的结果。为了做到这一点，我们首先需要创建一些支持方法。
- en: 'Start by adding a new method to the `TkTestCase` class as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`TkTestCase`类中添加一个新方法，如下所示：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This class will take a widget and a string and attempt to simulate a user typing
    the string into the widget. The first thing we do is force the focus to the widget;
    we need to use `focus_force()` because our test Tk window is unlikely to be in
    focus when the test is being run.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将接受一个小部件和一个字符串，并尝试模拟用户将字符串输入到小部件中。我们首先做的是强制焦点到小部件；我们需要使用`focus_force()`，因为我们的测试Tk窗口在运行测试时不太可能处于焦点状态。
- en: Once we have focus, we'll iterate through the characters in the string and translate
    the raw character into the appropriate key symbols for our event sequence. Recall
    that some characters, particularly symbols, must be represented as strings, such
    as `minus` or `colon`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得焦点，我们将遍历字符串中的字符，并将原始字符转换为事件序列的适当键符号。请记住，一些字符，特别是符号，必须表示为字符串，比如`minus`或`colon`。
- en: 'To make this work, we''ll need a class property called `dict` to translate
    between characters and their key symbols as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个方法起作用，我们需要一个名为`dict`的类属性，用于在字符和它们的键符号之间进行转换，如下所示：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: More key symbols can be found at [http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm](http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm)
    , but these should do for now.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的键符号可以在[http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm](http://www.tcl.tk/man/tcl8.4/TkCmd/keysyms.htm)找到，但现在这些就够了。
- en: 'Once our character is translated to the appropriate key symbol, we can create
    our event sequences and generate our key events.  Back in the  `type_in_widget()`
    method, we can create and call a key event sequence as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的字符被转换为适当的键符号，我们就可以创建我们的事件序列并生成我们的按键事件。在`type_in_widget()`方法中，我们可以创建并调用一个按键事件序列，如下所示：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that we call `self.root.update()` both before and after generating the
    keypress event. This ensures the widget is prepared for input, and that the inputs
    register after being generated. `update_idletasks()` will not do here, by the
    way; try it and you'll find that the tests will fail.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在生成按键事件之前和之后都调用了`self.root.update()`。这确保小部件已准备好输入，并且生成的输入在生成后注册。顺便说一句，`update_idletasks()`在这里行不通；试一试，你会发现测试会失败。
- en: 'We can create a similar method for simulating mouse button clicks as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个类似的方法来模拟鼠标点击按钮，如下所示：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Just as we did with our keystroke method, we first force focus, update the application,
    generate our events, then update again. In this method, however, we also need
    to specify the `x` and `y` coordinates for the mouse click. These are coordinates
    relative to the upper-left corner of the widget. We can also specify a button
    number, but we'll default to the left button (`1`).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用按键方法一样，我们首先强制焦点，更新应用程序，生成我们的事件，然后再次更新。然而，在这个方法中，我们还需要指定鼠标点击的`x`和`y`坐标。这些坐标是相对于小部件左上角的坐标。我们也可以指定按钮编号，但我们将默认为左按钮（`1`）。
- en: 'With these methods in place, return to `TestValidatedSpinbox` and write a new
    test:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些方法，回到`TestValidatedSpinbox`并编写一个新的测试：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method starts by clearing the widget, then simulates some valid input with
    `type_in _widget()` and checks that it was accepted by the widget. Note that in
    these integration tests we'll need to clear the widget each time because we are
    simulating keystrokes in an actual widget and triggering all the side effects
    of that action.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法首先通过清除小部件，然后用`type_in_widget()`模拟一些有效的输入，并检查小部件是否接受了输入。请注意，在这些集成测试中，我们需要每次清除小部件，因为我们正在模拟实际小部件中的按键，并触发所有这些操作的副作用。
- en: 'Next, let''s test some invalid input by executing the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过执行以下代码来测试一些无效的输入：
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can use our mouse click method to test the functionality of the `Spinbox`
    arrow buttons as well. To make this simpler, let''s create a helper method in
    our test case class to click on the arrow we want. Add this to `TestValidatedSpinbox`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用鼠标点击方法来测试`Spinbox`箭头按钮的功能。为了简化这个过程，让我们在测试用例类中创建一个辅助方法来点击我们想要的箭头。将这个方法添加到`TestValidatedSpinbox`中：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can target the increment arrow by clicking `5` pixels from the right and
    `5` from the top of the widget. The decrement arrow can be found at `5` pixels
    from the right and `15` from the top. This may need some adjustment depending
    on the theme or screen settings, of course. Now, we can test our arrow key functionality
    easily as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击距离小部件右侧`5`像素，顶部`5`像素来定位增量箭头。减量箭头可以在距右侧`5`像素，顶部`15`像素的位置找到。当然，这可能需要根据主题或屏幕设置进行一些调整。现在，我们可以轻松地测试我们的箭头键功能，如下所示：
- en: '[PRE57]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By setting the value of the widget, then clicking the appropriate arrow a specified
    number of times, we can test that the arrows did their jobs according to the rules
    of our widget class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置小部件的值，然后点击适当的箭头指定次数，我们可以测试箭头是否根据我们的小部件类的规则完成了它们的工作。
- en: Testing our mixin class
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的混合类
- en: 'One additional challenge we haven''t approached yet is testing our mixin class.
    Unlike our other widget classes, our mixin cannot really exist on its own: it
    depends on methods and properties found in the `ttk` widget which it''s combined
    with.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解决的一个额外挑战是测试我们的混合类。与我们的其他小部件类不同，我们的混合类实际上不能独立存在：它依赖于与之组合的`ttk`小部件中找到的方法和属性。
- en: One approach to testing this class would be to mix it with a `Mock` object which
    mocks out any inherited methods. This approach has merit, but a simpler (if less
    ideal) approach is to subclass it with the simplest possible `ttk` widget and
    test the resulting child class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个类的一种方法是将它与一个`Mock`对象混合，该对象模拟了任何继承方法。这种方法是有优点的，但一个更简单（虽然不太理想）的方法是用最简单的`ttk`小部件的子类来继承它，并测试生成的子类。
- en: 'That approach looks like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法看起来是这样的：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we've created just a basic child class using `ttk.Entry` and modified
    nothing else. Then, we created an instance of the class.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是使用`ttk.Entry`创建了一个基本的子类，并没有进行其他修改。然后，我们创建了该类的一个实例。
- en: 'Let''s test our `_validate()` method as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式测试我们的`_validate()`方法：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because we're sending a key event to `_validate()`, it routes the request to
    `_key_validate()`, which simply returns `True` by default. We'll need to verify
    that `_validate()` does what is needed when `_key_validate()` returns `False`
    as well.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们向`_validate()`发送了一个键事件，它将请求路由到`_key_validate()`，后者默认情况下只返回`True`。我们需要验证当`_key_validate()`返回`False`时，`_validate()`是否执行了所需的操作。
- en: 'We''ll employ `Mock` to do this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Mock`来实现这一点：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We test that `False` is returned and that `_key_validate` was called with the
    correct arguments.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试`False`被返回，并且`_key_validate`被调用时使用了正确的参数。
- en: 'By updating the `event` value in `args`, we can check that `focusout` events
    also work:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新`args`中的`event`值，我们可以检查`focusout`事件是否也起作用：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We've taken an identical approach here, just mocking out `_focusout_validate()`
    to make it return `False`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取了相同的方法，只是模拟了`_focusout_validate()`以使其返回`False`。
- en: As you can see, once we've created our test class, testing `ValidatedMixin`
    is like testing any other widget class. There are other test method examples in
    the included source code; these should be enough to get you started with creating
    a complete test suite.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一旦我们创建了我们的测试类，测试`ValidatedMixin`就像测试任何其他小部件类一样。在包含的源代码中还有其他测试方法的示例；这些应该足以让您开始创建一个完整的测试套件。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about automated testing and the capabilities provided
    by Python's `unittest` library. We wrote both unit tests and integration tests
    against portions of our application, and you learned methods for tackling a variety
    of testing challenges.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了自动化测试以及Python的`unittest`库提供的功能。我们针对应用程序的部分编写了单元测试和集成测试，您学会了解决各种测试挑战的方法。
- en: In the next chapter, we'll upgrade our backend to use a relational database.
    You'll also learn about relational databases, SQL, and database normalization.
    You'll learn to work with the PostgreSQL database server and Python's `psycopg2`
    PostgreSQL interface library.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将升级我们的后端以使用关系数据库。您还将学习关系数据库、SQL和数据库规范化。您将学习如何与PostgreSQL数据库服务器和Python的`psycopg2`
    PostgreSQL接口库一起工作。
