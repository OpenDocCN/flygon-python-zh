- en: 1\. Fundamentals of Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Python基础
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter reviews the basic Python data structures and tools that will be
    used in future discussions. These concepts will allow us to refresh our memory
    regarding Python's most fundamental and important features, while simultaneously
    preparing us for advanced topics in later chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了将在未来讨论中使用的基本Python数据结构和工具。这些概念将使我们能够刷新我们对Python最基本和重要特性的记忆，同时为以后章节中的高级主题做好准备。
- en: By the end of this chapter, you will be able to use control flow methods to
    design your Python programs and initialize common Python data structures, as well
    as manipulate their content. You will solidify your understanding of functions
    and recursion in Python algorithm design. You will also be able to facilitate
    debugging, testing, and version control for Python programs. Finally, in the activity
    at the end of this chapter, you will create a Sudoku solver.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够使用控制流方法设计Python程序并初始化常见的Python数据结构，以及操纵它们的内容。您将巩固对Python算法设计中函数和递归的理解。您还将能够为Python程序进行调试、测试和版本控制。最后，在本章末尾的活动中，您将创建一个数独求解器。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python has enjoyed an unprecedented increase in popularity and usage in recent
    years, especially in mathematics, which is the main topic of this chapter. However,
    before we delve into the advanced topics in mathematics, we will need to solidify
    our understanding of the fundamentals of the language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python近年来在数学领域的受欢迎程度和使用率前所未有。然而，在深入讨论数学的高级主题之前，我们需要巩固对语言基础知识的理解。
- en: This chapter will offer a refresher on the general concepts of Python; the topics
    covered will allow you to be in the best position for later discussions in this
    book. Specifically, we will be reviewing elementary concepts in general programming
    such as conditionals and loops, as well as Python-specific data structures such
    as lists and dictionaries. We will also discuss functions and the algorithm design
    process, which is an important part in any medium or large Python project that
    includes mathematics-related programs. All of this will be done through hands-on
    exercises and activities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将对Python的一般概念进行复习；所涵盖的主题将使您在本书的后续讨论中处于最佳位置。具体来说，我们将复习一般编程中的基本概念，如条件和循环，以及Python特定的数据结构，如列表和字典。我们还将讨论函数和算法设计过程，这是包括与数学相关的程序在内的任何中型或大型Python项目中的重要部分。所有这些都将通过实践练习和活动来完成。
- en: By the end of this chapter, you will be well positioned to tackle more complex,
    interesting problems in later chapters of this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够在本书后续章节中处理更复杂、更有趣的问题。
- en: Control Flow Methods
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流方法
- en: 'Control flow is a general term that denotes any programming syntax that can
    redirect the execution of a program. Control flow methods in general are what
    allow programs to be dynamic in their execution and computation: depending on
    the current state of a program or its input, the execution of that program and
    thus its output will dynamically change.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流是一个通用术语，表示可以重定向程序执行的任何编程语法。一般来说，控制流方法是使程序在执行和计算时具有动态性的原因：根据程序的当前状态或输入，程序的执行和输出将动态改变。
- en: if Statements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句
- en: The most common form of control flow in any programming language is conditionals,
    or `if` statements. `if` statements are used to check for a specific condition
    about the current state of the program and, depending on the result (whether the
    condition is true or false), the program will execute different sets of instructions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中最常见的控制流形式是条件语句，或者`if`语句。`if`语句用于检查程序当前状态的特定条件，并根据结果（条件是真还是假）执行不同的指令集。
- en: 'In Python, the syntax of an `if` statement is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`if`语句的语法如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given the readability of Python, you can probably already guess how conditionals
    work: when the execution of a given program reaches a conditional and checks the
    condition in the `if` statement, if the condition is true, the indented set of
    instructions *inside* the `if` statement will be executed; otherwise, the program
    will simply skip those instructions and move on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python的可读性，你可能已经猜到条件语句的工作原理：当给定程序的执行达到条件语句并检查`if`语句中的条件时，如果条件为真，则将执行缩进的指令集*在*`if`语句内部；否则，程序将简单地跳过这些指令并继续执行。
- en: 'Within an `if` statement, it is possible for us to check for a composite condition,
    which is a combination of multiple individual conditions. For example, using the
    `and` keyword, the following `if` block is executed when both of its conditions
    are satisfied:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句内部，我们可以检查复合条件，这是多个单独条件的组合。例如，使用`and`关键字，当满足其两个条件时，将执行以下`if`块：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of doing this, we can use the `or` keyword in a composite condition,
    which will display positive (true) if either the condition to the left or to the
    right of the keyword is true. It is also possible to keep extending a composite
    condition with more than one `and`/`or` keyword to implement conditionals that
    are nested on multiple levels.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，我们可以在复合条件中使用`or`关键字，如果关键字左侧或右侧的条件为真，则显示正（真）。还可以使用多个`and`/`or`关键字扩展复合条件，以实现嵌套在多个级别上的条件语句。
- en: 'When a condition is not satisfied, we might want our program to execute a different
    set of instructions. To implement this logic, we can use `elif` and `else` statements,
    which should immediately follow an `if` statement. If the condition in the `if`
    statement is not met, our program will move on and evaluate the subsequent conditions
    in the `elif` statements; if none of the conditions are met, any code inside an
    `else` block will be executed. An `if...elif...else` block in Python is in the
    following form:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件不满足时，我们可能希望程序执行不同的一组指令。为了实现这种逻辑，我们可以使用`elif`和`else`语句，这些语句应该紧随在`if`语句之后。如果`if`语句中的条件不满足，我们的程序将继续并评估`elif`语句中的后续条件；如果没有一个条件被满足，`else`块中的任何代码都将被执行。Python中的`if...elif...else`块的形式如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This control flow method is very valuable when there is a set of possibilities
    that our program needs to check for. Depending on which possibility is true at
    a given moment, the program should execute the corresponding instructions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序需要检查一组可能性时，这种控制流方法非常有价值。根据给定时刻的真实可能性，程序应该执行相应的指令。
- en: 'Exercise 1.01: Divisibility with Conditionals'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01：条件除法
- en: In mathematics, the analysis of variables and their content is very common,
    and one of the most common analyses is the divisibility of an integer. In this
    exercise, we will use `if` statements to consider the divisibility of a given
    number by 5, 6, or 7.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，对变量及其内容的分析是非常常见的，其中最常见的分析之一是整数的可整除性。在这个练习中，我们将使用`if`语句来考虑给定数字是否可以被5、6或7整除。
- en: 'Perform the following steps in order to achieve this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，请按照以下步骤进行：
- en: 'Create a new Jupyter notebook and declare a variable named `x` whose value
    is any integer, as shown in the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter笔记本，并声明一个名为`x`的变量，其值为任何整数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that declaration, write an `if` statement to check whether `x` is divisible
    by 5 or not. The corresponding code block should print out a statement indicating
    whether the condition has been met:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在声明之后，编写一个`if`语句，检查`x`是否可以被5整除。相应的代码块应该打印出一个指示条件是否满足的语句：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `%` is the modulo operator in Python; the `var % n` expression returns
    the remainder when we divide the `var` variable by the number, `n`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`%`是Python中的取模运算符；`var % n`表达式返回当我们用数字`n`除以变量`var`时的余数。
- en: 'In the same code cell, write two `elif` statements to check whether `x` is
    divisible by 6 and 7, respectively. Appropriate `print` statements should be placed
    under their corresponding conditionals:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个代码单元格中，编写两个`elif`语句，分别检查`x`是否可以被6和7整除。适当的`print`语句应该放在相应条件下面：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Write the final `else` statement to print out a message stating that `x` is
    not divisible by either 5, 6, or 7 (in the same code cell):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最终的`else`语句，以打印一条消息，说明`x`既不能被5整除，也不能被6或7整除（在同一个代码单元格中）：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the program with a different value assigned to `x` each time to test the
    conditional logic we have. The following output is an example of this with `x`
    assigned with the value `104832`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次为`x`分配一个不同的值来测试我们的条件逻辑。以下输出是`x`被赋值为`104832`的一个示例：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, instead of printing out a message about the divisibility of `x`, we would
    like to write that message to a text file. Specifically, we want to create a file
    named `output.txt` that will contain the same message that we printed out previously.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不想打印关于`x`的可整除性的消息，而是想将该消息写入文本文件。具体来说，我们想创建一个名为`output.txt`的文件，其中包含我们先前打印出的相同消息。
- en: 'To do this, we can use the `with` keyword together with the `open()` function
    to interact with the text file. Note that the `open()` function takes in two arguments:
    the name of the file to write to, which is `output.txt` in our case, and `w` (for
    write), which specifies that we would like to write to file, as opposed to reading
    the content from a file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用`with`关键字和`open()`函数与文本文件进行交互。请注意，`open()`函数接受两个参数：要写入的文件名，在我们的例子中是`output.txt`，以及`w`（表示写入），指定我们想要写入文件，而不是从文件中读取内容：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check the message in the output text file for its correctness. If the `x` variable
    still holds the value of `104832`, your text file should have the following contents:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输出文本文件中的消息是否正确。如果`x`变量仍然保持值`104832`，则您的文本文件应该包含以下内容：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this exercise, we applied the usage of conditionals to write a program that
    determines the divisibility of a given number by 6, 3, and 2 using the `%` operator.
    We also saw how to write content to a text file in Python. In the next section,
    we will start discussing loops in Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们应用了条件语句来编写一个程序，使用`%`运算符来确定给定数字是否可以被6、3和2整除。我们还学习了如何在Python中向文本文件写入内容。在下一节中，我们将开始讨论Python中的循环。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code lines in the `elif` block are executed sequentially, and breaks from
    sequence, when any one of the conditions is true. This implies that when x is
    assigned the value 30, once `x%5==0` is satisfied, `x%6==0` is not checked.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`块中的代码行按顺序执行，并在任何一个条件为真时中断序列。这意味着当x被赋值为30时，一旦满足`x%5==0`，就不会检查`x%6==0`。'
- en: To access the source code for this specific section, please refer to [https://packt.live/3dNflxO.](https://packt.live/3dNflxO
    )
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dNflxO.](https://packt.live/3dNflxO )
- en: You can also run this example online at [https://packt.live/2AsqO8w](https://packt.live/2AsqO8w).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2AsqO8w](https://packt.live/2AsqO8w)上在线运行此示例。
- en: Loops
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Another widely used control flow method is the use of loops. These are used
    to execute the same set of instructions repeatedly over a specified range or while
    a condition is met. There are two types of loops in Python: `while` loops and
    `for` loops. Let''s understand each one in detail.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个广泛使用的控制流方法是使用循环。这些用于在指定范围内重复执行相同的指令，或者在满足条件时重复执行相同的指令。Python中有两种类型的循环：`while`循环和`for`循环。让我们详细了解每种循环。
- en: The while Loop
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while循环
- en: 'A `while` loop, just like an `if` statement, checks for a specified condition
    to determine whether the execution of a given program should keep on looping or
    not. For example, consider the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环，就像`if`语句一样，检查指定的条件，以确定给定程序的执行是否应该继续循环。例如，考虑以下代码：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, after `x` was initialized with the value `0`, a `while`
    loop was used to successively print out the value of the variable and increment
    the same variable at each iteration. As you can imagine, when this program executes,
    `0`, `1`, and `2` will be printed out and when `x` reaches `3`, the condition
    specified in the `while` loop is no longer met, and the loop therefore ends.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`x`被初始化为值`0`后，使用`while`循环来连续打印变量的值，并在每次迭代中递增相同的变量。可以想象，当这个程序执行时，将打印出`0`、`1`和`2`，当`x`达到`3`时，`while`循环中指定的条件不再满足，因此循环结束。
- en: Note that the `x += 1` command corresponds to `x = x + 1`, which increments
    the value of `x` during each iteration of the loop. If we remove this command,
    then we would get an infinite loop printing `0` each time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`x += 1`命令对应于`x = x + 1`，它在循环的每次迭代中增加`x`的值。如果我们删除这个命令，那么我们将得到一个无限循环，每次打印`0`。
- en: The for Loop
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for循环
- en: 'A `for` loop, on the other hand, is typically used to iterate through a specific
    sequence of values. Using the `range` function in Python, the following code produces
    the exact same output that we had previously:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`for`循环通常用于迭代特定序列的值。使用Python中的`range`函数，以下代码产生了与我们之前相同的输出：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `in` keyword is the key to any `for` loop in Python: when it is used, the
    variable in front of it will be assigned values inside the iterator that we''d
    like to loop through sequentially. In the preceding case, the `x` variable is
    assigned the values inside the `range(3)` iterator—which are, in order, `0`, `1`,
    and `2`—at each iteration of the `for` loop.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`关键字是Python中任何`for`循环的关键：当使用它时，其前面的变量将被分配在我们想要顺序循环的迭代器中的值。在前面的例子中，`x`变量被分配了`range(3)`迭代器中的值，依次是`0`、`1`和`2`，在`for`循环的每次迭代中。'
- en: 'Instead of `range()`, other types of iterators can also be used in a Python
    `for` loop. The following table gives a brief summary of some of the most common
    iterators to be used in `for` loops. Don''t worry if you are not familiar with
    the data structures included in this table; we will cover those concepts later
    in this chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的`for`循环中，除了`range()`之外，还可以使用其他类型的迭代器。以下表格简要总结了一些最常见的用于`for`循环的迭代器。如果您对此表中包含的数据结构不熟悉，不要担心；我们将在本章后面介绍这些概念：
- en: '![Figure 1.1: List of datasets and their examples'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：数据集及其示例列表'
- en: '](image/B15968_01_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_01_01.jpg)'
- en: 'Figure 1.1: List of datasets and their examples'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：数据集及其示例列表
- en: It is also possible to nest multiple loops inside one another. While the execution
    of a given program is inside a loop, we can use the `break` keyword to exit the
    current loop and move on with the execution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在彼此内部嵌套多个循环。当给定程序的执行位于循环内部时，我们可以使用`break`关键字退出当前循环并继续执行。
- en: 'Exercise 1.02: Number Guessing Game'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：猜数字游戏
- en: For this exercise, we will put our knowledge of loops to practice and write
    a simple guessing game. A target integer between 0 and 100 is randomly selected
    at the beginning of the program. Then, the program will take in user inputs as
    guesses of what this number is. In response, the program will print out a message
    saying `Lower` if the guess is greater than the actual target, or `Higher` if
    the opposite is true. The program should terminate when the user guesses correctly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把我们对循环的知识付诸实践，并编写一个简单的猜数字游戏。程序开始时随机选择一个介于0和100之间的目标整数。然后，程序将接受用户输入作为猜测这个数字的猜测。作为回应，程序将打印出一条消息，如果猜测大于实际目标，则打印`Lower`，如果相反，则打印`Higher`。当用户猜对时，程序应该终止。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'In the first cell of a new Jupyter notebook, import the `random` module in
    Python and use its `randint` function to generate random numbers:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Jupyter笔记本的第一个单元格中，导入Python中的`random`模块，并使用其`randint`函数生成随机数：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Every time the `randint()` function is called, it generates a random integer
    between the two numbers passed to it; in our case, an integer between 0 and 100
    will be generated.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`randint()`函数时，它都会生成两个传递给它的数字之间的随机整数；在我们的情况下，将生成介于0和100之间的整数。
- en: While they are not needed for the rest of this exercise, if you are curious
    about other functionalities that the random module offers, you can take a look
    at its official documentation at [https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们在本练习的其余部分中并不需要，但如果您对随机模块提供的其他功能感兴趣，可以查看其官方文档[https://docs.python.org/3/library/random.html](https://docs.python.org/3/library/random.html)。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The rest of the program should also be put in the current code cell.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分也应该放在当前代码单元格中。
- en: 'Use the `input()` function in Python to take in the user''s input and assign
    the returned value to a variable (`guess`, in the following code). This value
    will be interpreted as the guess of what the target is from the user:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python中的`input()`函数接受用户的输入，并将返回的值赋给一个变量（在以下代码中为`guess`）。这个值将被解释为用户对目标的猜测：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Convert the user input into an integer using the `int()` function and check
    it against the true target. Print out appropriate messages for all possible cases
    of the comparison:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`int()`函数将用户输入转换为整数，并将其与真实目标进行比较。针对比较的所有可能情况打印出适当的消息：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `#` symbol in the code snippet below denotes a code comment. Comments are
    added into code to help explain specific bits of logic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面代码片段中的`#`符号表示代码注释。注释被添加到代码中，以帮助解释特定的逻辑部分。
- en: 'With our current code, the `int()` function will throw an error and crash the
    entire program if its input cannot be converted into an integer (for example,
    when the input is a string character). For this reason, we need to implement the
    code we have inside a `try...except` block to handle the situation where the user
    enters a non-numeric value:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们当前的代码，如果`int()`函数的输入无法转换为整数（例如，输入为字符串字符），它将抛出错误并使整个程序崩溃。因此，我们需要在`try...except`块中实现我们的代码，以处理用户输入非数字值的情况：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As of now, the user can only guess exactly once before the program terminates.
    To implement the feature that would allow the user to repeatedly guess until they
    find the target, we will wrap the logic we have developed so far in a `while`
    loop, which will break if and only if the user guesses correctly (implemented
    by a `while True` loop with the `break` keyword placed appropriately).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，用户只能在程序终止之前猜一次。为了实现允许用户重复猜测直到找到目标的功能，我们将迄今为止开发的逻辑包装在一个`while`循环中，只有当用户猜对时（通过适当放置`while
    True`循环和`break`关键字来实现）才会中断。
- en: 'The complete program should look similar to the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序应该类似于以下代码：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Try rerunning the program by executing the code cell and test out different
    input options to ensure that the program can process its instructions nicely,
    as well as handle cases of invalid inputs. For example, the output the program
    might produce when the target number is randomly selected to be 13 is as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过执行代码单元格重新运行程序，并尝试不同的输入选项，以确保程序可以很好地处理其指令，并处理无效输入的情况。例如，当目标数字被随机选择为13时，程序可能产生的输出如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this exercise, we have practiced using a `while` loop in a number guessing
    game to solidify our understanding of the usage of loops in programming. In addition,
    you have been introduced to a method of reading in user input and the `random`
    module in Python.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经练习了在猜数字游戏中使用`while`循环，以巩固我们对编程中循环使用的理解。此外，您已经了解了在Python中读取用户输入和`random`模块的方法。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BYK6CR.](https://packt.live/2BYK6CR
    )
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2BYK6CR.](https://packt.live/2BYK6CR )
- en: You can also run this example online at [https://packt.live/2CVFbTu](https://packt.live/2CVFbTu).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2CVFbTu](https://packt.live/2CVFbTu)上在线运行此示例。
- en: Next, we will start considering common Python data structures.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始考虑常见的Python数据结构。
- en: Data Structures
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: Data structures are types of variables that represent different forms of information
    that you might want to create, store, and manipulate in your program. Together
    with control flow methods, data structures are the other fundamental building
    block of any programming language. In this section, we will go through some of
    the most common data structures in Python, starting with strings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是代表您可能想要在程序中创建、存储和操作的不同形式的信息的变量类型。与控制流方法一起，数据结构是任何编程语言的另一个基本构建块。在本节中，我们将介绍Python中一些最常见的数据结构，从字符串开始。
- en: Strings
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are sequences of characters that are typically used to represent textual
    information (for example, a message). A Python string is denoted by any given
    textual data inside either single- or double-quotation marks. For example, in
    the following code snippet, the `a` and `b` variables hold the same information:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符序列，通常用于表示文本信息（例如，消息）。Python字符串由单引号或双引号中的任何给定文本数据表示。例如，在以下代码片段中，`a`和`b`变量保存相同的信息：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since strings are roughly treated as sequences in Python, common sequence-related
    operations can be applied to this data structure. In particular, we can concatenate
    two or more strings together to create a long-running string, we can iterate through
    a string using a `for` loop, and individual characters and substrings can be accessed
    using indexing and slicing. The effects of these operations are demonstrated in
    the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Python中字符串大致被视为序列，因此可以将常见的与序列相关的操作应用于此数据结构。特别是，我们可以将两个或多个字符串连接在一起以创建一个长字符串，我们可以使用`for`循环遍历字符串，并且可以使用索引和切片访问单个字符和子字符串。这些操作的效果在以下代码中进行了演示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One of the most important features that was added in Python 3.6 was f-strings,
    a syntax to format strings in Python. Since we are using Python 3.7, we can avail
    this feature. String formatting is used when we would like to insert the value
    of a given variable into a predefined string. Before f-strings, there were two
    other formatting options, which you may be familiar with: %-formatting and `str.format()`.
    Without going into too much detail, these two methods have a few undesirable characteristics,
    and f-strings was therefore developed to address those problems.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.6中添加的最重要的功能之一是f-strings，这是Python中格式化字符串的语法。由于我们使用的是Python 3.7，因此可以使用此功能。字符串格式化用于在我们想要将给定变量的值插入预定义字符串时使用。在f-strings之前，还有两种其他格式化选项，您可能熟悉：%-格式化和`str.format()`。不详细介绍这两种方法，这两种方法都有一些不良特性，因此开发了f-strings来解决这些问题。
- en: 'The syntax for f-strings is defined with curly brackets, `{` and `}`. For example,
    we can combine the printed value of a variable using an f-string as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: f-strings的语法是用大括号`{`和`}`定义的。例如，我们可以使用f-string将变量的打印值组合如下：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When a variable is put inside the f-string curly brackets, its `__str__()` representation
    will be used in the final printed output. This means you can obtain further flexibility
    with f-strings by overwriting and customizing the dunder method, `__str__()`,
    while working with Python objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当将变量放入f-string大括号中时，它的`__str__()`表示将在最终的打印输出中使用。这意味着在使用Python对象时，您可以通过覆盖和自定义dunder方法`__str__()`来获得f-strings的更多灵活性。
- en: 'Common numeric formatting options for strings such as specifying the number
    of digits after the decimal or datetime formatting can be done in f-strings using
    the colon, as demonstrated here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在f-strings中，可以使用冒号来指定字符串的常见数字格式选项，例如指定小数点后的位数或日期时间格式，如下所示：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another great thing about f-strings is that they are faster to render and process
    than the other two string formatting methods. Next, let's discuss Python lists.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: f-strings的另一个好处是它们比其他两种字符串格式化方法更快渲染和处理。接下来，让我们讨论Python列表。
- en: Lists
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists are arguably the most used data structure in Python. It is Python''s
    own version of an array in Java or C/C++. A list is a sequence of elements that
    can be accessed or iterated over in order. Unlike, say, Java arrays, elements
    in a Python list do not have to be of the same data structure, as demonstrated
    here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以说是Python中最常用的数据结构。它是Python版本的Java或C/C++中的数组。列表是可以按顺序访问或迭代的元素序列。与Java数组不同，Python列表中的元素不必是相同的数据结构，如下所示：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We'll talk more about tuples in the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节更多地讨论元组。
- en: 'As we have discussed previously, elements in a list can be iterated over in
    a `for` loop in a similar way as characters in a string. Lists can also be indexed
    and sliced in the same way as strings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，列表中的元素可以在`for`循环中以与字符串中字符类似的方式进行迭代。列表也可以像字符串一样进行索引和切片：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two ways to add new elements to a Python list: `append()` inserts
    a new single element to the end of a list, while list concatenation simply concatenates
    two or more strings together, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以向Python列表添加新元素：`append()`将一个新的单个元素插入到列表的末尾，而列表连接简单地将两个或多个字符串连接在一起，如下所示：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To remove an element from a list, the `pop()` method, which takes in the index
    of the element to be removed, can be used.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中删除一个元素，可以使用`pop()`方法，该方法接受要删除的元素的索引。
- en: 'One of the operations that make Python lists unique is list comprehension:
    a Pythonic syntax to efficiently initialize lists using a `for` loop placed inside
    square brackets. List comprehension is typically used when we want to apply an
    operation to an existing list to create a new list. For example, say we have a
    list variable, `a`, containing some integers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使Python列表独特的操作之一是列表推导：一种Python语法，可以使用放置在方括号内的`for`循环来高效地初始化列表。列表推导通常用于当我们想要对现有列表应用操作以创建新列表时。例如，假设我们有一个包含一些整数的列表变量`a`：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we want to create a new list, `b`, whose elements are two times the elements
    in `a`, in order. We could potentially initialize `b` as an empty list and iteratively
    loop through `a` and append the appropriate values to `b`. However, with list
    comprehension, we can achieve the same result with a more elegant syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要创建一个新的列表`b`，其元素是`a`中元素的两倍，按顺序。我们可以潜在地将`b`初始化为空列表，并迭代地遍历`a`并将适当的值附加到`b`。然而，使用列表推导，我们可以用更优雅的语法实现相同的结果：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Furthermore, we can even combine conditionals inside a list comprehension to
    implement complex logic in this process of creating Python lists. For example,
    to create a list of twice the elements in `a` that are odd numbers, we can do
    the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们甚至可以在列表推导中结合条件语句来实现在创建Python列表的过程中的复杂逻辑。例如，要创建一个包含`a`中奇数元素两倍的列表，我们可以这样做：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another Python data structure that is very often contrasted with list is tuple,
    which we will discuss in the next section. However, before moving forward, let''s
    go through an exercise on a new concept: multi-dimensional lists/arrays.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常与列表进行对比的Python数据结构是元组，我们将在下一节中讨论。然而，在继续之前，让我们通过一个新概念的练习来了解多维列表/数组。
- en: Multi-dimensional arrays, also known as tables or matrices (and sometimes tensors),
    are common objects in the field of mathematics and machine learning. Given the
    fact that elements in a Python list can be any Python objects, we can model arrays
    that span more than one dimension using lists in a list. Specifically, imagine
    that, within an overarching Python list, we have three sublists, each having three
    elements in it. This object can be thought of as a 2D, 3 x 3 table. In general,
    we can model *n*-dimensional arrays using Python lists that are nested inside
    other lists *n* times.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组，也称为表或矩阵（有时称为张量），是数学和机器学习领域中常见的对象。考虑到Python列表中的元素可以是任何Python对象，我们可以使用列表中的列表来模拟跨越多个维度的数组。具体来说，想象一下，在一个总体的Python列表中，我们有三个子列表，每个子列表中有三个元素。这个对象可以被看作是一个2D的3
    x 3表。一般来说，我们可以使用嵌套在其他列表中的Python列表来模拟*n*维数组。
- en: 'Exercise 1.03: Multi-Dimensional Lists'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：多维列表
- en: In this exercise, we will familiarize ourselves with the concept of multi-dimensional
    lists and the process of iterating through them. Our goal here is to write logic
    commands that dynamically display the content of a 2D list.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将熟悉多维列表的概念以及通过它们进行迭代的过程。我们的目标是编写逻辑命令，动态显示2D列表的内容。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Create a new Jupyter notebook and declare a variable named `a` in a code cell,
    as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter笔记本，并在一个代码单元格中声明一个名为`a`的变量，如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This variable represents a 3 x 3 2D table, with the individual sublists in the
    list representing the rows.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量表示一个3 x 3的2D表，列表中的各个子列表表示行。
- en: 'In a new code cell, iterate through the rows by looping through the elements
    in list `a` (do not run the cell just yet):'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的代码单元格中，通过循环遍历列表`a`中的元素来迭代行（暂时不要运行单元格）：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At each iteration in this `for` loop, a sublist in `a` is assigned to a variable
    called `row`. We can then access the individual cells in the 2D table by indexing
    the individual rows. The following `for` loop will print out the first element
    in each sublist, or in other words, the number in the first cell of each row in
    the table (`1`, `4`, and `7`):'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`for`循环的每次迭代中，`a`中的一个子列表被分配给一个名为`row`的变量。然后，我们可以通过索引访问2D表中的单个单元格。以下`for`循环将打印出每个子列表中的第一个元素，或者换句话说，表中每行的第一个单元格中的数字（`1`、`4`和`7`）：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In a new code cell, print out the values of all the cells in table `a` by having
    a nested `for` loop, whose inner loop will iterate through the sublists in `a`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的代码单元格中，通过嵌套的`for`循环打印出表`a`中所有单元格的值，内部循环将遍历`a`中的子列表：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This should print out the numbers from 1 to 9, each in a separate row.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该打印出从1到9的数字，每个数字在单独的行中。
- en: 'Finally, in a new cell, we need to print out the diagonal elements of this
    table in a nicely formatted message. To do this, we can have an indexing variable
    — `i`, in our case — loop from `0` to `2` to access the diagonal elements of the
    table:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在一个新的单元格中，我们需要以格式良好的消息打印出这个表的对角线元素。为此，我们可以使用一个索引变量——在我们的例子中是`i`——从`0`循环到`2`来访问表的对角线元素：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Your output should be 1, 5, and 9, each in a separate row.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应该是1、5和9，每个在单独的行中。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is because the row index and the column index of a diagonal element in
    a table/matrix are equal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为表/矩阵中对角线元素的行索引和列索引相等。
- en: 'In a new cell, change the preceding `print` statements using f-strings to format
    our printed output:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的单元格中，使用f-strings更改前面的`print`语句以格式化我们的打印输出：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This should produce the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下输出：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this exercise, we have combined what we have learned about loops, indexing,
    and f-string formatting to create a program that dynamically iterates through
    a 2D list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们结合了关于循环、索引和f-string格式化的知识，创建了一个动态迭代2D列表的程序。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dRP8OA.](https://packt.live/3dRP8OA
    )
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dRP8OA.](https://packt.live/3dRP8OA )
- en: You can also run this example online at [https://packt.live/3gpg4al](https://packt.live/3gpg4al).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3gpg4al](https://packt.live/3gpg4al)上线上运行此示例。
- en: Next, we'll continue our discussion about other Python data structures.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论其他Python数据结构。
- en: Tuples
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'Declared with parentheses instead of square brackets, Python tuples are still
    sequences of different elements, similar to lists (although the parentheses can
    be omitted in assignment statements). The main difference between these two data
    structures is that tuples are immutable objects in Python—this means they cannot
    be mutated, or changed, in any way after their initialization, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用括号而不是方括号声明的Python元组仍然是不同元素的序列，类似于列表（尽管在赋值语句中可以省略括号）。这两种数据结构之间的主要区别在于元组是Python中的不可变对象——这意味着它们在初始化后无法以任何方式进行变异或更改，如下所示：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Given this key difference between tuples and lists, we can utilize these data
    structures accordingly: when we want a sequence of elements to be immutable for
    any number of reasons (for example, to ensure the logical integrity functions),
    a tuple can be used; if we allow the sequence to be able to be changed after its
    initialization, it can be declared as a list.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于元组和列表之间的这一关键差异，我们可以相应地利用这些数据结构：当我们希望一个元素序列由于任何原因（例如，确保逻辑完整性函数）是不可变的时，可以使用元组；如果允许序列在初始化后进行更改，可以将其声明为列表。
- en: 'Next, we will be discussing a common data structure in mathematical computing:
    sets.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论数学计算中常见的数据结构：集合。
- en: Sets
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'If you are already familiar with the mathematical concept, the definition of
    a Python set is essentially the same: a Python set is a collection of unordered
    elements. A set can be initialized with curly brackets, and a new element can
    be added to a set using the `add()` method, like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉数学概念，Python集合的定义本质上是相同的：Python集合是无序元素的集合。可以使用大括号初始化集合，并可以使用`add()`方法向集合添加新元素，如下所示：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since a set is a collection of Python elements, or in other words, an iterator,
    its elements can still be iterated over using a `for` loop. However, given its
    definition, there is no guarantee that those elements will be iterated in the
    same order as they are initialized in or added to the set.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是Python元素的集合，或者换句话说，是一个迭代器，因此其元素仍然可以使用`for`循环进行迭代。但是，鉴于其定义，不能保证这些元素将以与它们初始化或添加到集合中相同的顺序进行迭代。
- en: 'Furthermore, when an element that already exists in a set is added to that
    set, the statement will have no effect:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当将已存在于集合中的元素添加到该集合时，该语句将不起作用：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Taking the union or the intersection of two given sets are the most common
    set operations and can be achieved via the `union()` and `intersection()` methods
    in Python, respectively:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对两个给定集合进行并集或交集操作是最常见的集合操作，并可以分别通过Python中的`union()`和`intersection()`方法来实现：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, to remove a given element from a set, we can use either the `discard()`
    method or the `remove()` method. Both remove the item passed to them from a set.
    However, if the item does not exist in the set, the former will not mutate the
    set, while the latter will raise an error. Just like tuples and lists, you can
    choose to use one of these two methods in your program to implement specific logic,
    depending on your goal.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要从集合中删除给定的元素，我们可以使用`discard()`方法或`remove()`方法。两者都会从集合中删除传递给它们的项目。但是，如果项目不存在于集合中，前者将不会改变集合，而后者将引发错误。与元组和列表一样，您可以选择在程序中使用这两种方法之一来实现特定逻辑，具体取决于您的目标。
- en: Moving on, the last Python data structure that we will be discussing in this
    section is dictionaries.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论本节中要讨论的最后一个Python数据结构，即字典。
- en: Dictionaries
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'Python dictionaries are the equivalent of hash maps in Java, where we can specify
    key-value pair relationships and perform lookups on a key to obtain its corresponding
    value. We can declare a dictionary in Python by listing out key-value pairs in
    the form of `key: value`, separated by commas inside curly brackets.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典相当于Java中的哈希映射，我们可以指定键值对关系，并对键进行查找以获得其对应的值。我们可以通过在花括号内用逗号分隔的形式列出键值对来声明Python字典。
- en: 'For example, a sample dictionary containing students'' names mapped to their
    final scores in a class may look as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个包含学生姓名映射到他们在课堂上的最终成绩的样本字典可能如下所示：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case, the names of the students (`''Alice''`, `''Bob''`, and `''Carol''`)
    are the keys of the dictionary, while their respective scores are the values that
    the keys are mapped to. A key cannot be used to map to multiple different values.
    The value of a given key can be accessed by passing the key to the dictionary
    inside square brackets:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，学生的姓名（'Alice'，'Bob'和'Carol'）是字典的键，而他们的成绩是键映射到的值。一个键不能用来映射到多个不同的值。可以通过将键传递给方括号内的字典来访问给定键的值：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that in the last statement in the preceding snippet, `'Chris'` is not a
    key in the dictionary, so when we attempt to access its value, `KeyError` is returned
    by the Python interpreter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面片段的最后一个语句中，`'Chris'`不是字典中的键，因此当我们尝试访问它的值时，Python解释器会返回`KeyError`。
- en: 'Changing the value of an existing key or adding a new key-value pair to an
    existing dictionary can be done using the same syntax:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相同的语法更改现有键的值或向现有字典添加新的键值对：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similar to list comprehension, a Python dictionary can be declared using dictionary
    comprehension. For instance, the following statement initializes a dictionary
    mapping integers from `-1` to `1` (inclusively) to their respective squares:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于列表推导，可以使用字典推导来声明Python字典。例如，以下语句初始化了一个将整数从`-1`到`1`（包括边界）映射到它们的平方的字典：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can see, this dictionary contains the key-value pairs `x` – `x ** 2` for
    every `x` between `-1` and `1`, which was done by placing the `for` loop inside
    the initialization of the dictionary.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个字典包含了每个`x`在`-1`和`1`之间的`x` - `x ** 2`键值对，这是通过在字典初始化中放置`for`循环来完成的。
- en: 'To delete a key-value pair from a dictionary, we would need to use the `del`
    keyword. Say we would like to delete the `''Alice''` key and its corresponding
    value. We would do this like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中删除键值对，我们需要使用`del`关键字。假设我们想删除`'Alice'`键及其对应的值。我们可以这样做：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Attempting to access a deleted key will cause the Python interpreter to raise
    an error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问已删除的键将导致Python解释器引发错误：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: One of the most important aspects of Python dictionaries to keep in mind is
    the fact that only immutable objects can be dictionary keys. In the examples so
    far, we have seen strings and numbers as dictionary keys. Lists, which can be
    mutated and changed after initialization, cannot be used as dictionary keys; tuples,
    on the other hand, can.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要牢记的Python字典最重要的一点是，只有不可变对象可以作为字典键。到目前为止，我们已经看到字符串和数字作为字典键。列表是可变的，初始化后可以改变，不能用作字典键；而元组可以。
- en: 'Exercise 1.04: Shopping Cart Calculations'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：购物车计算
- en: In this exercise, we will use the dictionary data structure to build a skeletal
    version of a shopping application. This will allow us to review and further understand
    the data structure and the operations that can be applied to it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用字典数据结构构建一个购物应用程序的骨架版本。这将使我们能够复习和进一步了解数据结构以及可以应用于它的操作。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Create a new Jupyter notebook and declare a dictionary representing any given
    items available for purchase and their respective prices in the first code cell.
    Here, we''ll add three different types of laptops with their prices in dollars:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个代码单元中创建一个新的Jupyter笔记本，并声明一个字典，表示可以购买的任何商品及其相应的价格。在这里，我们将添加三种不同类型的笔记本电脑及其美元价格：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code snippet shown here uses a backslash ( `\` ) to split the logic across
    multiple lines. When the code is executed, Python will ignore the backslash, and
    treat the code on the next line as a direct continuation of the current line.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的代码片段使用反斜杠（`\`）将逻辑分割成多行。当代码执行时，Python将忽略反斜杠，并将下一行的代码视为当前行的直接延续。
- en: 'In the next cell, initialize a dictionary representing our shopping cart. The
    dictionary should be empty at the beginning, but it should map an item in the
    cart to how many copies are to be purchased:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，初始化一个表示我们购物车的字典。字典在开始时应该是空的，但它应该将购物车中的商品映射到要购买的副本数量：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In a new cell, write a `while True` loop that represents each step of the shopping
    process and asks the user whether they would like to continue shopping or not.
    Use conditionals to handle different cases of the input (you can leave the case
    where the user wants to continue shopping until the next step):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的单元格中，编写一个`while True`循环，表示购物过程的每个步骤，并询问用户是否想继续购物。使用条件语句来处理输入的不同情况（您可以留下用户想要继续购物直到下一步的情况）：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the first conditional case, take in another user input to ask which
    item should be added to the cart. Use conditionals to increment the count of the
    item in the `cart` dictionary or handle invalid cases:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个条件情况下，接受另一个用户输入，询问应该将哪个商品添加到购物车。使用条件语句来增加`cart`字典中商品的数量或处理无效情况：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the next cell, loop through the `cart` dictionary and calculate the total
    amount of money the user has to pay (by looking up the quantity and price of each
    item in the cart):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，循环遍历`cart`字典，并计算用户需要支付的总金额（通过查找购物车中每件商品的数量和价格）：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, in a new cell, print out the items in the cart and their respective
    amount in different lines via a `for` loop and at the end the total bill. Use
    an f-string to format the printed output:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在一个新的单元格中，通过`for`循环打印出购物车中的商品及其各自的数量，并在最后打印出总账单。使用f-string格式化打印输出：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the program and experiment with different carts to ensure our program is
    correct. For example, if you were to add two MacBook 13s and one ASUS ROG to my
    shopping cart and stop, the corresponding output would be as follows:![Figure
    1.2: Output of the shopping cart application'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并尝试使用不同的购物车来确保我们的程序是正确的。例如，如果您要将两台MacBook 13和一台华硕ROG添加到我的购物车中并停止，相应的输出将如下所示：![图1.2：购物车应用程序的输出
- en: '](image/B15968_01_02.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_01_02.jpg)'
- en: 'Figure 1.2: Output of the shopping cart application'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：购物车应用程序的输出
- en: And that concludes our shopping cart exercise, through which we have familiarized
    ourselves with the use of dictionaries to look up information. We have also reviewed
    the use of conditionals and loops to implement control flow methods in a Python program.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的购物车练习，通过这个练习，我们熟悉了使用字典查找信息。我们还回顾了使用条件和循环来实现控制流方法在Python程序中的使用。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2C1Ra1C.](https://packt.live/2C1Ra1C
    )
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2C1Ra1C](https://packt.live/2C1Ra1C)
- en: You can also run this example online at [https://packt.live/31F7QXg.](https://packt.live/31F7QXg.
    )
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/31F7QXg](https://packt.live/31F7QXg)上线运行此示例。
- en: 'In the next section, we will discuss two integral components of any complex
    program: functions and algorithms.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论任何复杂程序的两个重要组成部分：函数和算法。
- en: Functions and Algorithms
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和算法
- en: While functions denote a specific object in Python programming with which we
    can order and factor our programs, the term *algorithm* typically refers to the
    general organization of a sequence of logic to process its given input data. In
    data science and scientific computing, algorithms are ubiquitous, commonly taking
    the form of machine learning models that are used to process data and potentially
    make predictions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数在Python编程中表示特定的对象，我们可以用它来对程序进行排序和分解，但术语*算法*通常指的是一系列逻辑的一般组织，用于处理给定的输入数据。在数据科学和科学计算中，算法是无处不在的，通常以处理数据并可能进行预测的机器学习模型的形式出现。
- en: In this section, we will discuss the concept and syntax of Python functions
    and then tackle some example algorithm-design problems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Python函数的概念和语法，然后解决一些示例算法设计问题。
- en: Functions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'In its most abstract definition, a function is simply an object that can take
    in an input and producing an output, according to a given set of instructions.
    A Python function is of the following form:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最抽象的定义中，函数只是一个可以接受输入并根据给定的一组指令产生输出的对象。Python函数的形式如下：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `def` keyword denotes the start of a Python function. The name of a function
    can be anything, though the rule is to avoid special characters at the beginning
    of the name and to use snake case. Between the parentheses are the parameters
    that the function takes in, which are separated by commas and can be used inside
    the indented code of the function.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`def`关键字表示Python函数的开始。函数的名称可以是任何东西，尽管规则是避免名称开头的特殊字符，并使用蛇形命名法。括号内是函数接受的参数，它们用逗号分隔，并可以在函数的缩进代码中使用。'
- en: 'For example, the following function takes in a string (though this requirement
    is unspecified) and prints out a greeting message:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下函数接受一个字符串（尽管这个要求未指定），并打印出问候消息：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we can call this function on any string that we want and achieve the
    effect that we intended with the instruction inside the function. If we somehow
    mis-specify the arguments that a function takes in (for example, the last statement
    in the following code snippet), the interpreter will return an error:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在任何想要的字符串上调用这个函数，并实现函数内部指令所期望的效果。如果我们以某种方式错误地指定了函数所需的参数（例如，以下代码片段中的最后一条语句），解释器将返回一个错误：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It is important to note that any local variables (variables declared inside
    a function) cannot be used outside of the scope of the function. In other words,
    once a function finishes its execution, none of its variables will be accessible
    by other code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，任何局部变量（在函数内部声明的变量）都不能在函数范围之外使用。换句话说，一旦函数完成执行，它的变量将无法被其他代码访问。
- en: Most of the time, we would want our functions to return some sort of value at
    the end, which is facilitated by the `return` keyword. As soon as a `return` statement
    is executed, the execution of a program will exit out of a given function and
    return to the parent scope that called the function. This allows us to design
    a number of dynamic logic sequences.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们希望我们的函数在结束时返回某种值，这是由`return`关键字实现的。一旦执行`return`语句，程序的执行将退出给定的函数，并返回调用函数的父级范围。这使我们能够设计许多动态逻辑序列。
- en: 'For example, imagine a function that takes in a Python list of integers and
    returns the first element that is divisible by 2 (and returns `False` if there
    is no even element in the list):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个函数，它接受一个Python整数列表，并返回第一个可以被2整除的元素（如果列表中没有偶数元素，则返回`False`）：
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, the natural way to write this function is to loop through the elements
    in the list and check for their `2`-divisibility:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写这个函数的自然方式是循环遍历列表中的元素，并检查它们是否可以被`2`整除：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, if and when the condition is met (that is, when the current element
    we are iterating over is divisible by `2`), that very element should be the return
    value of the function, since it is the first element in the list that is divisible
    by `2`. This means we can actually return it within the `if` block (and finally
    return `False` at the end of the function):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果条件满足（即我们正在迭代的当前元素可以被`2`整除），那么该元素应该是函数的返回值，因为它是列表中第一个可以被`2`整除的元素。这意味着我们实际上可以在`if`块内返回它（最后在函数末尾返回`False`）：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This approach is to be contrasted with an alternative version where we only
    return the element that satisfies our condition at the end of the loop, which
    will be more time-consuming (execution-wise) and require an additional check as
    to whether there is an even element in the input list. We will examine a variation
    of this logic in depth in the next exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与另一种版本形成对比，另一种版本只在循环结束时返回满足我们条件的元素，这将更耗时（执行方面），并需要额外的检查，以确定输入列表中是否有偶数元素。我们将在下一个练习中深入研究这种逻辑的变体。
- en: 'Exercise 1.05: Finding the Maximum'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05：查找最大值
- en: Finding the maximum/minimum of an array, or list, is a common exercise in any
    introductory programming class. In this exercise, we will consider an elevated
    version of the problem, in which we need to write a function that returns the
    index and the actual value of the maximum element within a list (if tie-breaking
    is needed, we return the last maximum element).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何入门编程课程中，查找数组或列表的最大/最小值是一个常见的练习。在这个练习中，我们将考虑这个问题的一个提升版本，即我们需要编写一个函数，返回列表中最大元素的索引和实际值（如果需要进行平局处理，我们返回最后一个最大元素）。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Create a new Jupyter notebook and declare the general structure of our target
    function in a code cell:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter笔记本，并在一个代码单元格中声明我们目标函数的一般结构：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a variable that keeps track of the index of the current maximum element
    called `running_max_index`, which should be initialized to `0`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来跟踪当前最大元素的索引，称为`running_max_index`，应初始化为`0`：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Loop through the values in the parameter list and their corresponding indices
    using a `for` loop and the `enumerate` operation:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环和`enumerate`操作循环遍历参数列表中的值及其对应的索引：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At each step of the iteration, check to see if the current element is greater
    than or equal to the element corresponding to the running indexing variable. If
    that is the case, assign the index of the current element to the running maximum
    index:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一步迭代中，检查当前元素是否大于或等于与运行索引变量对应的元素。如果是这样，将当前元素的索引分配给运行的最大索引：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, return the running maximum index and its corresponding value as a
    tuple:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将运行的最大索引及其对应的值作为一个元组返回：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In a new cell, call this function on various lists to test for different cases.
    An example of this is as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的单元格中，调用这个函数来测试不同情况下的各种列表。一个例子如下：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This exercise helped us review the general syntax of a Python function and also
    offered a refresher on looping. Furthermore, variations of the logic that we considered
    are commonly found in scientific computing projects (for example, finding the
    minimum or an element in an iterator that satisfies some given conditions).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习帮助我们复习了Python函数的一般语法，也提供了一个循环的复习。此外，我们考虑的逻辑变体通常在科学计算项目中找到（例如，在迭代器中找到最小值或满足某些给定条件的元素）。
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zu6KuH.](https://packt.live/2Zu6KuH
    )
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2Zu6KuH.](https://packt.live/2Zu6KuH )
- en: You can also run this example online at [https://packt.live/2BUNjDk.](https://packt.live/2BUNjDk
    )
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2BUNjDk.](https://packt.live/2BUNjDk )上线运行此示例
- en: Next, let's discuss a very specific style of function design called *recursion*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论一种非常特定的函数设计风格，称为*递归*。
- en: Recursion
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: The term **recursion** in programming denotes the style of solving a problem
    using functions by having a function recursively call itself. The idea is that
    each time the function is called, its logic will take a small step toward the
    solution of the problem, and by doing this many times, the original problem will
    be finally solved. The idea is that if we somehow have a way to translate our
    problem into a small one that can be solved in the same way, we can repeatedly
    break down the problem to arrive at the base case and ensure that the original,
    bigger problem is solved.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，术语**递归**表示使用函数解决问题的风格，通过使函数递归调用自身。其思想是每次调用函数时，其逻辑将向问题的解决方案迈出一小步，通过这样做多次，最终解决原始问题。如果我们以某种方式有办法将我们的问题转化为一个可以以相同方式解决的小问题，我们可以重复分解问题以达到基本情况，并确保解决原始的更大问题。
- en: Consider the problem of computing the sum of *n* integers. If we somehow already
    have the sum of the first *n - 1* integers, then we can simply add the last number
    to that sum to compute the total sum of the *n* numbers. But how can the sum of
    the first *n - 1* numbers be computed? With recursion, we once again assume that
    if we have the sum of the first *n - 2* numbers, then we add in that last number.
    This process repeats until we reach the first number in the list, and the whole
    process completes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑计算*n*个整数的总和的问题。如果我们已经有了前*n-1*个整数的总和，那么我们只需将最后一个数字加到这个总和中，就可以计算出*n*个数字的总和。但是如何计算前*n-1*个数字的总和呢？通过递归，我们再次假设如果我们有前*n-2*个数字的总和，那么我们将最后一个数字加进去。这个过程重复进行，直到我们达到列表中的第一个数字，整个过程完成。
- en: 'Let''s consider this function in the following example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下示例中考虑这个函数：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can see that, in the general case, the function computes and returns the
    result of adding the last element of the input list, `my_list[-1]`, to the sum
    of the sublist without this last element `my_list[: -1]`, which is in turn computed
    by the `find_sum()` function itself. Again, we rationalize that if the `find_sum()`
    function can somehow solve the problem of summing a list in a smaller case, we
    can generalize the result to any given non-empty list.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到，在一般情况下，该函数计算并返回了将输入列表的最后一个元素`my_list[-1]`与不包括这个最后一个元素的子列表`my_list[:
    -1]`的总和的结果，而这又是由`find_sum()`函数本身计算的。同样，我们可以理解，如果`find_sum()`函数可以以某种方式解决在较小情况下对列表求和的问题，我们可以将结果推广到任何给定的非空列表。'
- en: Handling the base case is therefore an integral part of any recursive algorithm.
    Here, our base case is when the input list is a single-valued one (checked by
    our `if` statement), in which case we should simply return that very element in
    the list.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 处理基本情况因此是任何递归算法的一个组成部分。在这里，我们的基本情况是当输入列表是一个单值列表（通过我们的`if`语句检查），在这种情况下，我们应该简单地返回列表中的那个元素。
- en: 'We can see that this function correctly computes the sum of any non-empty list
    of integers, as shown here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个函数正确地计算了任何非空整数列表的总和，如下所示：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is a somewhat basic example, as finding the sum of a list can be easily
    done by maintaining a running sum and using a `for` loop to iterate over all the
    elements in the input list. In fact, most of the time, recursion is less efficient
    than iteration, as there is significant overhead in repeatedly calling function
    after function in a program.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当基本的例子，因为可以通过保持运行总和并使用`for`循环来迭代输入列表中的所有元素来轻松地找到列表的总和。实际上，大多数情况下，递归不如迭代高效，因为在程序中重复调用函数会产生重大开销。
- en: However, there are situations, as we will see in the following exercise, where,
    by abstracting our approach to a problem to a recursive algorithm, we can significantly
    simplify how the problem is solved.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们将在接下来的练习中看到的那样，通过将我们对问题的方法抽象为递归算法，我们可以显著简化问题的解决方法。
- en: 'Exercise 1.06: The Tower of Hanoi'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.06：汉诺塔
- en: The Tower of Hanoi is a well-known mathematical problem and a classic application
    of recursion. The problem statement is as follows.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 汉诺塔是一个众所周知的数学问题，也是递归的一个经典应用。问题陈述如下。
- en: There are three disk stacks where disks can be placed in and *n* disks, all
    of different sizes. At the beginning, the disks are stacked in ascending order
    (the largest at the bottom) in one single stack. At each step of the game, we
    can take the top disk of one stack and put it at the top of another stack (which
    can be an empty stack) with the condition that no disk can be placed on top of
    a disk that is smaller than it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个盘堆，可以在其中放置盘子，有*n*个盘子，所有盘子都是不同大小的。一开始，盘子按升序堆叠（最大的在底部）在一个单独的堆栈中。在游戏的每一步中，我们可以取一个堆栈的顶部盘子，并将其放在另一个堆栈的顶部（可以是一个空堆栈），条件是不能将盘子放在比它更小的盘子的顶部。
- en: We are asked to compute the minimum number of moves necessary to move the entire
    stack of *n* disk from one stack to another. While the problem can be quite complex
    if we think about it in a linear way, it becomes simpler when we employ a recursive
    algorithm.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求计算将整个*n*个盘子从一个堆栈移动到另一个堆栈所需的最小移动次数。如果我们以线性方式思考这个问题，它可能会变得非常复杂，但是当我们使用递归算法时，它变得更简单。
- en: Specifically, in order to move the *n* disks, we need to move the top *n - 1*
    disks to another stack, move the bottom, biggest disk to the last stack, and finally
    move the *n - 1* disks in the other stack to the same stack as the biggest disk.
    Now, imagine we can compute the minimum number of steps taken to move *(n - 1)*
    disks from one stack to another, denoted as *S(n - 1)*, then to move *n* disks,
    we need *2 S(n - 1) + 1* steps.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，为了移动*n*个盘子，我们需要将顶部的*n - 1*个盘子移动到另一个堆栈，将底部最大的盘子移动到最后一个堆栈，最后将另一个堆栈中的*n -
    1*个盘子移动到与最大盘子相同的堆栈中。现在，想象我们可以计算移动*(n - 1)*个盘子所需的最小步骤，表示为*S(n - 1)*，然后移动*n*个盘子，我们需要*2
    S(n - 1) + 1*步。
- en: That is the recursively analytical solution to the problem. Now, let's write
    a function to actually compute this quantity for any given *n*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是问题的递归分析解决方案。现在，让我们编写一个函数来实际计算任何给定*n*的数量。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'In a new Jupyter notebook, define a function that takes in an integer named
    `n` and returns the quantity that we arrived at previously:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的Jupyter笔记本中，定义一个函数，该函数接受一个名为`n`的整数，并返回我们之前得到的数量：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a conditional in the function to handle the base case where `n = 1`
    (note that it only takes one step to move a single disk):'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中创建一个条件来处理基本情况，即`n = 1`（注意，只需一步即可移动单个盘子）：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In a different cell, call the function on different inputs to verify that the
    function returns the correct analytical solution to the problem, which is *2*n
    *- 1*:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个单元格中，调用该函数以验证函数返回问题的正确分析解决方案，即*2*n *- 1*：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, we are using the `==` operator to compare two values: the returned value
    from our `solve()` function and the analytical expression of the solution. If
    they are equal, we should see the Boolean `True` printed out, which is the case
    for both comparisons we have here.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`==`运算符来比较两个值：从我们的`solve()`函数返回的值和解决方案的分析表达式。如果它们相等，我们应该看到布尔值`True`被打印出来，这是我们这里的两个比较的情况。
- en: While the code in this exercise is short, it has illustrated the point that
    recursion can offer elegant solutions to a number of problems and has hopefully
    solidified our understanding of the procedure of a recursive algorithm (with the
    general step and a base case).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中的代码虽然很短，但它已经说明了递归可以提供优雅的解决方案来解决许多问题，并且希望巩固了我们对递归算法程序的理解（包括一般步骤和基本案例）。
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NMrGrk.](https://packt.live/2NMrGrk
    )
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2NMrGrk.](https://packt.live/2NMrGrk )
- en: You can also run this example online at [https://packt.live/2AnAP6R.](https://packt.live/2AnAP6R.
    )
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2AnAP6R](https://packt.live/2AnAP6R)上在线运行此示例。
- en: With that, we'll move on and start discussing the general process of algorithm
    design in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将继续讨论算法设计的一般过程。
- en: Algorithm Design
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法设计
- en: 'Designing algorithms is actually something that we have been doing all along,
    especially in this section, which is all about functions and algorithms: discussing
    what a functional object should take in, how it should process that input, and
    what output it should return at the end of its execution. In this section, we
    will briefly discuss some practices in a general algorithm-design procedure and
    then consider a somewhat complex problem called the *N-Queens problem* as an exercise.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 设计算法实际上是我们一直在做的事情，特别是在本节中，这一节主要讨论函数和算法：讨论一个函数对象应该接受什么，它应该如何处理输入，以及在执行结束时应该返回什么输出。在本节中，我们将简要讨论一般算法设计过程中的一些实践，然后考虑一个稍微复杂的问题，称为*N-Queens问题*作为练习。
- en: While writing Python functions, some programmers might choose to implement subfunctions
    (functions within other functions). Following the idea of encapsulation in software
    development, a subfunction should be implemented when it is only called by instructions
    within another function. If this is the case, the first function can be viewed
    as a helper function of the second and therefore should be placed *inside* that
    second function. This form of encapsulation allows us to be more organized with
    our programs/code and ensure that if a piece of code does not need to use the
    logic within a given function, then it should not have access to it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Python函数时，一些程序员可能选择实现子函数（在其他函数中的函数）。遵循软件开发中的封装思想，当子函数只被另一个函数内的指令调用时，应该实现子函数。如果是这种情况，第一个函数可以被视为第二个函数的辅助函数，因此应该*放在*第二个函数内。这种封装形式使我们能够更有条理地组织我们的程序/代码，并确保如果一段代码不需要使用给定函数内的逻辑，则不应该访问它。
- en: The next point of discussion involves recursive search algorithms, which we'll
    look at in the next exercise. Specifically, when an algorithm is recursively trying
    to find a valid solution to a given problem, it can reach a state in which there
    are no valid solutions (for example, when we are trying to find an even element
    in a list of only odd integers). This leads to the need for a way to indicate
    that we have reached an invalid state.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个讨论点涉及递归搜索算法，我们将在下一个练习中进行讨论。具体来说，当算法递归地尝试找到给定问题的有效解决方案时，它可能会达到一个没有有效解决方案的状态（例如，当我们试图在仅包含奇数的列表中找到一个偶数元素时）。这导致需要一种方式来指示我们已经达到了一个无效状态。
- en: In our find-the-first-even-number example, we chose to return `False` to indicate
    an invalid state where our input list only consists of odd numbers. Returning
    some sort of flag such as `False` or `0` is actually a common practice that we
    will follow in later examples in this chapter as well.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们找到第一个偶数的例子中，我们选择返回`False`来指示一个无效状态，即我们的输入列表只包含奇数。返回`False`或`0`这样的标志实际上是一个常见的做法，我们在本章的后续示例中也会遵循这种做法。
- en: With that in mind, let's jump into the exercise of this section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们开始本节的练习。
- en: 'Exercise 1.07: The N-Queens Problem'
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.07：N-Queens问题
- en: Another classic algorithm-design problem in mathematics and computer science,
    the N-Queens problem asks us to place *n* queen pieces in the game of chess on
    an *n* x *n* chessboard so that no queen piece can attack another. A queen can
    attack another piece if they share the same row, column, or diagonal, so the problem
    is essentially finding a combination of locations for the queen pieces so that
    any two given queens are in different rows, columns, and diagonals.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 数学和计算机科学中的另一个经典算法设计问题是N皇后问题，它要求我们在* n * x * n *棋盘上放置* n *个皇后棋子，以便没有皇后棋子可以攻击另一个。如果两个皇后棋子共享相同的行、列或对角线，那么一个皇后可以攻击另一个棋子，因此问题实质上是找到皇后棋子的位置组合，使得任意两个皇后在不同的行、列和对角线上。
- en: 'For this exercise, we will design a *backtracking* algorithm that searches
    for a valid solution to this problem for any positive integer, *n*. The algorithm
    is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将设计一个*回溯*算法，为任何正整数*n*搜索这个问题的有效解决方案。算法如下：
- en: Given the requirements of the problem, we argue that in order to place *n* pieces,
    each row of the chessboard needs to include exactly one piece.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到问题的要求，我们认为为了放置*n*个棋子，棋盘的每一行都需要包含恰好一个棋子。
- en: 'For each row, we iteratively go through all the cells of that row and check
    to see whether a new queen piece can be placed in a given cell:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一行，我们迭代地遍历该行的所有单元格，并检查是否可以在给定单元格中放置一个新的皇后棋子：
- en: a. If such a cell exists, we place a piece in that cell and move on to the next
    row.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果存在这样的单元格，我们在该单元格中放置一个棋子，然后转到下一行。
- en: b. If a new queen piece cannot be placed in any cell in the current row, we
    know that we have reached an invalid state and thus return `False`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果新的皇后棋子无法放置在当前行的任何单元格中，我们知道已经达到了一个无效状态，因此返回`False`。
- en: We repeat this process until a valid solution is found.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复这个过程，直到找到一个有效的解决方案。
- en: 'The following diagram describes how this algorithm works with *n = 4*:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了这个算法在*n=4*时的工作方式：
- en: '![Figure 1.3: Recursion with the N-Queens problem'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：N-Queens问题的递归'
- en: '](image/B15968_01_03.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_01_03.jpg)'
- en: 'Figure 1.3: Recursion with the N-Queens problem'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：N-Queens问题的递归
- en: 'Now, let''s actually implement the algorithm:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实际实现算法：
- en: 'Create a new Jupyter notebook. In its first cell, declare a variable named
    `N` to represent the size of our chessboard, as well as the number of queen pieces
    we need to place on the board:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter笔记本。在第一个单元格中，声明一个名为`N`的变量，表示棋盘的大小，以及我们需要在棋盘上放置的皇后数量：
- en: '[PRE68]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A chessboard will be represented as a 2D, *n* x *n* list with 0 representing
    an empty cell and 1 representing a cell with a queen piece. Now, in a new code
    cell, implement a function that takes in a list of this form and print it out
    in a nice format:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 国际象棋棋盘将被表示为一个2D的*n* x *n*列表，其中0表示一个空单元格，1表示一个带有皇后棋子的单元格。现在，在一个新的代码单元中，实现一个函数，该函数接受这种形式的列表并以良好的格式打印出来：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that the `end=' '` argument in our `print` statement specifies that instead
    of ending the printed output with a newline character, it should simply be a space
    character. This is so that we can print out the cells in the same row using different
    `print` statements.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们`print`语句中的`end=' '`参数指定，不是用换行符结束打印输出，而是用空格字符。这样我们就可以使用不同的`print`语句打印出同一行中的单元格。
- en: In the next cell, write a function that takes in a board, a row number, and
    a column number. The function should check to see whether a new queen piece can
    be placed on this board at the location given by the row and column numbers.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，编写一个函数，该函数接受一个棋盘、一个行号和一个列号。该函数应该检查是否可以在给定的行和列号位置的棋盘上放置一个新的皇后棋子。
- en: 'Note that since we are iteratively placing pieces rows to rows, each time we
    check to see whether a new piece can be placed at a given location, we only need
    to check for the rows above the location:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们正在逐行放置棋子，每次检查新棋子是否可以放在给定位置时，我们只需要检查位置上方的行：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the same code cell, implement a function that takes in a board and a row
    number. This function should go through all the cells in the given row and check
    to see whether a new queen piece can be placed at a particular cell (using the
    `check_next()` function written in the preceding step).
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个代码单元中，实现一个函数，该函数接受一个棋盘和一个行号。该函数应该遍历给定行中的所有单元格，并检查是否可以在特定单元格放置一个新的皇后棋子（使用前面步骤中编写的`check_next()`函数）。
- en: For such a cell, place a queen in that cell (by changing the cell value to `1`)
    and recursively call the function itself with the next row number. If a final
    solution is valid, return `True`; otherwise, remove the queen piece from the cell
    (by changing it back to `0`).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的单元格，在该单元格中放置一个皇后（将单元格值更改为`1`），并递归调用函数本身以获取下一个行号。如果最终解决方案有效，则返回`True`；否则，从单元格中移除皇后棋子（将其更改回`0`）。
- en: 'If, after we have considered all the cells of the given row, no valid solution
    is found, return `False` to indicate an `invalid` state. The function should also
    have a conditional at the beginning to check for whether the row number is larger
    than the board size `N`, in which case we simply return `True` to indicate that
    we have reached a valid final solution:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在考虑了给定行的所有单元格后没有找到有效解决方案，则返回`False`表示`无效`状态。函数还应该在开始时有一个条件检查，检查行号是否大于棋盘大小`N`，在这种情况下，我们只需返回`True`表示已经找到有效的最终解决方案：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the same code cell, write a final solver function that wraps around the two
    functions, `check_next()` and `recur_generate_solution()` (in other words, the
    two functions should be subfunctions of the function we are writing). The function
    should initialize an empty 2D *n* x *n* list (representing the chessboard) and
    call the `recur_generate_solution()` function with row number 0.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个代码单元中，编写一个最终求解器函数，该函数包装了两个函数`check_next()`和`recur_generate_solution()`（换句话说，这两个函数应该是我们正在编写的函数的子函数）。该函数应该初始化一个空的2D
    *n* x *n*列表（表示国际象棋棋盘），并调用`recur_generate_solution()`函数，行号为0。
- en: 'The function should also print out the solution at the end:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还应该在最后打印出解决方案：
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In a different code cell, run the overarching function from the preceding step
    to generate and print out a solution:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个代码单元中，运行前面步骤中的总体函数以生成并打印出解决方案：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Throughout this exercise, we have implemented a backtracking algorithm that
    is designed to search for a valid solution by iteratively making a move toward
    a potential solution (placing a queen piece in a safe cell), and if the algorithm
    somehow reaches an invalid state, it will *backtrack* by undoing its previous
    move (in our case, by removing the last piece we placed) and looking for a new
    move to make. As you can probably tell, backtracking is closely related to recursion,
    and that is why we chose to implement our algorithm using a recursive function,
    thus consolidating our understanding of the general concept.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个练习过程中，我们实现了一个回溯算法，该算法旨在通过迭代向潜在解决方案迈出一步（在安全单元格中放置一个皇后棋子），如果算法以某种方式达到无效状态，它将通过撤消先前的移动（在我们的情况下，通过移除我们放置的最后一个棋子）并寻找新的移动来进行*回溯*。正如您可能已经注意到的那样，回溯与递归密切相关，这就是为什么我们选择使用递归函数来实现我们的算法，从而巩固我们对一般概念的理解。
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Bn7nyt.](https://packt.live/2Bn7nyt
    )
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Bn7nyt.](https://packt.live/2Bn7nyt )
- en: You can also run this example online at [https://packt.live/2ZrKRMQ.](https://packt.live/2ZrKRMQ
    )
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2ZrKRMQ.](https://packt.live/2ZrKRMQ )上在线运行此示例
- en: In the next and final section of this chapter, we will consider a number of
    administrative tasks in Python programming that are often overlooked, namely debugging,
    testing, and version control.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一个和最后一节中，我们将考虑Python编程中经常被忽视的一些行政任务，即调试、测试和版本控制。
- en: Testing, Debugging, and Version Control
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、调试和版本控制
- en: It is important to note that, in programming, the actual task of writing code
    is not the only element of the process. There are other administrative procedures
    that play important roles in the pipeline that are often overlooked. In this section,
    we will discuss each task one by one and consider the process of implementing
    them in Python, starting with testing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，需要注意的是，编写代码的实际任务并不是整个过程的唯一元素。还有其他行政程序在流程中扮演着重要角色，但通常被忽视了。在本节中，我们将逐个讨论每个任务，并考虑在Python中实现它们的过程，从测试开始。
- en: Testing
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'In order to make sure that a piece of software that we have written works as
    we intended and produces correct results, it is necessary to put it through specific
    tests. In software development, there are numerous types of testing that we can
    apply to a program: integration testing, regression testing, system testing, and
    so on. One of the most common is unit testing, which is our topic of discussion
    in this section.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们编写的软件按照我们的意图工作并产生正确的结果，有必要对其进行特定的测试。在软件开发中，我们可以对程序应用多种类型的测试：集成测试、回归测试、系统测试等等。其中最常见的是单元测试，这是我们在本节讨论的主题。
- en: Unit testing denotes the focus on individual small units of the software, as
    opposed to the entire program. Unit testing is typically the first step of a testing
    pipeline—once we are reasonably confident that the individual components of our
    program are working correctly, we can move on to test how these components work
    together and see whether they produce the results we want (with integration or
    system testing).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试表示关注软件的个别小单元，而不是整个程序。单元测试通常是测试流水线的第一步——一旦我们相当有信心认为程序的各个组件工作正常，我们就可以继续测试这些组件如何一起工作，以及它们是否产生我们想要的结果（通过集成或系统测试）。
- en: 'Unit testing in Python can be easily implemented using the `unittest` module.
    Taking an object-oriented approach, `unittest` allows us to design tests for our
    programs as Python classes, making the process more modular. Such a class needs
    to inherit from the `TestCase` class from `unittest`, and individual tests are
    to be implemented in separate functions, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以使用`unittest`模块轻松实现单元测试。采用面向对象的方法，`unittest`允许我们将程序的测试设计为Python类，使过程更加模块化。这样的类需要从`unittest`的`TestCase`类继承，并且单独的测试需要在不同的函数中实现，如下所示：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the `SampleTest` class, we placed two test cases where we want to check whether
    two given quantities are equal or not using the `assertEqual()` method in the
    `test_equal()` function. Here, we test whether 23 - 1 is indeed equal to 7, and
    whether string concatenation in Python is correct.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SampleTest`类中，我们放置了两个测试用例，希望使用`assertEqual()`方法在`test_equal()`函数中检查两个给定的数量是否相等。在这里，我们测试23-1是否确实等于7，以及Python中的字符串连接是否正确。
- en: Similarly, the `assertTrue()` methods used in the `test_true()` function test
    for whether the given parameter is evaluated `True` or not. Here, we test whether
    23 is less than 32, and whether the negative of perfect squares of integers between
    0 and 10 are non-positive.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`test_true()`函数中使用的`assertTrue()`方法测试给定参数是否被评估为`True`。在这里，我们测试23是否小于32，以及0到10之间整数的完全平方的负值是否为非正数。
- en: 'To run the tests we have implemented, we can use the following statement:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们实现的测试，可以使用以下语句：
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The produced output tells us that both of our tests returned positive. One
    important side note to keep in mind is that if you are running a unit test in
    a Jupyter notebook, the last statement needs to be as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出告诉我们，我们的两个测试都返回了积极的结果。需要记住的一个重要的副作用是，如果在Jupyter笔记本中运行单元测试，最后的语句需要如下所示：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As a result of the fact that the unit tests are to be implemented as functions
    in a Python class, the `unittest` module also offers two convenient methods, `setUp()`
    and `tearDown()`, which are to be run automatically before and after each test,
    respectively. We will see an example of this in our next exercise. For now, we
    will move on and talk about debugging.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试需要作为Python类中的函数实现，`unittest`模块还提供了两个方便的方法`setUp()`和`tearDown()`，它们分别在每个测试之前和之后自动运行。我们将在下一个练习中看到这方面的一个例子。现在，我们将继续讨论调试。
- en: Debugging
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: The term *debugging* literally means the removal of one or many bugs from a
    given computer program, thus making it work correctly. In most cases, a debugging
    process follows a failed test where it is determined that there is a bug in our
    program. Then, to debug the program, we need to identify the source of the error
    that caused the test to fail and attempt to fix the code related to that error.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试*一词的字面意思是从给定的计算机程序中消除一个或多个错误，从而使其正确工作。在大多数情况下，调试过程是在测试失败后进行的，确定程序中存在错误。然后，为了调试程序，我们需要确定导致测试失败的错误的源头，并尝试修复与该错误相关的代码。'
- en: 'There are multiple forms of debugging that a program might employ. These include
    the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可能采用多种形式的调试。这些包括以下内容：
- en: '**Print debugging**: Arguably one of the most common and elementary methods
    of debugging, print debugging involves identifying the variables that might play
    a role in causing the bug, placing `print` statements for those variables at various
    places in our program so that we can track the changes in the values of those
    variables. Once a change in the value of a variable is found to be undesirable
    or unwanted, we look at where specifically that `print` statement is in the program
    and therefore (roughly) identify the location of the bug.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印调试**：可以说是最常见和基本的调试方法之一，打印调试涉及识别可能导致错误的变量，在程序中的各个位置放置这些变量的`print`语句，以便跟踪这些变量值的变化。一旦发现变量值的变化是不希望的，我们就会查看程序中`print`语句的具体位置，从而（粗略地）确定错误的位置。'
- en: '**Logging**: If instead of printing the values of our variables to standard
    output, we decide to write the output to a log file, this is called logging. Logging
    is often done to keep track of specific events taking place in the execution of
    the program we are debugging or simply monitoring.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录：如果我们决定将变量的值输出到日志文件而不是标准输出，这就被称为日志记录。通常会使用日志记录来跟踪我们正在调试或监视的程序执行中发生的特定事件。
- en: '**Tracing**: To debug a program, we, in this case, will follow the low-level
    function calls and execution stack of the program when it executes. By looking
    at the order in which variables and functions are used from that low-level perspective,
    we can identify the source of the error as well. Tracing can be implemented in
    Python using the `sys.settrace()` method from the `sys` module.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**: 要调试一个程序，在这种情况下，我们将跟踪程序执行时的低级函数调用和执行堆栈。通过从低级别的角度观察变量和函数的使用顺序，我们也可以确定错误的来源。在Python中，可以使用`sys`模块的`sys.settrace()`方法来实现跟踪。'
- en: In Python, it is quite easy to employ print debugging, as we simply need to
    use `print` statements. For more complex functionalities, we can use a debugger,
    a module/library that is specifically designed for debugging purposes. The most
    dominant debugger in Python is the built-in `pdb` module, which used to be run
    via the `pdb.set_trace()` method.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用打印调试非常容易，因为我们只需要使用`print`语句。对于更复杂的功能，我们可以使用调试器，这是专门设计用于调试目的的模块/库。Python中最主要的调试器是内置的`pdb`模块，以前是通过`pdb.set_trace()`方法运行的。
- en: Starting from Python 3.7, we can opt for a simpler syntax by placing calls to
    the built-in `breakpoint()` function. At each place where a `breakpoint()` function
    is called, the execution of the program will pause and allow us to inspect the
    behavior and current characteristics of the program, including the values of its
    variables.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.7开始，我们可以选择更简单的语法，通过调用内置的`breakpoint()`函数。在每个调用`breakpoint()`函数的地方，程序的执行将暂停，允许我们检查程序的行为和当前特性，包括其变量的值。
- en: 'Specifically, once the execution of the program reaches a `breakpoint()` function,
    an input prompt will appear, where we can enter a `pdb` command. There are many
    commands that you can take advantage of that are included in the documentation
    of the module. Some notable commands are as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，一旦程序执行到`breakpoint()`函数，将会出现一个输入提示，我们可以在其中输入`pdb`命令。模块的文档中包含了许多可以利用的命令。一些值得注意的命令如下：
- en: '`h`: For *help*, which prints out the complete list of commands you can use.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`: 用于*帮助*，打印出您可以使用的完整命令列表。'
- en: '`u`/`d`: For *up* and *down*, respectively, which move the running frame count
    one level in a direction.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`/`d`: 分别用于*上*和*下*，将运行帧计数向一个方向移动一级。'
- en: '`s`: For *step*, which executes the instruction that the program is currently
    at and pauses at the first possible place in the execution. This command is very
    useful in terms of observing the immediate effect of a line of code on the state
    of the program.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 用于*步骤*，执行程序当前所在的指令，并在执行中的第一个可能的位置暂停。这个命令在观察代码对程序状态的即时影响方面非常有用。'
- en: '`n`: For *next*, which executes the instruction that the program is currently
    at and only pauses at the next instruction in the current function and when the
    execution is returned. This command works somewhat similarly to `s`, though it
    skips through instructions at a much higher rate.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`: 用于*下一个*，执行程序当前所在的指令，并且只在当前函数中的下一个指令处暂停，当执行返回时也会暂停。这个命令与`s`有些类似，不过它以更高的速率跳过指令。'
- en: '`r`: For *return*, which continues the execution until the current function
    returns.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`: 用于*返回*，直到当前函数返回为止。'
- en: '`c`: For *continue*, which continues the execution until the next `breakpoint()`
    statement is reached.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`: 用于*继续*，直到达到下一个`breakpoint()`语句为止。'
- en: '`ll`: For *longlist*, which prints out the source code for the current instruction.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ll`: 用于*longlist*，打印出当前指令的源代码。'
- en: '`p [expression]`: For *print*, which evaluates and prints out the value of
    the given expression'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p [expression]`: 用于*打印*，评估并打印给定表达式的值'
- en: Overall, once the execution of a program is paused by a `breakpoint()` statement,
    we can utilize a combination of the preceding different commands to inspect the
    state of the program and identify a potential bug. We'll look at an example of
    this in the following exercise.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，一旦程序的执行被`breakpoint()`语句暂停，我们可以利用前面不同命令的组合来检查程序的状态并识别潜在的错误。我们将在下面的练习中看一个例子。
- en: 'Exercise 1.08: Testing for Concurrency'
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '练习1.08: 并发测试'
- en: In this exercise, we will consider a well-known bug in concurrency- or parallelism-related
    programs called a *race condition*. This will serve as a nice use case to try
    out our testing and debugging tools. Since the integration of `pdb` and other
    debugging tools is still underdeveloped in Jupyter Notebooks, we will be working
    with `.py` scripts in this exercise.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将考虑并发或并行相关程序中一个众所周知的错误，称为*竞争条件*。这将作为一个很好的用例来尝试我们的测试和调试工具。由于在Jupyter笔记本中集成`pdb`和其他调试工具仍处于不成熟阶段，所以我们将在这个练习中使用`.py`脚本。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个练习：
- en: The setup of our program (which is implemented in the following steps) is as
    follows. We have a class that implements a counter object that can be manipulated
    by multiple threads in parallel. The value of an instance of this counter object
    (stored in its `value` attribute, initialized to `0`) is incremented every time
    its `update()` method is called. The counter also has a target that its value
    should be incremented to. When its `run()` method is called, multiple threads
    will be spawned. Each thread will call the `update()` method, thus incrementing
    its `value` attribute a number of times that is equal to the original target.
    In theory, the final value of the counter should be the same as the target, but
    we will see that this is not the case due to a race condition. Our goal is to
    apply `pdb` to track the changes of variables inside this program to analyze this
    race condition.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们程序的设置（在以下步骤中实现）如下。我们有一个类，实现了一个计数器对象，可以被多个线程并行操作。这个计数器对象的实例的值（存储在其初始化为`0`的`value`属性中）在每次调用其`update()`方法时递增。计数器还有一个目标，即其值应该递增到。当调用其`run()`方法时，将会生成多个线程。每个线程将调用`update()`方法，因此将其`value`属性递增到与原始目标相等的次数。理论上，计数器的最终值应该与目标相同，但由于竞争条件，我们将看到这并不是这样。我们的目标是应用`pdb`来跟踪程序内部变量的变化，以分析这种竞争条件。
- en: 'Create a new `.py` script and enter the following code:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`.py`脚本，并输入以下代码：
- en: '[PRE77]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This code implements the `Counter` class that we discussed earlier. Note that
    there is a line of code that sets the switch interval of our system; we will discuss
    this later.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实现了我们之前讨论过的`Counter`类。请注意，有一行代码设置了系统的切换间隔；我们稍后会讨论这个。
- en: 'With the hope that the value of a `counter` object should be incremented to
    its true target, we will test its performance with three different target values.
    In the same `.py` script, enter the following code to implement our unit tests:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希望`counter`对象的值应该增加到其真正的目标值，我们将用三个不同的目标值测试其性能。在同一个`.py`脚本中，输入以下代码来实现我们的单元测试：
- en: '[PRE78]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, we can see that in each testing function, we initialize a new `counter`
    object, run it, and finally compare its value with the true target. The targets
    for the test cases are declared in the `setUp()` method, which, as we mentioned
    previously, is run before the tests are carried out:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在每个测试函数中，我们初始化一个新的`counter`对象，运行它，最后将其值与真实目标进行比较。测试用例的目标在`setUp()`方法中声明，正如我们之前提到的，在测试执行之前运行：
- en: '[PRE79]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see, the program failed at two tests: `test_med` (where the final
    value of the counter was only 4,999 instead of 5,000) and `test_large` (where
    the value was 9,996 instead of 10,000). It is possible that you might obtain a
    different output.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序在两个测试中失败了：`test_med`（计数器的最终值只有4,999，而不是5,000）和`test_large`（值为9,996，而不是10,000）。你可能会得到不同的输出。
- en: Rerun this code cell multiple times to see that the result might vary.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次重新运行这段代码，看到结果可能会有所不同。
- en: 'Now that we know there is a bug in our program, we will attempt to debug it.
    Reimplement our `Counter` class by placing a `breakpoint()` statement between
    the two instructions in the `update()` method, as shown in the following code,
    and rerun the code cell:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道程序中有一个bug，我们将尝试调试它。在`update()`方法的两条指令之间放置一个`breakpoint()`语句，重新实现我们的`Counter`类，如下面的代码所示，并重新运行代码：
- en: '[PRE80]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the main scope of our Python script, comment out the call to the unit tests.
    Instead, declare a new `counter` object and run the script using the Terminal:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Python脚本的主范围内，注释掉对单元测试的调用。相反，声明一个新的`counter`对象，并使用终端运行脚本：
- en: '[PRE81]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here, you will see a `pdb` prompt appear in the Terminal (you might need to
    press *Enter* first to make the debugger proceed):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会看到终端中出现一个`pdb`提示（你可能需要先按*Enter*让调试器继续）：
- en: '![Figure 1.4: pdb interface'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：pdb界面'
- en: '](image/B15968_01_04.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_01_04.jpg)'
- en: 'Figure 1.4: pdb interface'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：pdb界面
- en: 'Input `ll` and hit *Enter* to see where in the program we are pausing:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`ll`并按*Enter*键，查看我们在程序中暂停的位置：
- en: '[PRE82]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, the output indicates that we are currently pausing between the two instructions
    that increment the value of our counter inside the `update()` method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，输出表明我们当前在`update()`方法内增加计数器值的两条指令之间暂停。
- en: 'Hit *Enter* again to return to the `pdb` prompt and run the `p self.value`
    command:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按*Enter*返回到`pdb`提示符，并运行`p self.value`命令：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We can see that the current value of the counter is `0`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到计数器的当前值是`0`。
- en: 'Return to the prompt and enter the `n` command. After this, use the `p self.value`
    command again to inspect the value of the counter:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到提示符并输入`n`命令。然后再次使用`p self.value`命令检查计数器的值：
- en: '[PRE84]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can see that the value has been incremented by 1\. Repeat this process of
    alternating between `n` and `p self.value` to observe that the value stored in
    `self.value` is not updated as we proceed through the program. In other words,
    the value typically stays at 1\. This is how the bug manifests itself in large
    values of the counter, as we have seen in our unit tests.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到值已经增加了1。重复这个在`n`和`p self.value`之间交替的过程，观察在程序进行过程中`self.value`中存储的值没有更新。换句话说，值通常保持在1。这就是我们在计数器的大值中看到的bug表现方式，就像我们在单元测试中看到的那样。
- en: Exit the debugger using *Ctrl* + *C*.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *C*退出调试器。
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YPCZFJ](https://packt.live/2YPCZFJ).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这一特定部分的源代码，请参阅[https://packt.live/2YPCZFJ](https://packt.live/2YPCZFJ)。
- en: This section does not currently have an online interactive example and will
    need to be run locally.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分目前没有在线交互示例，需要在本地运行。
- en: For those who are interested, the bug of our program stems from the fact that
    multiple threads can increment the value of the counter at roughly the same time,
    overwriting the changes made by one another. With a large number of threads (such
    as 5,000 or 10,000, which we have in our test cases), the probability of this
    event taking place becomes higher. This phenomenon, as we mentioned previously,
    is called a race condition, and it is one of the most common bugs in concurrent
    and parallel programs.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些感兴趣的人，我们程序的错误源于多个线程可以在大致相同的时间增加计数器的值，覆盖彼此所做的更改。随着线程数量的增加（例如我们在测试用例中有的5,000或10,000），这种事件发生的概率变得更高。正如我们之前提到的，这种现象称为竞争条件，是并发和并行程序中最常见的错误之一。
- en: Aside from demonstrating some `pdb` commands, this exercise also illustrates
    the fact that it is necessary to design tests to cover different situations. While
    the program passed our small test with the target being 5, it failed with larger
    values of the target. In real life, we should have the tests for a program to
    simulate a wide range of possibilities, ensuring that the program still works
    as intended, even in edge cases.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 除了演示一些`pdb`命令之外，这个练习还说明了设计测试以覆盖不同情况是必要的事实。虽然程序通过了我们的目标为5的小测试，但在目标值较大时失败了。在现实生活中，我们应该对程序进行测试，模拟各种可能性，确保程序即使在边缘情况下也能正常工作。
- en: And with that, let's move on to the last topic of this chapter, version control.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们继续进行本章的最后一个主题，版本控制。
- en: Version Control
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: In this section, we will briefly talk about the general theory behind version
    control and then discuss the process of implementing it with Git and GitHub, arguably
    the most popular version control systems in the industry. Version control is to
    a programming project what backing up data is to regular files. In essence, version
    control systems allow us to save our progress in a project separately from our
    local files so that we can come back to it later on, even if the local files are
    lost or damaged.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要讨论版本控制的一般理论，然后讨论使用Git和GitHub实现版本控制的过程，这两者可以说是行业中最流行的版本控制系统。版本控制对于编程项目来说就像定期备份数据对于常规文件一样重要。实质上，版本控制系统允许我们将项目中的进度与本地文件分开保存，以便以后可以回到它，即使本地文件丢失或损坏。
- en: With the functionalities that current version control systems such as Git and
    GitHub provide, we can also do a lot more. For example, the branching and merging
    features from these systems offer their users a way to create multiple versions
    of a common project so that different directions can be explored; the branch that
    implements the most preferred direction will then be merged with the main branch
    in the end. Additionally, Git and GitHub allow work between users on their platform
    to be seamless, which is greatly appreciated in team projects.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前版本控制系统（如Git和GitHub）提供的功能，我们还可以做更多事情。例如，这些系统的分支和合并功能为用户提供了一种创建共同项目的多个版本的方法，以便可以探索不同的方向；实现最受欢迎方向的分支最终将与主分支合并。此外，Git和GitHub允许平台上的用户之间的工作无缝进行，这在团队项目中非常受欢迎。
- en: To understand the available features that we can take advantage of with Git
    and GitHub, let's go through the following exercise.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们可以利用Git和GitHub的可用功能，让我们进行以下练习。
- en: 'Exercise 1.09: Version Control with Git and GitHub'
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.09：使用Git和GitHub进行版本控制
- en: This exercise will walk us through all of the steps necessary to get started
    with Git and GitHub. If you do not have any experience working with version control
    yet, this exercise will be beneficial to you.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将引导我们完成开始使用Git和GitHub所需的所有步骤。如果您还没有使用版本控制的经验，这个练习对您将是有益的。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: First, if you haven't already, register for a GitHub account by going to [https://www.github.com/](https://www.github.com/)
    and sign up. This will allow you to host the files that you want to version control
    on their cloud storage.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果您还没有，请注册GitHub帐户，方法是访问[https://www.github.com/](https://www.github.com/)并注册。这将允许您在他们的云存储上托管您想要进行版本控制的文件。
- en: 'Go to [https://git-scm.com/downloads](https://git-scm.com/downloads) and download
    the Git client software for your system and install it. This Git client will be
    responsible for communicating with the GitHub server. You know if your Git client
    is successfully installed if you can run the `git` command in your Terminal:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://git-scm.com/downloads](https://git-scm.com/downloads)并下载适用于您系统的Git客户端软件并安装。这个Git客户端将负责与GitHub服务器通信。如果您可以在终端中运行`git`命令，那么您就知道您的Git客户端已成功安装：
- en: '[PRE85]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Otherwise, your system might need to be rebooted for the installation to take
    full effect.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您的系统可能需要重新启动才能完全生效。
- en: 'Now, let''s start the process of applying version control to a sample project.
    First, create a dummy folder and generate a Jupyter notebook and a text file named
    `input.txt` with the following content in it:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始将版本控制应用于一个示例项目的过程。首先，创建一个虚拟文件夹，并生成一个Jupyter笔记本和一个名为`input.txt`的文本文件，其中包含以下内容：
- en: '[PRE86]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the first cell of the Jupyter notebook, write a function called `add_elements()`
    that takes in two lists of numbers and adds them up element-wise. The function
    should return a list that consists of the element-wise sums; you can assume that
    the two parameter lists are of the same length:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本的第一个单元格中，编写一个名为`add_elements()`的函数，该函数接受两个数字列表并按元素相加。该函数应返回一个由元素和总和组成的列表；您可以假设两个参数列表的长度相同：
- en: '[PRE87]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the next code cell, read in the `input.txt` file using a `with` statement
    and extract the last two lines of the file using the `readlines()` function and
    list indexing:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，使用`with`语句读取`input.txt`文件，并使用`readlines()`函数和列表索引提取文件的最后两行：
- en: '[PRE88]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that in the `open()` function, the second argument, `'r'`, specifies that
    we are reading in the file, as opposed to writing to the file.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`open()`函数中，第二个参数`'r'`指定我们正在读取文件，而不是写入文件。
- en: 'In a new code cell, convert these two strings of text input into lists of numbers,
    first using the `str.split()` function with the `'',''` argument to isolate the
    individual numbers in each line, and then the `map()` and `int()` functions to
    apply the conversion to integers element-wise:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的代码单元格中，使用`str.split()`函数和`','`参数将这两个文本输入字符串转换为数字列表，然后使用`map()`和`int()`函数逐个元素地应用转换：
- en: '[PRE89]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In a new code cell, call `add_elements()` on `list1` and `list2`. Write the
    returned list to the same input file in a new line in the same **comma-separated
    values** (**CSV**) format:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的代码单元格中，对`list1`和`list2`调用`add_elements()`。将返回的列表写入相同的输入文件中的新行，格式为**逗号分隔值**（**CSV**）：
- en: '[PRE90]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here the `'a'` argument specifies that we are writing to append a new line to
    the file, as opposed to reading and overwriting the file completely.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`'a'`参数指定我们正在写入文件以追加一个新行，而不是完全读取和覆盖文件。
- en: 'Run the code cell and verify that the text file has been updated to the following:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码单元格，并验证文本文件是否已更新为以下内容：
- en: '[PRE91]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This is the current setup of our sample project so far: we have a text file
    and a Python script inside a folder; the script can alter the content of the text
    file when run. This setup is fairly common in real-life situations: you can have
    a data file that contains some information that you''d like to keep track of and
    a Python program that can read in that data and update it in some way (maybe through
    prespecified computation or adding new data that was collected externally).'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例项目的当前设置是：我们有一个文件夹中的文本文件和Python脚本；当运行时，脚本可以更改文本文件的内容。这种设置在现实生活中是相当常见的：您可以有一个包含一些信息的数据文件，您希望跟踪，并且可以读取该数据并以某种方式更新它的Python程序（也许是通过预先指定的计算或添加外部收集的新数据）。
- en: Now, let's implement version control in this sample project.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在这个示例项目中实现版本控制。
- en: 'Go to your online GitHub account, click on the plus sign icon (**+**) in the
    top-right corner of the window, and choose the `New repository` option, as illustrated
    here:![Figure 1.5: Creating a new repository'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的在线GitHub帐户，单击窗口右上角的加号图标（**+**），然后选择`New repository`选项，如下所示：![图1.5：创建一个新的存储库
- en: '](image/B15968_01_05.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_01_05.jpg)'
- en: 'Figure 1.5: Creating a new repository'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：创建一个新的存储库
- en: Input a sample name for your new repository in the form and finalize the creation
    process. Copy the URL to this new repository to your clipboard as we will need
    it later.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中输入一个新存储库的示例名称，并完成创建过程。将这个新存储库的URL复制到剪贴板上，因为我们以后会用到它。
- en: This, as the name suggests, will create a new online repository that will host
    the code we want to version control.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这将创建一个新的在线存储库，用于托管我们想要进行版本控制的代码。
- en: 'On your local computer, open your Terminal and navigate to the folder. Run
    the following command to initialize a local Git repository, which will be associated
    with our folder:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的本地计算机上，打开终端并导航到文件夹。运行以下命令以初始化本地Git存储库，这将与我们的文件夹关联：
- en: '[PRE92]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Still in the Terminal, run the following command to add everything in our project
    to Git and commit them:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在终端中，运行以下命令将我们项目中的所有内容添加到Git并提交它们：
- en: '[PRE93]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Instead of `git add .`, you can replace `.` with the names of the files that
    you want to register with Git. This option is helpful when you only want to register
    a file or two, as opposed to every file you have in a folder.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用文件的名称替换`git add .`中的`.`。当您只想注册一个或两个文件时，这个选项是有帮助的，而不是您在文件夹中的每个文件。
- en: 'Now, we need to link our local repository and the online repository that we
    have created. To do that, run the following command:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要链接我们的本地存储库和我们创建的在线存储库。为此，请运行以下命令：
- en: '[PRE94]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that "origin" is simply a conventional nickname for the URL.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“origin”只是URL的一个传统昵称。
- en: 'Finally, upload the locally registered files to the online repository by running
    the following command:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过运行以下命令将本地注册的文件上传到在线存储库：
- en: '[PRE95]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Go to the website for the online repository to verify that the local files we
    created have indeed been uploaded to GitHub.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到在线存储库的网站，验证我们创建的本地文件是否确实已上传到GitHub。
- en: On your local computer, run the script included in the Jupyter notebook and
    change the text file.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的本地计算机上，运行Jupyter笔记本中包含的脚本并更改文本文件。
- en: 'Now, we would like to commit this change to the GitHub repository. In your
    Terminal, run the following commands again:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要将这个更改提交到GitHub存储库。在您的终端上，再次运行以下命令：
- en: '[PRE96]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Go to or refresh the GitHub website to verify that the change we made the second
    time has also been made on GitHub.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到GitHub网站验证我们第二次所做的更改是否也已在GitHub上进行了更改。
- en: With this exercise, we have walked through a sample version control pipeline
    and seen some examples of how Git and GitHub can be used in this respect. We also
    saw a refresher on the process of reading and writing to files in Python using
    the `with` statement.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们已经走过了一个示例版本控制流水线，并看到了Git和GitHub在这方面的一些用法示例。我们还复习了使用`with`语句在Python中读写文件的过程。
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VDS0IS.](https://packt.live/2VDS0IS
    )
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2VDS0IS](https://packt.live/2VDS0IS)
- en: You can also run this example online at [https://packt.live/3ijJ1pM.](https://packt.live/3ijJ1pM
    )
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3ijJ1pM](https://packt.live/3ijJ1pM)上在线运行此示例。
- en: This also concludes the last topic of the first chapter of this book. In the
    next section, we have provided an activity that will serve as a hands-on project
    that encapsulates the important topics and discussions we have gone through in
    this chapter.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这也结束了本书第一章的最后一个主题。在下一节中，我们提供了一个活动，这个活动将作为一个实践项目，概括了本章中我们讨论的重要主题和内容。
- en: 'Activity 1.01: Building a Sudoku Solver'
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.01：构建数独求解器
- en: 'Let''s test what we have learned so far with a more complex problem: writing
    a program that can solve Sudoku puzzles. The program should be able to read in
    a CSV text file as input (which contains the initial puzzle) and output the complete
    solution to that puzzle.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个更复杂的问题来测试我们迄今为止学到的知识：编写一个可以解决数独谜题的程序。该程序应能够读取CSV文本文件作为输入（其中包含初始谜题），并输出该谜题的完整解决方案。
- en: This activity serves as a warmup consisting of multiple procedures that are
    common in scientific computing and data science projects, such as reading in data
    from external files and manipulating that information via an algorithm.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动作为一个热身，包括科学计算和数据科学项目中常见的多个程序，例如从外部文件中读取数据并通过算法操纵这些信息。
- en: Use the `sudoku_input_2.txt` file from the GitHub repository of this chapter
    as the input file for our program by copying it to the same location as the Jupyter
    notebook you will be creating in the next step (or create your own input file
    in the same format where empty cells are represented with zeros).
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章的GitHub存储库中的`sudoku_input_2.txt`文件作为程序的输入文件，将其复制到下一步中将要创建的Jupyter笔记本的相同位置（或者创建一个格式相同的自己的输入文件，其中空单元格用零表示）。
- en: In the first code cell of a new Jupyter notebook, create a `Solver` class that
    takes in the path to an input file. It should store the information read from
    the input file in a 9 x 9 2D list (a list of nine sublists, each of which contains
    the nine values of individual rows in the puzzle).
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Jupyter笔记本的第一个代码单元中，创建一个`Solver`类，该类接受输入文件的路径。它应将从输入文件中读取的信息存储在一个9x9的2D列表中（包含九个子列表，每个子列表包含谜题中各行的九个值）。
- en: 'Add a helper method that prints out the puzzle in a nice format, as follows:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个辅助方法，以以下方式打印出谜题的格式：
- en: '[PRE97]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Create a `get_presence(cells)` method in the class that takes in any 9 x 9 2D
    list, representing an unsolved/half-solved puzzle, and returns a sort of indicator
    regarding whether a given number (between 1 and 9) is present in a given row,
    column, or quadrant.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中创建一个`get_presence(cells)`方法，该方法接受任何9x9的2D列表，表示未解决/半解决的谜题，并返回一个关于给定数字（1到9之间）是否出现在给定行、列或象限中的指示器。
- en: For instance, in the preceding example, the returned value of this method should
    be able to tell you that 2, 3, and 6 are present in the first row, while no number
    is present in the second column.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的示例中，该方法的返回值应能够告诉您第一行中是否存在2、3和6，而第二列中是否没有数字。
- en: Create a `get_possible_values(cells)` method in the class that also takes in
    any 2D list representing an incomplete solution and returns a dictionary, whose
    keys are the locations of currently empty cells and the corresponding values are
    the lists/sets of possible values that those cells can take.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中创建一个`get_possible_values(cells)`方法，该方法还接受表示不完整解决方案的任何2D列表，并返回一个字典，其键是当前空单元格的位置，相应的值是这些单元格可以取的可能值的列表/集合。
- en: These lists of possible values should be generated by taking into account whether
    a number is present in the same row, column, or quadrant as a given empty cell.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能值的列表应通过考虑一个数字是否出现在给定空单元格的同一行、列或象限中来生成。
- en: Create a `simple_update(cells)` method in the class that takes in any 2D incomplete
    solution list and calls the `get_possible_values()` method on that list. From
    the returned value, if there is an empty cell that holds only one possible solution,
    update that cell with that value.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中创建一个`simple_update(cells)`方法，该方法接受任何2D不完整解决方案列表，并在该列表上调用`get_possible_values()`方法。根据返回的值，如果有一个只包含一个可能解的空单元格，就用该值更新该单元格。
- en: If such an update does happen, the method should call itself again to keep updating
    the cells. This is because after an update, the list of possible values for the
    remaining empty cells might change. The method should return the updated 2D list
    in the end.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生了这样的更新，该方法应再次调用自身以继续更新单元格。这是因为更新后，剩余空单元格的可能值列表可能会发生变化。该方法最终应返回更新后的2D列表。
- en: Create a `recur_solve(cells)` method in the class that takes in any 2D incomplete
    solution list and performs backtracking. First, this method should call `simple_update()`
    and return whether or not the puzzle is completely solved (that is, whether or
    not there are empty cells in the 2D list).
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中创建一个`recur_solve(cells)`方法，该方法接受任何2D不完整解决方案列表并执行回溯。首先，该方法应调用`simple_update()`，并返回谜题是否完全解决（即2D列表中是否有空单元格）。
- en: Next, consider the possible values of the remaining empty cells. If there are
    empty cells remaining and you have no possible values, return a negative result
    to indicate that we have reached an invalid solution.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑剩余空单元格的可能值。如果还有空单元格，并且没有可能的值，返回一个负结果，表示我们已经达到了一个无效的解决方案。
- en: On the other hand, if all cells have at least two possible values, find the
    cell that has the fewest number of possible values. Loop through these possible
    values, sequentially fill them in the empty cell, and call `recur_solve()` inside
    itself with the updated cells to implement the recursive nature of the algorithm.
    At each iteration, return whether the final solution is valid. If no valid final
    solution is found via any of the possible values, return a negative result.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果所有单元格至少有两个可能的值，找到可能值最少的单元格。依次循环这些可能的值，将它们填入空单元格，并在其中调用`recur_solve()`以使用算法的递归性质更新单元格。在每次迭代中，返回最终解是否有效。如果通过任何可能的值都找不到有效的最终解决方案，则返回一个负结果。
- en: Wrap the preceding methods in a `solve()` method, which should print out the
    initial puzzle, pass it to the `recur_solve()` method, and print out the returned
    solution from that method.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的方法封装在一个`solve()`方法中，该方法应打印出初始的谜题，将其传递给`recur_solve()`方法，并打印出该方法返回的解决方案。
- en: For example, with the preceding puzzle, a `Solver` instance, when `solve()`
    is called, will print out the following output.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的谜题中，当调用`solve()`时，`Solver`实例将打印出以下输出。
- en: 'Initial puzzle:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 初始谜题：
- en: '[PRE98]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Solved puzzle:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 解决的谜题：
- en: '[PRE99]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Extensions
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展
- en: 1\. Go to the *Project Euler* website, [https://projecteuler.net/problem=96](https://projecteuler.net/problem=96),
    to test out your algorithm against the included puzzles.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 前往*Project Euler*网站，[https://projecteuler.net/problem=96](https://projecteuler.net/problem=96)，测试你的算法是否能解决包含的谜题。
- en: 2\. Write a program that generates Sudoku puzzles and includes unit tests that
    check whether the solutions generated by our solver are correct.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 编写一个程序，生成数独谜题，并包括单元测试，检查我们的求解器生成的解是否正确。
- en: Note
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 648.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第648页找到。
- en: Summary
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced the most fundamental building blocks of Python programming:
    control flow, data structures, algorithm design, and various house-keeping tasks
    (debugging, testing, and version control). The knowledge that we have gained in
    this chapter will prepare us for discussions in future chapters, where we''ll
    learn about other more complex and specialized tools in Python. In particular,
    in the next chapter, we will talk about the main tools and libraries that Python
    offers in the fields of statistics, scientific computing, and data science.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Python编程的最基本构建模块：控制流、数据结构、算法设计以及各种日常任务（调试、测试和版本控制）。我们在本章中获得的知识将为我们在未来章节中的讨论做好准备，在那里我们将学习Python中其他更复杂和专业的工具。特别是在下一章中，我们将讨论Python在统计学、科学计算和数据科学领域提供的主要工具和库。
- en: PGM59
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: PGM59
- en: MAF28
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: MAF28
