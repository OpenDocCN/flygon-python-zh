- en: Chapter 7. More Advanced Class Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。更高级的类设计
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下以下的配方：
- en: Choosing between inheritance and extension – the is-a question
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继承和扩展之间进行选择 - is-a问题
- en: Separating concerns via multiple inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多重继承分离关注点
- en: Leveraging Python's duck typing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Python的鸭子类型
- en: Managing global and singleton objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理全局和单例对象
- en: Using more complex structures – maps of lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更复杂的结构 - 映射列表
- en: Creating a class that has orderable objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有可排序对象的类
- en: Defining an ordered collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个有序集合
- en: Deleting from a list of mappings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从映射列表中删除
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we looked at some recipes that cover the basics
    of class design. In this chapter, we'll dive a little more deeply into Python
    classes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00070.html#page "第6章。类和对象的基础")的*类和对象的基础*中，我们看了一些涵盖类设计基础的配方。在本章中，我们将更深入地了解Python类。
- en: In the *Designing classes with lots of processing* and *Using properties for
    lazy attributes* recipes in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we identified a design
    choice that's central to object-oriented programming, the wrap versus extend choice.
    It's possible to add features to a class via extension and it's also possible
    to create a new class that wraps an existing class to add new features. There
    are a number of extension techniques available in Python, providing a lot of alternatives.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00070.html#page "第6章。类和对象的基础")的*设计具有大量处理的类*和*使用属性进行惰性属性*中，我们确定了面向对象编程的一个设计选择，即包装与扩展的选择。可以通过扩展向类添加功能，也可以创建一个新的类，将现有类包装起来添加新功能。Python中有许多扩展技术可供选择。
- en: A Python class can inherit features from more than one superclass. This can
    lead to confusion, but a simple design pattern, the **mixin** , can prevent problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python类可以从多个超类继承特性。这可能会导致混乱，但一个简单的设计模式，即**mixin**，可以避免问题。
- en: A larger application may require some global data that's widely shared by many
    classes or modules. This can be challenging to manage. We can, however, use a
    module to manage a global object and create a simple solution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更大的应用程序可能需要一些全局数据，这些数据被许多类或模块广泛共享。这可能很难管理。然而，我们可以使用一个模块来管理全局对象并创建一个简单的解决方案。
- en: In [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* , we looked at the
    core built-in data structures. It's time to combine some features to create more
    sophisticated objects. This can also include extending built-in data structures
    to add sophistication.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构 - 列表，集合，字典")的*内置数据结构 - 列表，集合，字典*中，我们看了核心的内置数据结构。现在是时候结合一些特性来创建更复杂的对象了。这也可以包括扩展内置数据结构以添加复杂性。
- en: Choosing between inheritance and extension – the is-a question
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在继承和扩展之间进行选择 - is-a问题
- en: In the *Using cmd for creating command-line applications*  recipe in [Chapter
    5](text00063.html#page "Chapter 5. User Inputs and Outputs") , *User Inputs and
    Outputs* , and the  *Extending a collection – a list that does statistics* recipe
    in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we looked at extending a class. In both cases,
    our class was a subclass of a built-in class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00063.html#page "第5章。用户输入和输出")的*使用cmd创建命令行应用程序*和[第6章](text00070.html#page
    "第6章。类和对象的基础")的*扩展集合 - 进行统计的列表*中，我们看到了扩展类的方法。在这两种情况下，我们的类都是内置类的子类。
- en: The idea of extension is sometimes called the generalization-specialization
    relationship. It's sometimes also called the **is-a relationship** .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的概念有时被称为泛化-特化关系。有时也被称为**is-a关系**。
- en: 'There''s an important semantic issue here that we can also summarize as the
    **wrap versus extend problem** :'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的语义问题，我们也可以总结为**包装与扩展问题**：
- en: Do we really mean that the subclass is an example of the superclass? This is
    the is-a relationship. An example in Python is the built-in `Counter` , which
    extends the base class `dict` .
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们真的是指子类是超类的一个例子吗？这就是is-a关系。Python中的一个例子是内置的`Counter`，它扩展了基类`dict`。
- en: Or do we mean something else? Perhaps there's an association, sometimes called
    the **has-a relationship** . An example of this is in the *Designing classes with
    lots of processing* recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , where `CounterStatistics`
    wraps a `Counter` object.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们是指其他的东西吗？也许有一种关联，有时被称为**has-a关系**。这在[第6章](text00070.html#page "第6章。类和对象的基础")的*设计具有大量处理的类*中有一个例子，其中`CounterStatistics`包装了一个`Counter`对象。
- en: What's a good way to distinguish between these two techniques?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么好方法来区分这两种技术吗？
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The question is a bit of metaphysical philosophy, specifically focused on the
    ideas of an **ontology** . An ontology is a way to define categories of being.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有点形而上学的哲学，特别关注**本体论**的思想。本体论是定义存在类别的一种方式。
- en: 'When we extend an object, we have to ask the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展一个对象时，我们必须问以下问题：
- en: '*"Is this a new class of objects, or a mixture of existing classes of objects?"*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“这是一个新类的对象，还是现有类的对象的混合？”*'
- en: 'We''ll look at two ways to model a deck of playing cards:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看两种模拟一副扑克牌的方法：
- en: As a new class of objects that extends the built-in `list` class
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个扩展内置`list`类的新类对象
- en: As a wrapper that combines the built-in `list` class with some other features
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个将内置的`list`类与其他一些特性结合的包装器
- en: 'A deck is a collection of cards. The core ingredient, then, is the underlying
    `Card` object. We''ll define this very simply using `namedtuple()` :'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一副牌是一组卡片。那么，核心成分就是底层的“Card”对象。我们将使用`namedtuple()`来非常简单地定义这个：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've created the class definition, `Card` , using `namedtuple()` . This creates
    a simple class with two attributes—`rank` and `suit` .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`namedtuple()`创建了类定义`Card`。这创建了一个具有两个属性 - `rank`和`suit`的简单类。
- en: We also defined the various suits, `SUITS` , as a string of Unicode characters.
    To make it easier, to create cards of a specific suit, we also decomposed the
    string into four individual one character substrings. If your interactive environment
    doesn't properly display Unicode characters, you may have trouble with this. It
    might be necessary to change the OS environment variable, `PYTHONIOENCODING` ,
    to `UTF-8,` so that proper encoding is done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将各种花色“SUITS”定义为Unicode字符的字符串。为了更容易地创建特定花色的卡片，我们还将字符串分解为四个单个字符的子字符串。如果您的交互环境无法正确显示Unicode字符，您可能会遇到问题。可能需要更改操作系统环境变量“PYTHONIOENCODING”为“UTF-8”，以便进行正确的编码。
- en: The `\u2660` string is a single Unicode character. You can confirm this with
    `len(SUITS) == 4` . If the length isn't 4, check for extraneous spaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`\u2660`字符串是一个Unicode字符。您可以通过`len(SUITS) == 4`来确认这一点。如果长度不是4，请检查是否有多余的空格。'
- en: We'll use this `Card` class in the rest of this recipe. In some card games,
    a single 52-card deck is used. In other games, a dealing shoe is used. A shoe
    is a box that allows a dealer to shuffle together multiple decks and deal conveniently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本配方的其余部分使用这个`Card`类。在一些纸牌游戏中，使用一副52张卡片的牌组。在其他游戏中，使用发牌鞋。鞋子是一个允许荷官将多副牌洗在一起并方便地发牌的盒子。
- en: What's important is that the various kinds of collection—deck, shoe, and the
    built-in list all have considerable overlaps in the kinds of features they support.
    Are they all more or less related? Or are they fundamentally distinct?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是各种集合 - 牌组、鞋子和内置列表在它们支持的功能种类上有相当大的重叠。它们都或多或少相关吗？还是它们基本上是不同的？
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll wrap the *Using a class to encapsulate data and processing* recipe in
    [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects") ,
    *Basics of Classes and Objects,* with this recipe:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](text00070.html#page "第6章。类和对象的基础")中的*使用类封装数据和处理*配方中，与此配方一起包装*类和对象的基础*：
- en: Use the nouns and verbs from the original story or problem statement to identify
    all of the classes.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原始故事或问题陈述中的名词和动词来识别所有的类。
- en: 'Look for overlaps in the feature sets of various classes. In many cases, the
    relationships will come directly from the problem statement itself. In our preceding
    example, a game can deal cards from a deck, or deal cards from a shoe. In this
    case, we might state one of these two views:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找各种类的特征集中的重叠。在许多情况下，关系将直接来自问题陈述本身。在我们之前的例子中，游戏可以从一副牌中发牌，或者从一双鞋中发牌。在这种情况下，我们可能陈述这两种观点之一：
- en: A shoe is a specialized deck that starts with multiple copies of the 52-card
    domain
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鞋子是一个专门的牌组，由52张卡片的多个副本开始
- en: A deck is a specialized shoe with only one copy of the 52-card domain
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一副牌是一个专门的鞋子，只有52张卡片的一个副本
- en: Create a small ontology that clarifies the relationships among the classes.
    There are several kinds of relationships.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个小本体，澄清类之间的关系。有几种关系。
- en: 'Some classes are independent of each other. They''re linked for the purposes
    of implementing a user story. In our example a `Card` refers to a string for the
    suit. The two objects are independent of each other. Many cards will share a common
    suit string. These are ordinary references between objects and there are no special
    design considerations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类彼此独立。它们是为了实现用户故事而链接的。在我们的例子中，“Card”指的是花色的字符串。这两个对象彼此独立。许多卡片将共享一个常见的花色字符串。这些是对象之间的普通引用，没有特殊的设计考虑：
- en: '**Aggregation** : Some objects are bound into collections, but the objects
    have a properly independent existence. Our `Card` objects might be aggregated
    into a `Hand` collection. When the game ends, the `Hand` objects can be deleted,
    but the `Card` objects continue to exist. We might create a `Deck` that refers
    to a built-in `list` .'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：一些对象被绑定到集合中，但这些对象具有独立的存在。我们的“Card”对象可能被聚合到一个“Hand”集合中。游戏结束时，“Hand”对象可以被删除，但“Card”对象仍然存在。我们可以创建一个引用内置“list”的“Deck”。'
- en: '**Composition** : Some objects are bound into collections, but do not have
    an independent existence. When looking at card games, a `Hand` of cards cannot
    exist without a `Player` . We might say that a `Player` object is composed—in
    part—of a `Hand` . If a `Player` is eliminated from a game, then the `Hand` objects
    must also be removed. While this is important for understanding the relationships
    among objects, there are some practical considerations that we''ll look at in
    the next section.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：一些对象被绑定到集合中，但没有独立的存在。在看牌游戏时，一手牌不能没有玩家而存在。我们可能会说“Player”对象在某种程度上是由“Hand”组成的。如果一个“Player”被从游戏中淘汰，那么“Hand”对象也必须被移除。虽然这对于理解对象之间的关系很重要，但在下一节中我们将考虑一些实际的考虑。'
- en: '**Is-a or inheritance** : This is the idea that a `Shoe` is a `Deck` with an
    extra feature (or two). This may be central to our design. We''ll look into this
    in detail in the *Extending – inheritance* section of this recipe.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是一个或继承**：这是一个“Shoe”是一个带有额外功能（或两个）的“Deck”的想法。这可能是我们设计的核心。我们将在本配方的*扩展 - 继承*部分详细研究这一点。'
- en: We've identified several paths for implementing the associations. The aggregation
    and composition cases are both wrap techniques. The inheritance case is the extend
    technique. We'll look at aggregation and composition—both wrapping techniques
    and extending techniques—separately.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了几种实现关联的路径。聚合和组合案例都是包装技术。继承案例是扩展技术。我们将分别研究聚合和组合 - 包装技术和扩展技术。
- en: Wrapping – aggregation and composition
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装 - 聚合和组合
- en: Wrapping is a way to understand a collection. It can be a class that is an aggregate
    of independent objects. It's also a composition that wraps an existing list, meaning
    that the underlying `Card` objects will be shared by a `list` collection and a
    `Deck` collection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包装是一种理解集合的方式。它可以是一个包含独立对象的类。它也是一个包装现有列表的组合，这意味着底层的`Card`对象将被`list`集合和`Deck`集合共享。
- en: 'Define the independent collection. It might be a built-in collection, for example,
    a `set` , `list` , or `dict` . For this example, it will be a list that contains
    the cards:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义独立的集合。它可能是一个内置的集合，例如`set`，`list`或`dict`。在这个例子中，它将是一个包含卡片的列表：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the aggregate class. For this example, the name has a `_W` suffix. This
    is not a recommended practice; it''s only used here to make the distinctions between
    class definitions more clear. Later, we''ll see a slightly different variation
    on this design:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义聚合类。在这个例子中，名称带有`_W`后缀。这不是一个推荐的做法；这里只是为了更清楚地区分类定义之间的区别。稍后，我们将看到对这种设计的稍微不同的变化：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `__init__()` method of this class as one way to provide the underlying
    collection object. This will also initialize any stateful variables. We might
    create an iterator for dealing:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个类的`__init__()`方法作为提供底层集合对象的一种方式。这也将初始化任何有状态的变量。我们可能会创建一个用于发牌的迭代器：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This uses a type hint, `List[Card]` . The `typing` module provides the necessary
    definition of `List` .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个类型提示，`List[Card]`。`typing`模块提供了`List`的必要定义。
- en: If needed, provide other methods to either replace the collection, or update
    the collection. This is rare in Python, since the underlying attribute, `cards`
    , can be accessed directly. However, it might be helpful to provide a method that
    replaces the `self.cards` value.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，提供其他方法来替换集合，或更新集合。这在Python中很少见，因为底层属性`cards`可以直接访问。然而，提供一个替换`self.cards`值的方法可能是有帮助的。
- en: 'Provide the methods appropriate to the aggregate object:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供适用于聚合对象的方法：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `shuffle()` method randomizes the internal list object, `self.cards` . The
    `deal()` object creates an iterator that can be used to step through the `self.cards`
    list. We've provided a type hint on `deal()` to clarify that it returns a `Card`
    instance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle()`方法随机化内部列表对象`self.cards`。`deal()`对象创建一个迭代器，可以用来遍历`self.cards`列表。我们在`deal()`上提供了一个类型提示，以澄清它返回一个`Card`实例。'
- en: 'Here''s how we can use this class. We''ll be sharing a list of `Card` objects.
    In this case, the `domain` variable was created from a list comprehension that
    generated all 52 combinations of 13 ranks and four suits:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个类的方法。我们将共享一个`Card`对象列表。在这种情况下，`domain`变量是从一个列表推导式中创建的，该推导式生成了13个等级和四种花色的52种组合：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use the items in this collection, `domain` , to create a second aggregate
    object that shares the same underlying `Card` objects. We''ll build the `Deck_W`
    object from the list of objects in the `domain` variable:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个集合中的项目`domain`来创建一个共享相同底层`Card`对象的第二个聚合对象。我们将从`domain`变量中的对象列表构建`Deck_W`对象：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the `Deck_W` object is available, it''s possible to use the unique features:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Deck_W`对象可用，就可以使用独特的功能：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've seeded the random number generator to force the cards to have a defined
    order. That makes unit testing possible. After that, we shuffled the deck into
    an order based on the random seed. Once the seed is sown, the results are consistent,
    making unit testing easy. We can deal five cards from the deck. This shows how
    the `Deck_W` object, `d` , shares the same pool of objects as the `domain` list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经种子化了随机数生成器，以强制卡片有一个定义的顺序。这样可以进行单元测试。之后，我们根据随机种子对牌组进行了洗牌。一旦种子被播下，结果就是一致的，这样单元测试就变得容易了。我们可以从牌组中发出五张牌。这展示了`Deck_W`对象`d`如何与`domain`列表共享相同的对象池。
- en: We can delete the `Deck_W` object, `d` , and create a new deck from the `domain`
    list. This is because the `Card` objects are not part of a composition. The cards
    have an independent existence from the `Deck_W` collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除`Deck_W`对象`d`，并从`domain`列表中创建一个新的牌组。这是因为`Card`对象不是组合的一部分。这些卡片与`Deck_W`集合有独立的存在。
- en: Extending - inheritance
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展-继承
- en: 'Here''s an approach to defining a class that extends a collection of objects.
    We''ll define a `Deck` as an aggregate that wraps an existing list. The underlying
    `Card` objects will be shared by a list and a `Deck` :'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种定义扩展对象集合的类的方法。我们将一个`Deck`定义为一个包装现有列表的聚合体。底层的`Card`对象将被列表和`Deck`共享：
- en: 'Define the extension class as a subclass of a built-in collection. For this
    example, the name has a `_X` suffix. This not a recommended practice; it''s only
    used here to make the distinctions between two class definitions in this recipe
    more clear:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将扩展类定义为内置集合的子类。在这个例子中，名称带有`_X`后缀。这不是一个推荐的做法；这里只是为了更清楚地区分这个配方中两个类定义之间的区别：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a clear and formal statement—a `Deck` is a list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个清晰而正式的陈述——`Deck`是一个列表。
- en: Use the `__init__()` method inherited from the `list` class. No code is needed.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从`list`类继承的`__init__()`方法。不需要代码。
- en: Use other methods of the `list` class for adding, changing, or removing items
    from the `Deck` . No code is needed.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list`类的其他方法来向`Deck`添加、更改或删除项目。不需要代码。
- en: 'Provide the appropriate methods to the extended object:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为扩展对象提供适当的方法：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `shuffle()` method randomizes the object as a whole, `self` , because it
    is an extension of the list. The `deal()` object creates an iterator that can
    be used to step through the `self.cards` list. We've provided a type hint on `deal()`
    to clarify that it returns a `Card` instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle()`方法将对象作为一个整体进行随机化，因为它是列表的扩展。`deal()`对象创建一个迭代器，可以用来遍历`self.cards`列表。我们在`deal()`上提供了一个类型提示，以澄清它返回一个`Card`实例。'
- en: 'Here''s how we can use this class. First, we''ll build a deck of cards:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个类的方法。首先，我们将构建一副牌：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We used a generator expression to build individual `Card` objects. We can use
    the `Deck_X()` class function exactly the way we'd use the `list()` class function.
    In this case, we built a `Deck_X` object from the generator expression. We could
    build a `list` similarly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生成器表达式构建了单独的`Card`对象。我们可以像使用`list()`类函数一样使用`Deck_X()`类函数。在这种情况下，我们从生成器表达式构建了一个`Deck_X`对象。我们也可以类似地构建一个`list`。
- en: We did not provide an implementation for the built-in `__len__()` method. This
    was inherited from the `list` class, and works nicely.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为内置的`__len__()`方法提供实现。这是从`list`类继承的，并且工作得很好。
- en: 'Using the deck-specific features for this implementation looks exactly like
    the other implementation, `Deck_W` :'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现，使用特定于牌组的特性看起来与另一个实现`Deck_W`完全相同：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've seeded the random number generator, shuffled the deck, and dealt five
    cards. The extension methods work as well for `Deck_X` as they do for `Deck_W`
    . The `shuffle()` and `deal()` methods do their jobs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经初始化了随机数生成器，洗牌了牌组，并发了五张牌。扩展方法对`Deck_X`和`Deck_W`同样适用。`shuffle()`和`deal()`方法都能正常工作。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Python''s mechanism for finding a method (or attribute) works like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python查找方法（或属性）的机制如下：
- en: Search in the class for the method or attribute.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中搜索方法或属性。
- en: If the name is not defined in the immediate class, then search in all of the
    parent classes for the method or attribute.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在当前类中未定义名称，则在所有父类中搜索方法或属性。
- en: 'This is how Python implements the idea of inheritance. Searching through the
    parent classes assures two things:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Python实现继承的方式。通过搜索父类，可以确保两件事：
- en: Any method defined in any superclass is available to all subclasses
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何超类中定义的方法都可用于所有子类
- en: Any subclass can override a method to replace a superclass method
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何子类都可以重写一个方法来替换超类方法
- en: Because of this, a subclass of the `list` class inherits all the features of
    the parent class. It is a specialized variation of the built-in `list` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`list`类的子类继承了父类的所有特性。它是内置`list`类的专门变体。
- en: This also means that all methods have the potential to be overridden by a subclass.
    Some languages have ways to lock a method against extension. The word `private`
    is used by languages such as C++ and Java. Python doesn't have this, a subclass
    can override any method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着所有方法都有可能被子类重写。一些语言有方法可以锁定方法防止扩展。像C++和Java这样的语言使用`private`关键字。Python没有这个限制，子类可以重写任何方法。
- en: 'To explicitly refer to methods from a superclass, we can use the `super()`
    function to force a search through the superclasses. This allows a subclass to
    add features by wrapping the superclass version of a method. We use it like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确引用超类的方法，我们可以使用`super()`函数来强制搜索超类。这允许子类通过包装方法的超类版本来添加特性。我们可以像这样使用它：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, the `some_method()` object will do something extra and then do
    the superclass version of the method. This allows us a handy way to extend selected
    methods of a class. We can preserve the superclass features while adding features
    unique to the subclass.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`some_method()`对象将执行一些额外的操作，然后执行方法的超类版本。这使我们能够方便地扩展类的选定方法。我们可以保留超类的特性，同时添加子类独有的特性。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When designing a class, we must choose between the several essential techniques:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类时，我们必须在几种基本技术之间进行选择：
- en: '**Wrapping** : This technique creates a new class. All of the required methods
    must be defined. This can be a lot of code to provide the required methods. Wrapping
    can be decomposed into two broad implementation choices:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装**：这种技术创建了一个新的类。必须定义所有必需的方法。这可能需要大量的代码来提供所需的方法。包装可以分解为两种广泛的实现选择：'
- en: '**Aggregation** : The objects being wrapped have an independent existence from
    the wrapper. The `Deck_W` example showed how the `Card` objects and even the list
    of cards were independent from the class. When any `Deck_W` object is deleted,
    the underlying list will continue to exist.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：被包装的对象与包装器具有独立的存在。`Deck_W`示例展示了`Card`对象甚至牌组列表与类是独立的。当任何`Deck_W`对象被删除时，底层列表将继续存在。'
- en: '**Composition** : The objects being wrapped don''t have any independent existence;
    they''re an essential part of the composition. This involves a subtle difficulty
    because of Python''s reference counting. We''ll look at this shortly in some detail.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：被包装的对象没有独立的存在；它们是组合的重要部分。这涉及到Python的引用计数的微妙难题。我们很快会详细看一下这个问题。'
- en: '**Extension via inheritance** : This is the is-a relationship. When extending
    a built-in class, then a great many methods are available from the superclass.
    The `Deck_X` example showed this technique by creating a deck as an extension
    to the built-in `list` class.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过继承进行扩展**：这是is-a关系。当扩展内置类时，许多方法都可以从超类中获得。`Deck_X`示例通过创建一个作为内置`list`类扩展的牌组来展示了这种技术。'
- en: When looking at independent existence of objects, there's an important consideration.
    We don't really remove objects from memory. Instead, Python uses a technique called
    reference counting to track how many times an object is used. A statement such
    as `del deck` doesn't really remove the `deck` object, it removes the `deck` variable,
    which decrements the reference count for the underlying object. If the reference
    count is zero, the object is not used and can be removed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看对象的独立存在时，有一个重要的考虑因素。我们实际上并没有从内存中删除对象。相反，Python使用一种称为引用计数的技术来跟踪对象被使用的次数。例如`del
    deck`这样的语句实际上并没有删除`deck`对象，而是删除了`deck`变量，这会减少底层对象的引用计数。如果引用计数为零，则对象未被使用，可以被删除。
- en: 'Consider the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, we have an object, `Card(2, Spades)` , and two variables that
    refer to the object—`c_2s` and `another` .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个对象`Card(2, Spades)`，以及两个引用该对象的变量`c_2s`和`another`。
- en: If we remove one of those variables with the `del` statement, the other variable
    still has a reference to the underlying object. The object can't be removed from
    memory until both variables are removed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`del`语句删除其中一个变量，另一个变量仍然引用底层对象。直到两个变量都被删除，对象才能从内存中删除。
- en: This consideration makes the distinction between aggregation and composition
    mostly irrelevant for Python programmers. In languages that don't use automatic
    garbage collection or reference counters, then composition becomes important because
    objects may vanish. In Python, objects can't vanish unexpectedly. We generally
    focus on aggregation because removal of unused objects is entirely automatic.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这一考虑使得聚合和组合的区别对于Python程序员来说基本上无关紧要。在不使用自动垃圾收集或引用计数器的语言中，组合变得重要，因为对象可能会消失。在Python中，对象不会意外消失。我们通常关注聚合，因为未使用的对象的删除是完全自动的。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: We've looked at the built-in collections in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* . Also, in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we looked at how
    to define simple collections.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中查看了内置集合，*内置数据结构-列表、集合、字典*。此外，在[第6章](text00070.html#page
    "第6章。类和对象的基础知识")中，*类和对象的基础知识*，我们已经了解了如何定义简单的集合。
- en: In the  *Designing classes with lots of processing* recipe, we looked at wrapping
    a class with a separate class that handles the processing details. We can contrast
    this with the *Using properties for lazy attributes* recipe of [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , where we put the complex computations into the class as properties; this design
    relies on extension.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*设计具有大量处理的类*配方中，我们研究了用一个处理处理细节的单独类包装一个类。我们可以将其与[第6章](text00070.html#page "第6章。类和对象的基础知识")中的*使用属性进行延迟属性*配方进行对比，*类和对象的基础知识*，在那里我们将复杂的计算作为属性放入类中；这种设计依赖于扩展。
- en: Separating concerns via multiple inheritance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过多重继承分离关注点
- en: 'In the *Choosing between inheritance and extension – the is-a question* recipe,we
    looked at the idea of defining a `Deck` class that was a composition of playing
    card objects. For the purposes of that example, we treated each `Card` object
    as simply having a rank and a suit. This created a number of small problems:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*选择继承和扩展之间-是一个问题*配方中，我们研究了定义一个`Deck`类的想法，它是扑克牌对象的组合。对于该示例，我们将每个`Card`对象简单地视为具有等级和花色。这产生了一些小问题：
- en: The display for the card always showed a numeric rank. We didn't see J, Q, or
    K. Instead we saw 11, 12, and 13\. Similarly, an Ace was shown as 1 instead of
    A.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片的显示总是显示数字等级。我们没有看到J、Q或K。相反，我们看到11、12和13。同样，Ace显示为1而不是A。
- en: Many games, such as, *Blackjack* and *Cribbage* assign a point value to each
    rank. Generally, the face cards have 10 points. For Blackjack, an Ace has two
    different point values; depending on the total of other cards in the hand, it
    can be worth one point or ten points.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多游戏，如*Blackjack*和*Cribbage*，为每个等级分配一个点值。通常，花牌有10点。对于Blackjack，Ace有两个不同的点值；取决于手中其他牌的总数，它可以值1点或10点。
- en: How can we handle all of the variations in card game rules?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理卡牌游戏规则的所有变化？
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'The `Card` class is really a mixture of two feature sets:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Card`类实际上是两个特征集的混合：'
- en: Some essential features, such as rank and suit.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些基本特性，如等级和花色。
- en: Some game-specific features, such as the number of points. For a game such as
    *Cribbage* , the points are consistent regardless of any context. For *Blackjack*
    , however, there's a relationship between a `Hand` and the `Card` objects within
    a `Hand` .
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些特定于游戏的特性，如点数。对于*Cribbage*这样的游戏，无论上下文如何，点数都是一致的。然而，对于*Blackjack*，`Hand`和`Hand`中的`Card`对象之间存在关系。
- en: Python lets us define a class that has multiple parents. A class can have both
    a `Card` superclass and a `GameRules` superclass.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们定义一个具有多个父类的类。一个类可以同时拥有`Card`超类和`GameRules`超类。
- en: 'In order to make sense of this kind of design, we''ll often partition the various
    class hierarchies into two sets of features:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这种设计，我们经常将各种类层次结构分为两组特征：
- en: '**Essential features** : This includes `rank` and `suit`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本特征**：这包括`rank`和`suit`'
- en: '**Mixin features** : These features are mixed into the class definition'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mixin特性**：这些特性被混合到类定义中'
- en: The idea is that a working class definition will have both essential and mixin
    features.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是一个工作类定义将具有基本特征和mixin特征。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Define the essential class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基本类：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've defined a generic `Card` class that is suitable for ranks two to ten.
    We've included an explicit call to any superclass initialization via `super().__init__()`
    .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个通用的`Card`类，适用于等级为2到10。我们通过`super().__init__()`显式调用任何超类初始化。
- en: 'Define any subclasses to handle specializations:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义任何子类来处理特殊化：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've defined two subclasses of the `Card` class. The `AceCard` class handles
    the special formatting rules for an Ace. The `FaceCard` class handles other formatting
    rules for Jack, Queen, and King.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`Card`类的两个子类。`AceCard`类处理Ace的特殊格式规则。`FaceCard`类处理Jack、Queen和King的其他格式规则。
- en: 'Define a mixin superclass that identifies the additional features that will
    be added. In some cases, the mixins will all inherit features from a common abstract
    class. In this example, we''ll use a concrete class that handles the rules for
    Ace through 10:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个标识将要添加的附加特征的mixin超类。在某些情况下，mixin将全部继承自一个共同的抽象类。在这个例子中，我们将使用一个处理Ace到10的规则的具体类：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the game of *Cribbage* , the points for most cards are equal to the rank
    of the card.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*Cribbage*游戏，大多数卡片的点数等于卡片的等级。
- en: 'Define concrete mixin subclasses for the various kinds of features:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为各种特征定义具体的mixin子类：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the three ranks of face cards, the points are always 10.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三个花色的牌，点数总是10。
- en: Create the class definitions that combine the essential classes and the mixin
    classes. While it's technically possible to add unique method definitions here,
    that often leads to confusion. The goal is to have two separate sets of features
    that are simply merged to create the resulting class definition.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建结合基本类和混合类的类定义。虽然在这里技术上可以添加独特的方法定义，但这经常会导致混乱。目标是有两组简单合并以创建结果类定义的特性。
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a factory function (or factory class) to create the appropriate objects
    based the on input parameters:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个工厂函数（或工厂类）来根据输入参数创建适当的对象：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use this function to create a deck of cards like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数来创建一副牌：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've seeded the random number generator to assure that the results are the
    same each time we evaluate the `shuffle()` function. This makes unit testing possible.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经种子化了随机数生成器，以确保每次评估`shuffle()`函数时结果都是相同的。这使得单元测试成为可能。
- en: We use a list comprehension to generate a list of cards that include all 13
    ranks and four suits. This is a collection of 52 individual objects. The objects
    belong to two class hierarchies. Each object is a subclass of `Card` as well as
    being a subclass of `CribbagePoints` . This means that both collections of features
    are available for all of the objects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导来生成一个包含所有13个等级和四种花色的卡牌列表。这是52个单独的对象的集合。这些对象属于两个类层次结构。每个对象都是`Card`的子类，也是`CribbagePoints`的子类。这意味着所有对象都可以使用这两个特性集合。
- en: 'For example, we can evaluate the `points()` method of each `Card` object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以评估每个`Card`对象的`points()`方法：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The hand has two face cards, plus three, six, and Ace, so the total points are
    `30` .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 手中有两张花色牌，加上三、六和A，所以总点数是`30`。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Python''s mechanism for finding a method (or attribute) works like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python查找方法（或属性）的机制如下：
- en: Search in the class for the method or attribute.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中搜索方法或属性。
- en: If the name is not defined in the immediate class, then search in all of the
    parent classes for the method or attribute. The parent classes are searched in
    a sequence called appropriately, the **Method Resolution Order** ( **MRO** ).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果名称在当前类中未定义，则在所有父类中搜索该方法或属性。父类按照称为**方法解析顺序**（**MRO**）的顺序进行搜索。
- en: The method resolution order is computed when the class is created. The algorithm
    used is called C3\. More information is available at [https://en.wikipedia.org/wiki/C3_linearization](https://en.wikipedia.org/wiki/C3_linearization)
    . This algorithm assures that each parent class is searched once. It also assures
    that the relative ordering of superclasses is preserved so that all subclasses
    tend to be searched before any of their parent classes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被创建时，方法解析顺序被计算。使用的算法称为C3。更多信息可在[https://en.wikipedia.org/wiki/C3_linearization](https://en.wikipedia.org/wiki/C3_linearization)找到。该算法确保每个父类只被搜索一次。它还确保了超类的相对顺序被保留，以便所有子类在任何父类之前被搜索。
- en: 'We can see the method resolution order using the `mro()` method of a class.
    Here''s an example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类的`mro()`方法来查看方法解析顺序。这里有一个例子：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We picked a card from the deck, `c` . The card''s `__class__` attribute is
    a reference to the class. In this case, the class name is `CribbageCard` . The
    `mro()` method of this class shows us the order that''s used to resolve names:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从牌堆中抽取了一张牌`c`。牌的`__class__`属性是对该类的引用。在这种情况下，类名是`CribbageCard`。这个类的`mro()`方法向我们展示了用于解析名称的顺序：
- en: First search the class itself, `CribbageCard` .
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先搜索类本身，`CribbageCard`。
- en: If it's not there, search `Card` .
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到，搜索`Card`。
- en: Try to find it in `CribbagePoints` next.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在`CribbagePoints`中找到它。
- en: Use `object` last.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后使用`object`。
- en: Class definitions generally use internal `dict` objects to store the method
    definitions. This means that the search is a hash lookup that is extremely fast.
    The overhead difference is about 3% more time to search `object` (when something's
    not found in any of the previous classes) than to search `Card` .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义通常使用内部的`dict`对象来存储方法定义。这意味着搜索是一个非常快速的哈希查找。额外的开销差异大约是搜索`object`（当在任何之前的类中找不到时）比搜索`Card`多3%的时间。
- en: 'If we do one million operations, we see numbers such as the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行一百万次操作，我们会看到以下数字：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We compared the time to find `__repr__()` , defined in `Card` , against the
    time to find `__str__()` , defined in `object` . The extra time summed over a
    million repetitions is 0.03 seconds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较了查找`Card`中定义的`__repr__()`和查找`object`中定义的`__str__()`的时间。在一百万次重复中额外的时间总和是0.03秒。
- en: Since the cost is negligible, this capability is an important way to structure
    the design of a class hierarchy.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成本微乎其微，这种能力是构建类层次结构设计的重要方式。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several kinds of concerns, that we can separate like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种关注点，我们可以像这样分开：
- en: '**Persistence and representation of state** : We might add methods to manage
    conversion to a consistent external representation.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性和状态的表示**：我们可以添加方法来管理转换为一致的外部表示。'
- en: '**Security** : This may involve a mixin class that performs a consistent authorization
    check that becomes part of each object.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这可能涉及一个执行一致授权检查的混合类，这成为每个对象的一部分。'
- en: '**Logging** : A mixin class that creates a logger that''s consistent across
    a variety of classes might be defined.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录：创建一个跨多个类一致的记录器的混合类可能被定义。
- en: '**Event signaling and change notification** : In this case, we might have objects
    that produce state change notifications and objects that will subscribe to those
    notifications. These are sometimes called the observable and observer design patterns.
    A GUI widget might observe the state of an object; when the object changes, it
    notifies the GUI widget so that the display is refreshed.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件信号和变更通知**：在这种情况下，我们可能有一些产生状态变化通知的对象，以及将订阅这些通知的对象。这些有时被称为可观察者和观察者设计模式。GUI小部件可能观察对象的状态；当对象发生变化时，它会通知GUI小部件，以便刷新显示。'
- en: As a small example, we could add a mixin to introduce logging. We'll define
    this class so that it must be provided first in the list of superclasses. Since
    it's early in the MRO list, the `super()` function will find methods defined later
    in the list of classes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 举个小例子，我们可以添加一个mixin来引入日志记录。我们将定义这个类，以便它必须首先在超类列表中提供。由于它在MRO列表中很早，`super()`函数将找到后面类列表中定义的方法。
- en: 'This class will add the `logger` attribute to each class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将为每个类添加`logger`属性：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we've used `super().__init__()` to perform the `__init__()` method
    of any other classes defined in the MRO. As we just noted, it's generally the
    simplest approach to have one class that defines the essential features of an
    object, and all other mixins simply add features to that object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经使用`super().__init__()`来执行MRO中定义的任何其他类的`__init__()`方法。正如我们刚才指出的，通常最简单的方法是有一个类来定义对象的基本特征，所有其他mixin只是为该对象添加特性。
- en: We've provided a definition for `points()` . This will search other classes
    in the MRO list for an implementation of `points()` . Then it will log the results
    computed by the method from another class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`points()`提供了一个定义。这将在MRO列表中搜索其他类的`points()`实现。然后，它将记录另一个类的方法计算的结果。
- en: 'Here are some classes that include the `Logged` mixin features:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些包含`Logged` mixin特性的类：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each of these classes are built from a three separate class definitions. Since
    the `Logged` class is provided first, we're assured that all classes have consistent
    logging. We're also assured that any method in `Logged` can use `super()` to locate
    an implementation in the superclass list that follows it in the class definition.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类中的每一个都是由三个单独的类定义构建的。由于`Logged`类首先提供，我们可以确保所有类都具有一致的日志记录。我们还可以确保`Logged`中的任何方法都可以使用`super()`来定位在类定义中跟随它的超类列表中的实现。
- en: 'To make use of these classes, we''d need to make one more small change to an
    application:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些类，我们需要对应用程序进行一个小的改变：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We need to use this function instead of `make_card()` . This function will use
    the other set of class definitions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用这个函数来代替`make_card()`。这个函数将使用另一组类定义。
- en: 'Here''s how we use this function to build a deck of card instances:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用这个函数来构建一副卡片实例：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've replaced `make_card()` with `make_logged_card()` when creating a deck.
    Once we do this, we now have detailed debugging information available from a number
    of classes in a consistent fashion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一副牌时，我们用`make_logged_card()`替换了`make_card()`。一旦我们这样做，我们现在可以以一致的方式从多个类中获得详细的调试信息。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: When considering multiple inheritance, it's always essential to also consider
    whether or not a wrapper is a better design. See the *Choosing between inheritance
    and extension – the is-a question* recipe.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在考虑多重继承时，始终要考虑包装器是否是更好的设计。参见*选择继承和扩展之间的选择-是一个问题*食谱。
- en: Leveraging Python's duck typing
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Python的鸭子类型
- en: Most of the time that a design involves inheritance, there's a clear relationship
    from a superclass to one or more subclasses. In the *Choosing between inheritance
    and extension – the is-a question* recipe of this chapter as well as the  *Extending
    a collection – a list that does statistics*  recipe in [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , we've looked at extensions that involve a proper subclass-superclass relationship.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，设计涉及继承，从超类到一个或多个子类都有一个明确的关系。在本章的*选择继承和扩展之间的选择-是一个问题*食谱以及[第6章](text00070.html#page
    "第6章。类和对象的基础")中的*扩展集合-进行统计的列表*食谱中，我们已经看到了涉及适当子类-超类关系的扩展。
- en: Python doesn't have a formal mechanism for abstract superclasses. The standard
    library, however, has the `abc` module that supports the creation of abstract
    classes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有正式的抽象超类机制。然而，标准库有一个`abc`模块，支持创建抽象类。
- en: 'This isn''t always necessary, however. Python relies on duck typing to locate
    methods within a class. This name comes from the quote:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是必要的。Python依赖于鸭子类型来定位类中的方法。这个名字来自这句话：
- en: '*"When I see a bird that walks like a duck and swims like a duck and quacks
    like a duck, I call that bird a duck."*'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"当我看到一只像鸭子一样走路、游泳和嘎嘎叫的鸟时，我就称那只鸟为鸭子。"*'
- en: 'The quote is originally from James Whitcomb Riley. It''s sometimes taken as
    a summary of **abductive reasoning** : we go from an observation to a more complete
    theory that includes that observation. In the case of Python class relationships,
    if two objects have the same methods, and the same attributes, this has the same
    effect as having a common superclass. It works even if there''s no common superclass
    definition other than the `object` class.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话最初来自詹姆斯·惠特科姆·赖利。有时被视为**归纳推理**的总结：我们从观察到一个更完整的理论，其中包括了那个观察。在Python类关系的情况下，如果两个对象具有相同的方法和属性，这与具有共同的超类具有相同的效果。即使除了`object`类之外没有共同的超类定义，它也可以工作。
- en: We can call the collection of methods and attributes the signature of a class.
    The signature uniquely identifies the class's properties and behaviors. In Python,
    the signature is dynamic, and the matching is simply a matter of doing a lookup
    for a name within an object's namespace.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以称方法和属性的集合为类的签名。签名唯一标识了类的属性和行为。在Python中，签名是动态的，匹配只是在对象的命名空间中查找名称。
- en: Can we exploit this?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能利用这个吗？
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: It's often easy to create a superclass and be sure that all subclasses extend
    this class. In some cases, though, this can be awkward. For example, if an application
    is spread across several modules, it might be challenging to factor out a common
    superclass and put this by itself in a separate module so that it can be included
    widely.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常很容易创建一个超类，并确保所有子类都扩展了这个类。但在某些情况下，这可能会很麻烦。例如，如果一个应用程序分布在几个模块中，可能很难因素出一个共同的超类，并将其单独放在一个单独的模块中，以便可以广泛包含它。
- en: Instead, it's sometimes easier to avoid a common superclass and simply check
    that two classes are both equivalent using the duck test—the two classes have
    the same methods and attributes, therefore, they are effectively members of some
    superclass that has no formal realization as Python code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有时更容易避免共同的超类，只需检查两个类是否等效，使用鸭子测试——两个类具有相同的方法和属性，因此，它们实际上是某个没有正式实现为Python代码的超类的成员。
- en: We'll use a simple pair of classes to show how this works. These classes will
    both simulate rolling a pair of dice. While the problem is simple, we can easily
    create a variety of implementations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一对简单的类来展示这是如何工作的。这些类都将模拟掷一对骰子。虽然问题很简单，但我们可以轻松地创建各种实现。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define a class with the required methods and attributes. In this example, we''ll
    have one attribute, `dice` , that retains the result of the last roll, and one
    method, `roll()` , that changes the state of the dice:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有所需方法和属性的类。在这个例子中，我们将有一个属性`dice`，它保留了上次掷骰子的结果，以及一个方法`roll()`，它改变了骰子的状态：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define other classes that have the same methods and attributes. Here''s a somewhat
    more complex definition that creates a class that has the same signature as the
    `Dice1` class:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义其他具有相同方法和属性的类。以下是一个稍微复杂的定义，它创建了一个与`Dice1`类具有相同签名的类：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This class introduces an additional attribute, `_dice` . This change in implementation
    doesn't change the advertised interface of a single attribute, `dice` , and method,
    `roll()` .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类引入了一个额外的属性，`_dice`。这种实现上的改变并不会改变单个属性`dice`和方法`roll()`的公开接口。
- en: 'At this point, the two classes can be interchanged freely:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这两个类可以自由交换：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use this function as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数如下：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The objects built from `Dice1` and `Dice2` have enough similarities that they're
    indistinguishable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Dice1`和`Dice2`构建的对象有足够的相似之处，以至于它们是无法区分的。
- en: We can, of course, push the envelope and look for the `_dice` attribute as a
    way to distinguish between the two classes. We can also use `__class__` to distinguish
    between the classes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以推动边界，并寻找`_dice`属性作为区分两个类的方法。我们也可以使用`__class__`来区分这两个类。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we write an expression of the form `namespace.name` , Python will look
    up the name within the given namespace. The algorithm works like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写形式为`namespace.name`的表达式时，Python将在给定的命名空间中查找名称。算法的工作方式如下：
- en: Search the object's `self.__dict__` collection for the name. Some class definitions
    will save space, using `__slots__` . See the *Optimizing small objects with __slots__*
    recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , for more on this optimization. This is generally
    how attribute values are found.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索对象的`self.__dict__`集合以查找名称。一些类定义将节省空间，使用`__slots__`。有关此优化的更多信息，请参阅[第6章](text00070.html#page
    "第6章。类和对象的基础知识")中的*使用__slots__优化小对象*，*类和对象的基础知识*。这通常是如何找到属性值的。
- en: Search the object's `self.__class__.__dict__` collection for the name. This
    is generally how methods are found.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索对象的`self.__class__.__dict__`集合以查找名称。这通常是方法被找到的方式。
- en: As we noted in the *Choosing between inheritance and extension - the is-a question*
    and *Separating concerns via multiple inheritance* recipes, the search can continue
    through all of the superclasses of the class. This search is done in the defined
    method resolution order.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在*选择继承和扩展之间的区别——is-a问题*和*通过多重继承分离关注点*中所指出的，搜索可以继续通过类的所有超类。这个搜索是按照定义的方法解析顺序进行的。
- en: 'There are two essential outcomes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个基本的结果：
- en: The value is an object that's not callable. This is the value. This is typical
    of attributes.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值是一个不可调用的对象。这就是值。这是属性的典型特征。
- en: The value of the attribute is a bound method of a class. This is true for both
    ordinary methods and properties. See the *Using properties for lazy attributes*
    recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , for more information on properties. The bound
    method must be evaluated. For simple methods, the arguments are in `()` after
    the method name. For properties, there are no `()` with method argument values.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的值是类的绑定方法。这对于普通方法和属性都是正确的。有关属性的更多信息，请参阅[第6章](text00070.html#page "第6章。类和对象的基础知识")中的*使用属性进行惰性属性*，*类和对象的基础知识*。绑定方法必须被评估。对于简单的方法，参数在方法名称后的`()`中。对于属性，没有带有方法参数值的`()`。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We've elided some details about how descriptors are used. For the most common
    use cases, the presence of the descriptor isn't important.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了一些关于如何使用描述符的细节。对于最常见的用例，描述符的存在并不重要。
- en: The essence of this is the search through `__dict__` (or `__slots__` ) collections
    of names. If objects have a common superclass, then we can guarantee that a matching
    name will be found. If objects do not have a common superclass, then we don't
    have the same kind of guarantee. We have to rely on disciplined design and good
    test coverage.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这的本质是通过`__dict__`（或`__slots__`）名称集合进行搜索。如果对象有一个共同的超类，那么我们可以保证会找到匹配的名称。如果对象没有共同的超类，那么我们就没有同样的保证。我们必须依赖纪律性的设计和良好的测试覆盖率。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When we look at the `decimal` module we see an example of a numeric type that
    is distinct from all of the other numeric types. In order to make this work out
    well, the `numbers` module includes a concept of registering a class as a part
    of the `Number` class hierarchy. This injects a new class into the hierarchy without
    using inheritance.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 `decimal` 模块时，我们看到了一个与所有其他数值类型不同的数值类型的例子。为了使其正常工作，`numbers` 模块包括了将类注册为
    `Number` 类层次结构的一部分的概念。这样可以在不使用继承的情况下将一个新类注入到层次结构中。
- en: A similar technique is used by the `codecs` module to add new data encodings.
    We can define a new encoding and register it without using any of the classes
    defined in the `codecs` module.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`codecs` 模块使用类似的技术来添加新的数据编码。我们可以定义一个新的编码并将其注册，而不使用 `codecs` 模块中定义的任何类。'
- en: Previously, we noted that the search for a method of a class involves the concept
    of a descriptor. Internally, Python uses descriptor objects to create gettable
    and settable properties of an object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们注意到类的方法的搜索涉及描述符的概念。在内部，Python 使用描述符对象来创建对象的可获取和可设置属性。
- en: A descriptor object must implement some combination of the special methods `__get__`
    , `__set__` , and `__delete__` . When the attribute appears in an expression,
    then `__get__` will be used to locate the value. When the attribute appears on
    the left side of an assignment, then `__set__` is used. In a `del` statement,
    the `__delete__` method is used.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符对象必须实现一些特殊方法 `__get__` 、`__set__` 和 `__delete__` 的组合。当属性出现在表达式中时，将使用 `__get__`
    来定位值。当属性出现在赋值的左侧时，将使用 `__set__`。在 `del` 语句中，将使用 `__delete__` 方法。
- en: The descriptor object acts as an intermediary so that a simple attribute can
    be used in a variety of contexts. It's rare to use descriptors directly. We can
    use the `@property` decorator to build descriptors for us.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符对象充当中介，以便一个简单的属性可以在各种上下文中使用。很少直接使用描述符。我们可以使用 `@property` 装饰器为我们构建描述符。
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The duck type question is implicit in the *Choosing between inheritance and extension
    – the is-a question* recipe; if we leverage duck typing, we're also making a claim
    that two classes are not the same thing. When we bypass inheritance, we are implicitly
    claiming that the is-a relationship doesn't hold.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸭子类型问题在*选择继承和扩展之间——is-a问题*的示例中是隐含的；如果我们利用鸭子类型，我们也在声称两个类不是同一种东西。当我们绕过继承时，我们隐含地声称is-a关系不成立。
- en: When looking at the *Separating concerns via multiple inheritance* recipe, we're
    also able to leverage duck typing to create composite classes that may not have
    a simple inheritance hierarchy. Since it's very simple to use the mixin design
    pattern, duck typing is rarely needed.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查看*通过多重继承分离关注点*的示例时，我们还可以利用鸭子类型来创建可能没有简单继承层次结构的组合类。由于使用混合设计模式非常简单，很少需要使用鸭子类型。
- en: Managing global and singleton objects
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理全局和单例对象
- en: The Python environment contains a number of implicit global objects. These objects
    provide a convenient way to work with a collection of other objects. Because the
    collection is implicit, we're saved from the annoyance of an explicit initialization
    code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境包含许多隐式全局对象。这些对象提供了一种方便的方式来处理其他对象的集合。由于集合是隐式的，我们不必写任何显式的初始化代码，从而避免了麻烦。
- en: One example of this is an implicit random number generating object that's part
    of the `random` module. When we evaluate `random.random()` , we're actually making
    use of an instance of the `random.Random` class that's an implicit part of the
    `random` module.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是 `random` 模块中的一个隐式随机数生成对象。当我们评估 `random.random()` 时，实际上是在使用 `random`
    模块中隐式的 `random.Random` 类的一个实例。
- en: 'Other examples of this include the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子包括以下内容：
- en: The collection of numeric types available. By default, we only have `int` ,
    `float` , and `complex` . We can, however, add more numeric types, and they will
    work seamlessly with existing types. There's a global registry of available numeric
    types.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的数值类型的集合。默认情况下，我们只有 `int` 、`float` 和 `complex` 。但是，我们可以添加更多的数值类型，并且它们将与现有类型无缝配合。有一个可用数值类型的全局注册表。
- en: The collection of data code/decode methods (codecs) available. The `codecs`
    module lists the available encoders and decoders. This also involves an implicit
    registry. We can add encodings and decodings to this registry.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的数据编码/解码方法（编解码器）的集合。`codecs` 模块列出了可用的编码器和解码器。这也涉及到一个隐式注册。我们可以向这个注册表中添加编码和解码。
- en: The `webbrowser` module has a registry of known browsers. For the most part,
    the operating system default browser is the one preferred by the user and the
    right one to use, but it's possible for an application to launch a browser other
    than the user's preferred browser. It's also possible to register a new browser
    that's unique to an application.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webbrowser` 模块有一个已知浏览器的注册表。在大多数情况下，操作系统默认浏览器是用户首选的浏览器，也是要使用的正确的浏览器，但应用程序也可以启动用户首选浏览器之外的浏览器。还可以注册一个新的浏览器，该浏览器是特定应用程序的唯一浏览器。'
- en: How can we work with this kind of implicit global object?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这种隐式全局对象？
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Generally, an implicit object can cause some confusion. The idea is to provide
    a suite of features as separate functions rather than methods of an object. The
    benefit, however, is to allow independent modules to share a common object without
    having to write any code that explicitly coordinates between the modules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，隐式对象可能会引起一些混淆。想法是提供一套功能作为独立的函数，而不是对象的方法。然而，好处是允许独立的模块共享一个公共对象，而无需编写任何显式协调模块之间的代码。
- en: For a simple example, we'll define a module that will have a global singleton
    object. We'll look more at modules in [Chapter 13](text00137.html#page "Chapter 13. Application
    Integration") ,  *Application integration* .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，我们将定义一个具有全局单例对象的模块。我们将在[第13章](text00137.html#page "第13章 应用集成")中更详细地了解模块，*应用集成*。
- en: Our global object will be a counter that we can use to accumulate centralized
    data from several independent modules or objects. We'll provide an interface to
    this object using simple functions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的全局对象将是一个计数器，我们可以用它来积累来自几个独立模块或对象的集中数据。我们将使用简单的函数来提供对这个对象的接口。
- en: 'The goal is to be able to write something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够编写类似这样的内容：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This implies two functions that will refer to a global counter:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着会有两个函数引用一个全局计数器：
- en: '`count()` : It will increment the counter and return the current value'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`：它将增加计数器并返回当前值'
- en: '`counts()` : It will provide all of the various counter values'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counts()`：它将提供所有不同的计数器值'
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are two ways to do handle global state information. One technique uses
    a module global variable because modules are singleton objects. The other uses
    a class level (static) variable because a class definition is a singleton object,
    also we'll show both techniques.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种处理全局状态信息的方法。一种技术使用模块全局变量，因为模块是单例对象。另一种使用类级（静态）变量，因为类定义也是单例对象，我们将展示这两种技术。
- en: Module global variable
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块全局变量
- en: Create a module file. This will be a `.py` file with the definitions in it.
    We'll call it `counter.py` .
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块文件。这将是一个`.py`文件，其中包含定义。我们将其称为`counter.py`。
- en: 'If necessary, define a class for the global singleton. In our case, we can
    use this definition:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有必要，为全局单例定义一个类。在我们的例子中，我们可以使用这个定义：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In some cases, a `types.SimpleNamespace` might be used. In other cases, a more
    complex class with methods as well as attributes may be necessary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会使用`types.SimpleNamespace`。在其他情况下，可能需要一个更复杂的类，其中包括方法和属性。
- en: 'Define the one and only instance of the global singleton object:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局单例对象的唯一实例：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've used a leading `_` in the name to make it slightly less visible. It's
    not—technically—private. It is, however, gracefully ignored by many Python tools
    and utilities.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名称中使用了一个前导`_`，使其稍微不太可见。它不是——技术上——私有的。然而，它被许多Python工具和实用程序优雅地忽略了。
- en: 'Define any wrapper functions:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义任何包装函数：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We've defined two functions that use the global object, `_global_counter` .
    These functions encapsulate a detail of how the counter is implemented.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个使用全局对象`_global_counter`的函数。这些函数封装了计数器的实现细节。
- en: Now we can write applications that use the `count()` function in a variety of
    places. The counted events, however, are fully centralized into this single object.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写应用程序，在各种地方使用`count()`函数。然而，计数的事件完全集中在这个单一对象中。
- en: 'We might have code that looks like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有这样的代码：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've imported the `count()` and `counts()` functions from a central module.
    We've also imported the `Dice1` object as a handy object that we can use to create
    a sequence of events. When we create an instance of `Dice1` , we provide an initialization
    to force a particular random seed. This gives repeatable results.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个中央模块导入了`count()`和`counts()`函数。我们还导入了`Dice1`对象作为一个方便的对象，我们可以用它来创建一系列事件。当我们创建`Dice1`的一个实例时，我们提供一个初始化来强制使用特定的随机种子。这可以得到可重复的结果。
- en: We can then use the object, `d` , to create random events. For this demonstration,
    we've categorized the events into two simple buckets, labeled `seven` and `other`
    . The `count()` function uses an implied global object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用对象`d`来创建随机事件。在这个演示中，我们将事件分类为两个简单的桶，标记为`seven`和`other`。`count()`函数使用了一个隐含的全局对象。
- en: When the simulation is done, we can dump the results using the `counts()` function.
    This will access the global object defined in the module.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟完成时，我们可以使用`counts()`函数来输出结果。这将访问模块中定义的全局对象。
- en: The benefit of this technique is that several modules can all share the global
    object within the `ch07_r04` module. All that's required is an `import` statement.
    No further coordination or overheads are necessary.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的好处是，几个模块都可以共享`ch07_r04`模块中的全局对象。只需要一个`import`语句。不需要进一步的协调或开销。
- en: Class-level static variable
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类级静态变量
- en: 'Define a class and provide a variable outside the `__init__` method. This variable
    is part of the class, not part of each individual instance. It''s shared by all
    instances of the class:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类并在`__init__`方法之外提供一个变量。这个变量是类的一部分，而不是每个单独实例的一部分。它被所有类的实例共享：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We've given the class-level variable a leading underscore to make it less public.
    This is a note to anyone using the class that the attribute is an implementation
    detail that might change. It's not part of the visible interface to the class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给类级变量加了一个前导下划线，使其不太公开。这是对使用类的任何人的一个提示，该属性是一个可能会改变的实现细节。它不是类的可见接口的一部分。
- en: 'Add methods to update and extract data from this variable:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加方法来更新和提取这个变量的数据：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We didn't use `self` in this example to make a point about variable assignment
    and instance variables. When we use `self.name` on the right side of an assignment
    statement, the name may be resolved by the object, or the class, or any superclass.
    This is the ordinary rule for searching a class.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中没有使用`self`，是为了说明变量赋值和实例变量。当我们在赋值语句的右侧使用`self.name`时，名称可以由对象、类或任何超类解析。这是搜索类的普通规则。
- en: When we use `self.name` on the left side of assignment, that will create an
    instance variable. We must use `Class.name` to be sure that a class-level variable
    is updated instead of creating an instance variable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在赋值语句的左侧使用`self.name`时，那将创建一个实例变量。我们必须使用`Class.name`来确保更新类级变量，而不是创建一个实例变量。
- en: 'The various application components can create objects, but the objects all
    share a common class level value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 各种应用程序组件可以创建对象，但所有对象都共享一个公共类级值：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, we've created three separate objects, `c1` , `c2` , and `c3`
    . Since all three share a common variable, defined in the `EventCounter` class,
    each can be used to increment that shared variable. These objects could be part
    of separate modules, separate classes, or separate functions, yet still share
    a common global state.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了三个单独的对象，`c1`，`c2`和`c3`。由于所有三个对象共享`EventCounter`类中定义的一个公共变量，因此每个对象都可以用于增加该共享变量。这些对象可以是单独的模块、单独的类或单独的函数的一部分，但仍然共享一个共同的全局状态。
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Python import mechanism uses `sys.modules` to track which modules are loaded.
    Once a module is in this mapping, it is not loaded again. This means that any
    variable defined within a module will be a singleton: there will only be one instance.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Python导入机制使用`sys.modules`来跟踪加载了哪些模块。一旦模块在这个映射中，它就不会再次加载。这意味着在模块内定义的任何变量都将是单例：只会有一个实例。
- en: 'We have two ways to share these kinds of global singleton variables:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来共享这些全局单例变量：
- en: Using the module name, explicitly. We could have simply created an instance
    of `Counter` in the module and shared this via `counter.counter` . This can work,
    but it exposes an implementation detail.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式使用模块名称。我们本可以在模块中简单地创建`Counter`的实例，并通过`counter.counter`共享它。这样可以工作，但它暴露了一个实现细节。
- en: Using wrapper functions, as shown in this recipe. This requires a little more
    code, but it permits a change in implementation without breaking other parts of
    the application.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包装函数，如本示例所示。这需要更多的代码，但它允许在不破坏应用程序的其他部分的情况下进行实现的更改。
- en: The functions provide a way to identify relevant features of the global variable,
    while encapsulating details of how it's implemented. This gives us the freedom
    to consider changing the implementation details. As long as the wrapper functions
    have the same semantics, the implementation can be changed freely.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数提供了一种识别全局变量相关特征的方式，同时封装了它的实现细节。这使我们有自由考虑改变实现细节的自由。只要包装函数具有相同的语义，实现就可以自由更改。
- en: Since we generally provide only one definition of a class, the Python import
    mechanism tends to assure us that the class definition is a proper singleton object.
    If we make the mistake of copying a class definition, and pasting it into two
    or more modules used by a single application, we would not share a single global
    object among these class definitions. This is an easy mistake to avoid.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常只提供一个类的定义，Python导入机制倾向于向我们保证类定义是一个正确的单例对象。如果我们错误地复制一个类定义，并将其粘贴到单个应用程序使用的两个或更多模块中，我们将不会在这些类定义之间共享一个全局对象。这是一个容易避免的错误。
- en: How can we choose between these two mechanisms? The choice is based on the degree
    of confusion created by having multiple classes sharing a global state. As shown
    in the previous example, three variables share a common `Counter` object. The
    presence of an implicitly shared global state can be confusing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在这两种机制之间进行选择？选择是基于多个类共享全局状态所造成的混乱程度。如前面的示例所示，三个变量共享一个公共的`Counter`对象。隐式共享全局状态的存在可能会令人困惑。
- en: There's more...
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A shared global state is in a way the opposite of object-oriented programming.
    One ideal of object-oriented programming is to encapsulate all state changes in
    individual objects. When we have a shared global state, we have strayed from this
    ideal:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 共享全局状态在某种程度上与面向对象编程相反。面向对象编程的一个理想是将所有状态变化封装在各个对象中。当我们有一个共享的全局状态时，我们已经偏离了这个理想：
- en: Using wrapper functions makes the shared object implicit
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包装函数使共享对象变得隐式
- en: Using a class-level variable conceals the fact that an object is shared
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类级变量隐藏了对象是共享的事实
- en: The alternative, of course, is to create a global object explicitly, and make
    it part of the application in some more obvious way. This might mean providing
    the object as an initialization parameter to objects throughout the application.
    This can be a fairly large burden in a complex application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，另一种选择是显式地创建一个全局对象，并以一种更明显的方式将其作为应用程序的一部分。这可能意味着将对象作为初始化参数提供给整个应用程序中的对象。在复杂的应用程序中，这可能是一个相当大的负担。
- en: Having a few shared global objects is more appealing because the application
    becomes simpler. When these objects are used for pervasive features such as audits,
    logging, and security, they can be helpful.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一些共享的全局对象更具吸引力，因为应用程序变得更简单。当这些对象用于普遍特性，如审计、日志记录和安全性时，它们可能会有所帮助。
- en: This is a technique that is open for abuse. A design that relies on too many
    global objects can be confusing. It can also harbor subtle bugs because the encapsulation
    of objects in classes may be difficult to discern. It may also make unit test
    cases hard to write because of the implicit relationships among objects.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种容易被滥用的技术。依赖过多全局对象的设计可能会令人困惑。它也可能存在微妙的错误，因为在类中封装对象可能难以辨别。它也可能使单元测试用例难以编写，因为对象之间的隐式关系。
- en: '![](image/614271.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Using more complex structures – maps of lists
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更复杂的结构 - 列表的映射
- en: In [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* , we looked at the
    basic data structures available in Python. The recipes generally looked at the
    various structures in isolation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构 - 列表，集合，字典")中，*内置数据结构 - 列表，集合，字典*，我们看了Python中可用的基本数据结构。这些示例通常独立地查看了各种结构。
- en: We'll look at a common combination structure—the mapping from a key to a list.
    This is used to accumulate detailed information about an object identified by
    a given key. This recipe will transform a flat list of details into a structure
    that for one column contains values taken from other columns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下一个常见的组合结构 - 从一个键到一个列表的映射。这用于累积有关由给定键标识的对象的详细信息。这个示例将把详细信息的平面列表转换成一个结构，其中一个列包含来自其他列的值。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll work with an imaginary web log that's been transformed from the raw web
    format to a **CSV** ( **comma-separated value** ) format. This kind of transformation
    is often done with a regular expression that picks out the various syntactic groups.
    See the *String parsing with regular expressions* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") , *Numbers, Strings, and Tuples* ,
    for information on how the parsing might work.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个虚构的网络日志，它已经从原始网络格式转换为CSV（逗号分隔值）格式。这种转换通常是通过使用正则表达式来选择各种句法组完成的。有关解析可能如何工作的信息，请参阅[第1章](text00014.html#page
    "第1章。数字、字符串和元组")中的*使用正则表达式解析字符串*配方，*数字、字符串和元组*。
- en: 'The raw data looks like the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据看起来像这样：
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Each line in the file has a timestamp, a severity level, a module name, and
    some text. After parsing, the data is effectively a flat list of events. It looks
    like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的每一行都有一个时间戳、一个严重级别、一个模块名称和一些文本。解析后，数据实际上是一个事件的平面列表。它看起来像这样：
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We'd like to examine the log, creating a list of all the messages organized
    by module, instead of sequentially through time. This kind of restructuring can
    make analysis simpler.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要检查日志，创建一个按模块组织的所有消息的列表，而不是按时间顺序。这种重组可以使分析更简单。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'Import `defaultdict` from `collections` :'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`collections`导入`defaultdict`：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the `list` function as the default value for `defaultdict` :'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list`函数作为`defaultdict`的默认值：
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Iterate through the data, appending to the list associated with each key. The
    `defaultdict` object will use the `list()` function to build an empty list for
    each new key:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过数据进行迭代，将其附加到与每个键关联的列表中。`defaultdict`对象将使用`list()`函数为每个新键构建一个空列表：
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result of this will be a dictionary that maps from a module to a list of
    all log rows for that module name. The data will look like the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个从模块到该模块名称的所有日志行的列表的字典。数据看起来像这样：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The key for this mapping is the module name and the value in the mapping is
    the list of rows for that module name. We can now focus the analysis on a specific
    module.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 该映射的键是模块名称，映射中的值是该模块名称的行列表。现在我们可以专注于特定模块的分析。
- en: How it works...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There are two choices for how a mapping behaves when a key is not found:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当键未找到时，映射的行为有两种选择：
- en: The built-in `dict` class raises an exception when a key is missing.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`dict`类在键丢失时会引发异常。
- en: The class `defaultdict` evaluates a function that creates a default value when
    a key is missing. In many cases, the function is `int` or `float` to create a
    default numeric value. In this case, the function is `list` to create an empty
    list.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`类在键丢失时会评估一个创建默认值的函数。在许多情况下，该函数是`int`或`float`，用于创建默认的数值。在这种情况下，该函数是`list`，用于创建一个空列表。'
- en: We can imagine using the `set` function to create an empty `set` object for
    a missing key. This would be suitable for a mapping from a key to a set of objects
    that share that key.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象使用`set`函数为缺少的键创建一个空的`set`对象。这适用于从键到共享该键的对象集的映射。
- en: There's more...
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When we think about Python 3.5 and the ability to do type inferencing, we need
    to have a way to describe this structure:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑Python 3.5和进行类型推断的能力时，我们需要有一种描述这种结构的方法：
- en: '[PRE46]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This uses the notation `Mapping[str, List]` to show that the result is a mapping
    from string keys to a list of string data items.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用符号`Mapping[str, List]`来显示结果是从字符串键到字符串数据项列表的映射。
- en: 'We can also build a version of this as an extension to the built-in `dict`
    class:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以构建一个作为内置`dict`类的扩展版本：
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We've defined a method that's unique to this class, `add_event()` . This will
    add the empty list if the key, the module name in `event[2]` , is not currently
    present in the dictionary. After the `if` statement, a postcondition could be
    added to assert that the key is now in the dictionary.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个对这个类独有的方法`add_event()`。如果字典中当前不存在`event[2]`中的模块名称的键，则将添加空列表。在`if`语句之后，可以添加一个后置条件来断言该键现在在字典中。
- en: 'This allows us to use code such as the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用以下代码：
- en: '[PRE48]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The resulting structure is very similar to `defaultdict` .
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 结果结构与`defaultdict`非常相似。
- en: See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Creating dictionaries – inserting and updating* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structure
    – list, set, dict* , we looked at the basics of using a mapping
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构 - 列表、集合、字典")的*创建字典 - 插入和更新*配方中，我们看到了使用映射的基础知识
- en: In the *Avoiding mutable default values for function parameters* recipe of [Chapter
    4](text00048.html#page "Chapter 4. Built-in Data Structures – list, set, dict")
    , *Built-in Data Structure – list, set, dict* , we looked at other places where
    default values are used
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构 - 列表、集合、字典")的*避免函数参数的可变默认值*配方中，我们看到了其他使用默认值的地方
- en: In the *Using more sophisticated collections* recipe of [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , we looked at other examples of using the `defaultdict` class
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](text00070.html#page "第6章。类和对象的基础知识")的*使用更复杂的集合*配方中，我们看到了使用`defaultdict`类的其他示例
- en: Creating a class that has orderable objects
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个具有可排序对象的类
- en: When simulating card games, it's often essential to be able to sort the `Card`
    objects into a defined order. When cards form a sequence, sometimes called a straight,
    this can be an important way to score the hand. This is part of games such as
    Poker, Cribbage, and even Pinochle.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟纸牌游戏时，能够将`Card`对象排序到一个定义的顺序中通常是至关重要的。当卡片形成一个序列时，有时被称为顺子，这可能是评分手的重要方式。这是类似扑克牌、Cribbage甚至Pinochle的游戏的一部分。
- en: Most of our class definitions have not included the features necessary for sorting
    objects into order. Many of the recipes have kept objects in mappings or sets
    based on the internal hash value computed by `__hash__()` .
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数类定义都没有包括对将对象排序的必要特征。许多示例都将对象保留在基于`__hash__()`计算的内部哈希值的映射或集合中。
- en: In order to keep items in a sorted collection, we'll need the comparison methods
    that implement `<` , `>` , `<=` , `>=` , `==` , and `!=` . These comparisons are
    based on the attribute values of each object.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将项目保留在有序集合中，我们需要实现`<`、`>`、`<=`、`>=`、`==`和`!=`的比较方法。这些比较是基于每个对象的属性值。
- en: How do we create comparable objects?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建可比较的对象？
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The game of Pinochle generally involves a deck with 48 cards. There are six
    ranks—9, 10, Jack, Queen, King, and Ace. There are the standard four suits. Each
    of these 24 cards appears twice in the deck. We have to be careful of using a
    structure such as a dict or set because cards are not unique in Pinochle; there
    can be duplicates.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Pinochle游戏通常涉及一副有48张牌的牌组。有六个等级——9、10、J、Q、K和A。有标准的四种花色。这24张牌中的每一张在牌组中都出现两次。我们必须小心使用诸如dict或set之类的结构，因为在Pinochle中卡片并不是唯一的；可能会有重复。
- en: In the *Separating concerns via multiple inheritance* recipe, we defined playing
    cards using two class definitions. The `Card` class hierarchy defined essential
    features of each card. A second set of mixin classes provided game specific features
    for each card.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在*通过多重继承分离关注点*的示例中，我们使用了两个类定义来定义纸牌。`Card`类层次结构定义了每张牌的基本特征。第二组混合类为每张牌提供了特定于游戏的特征。
- en: We'll need to add features to those cards to create objects that can be ordered
    properly. In order to support the *Defining an ordered collection* recipe, we'll
    look at cards for the game of Pinochle.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这些牌添加特征，以创建可以正确排序的对象。为了支持*定义有序集合*的示例，我们将研究Pinochle游戏的牌。
- en: 'Here are the first two elements of the design:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设计的前两个元素：
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We've imported the existing `Card` hierarchy. We've also defined a rule for
    computing the points for each card taken in a trick during play, the `PinochlePoints`
    class. This has a mapping from card ranks to the potentially confusing points
    for each card.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了现有的`Card`层次结构。我们还定义了在玩牌过程中计算每张牌得分的规则，`PinochlePoints`类。这个类有一个从卡片等级到每张卡片可能令人困惑的点数的映射。
- en: A 10 is worth 10 points, and an Ace is worth 11 points, but the King, Jack,
    and Queen are worth four, three, and two points respectively. This can be confusing
    for new players.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 10点值10分，A值11分，但K、J和Q分别值4、3和2分。这可能会让新玩家感到困惑。
- en: Because an Ace ranks above a King for purposes of identifying a straight, we've
    made the rank of the Ace 14\. This slightly simplifies the processing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因为A的排名在识别顺子的目的上高于K，所以我们将A的排名设为14。这在一定程度上简化了处理过程。
- en: In order to use a sorted collection of cards, we need to add yet another feature
    to the cards. We'll need to define the comparison operations. There are six special
    methods used for object comparison.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用有序的卡片集合，我们需要为卡片添加另一个特征。我们需要定义比较操作。用于对象比较的有六个特殊方法。
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''re using a mixin design. Therefore, we''ll create a new class to hold the
    comparison features:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用混合设计。因此，我们将创建一个新的类来保存比较特征：
- en: '[PRE50]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This class will join a member of the `Card` hierarchy plus the `PinochlePoints`
    to create the final composite class definition.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将加入`Card`层次结构的成员加上`PinochlePoints`，以创建最终的复合类定义。
- en: 'Define the six comparison methods:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义六个比较方法：
- en: '[PRE51]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We've written all six comparisons out in full. We've converted the relevant
    attributes of a `Card` into a tuple, and relied on Python's built-in tuple comparison
    to handle the details.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完整地写出了所有六个比较。我们将`Card`的相关属性转换为元组，并依赖于Python的内置元组比较来处理细节。
- en: 'Write the composite class definitions, built from an essential class and two
    mixin classes to provide additional features:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写复合类定义，由一个基本类和两个混合类构建以提供额外特征：
- en: '[PRE52]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The final class contains elements with three separate, and largely independent
    feature sets: the essential `Card` features, the mixin comparison features, and
    the mixin Pinochle specific features.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的类包含具有三个独立且大部分独立的特征集的元素：基本的`Card`特征，混合比较特征和混合Pinochle特定特征。
- en: 'Create a function that will create individual card objects from the classes
    defined previously:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，从先前定义的类中创建单独的卡片对象：
- en: '[PRE53]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Even though the point rules are dauntingly complex, the complexity is hidden
    in the `PinochlePoints` class. Building composite classes as a base subclass of
    `Card` plus `PinochlePoints` leads to an accurate model of the cards without too
    much overt complexity.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管点数规则非常复杂，但复杂性隐藏在`PinochlePoints`类中。构建复合类作为`Card`和`PinochlePoints`的基类子类会导致对牌的准确建模，而不会有太多明显的复杂性。
- en: 'We can now make cards that respond to comparison operators:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以制作可以响应比较运算符的卡片：
- en: '[PRE54]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here''s a function that builds the 48-card deck:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个构建48张牌的牌组的函数：
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The value of `SUITS` is four Unicode characters. We could have set each suit
    string separately, but this seems slightly simpler. The generator expression inside
    the `make_deck()` function builds two copies of each card. There are only six
    ranks and four suits.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUITS`的值是四个Unicode字符。我们本可以分别设置每个花色字符串，但这样似乎稍微简单一些。`make_deck()`函数内部的生成器表达式构建了每张牌的两份副本。只有六种等级和四种花色。'
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Python uses special methods for a vast number of things. Almost every visible
    behavior in the language is due to some special method name. In this recipe, we've
    leveraged the six comparison operators.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Python为大量的事情使用特殊方法。语言中几乎每个可见的行为都归因于某些特殊方法名称。在这个示例中，我们利用了六个比较运算符。
- en: 'Write the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 写下以下内容：
- en: '[PRE56]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code is evaluated as if we''d written the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码被评估为我们写了以下内容：
- en: '[PRE57]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This kind of transformation happens for all of the expression operators.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换适用于所有表达式运算符。
- en: 'Careful study of *Section 3.3* of the *Python Language Reference* shows that
    the special methods can be organized into several distinct groups:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究*Python语言参考*的*第3.3节*表明，特殊方法可以组织成几个不同的组：
- en: Basic customization
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本定制
- en: Customizing attribute access
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性访问
- en: Customizing class creation
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类创建
- en: Customizing instance and subclass checks
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义实例和子类检查
- en: Emulating callable objects
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟可调用对象
- en: Emulating container types
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟容器类型
- en: Emulating numeric types
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟数值类型
- en: With statement context managers
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语句上下文管理器
- en: In this recipe, we've looked at only the first of these categories. The others
    follow some similar design patterns.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只看了这些类别中的第一个。其他的遵循一些类似的设计模式。
- en: 'Here''s how it looks when we create instances of this class hierarchy. The
    first example will create a 48-card Pinochle deck:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建这个类层次结构的实例时，它看起来是这样的。第一个例子将创建一个48张牌的Pinochle牌组：
- en: '[PRE58]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we look at the first eight cards, we can see how they''re built from all
    the combinations of rank and suit:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前八张牌，我们可以看到它们是如何由所有等级和花色的组合构建而成的：
- en: '[PRE59]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we look at the second half of the deck, we can see that it has the same
    cards as the first half of the deck:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下牌组的后半部分，我们会发现它与牌组的前半部分是一样的：
- en: '[PRE60]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Since the `deck` variable is a simple list, we can shuffle the list object and
    pick a dozen cards.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`deck`变量是一个简单的列表，我们可以打乱列表对象并选择十二张牌。
- en: '[PRE61]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The important part is the use of the `sorted()` function. Because we've defined
    proper comparison operators, we can sort the `Card` instances, and they are presented
    in the expected order.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的部分是使用`sorted()`函数。因为我们已经定义了适当的比较运算符，我们可以对`Card`实例进行排序，并按预期顺序呈现。
- en: There's more...
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A little formal logic suggests that we really only need to implement two of
    the comparisons. With any two, all the others can be derived. For example, if
    we could only do the operations for less than (`__lt__()` ) and equal to (`__eq__()`
    ), we could compute the missing three fairly easily:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一点形式逻辑表明，我们实际上只需要实现两种比较。对于任何两个，其他所有的都可以推导出来。例如，如果我们只能执行小于(`__lt__()` )和等于(`__eq__()`
    )的操作，我们可以相当容易地计算出其余的三个：
- en: '*a* ≤ *b* ≡ *a < b* ∨ *a* = *b*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* ≤ *b* ≡ *a < b* ∨ *a* = *b*'
- en: '*a* ≥ *b* ≡ *a > b* ∨ *a* = *b*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* ≥ *b* ≡ *a > b* ∨ *a* = *b*'
- en: '*a* ≠ *b* ≡ ¬( *a* = *b* )'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* ≠ *b* ≡ ¬(*a* = *b*)'
- en: Python emphatically does not do any of this kind of advanced algebra for us.
    We need to do the algebra carefully, or if we're unsure of the logic, we can write
    out all six comparisons in full.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Python明确不会为我们执行任何这种高级代数。我们需要仔细进行代数运算，或者如果我们对逻辑不确定，可以完整地写出所有六个比较。
- en: 'We''ve assumed that each `Card` is compared against another card. Try this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设每个`Card`都与另一张卡进行比较。试试这个：
- en: '[PRE62]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We'll get an `AttributeError` exception.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个`AttributeError`异常。
- en: 'If we need this feature, we''ll have to modify the comparison operators to
    handle two kinds of comparison:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要这个功能，我们将不得不修改比较运算符来处理两种比较：
- en: '`Card` against `Card`'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Card`对`Card`'
- en: '`Card` against `int`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Card`对`int`'
- en: This is done by using the `isinstance()` function to discriminate between the
    argument types.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`isinstance()`函数来区分参数类型来完成的。
- en: 'Each of our comparison methods would be changed to look like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个比较方法将被更改为这样：
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This handles the `Card` against the `Card` case using rank and suit comparisons.
    For all other cases, Python's ordinary rules are used to compare the rank against
    the other value. If, for some obscure reason, the value of the other was `float`
    , then a `float()` conversion would be used on `self.rank` .
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了`Card`与`Card`之间的情况，使用等级和花色进行比较。对于所有其他情况，Python使用普通的规则来将等级与其他值进行比较。如果由于某种隐晦的原因，另一个值是`float`，那么将在`self.rank`上使用`float()`转换。
- en: See also
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Defining an ordered collection* recipe that relies on sorting these
    cards into order
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看依赖于对这些卡进行排序的*定义有序集合*配方
- en: Defining an ordered collection
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个有序集合
- en: When simulating card games, the player's hand can be modeled as a set of cards
    or a list of cards. With most conventional single-deck games, a set works out
    nicely because there's only one instance of any given card, and the set class
    can do very fast operations to confirm that a given card is (or is not) in the
    set.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟纸牌游戏时，玩家的手可以被建模为一组牌或一叠牌。对于大多数传统的单副牌游戏，集合是很好的选择，因为任何给定的牌只有一个实例，并且集合类可以非常快速地执行操作来确认给定的牌是否在集合中（或不在）。
- en: When modeling Pinochle, however, we have a challenging problem. The Pinochle
    deck is 48 cards; it has two of 9, 10, Jack, Queen, King, and Ace. A simple set
    won't work well for this; we would need a multiset or bag. This is a set that
    permits duplicate items.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在建模Pinochle时，我们面临一个具有挑战性的问题。Pinochle牌组有48张牌；它有两张9、10、J、Q、K和A。简单的集合对于这个不太适用；我们需要一个多重集或袋子。这是一个允许重复项的集合。
- en: The operations are still limited to membership tests. For example, we can add
    the object `Card(9,'♢')` object more than once, and then also remove it more than
    one time.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作仍然仅限于成员测试。例如，我们可以多次添加对象`Card(9,'♢')`对象，然后多次删除它。
- en: 'We have a number of ways to create a multiset:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种方法来创建多重集：
- en: We can use a list. Appending an item has a nearly fixed cost, characterized
    as *O* (1). Searching for an item has a bad performance problem. The complexity
    of testing for membership tends to grow with the size of the collection. It becomes
    *O* (n).
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用列表。添加一个项目几乎是固定成本，被描述为*O*(1)。搜索项目的性能有严重问题。测试成员资格的复杂性往往随着集合大小的增长而增长。它变成了*O*(n)。
- en: 'We can use a mapping; the value can be an integer count of the number of times
    a duplicated element shows up. This only requires that the default `__hash__()`
    method is available for each object in the mapping. We have three ways of implementing
    this:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用映射；值可以是重复元素出现的整数计数。这只需要映射中每个对象都有默认的`__hash__()`方法。我们有三种实现这种方法的方式：
- en: Define our own subclass of dict.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们自己的dict子类。
- en: Use a `defaultdict` . See the *Using more complex structures - maps of lists*
    recipe, which uses `defaultdict(list)` to create a list of values for each key.
    The `len()` of this list is the number of times the key occurred. In effect, this
    is a kind of multiset.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`defaultdict`。请参阅*使用更复杂的结构-列表映射*示例，该示例使用`defaultdict(list)`为每个键创建一个值列表。该列表的`len()`是键出现的次数。实际上，这是一种多重集。
- en: Use a `Counter` . This can be very simple. We've looked at `Counter` in a number
    of recipes. See the *Avoiding mutable default values for function parameters*
    recipe in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* , also the
    *Designing classes with lots of processing* and *Using properties for lazy attributes*
    recipes in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , and the *Managing global and singleton objects*
    recipe of this chapter for other examples.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Counter`。这可以非常简单。我们已经在许多示例中看过`Counter`。请参阅[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中的*避免函数参数的可变默认值*，*内置数据结构-列表、集合、字典*，以及[第6章](text00070.html#page
    "第6章。类和对象的基础知识")中的*设计具有大量处理的类*和*使用属性进行惰性属性*，*类和对象的基础知识*，以及本章的*管理全局和单例对象*示例。
- en: We can use a sorted list. Inserting an item that maintains this sort sequence
    is slightly more expensive than inserting into a list, ***O*** ( *n* log *[2]
    n* ). Searching, however, is less expensive than an unsorted list; it's ***O***
    (log *[2] n* ). The `bisect` module provides a set of functions that do this nicely.
    This, however, requires objects with a full set of comparison methods.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用有序列表。插入维护此排序顺序的项目比插入列表稍微昂贵，***O*** ( *n* log *[2] n* )。然而，搜索比无序列表便宜;它是***O***
    (log *[2] n* )。`bisect`模块提供了一组很好地执行此操作的函数。然而，这需要具有完整比较方法集的对象。
- en: How can we build a sorted collection of objects? How can we build a multiset
    or bag using a sorted collection?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何构建一个有序对象的有序集合？如何使用有序集合构建多重集或袋？
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In the *Creating a class that has orderable objects* recipe, we defined cards
    that could be sorted. This is essential for using `bisect` . The algorithms in
    this module require a full set of comparisons among objects.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建具有可排序对象的类*示例中，我们定义了可以排序的卡片。这对于使用`bisect`至关重要。该模块中的算法要求对象之间进行全面的比较。
- en: We'll define a multiset to keep 12-card Pinochle hands. Because of the duplication,
    there will be more than one card of a given rank and suit.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个多重集，以保留12张Pinochle手牌。由于重复，同一等级和花色的卡片将会有多张。
- en: In order to view a hand as a kind of set, we'll also need to define some set
    operators on hand objects. The idea is to define set membership and subset operators.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将手牌视为一种集合，我们还需要在手牌对象上定义一些集合运算符。其思想是定义集合成员和子集运算符。
- en: 'We''d like to have Python code that''s equivalent to the following:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有Python代码等效于以下内容：
- en: '*c* ∈ *H*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* ∈ *H*'
- en: This is for a card, *c* , and a hand of cards, *H* = { *c* [1] *, c* [2] *,
    c* [3] *,...* }
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对一张卡片*c*和一手牌*H*={ *c* [1] *, c* [2] *, c* [3] *,...* }。
- en: 'We''d also like code equivalent to this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望有与此等效的代码：
- en: '{ *J, Q* } ⊂ *H*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '{ *J, Q* } ⊂ *H*'
- en: This is for a specific pair of cards, called the Pinochle, and a hand of cards,
    *H* .
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对一对特定的卡片，称为Pinochle，以及一手牌，*H*。
- en: 'We''ll need to import two things:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入两样东西：
- en: '[PRE64]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first import brings in our orderable card definitions from the *Creating
    a class that has orderable objects* recipe. The second import brings in the various
    bisect functions that we'll use to maintain an ordered set with duplicates.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个导入将我们可排序的卡片定义从*创建具有可排序对象的类*示例中引入。第二个导入将我们将用来维护一个有序集合的各种bisect函数引入。
- en: How to do it...
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define a class with an initialization that can load the collection from any
    iterable source of data:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类，其中初始化可以从任何可迭代的数据源加载集合：
- en: '[PRE65]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We can use this to build a `Hand` from a list or possibly a generator expression.
    If the list is non-empty, we'll need to sort the items into order. The `sort()`
    method of the `self.cards` list will rely on the various comparison operators
    implemented by the `Card` objects.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个从列表或可能是生成器表达式构建一个`Hand`。如果列表不为空，我们需要将项目排序。`self.cards`列表的`sort()`方法将依赖于`Card`对象实现的各种比较运算符。
- en: Technically, we only care about objects that are subclasses of `SortedCard`
    , since that is where the comparison methods are defined.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们只关心那些是`SortedCard`的子类的对象，因为这是定义比较方法的地方。
- en: 'Define a method to add cards to a hand:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个将卡片添加到手牌的方法：
- en: '[PRE66]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We've used the `bisect` algorithm to assure that the card is properly inserted
    into the `self.cards` list.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`bisect`算法来确保卡片被正确插入到`self.cards`列表中。
- en: 'Define a method to find the position of a given card in a hand:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个查找给定卡片在手牌中位置的方法：
- en: '[PRE67]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We've used the `bisect` algorithm for locating a given card. The additional
    `if` test is recommended in the documentation for `bisect.bisect_left()` to properly
    handle an edge case in the processing.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`bisect`算法来定位给定的卡片。建议在`bisect.bisect_left()`的文档中使用额外的`if`测试来正确处理处理中的边缘情况。
- en: 'Define the special method that implements the `in` operator:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义实现`in`运算符的特殊方法：
- en: '[PRE68]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we write `card in some_hand` in Python, it's evaluated as if we had written
    `some_hand.__contains__(card)` . We've used the `index()` method to either find
    the card or raise an exception. The exception is transformed into a return value
    of `False` .
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Python中编写`card in some_hand`时，它会被计算为如果我们编写了`some_hand.__contains__(card)`。我们使用`index()`方法来查找卡片或引发异常。异常被转换为`False`的返回值。
- en: 'Define an iterator over the hand. This is a simple delegation to the `self.cards`
    collection:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义手牌上的迭代器。这只是对`self.cards`集合的简单委托：
- en: '[PRE69]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: When we write `iter(some_hand)` in Python, it's evaluated as if we had written
    `some_hand.__iter__()` .
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Python中编写`iter(some_hand)`时，它会被计算为如果我们编写了`some_hand.__iter__()`。
- en: 'Define a subset operation between two hand instances:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个手实例之间定义一个子集操作：
- en: '[PRE70]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Python doesn't have the *a* ⊂ *b* or *a* ⊆ *b* symbols, so < and <= are pressed
    into service for comparing sets. When we write `pinochle <= some_hand` to see
    if the hand contains a specific combination of cards, it's evaluated as if we'd
    written `pinochle.__le__(some_hand)` . The subset is the `self` instance variable,
    and the target `Hand` is the other parameter value.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有*a*⊂*b*或*a*⊆*b*符号，因此<和<=被用来比较集合。当我们写`pinochle <= some_hand`来查看手中是否包含特定的卡片组合时，它被评估为如果我们写了`pinochle.__le__(some_hand)`。子集是self实例变量，目标Hand是另一个参数值。
- en: The in operator is implemented by the `__contains__()` method. This shows how
    the simple Python syntax is implemented by the special methods.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: in运算符由__contains__()方法实现。这显示了简单的Python语法是如何由特殊方法实现的。
- en: 'We can use this `Hand` class like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用这个Hand类：
- en: '[PRE71]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The cards are properly sorted in the hand. This is a consequence of the way
    the hand was created.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片在手中被正确排序。这是手的创建方式的结果。
- en: 'Here''s an example of using the subset operator, `<=` , to compare a specific
    pattern to the hand as a whole:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用子集运算符`<=`将特定模式与整个手进行比较的示例：
- en: '[PRE72]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A `Hand` is a collection, and supports iteration. We can use generator expressions
    that reference the `Card` objects within the overall `Hand` :'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 手是一个集合，并支持迭代。我们可以使用引用整个手中的卡对象的生成器表达式：
- en: '[PRE73]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our `Hand` collection works by wrapping an internal `list` object and applying
    an important constraint to that object. The items are kept in sorted order. This
    increases the cost to insert a new item, but reduces the cost to search for an
    item.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Hand集合通过包装内部的list对象并对该对象应用重要的约束来工作。项目按排序顺序保留。这增加了插入新项目的成本，但减少了搜索项目的成本。
- en: The core algorithms for locating the position for an item are part of the `bisect`
    module, saving us from having to write (and debug) them. The algorithms aren't
    really very complex. But it seems more efficient to leverage existing code.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 用于查找项目位置的核心算法是`bisect`模块的一部分，这样我们就不必编写（和调试）它们。这些算法实际上并不是非常复杂。但利用现有代码似乎更有效。
- en: 'The module''s name comes from the idea of bisecting the sorted list to look
    for an item. The essence is this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的名称来自于对排序列表进行二分查找的想法。其本质是：
- en: '[PRE74]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This searches a list, `a` , for a given value, `x` . The value of `lo` is initially
    zero and the value of `hi` is initially the size of the list, `len(a)` .
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这将搜索列表`a`以查找给定值`x`。`lo`的值最初为零，`hi`的值最初为列表的大小`len(a)`。
- en: 'First, the midpoint is identified. If the target value, `x` , is less than
    the midpoint value, `a[mid]` , then it must be in the first half of the list:
    the value of `hi` is shifted so that only the first half is considered.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确定中点。如果目标值`x`小于中点值`a[mid]`，那么它必须在列表的前半部分：将`hi`的值移动，以便只考虑前半部分。
- en: 'If the target value, `x` , is greater than or equal to the midpoint value,
    `a[mid]` , then `x` must be in the second half of the list: the value of `lo`
    is shifted so that only the second half is considered.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标值`x`大于或等于中点值`a[mid]`，那么`x`必须在列表的后半部分：将`lo`的值移动，以便只考虑后半部分。
- en: Since the list is chopped in half at each operation, it requires *O* (log *[2]
    n* ) steps to have the values of `lo` and `hi` converge on the position that should
    have the target value.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次操作都会将列表减半，因此需要*O*(log*[2]n*)步才能使lo和hi的值收敛到应该具有目标值的位置。
- en: If we have a hand with 12 cards, then the first comparison discards six. The
    next comparison discards three more. The next comparison discards one of the final
    three. The fourth comparison will locate the position the card should occupy.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个有12张卡的手，那么第一个比较会丢弃六张。下一个比较会再丢弃三张。下一个比较会丢弃最后三张中的一张。第四个比较将找到卡片应该占据的位置。
- en: If we use an ordinary list, with cards stored in the random order of arrival,
    then finding a card will take an average of six comparisons. The worst possible
    case means it's the last of 12 cards, requiring all 12 to be examined.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用普通列表，卡片按到达的随机顺序存储，那么找到一张卡片将平均需要六次比较。最坏的情况意味着它是12张卡片中的最后一张，需要检查所有12张。
- en: With `bisect` the number of comparisons is always *O* (log *[2] n* ). That's
    the average as well as the worst case.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bisect`，比较的次数始终是*O*(log*[2]n*)。这是平均值和最坏情况。
- en: There's more...
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `collections.abc` module defines abstract base classes for various collections.
    If we want our `Hand` to behave more like other kinds of sets, we can leverage
    these definitions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc`模块为各种集合定义了抽象基类。如果我们希望我们的Hand表现得更像其他类型的集合，我们可以利用这些定义。'
- en: We can add numerous set operators to this class definition to make it behave
    more like the built-in `MutableSet` abstract class definition.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个类定义中添加许多集合运算符，使其更像内置的`MutableSet`抽象类定义。
- en: 'A `MutableSet` is an extension to `Set` . The `Set` class is a composite built
    from three class definitions: `Sized` , `Iterable` , and `Container` . This means
    that it must define the following methods:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableSet`是`Set`的扩展。`Set`类是由三个类定义构建的复合类：`Sized`，`Iterable`和`Container`。这意味着它必须定义以下方法：'
- en: '`__contains__()`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__contains__()`'
- en: '`__iter__()`'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iter__()`'
- en: '`__len__()`'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__len__()`'
- en: '`add()`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: add()
- en: '`discard()`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard()`'
- en: 'We''ll also need to provide some other methods that are part of being a mutable
    set:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供一些其他作为可变集合的方法：
- en: '`clear()` , `pop()` : These will remove items from the set.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`，`pop()`：这些将从集合中删除项目。'
- en: '`remove()` : Unlike `discard()` , this will raise an exception when attempting
    to remove a missing item.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`：与`discard()`不同，当尝试删除缺失的项目时，这将引发异常。'
- en: 'In order to have unique set-like features, it also needs a number of additional
    methods. We provided an example of a subset, based on `__le__()` . We also need
    to provide the following subset comparisons:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 为了具有唯一的集合特性，还需要一些额外的方法。我们提供了一个基于__le__()的子集的示例。我们还需要提供以下子集比较：
- en: '`__le__()`'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__le__()`'
- en: '`__lt__()`'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__lt__()`'
- en: '`__eq__()`'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__eq__()`'
- en: '`__ne__()`'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ne__()`'
- en: '`__gt__()`'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__gt__()`'
- en: '`__ge__()`'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ge__()`'
- en: '`isdisjoint()`'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isdisjoint()`'
- en: These are generally not trivial one-line definitions. In order to implement
    the core set of comparisons, we'll often write two and then use logic to build
    the remainder based on those two.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常不是简单的一行定义。为了实现核心比较集，我们经常会写两个，然后使用逻辑来基于这两个构建其余部分。
- en: 'Since `__eq__()` is simple, let''s assume we have definitions for the `==`
    and `<=` operators. The others would be defined as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`__eq__()`很简单，让我们假设我们已经为`==`和`<=`运算符定义了定义。其他的将定义如下：
- en: '*x* ≠ *y* ≡ ¬( *x* = *y* )'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* ≠ *y* ≡ ¬( *x* = *y* )'
- en: '*x* < *y* ≡ ( *x* ≤ *y* ) ∧ ¬( *x* = *y* )'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* < *y* ≡ ( *x* ≤ *y* ) ∧ ¬( *x* = *y* )'
- en: '*x* > *y* ≡ ¬( *x* ≤ *y* )'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* > *y* ≡ ¬( *x* ≤ *y* )'
- en: '*x* ≥ *y* ≡ ¬( *x* < *y* ) ≡ ¬( *x* ≤ *y* ) ∨ ( *x* = *y* )'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* ≥ *y* ≡ ¬( *x* < *y* ) ≡ ¬( *x* ≤ *y* ) ∨ ( *x* = *y* )'
- en: 'In order to do set operations, we''ll need to provide the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行集合操作，我们需要提供以下内容：
- en: '`__and__()` and `__iand__()` . These methods implement the Python `&` operator
    and the `&=` assignment statement. Between two sets, this is a set intersection,
    or *a* ∩ *b* .'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__and__()`和`__iand__()`。这些方法实现了Python的`&`运算符和`&=`赋值语句。在两个集合之间，这是一个集合的交集，或者*a*
    ∩ *b*。'
- en: '`__or__()` and `__ior__()` . These methods implement the Python `|` operator
    and the `|=` assignment statement. Between two sets, this is a set union, or *a*
    ∪ *b* .'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__or__()`和`__ior__()`。这些方法实现了Python的`|`运算符和`|=`赋值语句。在两个集合之间，这是一个集合的并集，或者*a*
    ∪ *b*。'
- en: '`__sub__()` and `__isub__()` . These methods implement the Python `-` operator
    and the `-=` assignment statement. Between sets, this is a set difference, often
    written as *a* - *b* .'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__sub__()`和`__isub__()`。这些方法实现了Python的`-`运算符和`-=`赋值语句。在集合之间，这是一个集合的差，通常写作*a*
    - *b*。'
- en: '`__xor__()` and `__ixor__()` . These methods implement the Python `^` operator
    and the `^=` assignment statement. When applied between two sets, this is the
    symmetric difference, often written as *a* ∆ *b* .'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__xor__()`和`__ixor__()`。这些方法实现了Python的`^`运算符和`^=`赋值语句。当应用于两个集合之间时，这是对称差，通常写作*a*
    ∆ *b*。'
- en: 'The abstract class permits two versions of each operator. There are two cases:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类允许每个运算符有两个版本。有两种情况：
- en: If we provide `__iand__()` , for example, then the statement `A &= B` will be
    evaluated as `A.__iand__(B)` . This might permit an efficient implementation.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们提供了`__iand__()`，那么语句`A &= B`将被计算为`A.__iand__(B)`。这可能会允许有效的实现。
- en: If we do not provide `__iand__()` , then the statement `A &= B` will be evaluated
    as `A = A.__and__(B)` . This might be somewhat less efficient because we'll create
    a new object. The new object is given the label `A` , and the old object will
    be removed from memory.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不提供`__iand__()`，那么语句`A &= B`将被计算为`A = A.__and__(B)`。这可能会有点不太高效，因为我们将创建一个新对象。新对象被标记为`A`，旧对象将从内存中删除。
- en: There are almost two dozen methods that would be required to provide a proper
    replacement for the built-in set class. On one the hand, it's a lot of code. On
    the other hand, Python lets us extend the built-in classes in a way that's transparent
    and uses the same operators with the same semantics.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎需要两打方法来为内置的集合类提供适当的替代。一方面，这是大量的代码。另一方面，Python让我们以透明的方式扩展内置类，并使用相同的语义和操作符。
- en: See also
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Creating a class that has orderable objects* recipe for the companion
    recipe that defines Pinochle cards
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*创建一个具有可排序对象的类*配方，以获取定义Pinochle卡的伴侣配方
- en: Deleting from a list of mappings
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从映射列表中删除
- en: 'Removing items from a list has an interesting consequence. Specifically, when
    item `list[x]` is removed, one of two other things will happen:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中删除项目会产生有趣的后果。具体来说，当删除项目`list[x]`时，将会发生以下两种情况之一：
- en: Item `list[x+1]` takes the place of `list[x]`
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目`list[x+1]`取代了`list[x]`
- en: Item `x+1 == len(list)` takes the place of `list[x]` because `x` was the last
    index in the list
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目`x+1 == len(list)`取代了`list[x]`，因为`x`是列表中的最后一个索引
- en: These are side-effects that happen in addition to removing an item. Because
    things can move around in a list, it makes deleting more than one item at a time
    challenging.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是除了删除项目之外发生的副作用。因为列表中的项目可能会移动，所以一次删除多个项目变得更具挑战性。
- en: When the list contains items that have a definition for the `__eq__()` special
    method, then the list `remove()` method can remove each item. When the list items
    don't have a simple `__eq__()` test, then it becomes more challenging to remove
    multiple items from the list.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表包含具有`__eq__()`特殊方法定义的项目时，列表`remove()`方法可以删除每个项目。当列表项没有简单的`__eq__()`测试时，从列表中删除多个项目就变得更具挑战性。
- en: How can we delete multiple items from a list?
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从列表中删除多个项目？
- en: Getting ready
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll work with a list-of-dict structure. In this case, we''ve got some data
    that includes a song name, the writers, and a duration. The data looks like this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个字典列表结构。在这种情况下，我们有一些包括歌曲名称、作者和持续时间的数据。数据看起来像这样：
- en: '[PRE75]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To work with this kind of data structure, we''ll need the `pprint` function:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种数据结构，我们需要`pprint`函数：
- en: '[PRE76]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can easily traverse the list of values with the `for` statement. The problem
    is, how do we delete selected items?
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用`for`语句遍历值列表。问题是，我们如何删除选定的项目？
- en: '[PRE77]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can't simply use the statement `del item` here, because it has no effect
    on the source collection, `data` . This statement would only delete the local
    variable copy of the item in the original list by deleting the `item` variable
    and the associated object.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地在这里使用语句`del item`，因为它对源集合`data`没有影响。这个语句只会通过删除`item`变量和相关对象来删除原始列表中项目的本地变量副本。
- en: 'To properly delete items from a list, we must work with index positions in
    the list. Here''s a naïve approach that emphatically does not work:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地从列表中删除项目，我们必须使用列表中的索引位置。这是一个天真的方法，绝对行不通：
- en: '[PRE78]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can't simply use `range(len(data))` based on the original size of the list.
    As items are removed, the list gets smaller. The value of the index will be set
    to a value that's too large.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 不能简单地使用`range(len(data))`基于列表的原始大小。随着项目的移除，列表变得更小。索引的值将被设置为一个太大的值。
- en: 'When removing simple items that have simple equality tests, we would use something
    like this:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除具有简单相等测试的简单项目时，我们将使用类似这样的东西：
- en: '[PRE79]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The problem is that we don't have an implementation of `__contains__()` that
    identifies items with `Lake` in `item['writer']` . We could use a subclass of
    dict that implements `__eq__()` as a string parameter value in `self['writer']`
    . This clearly violates the semantics of equality because it only checks a single
    field.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们没有一个`__contains__()`的实现，它可以识别`item['writer']`中带有`Lake`的项目。我们可以使用dict的子类来实现`__eq__()`，作为`self['writer']`中的字符串参数值。这显然违反了相等性的语义，因为它只检查一个字段。
- en: We can't extend the built-in features of these classes. The use case here is
    very specific to the problem domain, not a general feature of the list of dict
    structure.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能扩展这些类的内置特性。这里的用例非常特定于问题域，而不是字典结构的一般特性。
- en: 'To parallel the basic `while in...remove` loop, we need to write something
    like this:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与基本的`while in...remove`循环并行，我们需要写出类似这样的东西：
- en: '[PRE80]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We''ve written a function, `index()` , that locates the first instance of the
    target value. The result of this function is a single value that provides two
    kinds of information:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个名为`index()`的函数，它定位目标值的第一个实例。这个函数的结果是一个提供两种信息的单个值：
- en: When the value returned is not `None` , the item exists in the list
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当返回的值不是`None`时，该项目存在于列表中
- en: The return value is the proper index for the item within the list
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是列表中项目的正确索引
- en: The `index()` function is wordy and inflexible. If we have alternate rules,
    we need to either write multiple `index()` functions or we need to make the test
    more flexible.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`函数冗长且不灵活。如果我们有替代规则，我们需要编写多个`index()`函数，或者我们需要使测试更灵活。'
- en: More importantly, consider when a target value occurs *x* times in a list of
    *n* items. There will be *x* trips through this loop. Each trip through the loop
    examines an average of **O** ( *x* × *n/2* ) trips through the list. The worst
    case is that the items are all at the end of the list, leading to just under 
    **O** ( *x* × *n* ) processing iterations.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，考虑当目标值在*n*个项目的列表中出现*x*次时。这个循环将进行*x*次。每次循环平均检查列表中的**O**(*x*×*n/2*)次。最坏的情况是项目都在列表的末尾，导致处理迭代次数略少于**O**(*x*×*n*)。
- en: We can do better. Our preferred solution builds on the ideas in the *Designing
    a while statement which terminates properly* recipe in [Chapter 2](text00027.html#page
    "Chapter 2. Statements and Syntax") , *Statements and Syntax* , to design a proper
    loop for removing complex items from a list structure.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好。我们的首选解决方案建立在[第2章](text00027.html#page "第2章。语句和语法")的*设计一个正确终止的while语句*配方中的想法上，*语句和语法*，以设计一个适当的循环来从列表结构中删除复杂的项目。
- en: How to do it...
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Initialize an index value to zero. This establishes a variable that will traverse
    the data collection:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将索引值初始化为零。这建立了一个将遍历数据集合的变量：
- en: '[PRE81]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The terminating condition must show that every item in the list has been examined.
    Additionally, the body of the loop needs to remove all of the items that match
    the target criteria. This leads to an invariant condition that `item[i]` has not
    yet been examined. After the item is examined, it may be preserved, which means
    the index, `i` , must be incremented to reset the not yet examined invariant.
    If the item is removed, then items will shift forward and `item[i]` will automatically
    meet the not yet examined invariant:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止条件必须表明列表中的每个项目都已经被检查过了。此外，循环体需要删除所有符合目标条件的项目。这导致了一个不变条件，即`item[i]`尚未被检查。项目被检查后，它可能被保留，这意味着索引`i`必须被递增以重置尚未被检查的不变条件。如果项目被移除，那么项目将向前移动，`item[i]`将自动满足尚未被检查的不变条件：
- en: '[PRE82]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When removing an item, the list becomes one shorter, and the index value, `i`
    , will point to a new, unexamined item. When preserving an item, the index value,
    `i` , is advanced to the next unexamined item.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个项目时，列表变短了一个，索引值`i`将指向一个新的未检查的项目。保留一个项目时，索引值`i`将被提前到下一个未检查的项目。
- en: 'The terminating condition is used to wrap the processing body:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止条件用于包装处理体：
- en: '[PRE83]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: At the end of the `while` statement, the value of `i` will indicate that all
    items have been examined.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`语句结束时，`i`的值将表明所有项目都已经被检查过了。
- en: 'This leads to the following:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下结果：
- en: '[PRE84]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This makes exactly one pass through the data and removes the requested items
    without raising index errors, or skipping items that should have been deleted.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得数据只经过一次，并且在不引发索引错误或跳过应该被删除的项目的情况下删除了请求的项目。
- en: How it works...
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The goal is to examine each item exactly once and either remove it or step over
    it. The loop design reflects the way that the Python list item removal works.
    When an item is removed, all of the subsequent items are shuffled forward in the
    list.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确切地检查每个项目一次，并且要么删除它，要么跳过它。循环设计反映了Python列表项目移除的工作方式。当一个项目被移除时，所有后续项目都会在列表中向前移动。
- en: 'A naïve process based on the `range()` and `len()` functions will have two
    problems:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`range()`和`len()`函数的天真过程将有两个问题：
- en: Items will be skipped when the items shift forward and the next value is produced
    by the range object
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当项目向前移动并且范围对象产生下一个值时，项目将被跳过。
- en: The index can go beyond the end of the list structure after items are removed
    because the `len()` was used once to get the original size, not the current size
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引可以超出列表结构的末尾，因为`len()`只被用来获取原始大小，而不是当前大小
- en: 'Because of these two problems, the design of the invariant condition in the
    body of the loop is important. This reflects the two possible state changes:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个问题，循环体中不变条件的设计非常重要。这反映了两种可能的状态变化：
- en: If an item is removed, the index must not change. The list itself will change.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个项目被移除，索引就不会改变。列表本身将会改变。
- en: If an item is preserved, the index must change.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个项目被保留，索引必须改变。
- en: We can argue that the loop makes one trip through the data, and has a complexity
    of **O** ( *n* ). What's not considered in this is the relative cost of each deletion.
    Deleting item `0` from a list means that each remaining item is shuffled forward
    one position. The cost of each deletion is effectively *O* ( *n* ). Therefore
    the complexity is more like  **O** ( *n × x* ), where *x* items are removed from
    a list of *n* items.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说循环使数据通过一次，并且具有**O**(*n*)的复杂度。这里没有考虑的是每次删除的相对成本。从列表中删除项目`0`意味着每个剩余项目都向前移动一个位置。每次删除的成本实际上是*O*(*n*)。因此，复杂度更像是**O**(*n
    × x*)，其中从*n*个项目的列表中移除*x*个项目。
- en: Even this algorithm isn't the fastest way to remove items from a list.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个算法也不是从列表中删除项目的最快方法。
- en: There's more...
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we give up on the idea of deleting, we can do even better. Making a shallow
    copy of items is much faster than removing items from a list, but uses more storage.
    This is a common time versus memory tradeoff.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放弃删除的想法，我们甚至可以做得更好。制作项目的浅拷贝比从列表中删除项目要快得多，但使用的存储空间更多。这是一种常见的时间与内存的权衡。
- en: 'We can use a generator expression like the following:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似以下的生成器表达式：
- en: '[PRE85]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This will create a shallow copy of the items in the list that we want to keep.
    The items we don't want to keep will be ignored. For more information on the idea
    of a shallow copy, see the *Making shallow and deep copies of objects* recipe
    in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* .
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个列表中我们想要保留的项目的浅拷贝。我们不想保留的项目将被忽略。有关浅拷贝的更多信息，请参阅[第4章](text00048.html#page
    "第4章。内置数据结构 - 列表、集合、字典")中的*制作对象的浅拷贝和深拷贝*配方，*内置数据结构 - 列表、集合、字典*。
- en: 'We can also use a higher-order function such as this:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这样的高阶函数：
- en: '[PRE86]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `filter()` function has two arguments: a `lambda` object, and the original
    set of data. The `lambda` object is a kind of degenerate case for a function:
    it has arguments and a single expression. In this case, the single expression
    is used to decide which items to pass. Items for which the lambda is `False` are
    rejected.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数有两个参数：一个`lambda`对象和原始数据集。`lambda`对象是函数的一种退化情况：它有参数和一个单一表达式。在这种情况下，单一表达式用于决定要传递哪些项目。`lambda`为`False`的项目将被拒绝。'
- en: The `filter()` function is a generator. This means that we need to collect all
    of the items to create a final list object. A `for` statement is one way to process
    all results from a generator. The `list()` and `tuple()` functions will also consume
    all items from a generator.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数是一个生成器。这意味着我们需要收集所有项目来创建最终的列表对象。`for`语句是处理生成器的所有结果的一种方法。`list()`和`tuple()`函数也会消耗生成器的所有项目。'
- en: The third way we can implement this is to write our own generator function that
    embodies the filter concept. This will use more statements than the generator
    or the `filter()` function, but it might be more clear.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现这一点的第三种方法是编写自己的生成器函数，体现了过滤的概念。这将使用比生成器或`filter()`函数更多的语句，但可能更清晰。
- en: 'Here''s a generator function definition:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器函数定义：
- en: '[PRE87]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We've used a `for` statement to examine each item in the source list. If the
    item has `'Lake'` in the list of writers, we'll continue the `for` statement process
    effectively rejecting this item. If `'Lake'` is not in the list of writers, we'll
    yield the item.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`语句来检查源列表中的每个项目。如果项目在作者列表中有'Lake'，我们将继续`for`语句的处理过程，有效地拒绝这个项目。如果'Lake'不在作者列表中，我们将产生该项目。
- en: 'When we call this function, it will yield the interesting list. We can use
    the function `writer_rule()` like this:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，它将产生有趣的列表。我们可以像这样使用函数`writer_rule()`：
- en: '[PRE88]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This will accumulate the interesting rows into a new structure. Since it's a
    shallow copy, it doesn't waste vast amounts of storage.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把有趣的行累积到一个新的结构中。由于这是一个浅拷贝，它不会浪费大量的存储空间。
- en: See also
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This is based on the *Designing a while statement which terminates properly*
    recipe in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax*
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是基于[第2章](text00027.html#page "第2章。语句和语法")中的*设计一个正确终止的while语句*配方，*语句和语法*
- en: 'We''ve also leveraged two other recipes: *Making shallow and deep copies of
    objects* and *Slicing and dicing a list* in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还利用了另外两个配方：*制作对象的浅拷贝和深拷贝*和*切片和切割列表*在[第4章](text00048.html#page "第4章。内置数据结构
    - 列表、集合、字典")，*内置数据结构 - 列表、集合、字典*。
