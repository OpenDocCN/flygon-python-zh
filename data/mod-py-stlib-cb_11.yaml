- en: Web Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web开发
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Treating JSON—how to parse and write JSON objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理JSON - 如何解析和编写JSON对象
- en: Parsing URLs—how to parse the path, query, and other parts of a URL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析URL - 如何解析URL的路径、查询和其他部分
- en: Consuming HTTP—how to read data from an HTTP endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费HTTP - 如何从HTTP端点读取数据
- en: Submitting forms to HTTP—how to POST HTML forms to an HTTP endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交表单到HTTP - 如何将HTML表单提交到HTTP端点
- en: Building HTML—how to generate HTML with proper escaping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建HTML - 如何生成带有适当转义的HTML
- en: Serving HTTP—serving dynamic content over HTTP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供HTTP - 在HTTP上提供动态内容
- en: Serving static files—how to serve static files over HTTP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件 - 如何通过HTTP提供静态文件
- en: Errors in web applications—how to report errors in web applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序中的错误 - 如何报告Web应用程序中的错误
- en: Handling forms and files—parsing data received from HTML forms and uploaded
    files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理表单和文件 - 解析从HTML表单和上传的文件接收到的数据
- en: REST API—serving a basic REST/JSON API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API - 提供基本的REST/JSON API
- en: Handling cookies—how to handle cookies to identify a returning user
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理cookies - 如何处理cookies以识别返回用户
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The HTTP protocol and, more generally, the web set of technologies, are being
    recognized as an effective and robust way to create distributed systems that can
    leverage a widespread and reliable way to implement inter-process communication
    with ready available technologies and paradigms for caching, error propagation,
    reiterable requests, and best practices for contexts where services might fail
    without impacting the overall system status.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议，更一般地说，Web技术集，被认为是创建分布式系统的一种有效和健壮的方式，可以利用一种广泛和可靠的方式来实现进程间通信，具有可用的技术和缓存、错误传播、可重复请求的范例，以及在服务可能失败而不影响整体系统状态的情况下的最佳实践。
- en: Python has many very good and reliable web frameworks, from full stack solutions,
    such as Django and TurboGears, to more finely tweakable frameworks, such as Pyramid
    and Flask. However, for many cases, the standard library might already provide
    the tools you need to implement an HTTP-based software without the need to rely
    on external libraries and frameworks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python有许多非常好的和可靠的Web框架，从全栈解决方案，如Django和TurboGears，到更精细调整的框架，如Pyramid和Flask。然而，对于许多情况来说，标准库可能已经提供了您需要实现基于HTTP的软件的工具，而无需依赖外部库和框架。
- en: In this chapter, we will look at some some common recipes and tools provided
    by the standard library that can be convenient in the context of HTTP and web-based
    applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍标准库提供的一些常见配方和工具，这些工具在HTTP和基于Web的应用程序的上下文中非常方便。
- en: Treating JSON
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理JSON
- en: One of the most frequent needs when working with web-based solutions is parsing
    and speaking JSON. Python has built-in support for XML and HTML, but also for
    JSON encoding and decoding.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基于Web的解决方案时，最常见的需求之一是解析和处理JSON。Python内置支持XML和HTML，还支持JSON编码和解码。
- en: The JSON encoder can also be specialized to handle non-standard types, such
    as dates.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JSON编码器也可以被专门化以处理非标准类型，如日期。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the following steps are to be performed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要执行以下步骤：
- en: 'The `JSONEncoder` and `JSONDecoder` classes can be specialized to implement
    custom encoding and decoding behaviors:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JSONEncoder`和`JSONDecoder`类可以被专门化以实现自定义的编码和解码行为：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our custom encoder can then be passed to `json.dumps` to encode the JSON output
    according to our rules:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的自定义编码器传递给`json.dumps`，以根据我们的规则对JSON输出进行编码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also encode any custom class as far as it provides a `__json__` method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要提供了`__json__`方法，我们也可以对任何自定义类进行编码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result will be a JSON object that contains the provided data:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将是一个包含提供数据的JSON对象：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Loading back-encoded values will, by the way, lead to plain strings being decoded,
    because they are not JSON types:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载回编码值将导致纯字符串被解码，因为它们不是JSON类型：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we want to also parse back dates, we can try to specialize a `JSONDecoder`
    to guess whether a string contains a date in ISO 8601 format and try to parse
    it back:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还想解析回日期，我们可以尝试专门化`JSONDecoder`来猜测字符串是否包含ISO 8601格式的日期，并尝试解析它：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Loading back at previous data should lead to the expected types:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到以前的数据应该导致预期的类型：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To generate JSON representation of Python objects, the `json.dumps` method
    is used. This method accepts an additional argument, `cls`, where a custom encoder
    class can be provided:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成Python对象的JSON表示，使用`json.dumps`方法。该方法接受一个额外的参数`cls`，可以提供自定义编码器类：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `default` method of the provided class will be called whenever it is required
    to encode an object that the encoder doesn't know how to encode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要编码编码器不知道如何编码的对象时，提供的类的`default`方法将被调用。
- en: 'Our `CustomJSONEncoder` class provides a `default` method that handles encoding
    dates, times, generators, decimals, and any custom class that provides a `__json__` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CustomJSONEncoder`类提供了一个`default`方法，用于处理编码日期、时间、生成器、小数和任何提供`__json__`方法的自定义类：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is done by checking one after the other the properties of the encoded object.
    Remember that objects that the encoder knows how to encode won't be provided to
    the `default` method; only objects that the encoder doesn't know how to treat
    will be passed to the `default` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过依次检查编码对象的属性来完成的。请记住，编码器知道如何编码的对象不会被提供给`default`方法；只有编码器不知道如何处理的对象才会传递给`default`方法。
- en: So we only have to check for the objects we want to support additionally to
    the standard ones.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要检查我们想要支持的对象，而不是标准对象。
- en: 'Our first check is to verify if the provided object has a `__json__` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个检查是验证提供的对象是否有`__json__`方法：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For any object that has a `__json__` attribute that is a callable, we will rely
    on calling it to retrieve a JSON representation of the object. All the `__json__`
    method has to do is return any object that the JSON encoder knows how to encode,
    usually a `dict` where the properties of the object will be stored.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`__json__`属性的任何对象，该属性是可调用的，我们将依赖调用它来检索对象的JSON表示。`__json__`方法所需做的就是返回任何JSON编码器知道如何编码的对象，通常是一个`dict`，其中对象的属性将被存储。
- en: 'For the case of dates, we will encode them using a simplified form of the ISO
    8601 format:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日期的情况，我们将使用简化的ISO 8601格式对其进行编码：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This usually allows easy parsing from clients, such as JavaScript interpreters
    that might have to build `date` objects back from the provided data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常允许来自客户端的轻松解析，例如JavaScript解释器可能需要从提供的数据中构建`date`对象。
- en: '`Decimal` is just converted to a floating point number for convenience. This
    will suffice in most cases and is fully compatible with any JSON decoder without
    any additional machinery required. Of course, nothing prevents us from returning
    a more complex object, such as a dictionary, to retain fixed precision:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal`只是为了方便转换为浮点数。这在大多数情况下足够了，并且与任何JSON解码器完全兼容，无需任何额外的机制。当然，我们可以返回更复杂的对象，例如字典，以保留固定的精度：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, generators are consumed and a list of the contained values is returned
    from them. This is usually what you would expect, and representing the generator
    logic itself would require an unreasonable effort to guarantee cross-languages
    compatibility:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成器被消耗，并从中返回包含的值的列表。这通常是您所期望的，表示生成器逻辑本身将需要不合理的努力来保证跨语言的兼容性：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For any object we don''t know how to handle, we just let the parent implement
    the `default` method and proceed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们不知道如何处理的任何对象，我们只需让父对象实现`default`方法并继续：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will just complain that the object is not JSON-serializable and will inform
    the developer that we don't know how to handle it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只是抱怨对象不可JSON序列化，并通知开发人员我们不知道如何处理它。
- en: The custom decoder support instead works slightly differently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义解码器支持的工作方式略有不同。
- en: While the encoder will receive objects that it knows and objects that it doesn't
    know (as the Python objects are richer than the JSON objects), it's easy to see
    how it can only request additional guidance for the objects that it doesn't know
    and behave in a standard way for those that it knows how to handle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编码器将接收它知道的对象和它不知道的对象（因为Python对象比JSON对象更丰富），但很容易看出它只能请求对它不知道的对象进行额外的指导，并对它知道如何处理的对象以标准方式进行处理。
- en: The decoder instead receives only valid JSON objects; otherwise, the provided
    string wouldn't be valid JSON at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器只接收有效的JSON对象；否则，提供的字符串根本就不是有效的JSON。
- en: How can it know that the provided string must be decoded as a normal string
    or if it should ask for additional guidance?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何知道提供的字符串必须解码为普通字符串，还是应该要求额外的指导？
- en: It can't, and for this reason it asks for guidance on any single decoded object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它不能，因此它要求对任何单个解码的对象进行指导。
- en: This is the reason why the decoder is based on an `object_hook` callable that
    will receive every single decoded JSON object and can check it to perform additional
    transformations or it can let it go if the normal decoding was the right one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么解码器基于一个`object_hook`可调用，它将接收每个单独解码的JSON对象，并可以检查它以执行其他转换，或者如果正常解码是正确的，它可以让它继续。
- en: 'In our implementation, we subclassed the decoder and provided a default `object_hook`
    argument that is based on a local class method, `parse_object`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们对解码器进行了子类化，并提供了一个基于本地类方法`parse_object`的默认`object_hook`参数：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `parse_object` method will then receive any JSON object that was found
    decoding the JSON (top or nested ones); thus, it will receive a bunch of dictionaries
    that it can check in any way that is needed and edit their content to perform
    additional conversions on top of those performed by the JSON decoder itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`parse_object`方法将接收到解码JSON（顶级或嵌套的）中找到的任何JSON对象；因此，它将接收到一堆字典，可以以任何需要的方式检查它们，并编辑它们的内容以执行JSON解码器本身执行的其他转换：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The received argument is actually a full JSON object, so it will never be a
    single field alone; it will always be an object (so, a full Python dictionary
    with multiple key values).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的参数实际上是一个完整的JSON对象，因此它永远不会是单个字段；它总是一个对象（因此，一个完整的Python字典，具有多个键值）。
- en: 'Look at the following object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下对象：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You won't receive a `g` key but you will receive the whole Python dictionary.
    This means that if your JSON document has no nested JSON objects, your `object_hook`
    will be called exactly once with the whole document and nothing more.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您不会收到一个`g`键，但您将收到整个Python字典。这意味着如果您的JSON文档没有嵌套的JSON对象，您的`object_hook`将被调用一次，并且不会再有其他调用。
- en: 'So, our custom `object_hook` provided by the `parse_object` method iterates
    over all the properties of the decoded JSON object:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`parse_object`方法提供的自定义`object_hook`会迭代解码后的JSON对象的所有属性：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And as dates and times in JSON are usually represented in strings in ISO 8601
    format, it just ignores everything that is not a string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON中的日期和时间通常以ISO 8601格式的字符串表示，因此它会忽略一切不是字符串的内容。
- en: We are perfectly fine with the way numbers, lists, and dictionaries were converted
    (you might have to jump into lists if you expect dates to be placed inside lists)
    so if the value is not a string, we just skip it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对数字、列表和字典的转换非常满意（如果您期望日期被放在列表中，可能需要转到列表），因此如果值不是字符串，我们就跳过它。
- en: When the value is a string instead, we check its properties and if we guess
    it might be a date, we try to parse it as a date.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当值是字符串时，我们检查其属性，如果我们猜测它可能是日期，我们尝试将其解析为日期。
- en: 'We can consider a proper definition of a date: three values separated by two
    dashes, followed by three values separated by two colons with a `"T"` in the middle
    splitting the two:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑日期的正确定义：由两个破折号分隔的三个值，后跟由两个冒号分隔的三个值，中间有一个"T"来分隔两个值：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If that definition is matched, we actually try to decode it as a Python `datetime`
    object and replace the value in the decoded JSON object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配该定义，我们实际上会尝试将其解码为Python的`datetime`对象，并在解码后的JSON对象中替换该值：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You probably noticed that while encoding Python to JSON is fairly reasonable
    and robust, the trip back is full of issues.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，将Python编码为JSON是相当合理和健壮的，但返回的过程中充满了问题。
- en: JSON is not a very expressive language; it doesn't provide any machinery for
    custom types, so you have a standard way to give back hints to the decoder about
    the type that you would expect something to be decoded to.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JSON不是一种非常表达性的语言；它不提供任何用于自定义类型的机制，因此您有一种标准方法可以向解码器提供关于您期望将某些内容解码为的类型的提示。
- en: While we can *guess* that something like `2017-01-01T13:21:17` is a date, we
    have no guarantee at all. Maybe, originally, it was actually some text that by
    chance contained something that can be decoded as a date, but was never meant
    to become a `datetime` object in Python.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以*猜测*像`2017-01-01T13:21:17`这样的东西是一个日期，但我们根本没有任何保证。也许最初它实际上是一些文本，碰巧包含可以解码为日期的内容，但从未打算成为Python中的`datetime`对象。
- en: For this reason, it's usually safe to implement custom decoding only in constrained
    environments. If you know and control the source you will be receiving data from,
    it's usually safe to provide custom decoding. And you might want to go for extending
    JSON with custom properties that might guide the decoder (like having a `__type__`
    key that tells you whether it's a date or a string), but in the open web world,
    it is usually not a very good idea to try to guess what people are sending you,
    as the web is very diverse.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常只在受限环境中实现自定义解码是安全的。如果您知道并控制将接收数据的源，通常可以安全地提供自定义解码。您可能希望通过使用自定义属性来扩展JSON，这些属性可能会指导解码器（例如具有告诉您它是日期还是字符串的`__type__`键），但在开放的网络世界中，通常不明智地尝试猜测人们发送给您的内容，因为网络非常多样化。
- en: There are extended standard versions of JSON that try to solve exactly this
    ambiguity in decoding data, such as JSON-LD and JSON Schema, that allow you to
    express more complex entities in JSON.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些扩展的标准JSON版本试图解决解码数据中的这种歧义，例如JSON-LD和JSON Schema，它们允许您在JSON中表示更复杂的实体。
- en: If you feel the need, you should rely on those standards to avoid the risk of
    reinventing the wheel and facing limits of your solution that were already solved
    by existing standards.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，您应该依赖这些标准，以避免重新发明轮子的风险，并面对您的解决方案已经由现有标准解决的限制。
- en: Parsing URLs
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析URL
- en: When working with web-based software, it's frequently necessary to understand
    links, protocols, and paths.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理基于Web的软件时，经常需要了解链接、协议和路径。
- en: You might be tempted to rely on regular expressions or strings splitting to
    parse URLs, but if you account for all the oddities a URL might include (things
    such as credentials or particular protocols), it might not be as easy as you expect.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会倾向于依赖正则表达式或字符串拆分来解析URL，但是如果考虑到URL可能包含的所有奇特之处（例如凭据或特定协议等），它可能并不像您期望的那样容易。
- en: Python provides utilities in the `urllib` and `cgi` modules that make life easier
    when you want to account for all the possible different formats a URL can have.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了`urllib`和`cgi`模块中的实用工具，当您想要考虑URL可能具有的所有可能不同的格式时，这些工具可以使生活更轻松。
- en: Relying on them can make life easier and your software more robust.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 依靠它们可以使生活更轻松，使您的软件更健壮。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `urllib.parse` module has multiple tools to parse URLs. The most commonly
    used solution is to rely on `urllib.parse.urlparse`, which can handle the most
    widespread kinds of URLs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.parse`模块具有多种工具可用于解析URL。最常用的解决方案是依赖于`urllib.parse.urlparse`，它可以处理最常见的URL类型：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code snippet can be called on the command line, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在命令行上调用前面的代码片段，如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The returned `OrderedDict` contains all the parts that compose our URL and also,
    for the query arguments, it provides them already parsed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`OrderedDict`包含组成我们的URL的所有部分，并且对于查询参数，它们已经被解析。
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Nowadays, the URIs also support parameters to be provided at each path segment.
    Those are very rarely used in practice, but if your code is expected to receive
    those kind of URIs, then you should not rely on `urllib.parse.urlparse` because
    it tries to parse the parameters from the URL, which is not properly supported
    for those URIs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，URI还支持在每个路径段中提供参数。这在实践中很少使用，但如果您的代码预期接收此类URI，则不应依赖于`urllib.parse.urlparse`，因为它尝试从URL中解析参数，而这对于这些URI来说并不受支持：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might have noticed that parameters for the last part of the path were properly
    parsed in `params`, but the parameters for the first part were left in `path`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，路径的最后一部分的参数在`params`中被正确解析，但是第一部分的参数保留在`path`中。
- en: 'In such case, you might want to rely on `urllib.parse.urlsplit`, which won''t
    parse the parameters and will leave them as they are for you to parse. So you
    can split the URL segments from the parameters on your own:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能希望依赖于`urllib.parse.urlsplit`，它不会解析参数，而会将它们保留下来供您解析。因此，您可以自行拆分URL段和参数：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See that, in this case, all parameters were left in place in `path` and you
    can then split them yourself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，所有参数都保留在“路径”中，然后您可以自行拆分它们。
- en: Consuming HTTP
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP消费
- en: You might be interacting with a third-party service based on HTTP REST APIs,
    or you might be fetching content from a third party or just downloading a file
    that your software needs as the input. It doesn't really matter. Nowadays, it's
    virtually impossible to write an application and ignore HTTP; you will have to
    face it sooner or later. People expect HTTP support from all kind of applications.
    If you are writing an image viewer, they probably expect to be able to throw a
    URL that leads to an image to it and see it appear.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在与基于HTTP REST API的第三方服务进行交互，或者可能正在从第三方获取内容或仅下载软件需要的文件。这并不重要。如今，几乎不可能编写一个应用程序并忽略HTTP；您迟早都会面对它。人们期望各种应用程序都支持HTTP。如果您正在编写图像查看器，他们可能希望能够将指向图像的URL传递给它并看到图像出现。
- en: While they have never been really user friendly and obvious, the Python standard
    library has always had ways to interact with HTTP, and they are available out
    of the box.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们从来没有真正用户友好和明显，但Python标准库一直有与HTTP交互的方式，并且这些方式可以直接使用。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps for this recipe are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的步骤如下：
- en: 'The `urllib.request` module provides the machinery required to submit an HTTP
    request. A light wrapper around it can solve most needs in terms of using HTTP:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`urllib.request`模块提供了提交HTTP请求所需的机制。它的轻量级包装可以解决大多数HTTP使用需求：'
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can use our `http_request` function to perform requests to fetch files:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`http_request`函数执行请求以获取文件：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use it to interact with JSON-based APIs:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用它与基于JSON的API进行交互：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Also, it can be used to submit or upload data to endpoints:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还可以用于提交或上传数据到端点：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `http_request` method takes care of creating a `urllib.request.Request`
    instance, sending it through the network and fetching back the response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`http_request`方法负责创建`urllib.request.Request`实例，通过网络发送它并获取响应。'
- en: A request is sent to the specified URL to which query arguments are appended.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 向指定的URL发送请求，其中附加了查询参数。
- en: 'The first thing the function does is parse the URL, so that it can replace
    parts of it. This is done to be able to replace/append the query arguments with
    the one provided:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一件事是解析URL，以便能够替换其中的部分。这样做是为了能够用提供的部分替换/追加查询参数：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`urllib.parse.urlencode` will accept a dictionary of arguments, such as`{''a'':
    5, ''b'': 7}`, and will give you back the string with the `urlencode` arguments:
    `''b=7&a=5''`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.parse.urlencode`将接受一个参数字典，例如`{''a'': 5, ''b'': 7}`，并将返回带有`urlencode`参数的字符串：`''b=7&a=5''`。'
- en: The resulting query string is then placed into the parsed parts of the `url`
    to replace the currently existing query arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将生成的查询字符串放入`url`的解析部分中，以替换当前存在的查询参数。
- en: 'Then the `url` is built back from all the parts that now include the right
    query arguments:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从现在包括正确查询参数的所有部分构建`url`：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the `url` with the encoded query is ready, it builds a request out of
    it, proxying the specified method, headers, and body of the request:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好带有编码查询的`url`，它就会构建一个请求，代理指定的方法、标头和请求的主体：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When doing a plain `GET` request, those will be the default ones, but being
    able to specify them allows us to perform also more advanced kinds of requests,
    such as `POST`, or provide special headers into our requests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行普通的`GET`请求时，这些将是默认的，但能够指定它们允许我们执行更高级的请求，例如`POST`，或者在我们的请求中提供特殊的标头。
- en: 'The request is then opened and the response is read back:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开请求并读取响应：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The response comes back as a `urllib.response.addinfourl` object, with two
    relevant parts: the body of the response and an `http.client.HTTPMessage`, from
    which we can get all the response info, such as headers, URL, and so on.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 响应以`urllib.response.addinfourl`对象的形式返回，其中包括两个相关部分：响应的主体和一个`http.client.HTTPMessage`，我们可以从中获取所有响应信息，如标头、URL等。
- en: The body is retrieved by reading the response like a file, while the `HTTPMessage` is
    retrieve through the `info()` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像读取文件一样读取响应来检索主体，而通过`info()`方法检索`HTTPMessage`。
- en: 'Through the retrieved info, we can check whether the response is a JSON response,
    and in this case, we decode it back to a dictionary so we can navigate the response
    instead of just receiving plain bytes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检索的信息，我们可以检查响应是否为JSON响应，在这种情况下，我们将其解码回字典，以便我们可以浏览响应而不仅仅是接收纯字节：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For all responses, we return the message and the body. The caller can just
    ignore the message if it''s not needed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有响应，我们返回消息和主体。如果不需要，调用者可以忽略消息：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Making HTTP requests can be very simple for simple cases and very complicated
    for more complex cases. Perfectly handling the HTTP protocol can be a long and
    complex job, especially since the protocol specifications themselves are not always
    clear in enforcing how things should work and a lot comes from experience of how
    real existing web servers and clients work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的情况来说，进行HTTP请求可能非常简单，但对于更复杂的情况来说可能非常复杂。完美地处理HTTP协议可能是一项漫长而复杂的工作，特别是因为协议规范本身并不总是清楚地规定事物应该如何工作，很多都来自于对现有的网络服务器和客户端工作方式的经验。
- en: For this reason, if you have needs that go further than just fetching simple
    endpoints, you might want to rely on a third-party library for performing HTTP
    requests, such as the requests library that is available for nearly all Python
    environments.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您的需求超出了仅仅获取简单端点的范围，您可能希望依赖于第三方库来执行HTTP请求，例如几乎适用于所有Python环境的requests库。
- en: Submitting forms to HTTP
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向HTTP提交表单
- en: Sometimes you have to interact with HTML forms or upload files. This usually
    requires handling the `multipart/form-data` encoding.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您必须与HTML表单交互或上传文件。这通常需要处理`multipart/form-data`编码。
- en: Forms can mix files and text data, and there can be multiple different fields
    within a form. Thus, it requires a way to express multiple fields in the same
    request and some of those fields can be binary files.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表单可以混合文件和文本数据，并且表单中可以有多个不同的字段。因此，它需要一种方式来在同一个请求中表示多个字段，其中一些字段可以是二进制文件。
- en: That's why encoding data in multipart can get tricky, but it's possible to roll
    out a basic recipe using only standard library tools that will work in most cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在多部分中编码数据可能会变得棘手，但是可以使用标准库工具来制定一个基本的食谱，以便在大多数情况下都能正常工作。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are the steps for this recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此食谱的步骤：
- en: '`multipart` itself requires tracking all the fields and files we want to encode
    and then performing the encoding itself.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`multipart`本身需要跟踪我们想要编码的所有字段和文件，然后执行编码本身。'
- en: 'We will rely on `io.BytesIO` to store all the resulting bytes:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将依赖`io.BytesIO`来存储所有生成的字节：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can then provide and encode our `form` data:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以提供并编码我们的`form`数据：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using this with our `http_request` method from previous recipe, we can submit
    any `form` through HTTP:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们先前食谱中的`http_request`方法，我们可以通过HTTP提交任何`form`：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, `httpbin` properly received our `file1` and and our `name` field
    and processed both.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`httpbin`正确接收了我们的`file1`和我们的`name`字段，并对两者进行了处理。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`multipart` is practically based on encoding multiple requests within a single
    body. Each part is separated by a **boundary** and within the boundary lies the
    data of that part.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`multipart`实际上是基于在单个主体内编码多个请求。每个部分都由一个**boundary**分隔，而在边界内则是该部分的数据。'
- en: Each part can provide both data and metadata, such as the content type of the
    provided data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都可以提供数据和元数据，例如所提供数据的内容类型。
- en: 'This way the receiver can know whether the contained data is binary, text,
    or whatever. For example, the part specifying the value for the `surname` field
    of a `form` would look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这样接收者就可以知道所包含的数据是二进制、文本还是其他类型。例如，指定`form`的`surname`字段值的部分将如下所示：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And the part providing data for an uploaded file would look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 提供上传文件数据的部分将如下所示：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our `MultiPartForm` allows us to store aside both plain `form` fields by setting
    them with dictionary syntax:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MultiPartForm`允许我们通过字典语法存储纯`form`字段：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can call it on a command line, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令行上调用它，如下所示：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And to provide files by adding them with the `add_file` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过“add_file”方法提供文件：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can call this method on a command line, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令行上调用这个方法，如下所示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Those just record the wanted fields and files in a dictionary and a list that
    are only used later on when `_generate_bytes` is called to actually generate the
    full multipart content.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是在稍后调用`_generate_bytes`时才会使用的字典和列表，用于记录想要的字段和文件。
- en: 'All the hard work is done by `_generate_bytes` that goes through all those
    fields and files and creates a part for each one of them:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的辛苦工作都是由`_generate_bytes`完成的，它会遍历所有这些字段和文件，并为每一个创建一个部分：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As the boundary must separate every part, it's very important to verify that
    the boundary is not contained within the data itself, or the receiver might wrongly
    consider a part ended when it encounters it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于边界必须分隔每个部分，非常重要的是要验证边界是否不包含在数据本身中，否则接收者可能会在遇到它时错误地认为部分已经结束。
- en: 'That''s why our `MultiPartForm` class generates a `boundary`, checks whether
    it''s contained within the multipart response, and if it is, it generates a new
    one, until it can find a `boundary` that is not contained within the data:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们的“MultiPartForm”类会生成一个“boundary”，检查它是否包含在多部分响应中，如果是，则生成一个新的，直到找到一个不包含在数据中的“boundary”：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once we have found a valid `boundary`, we can use it to generate the multipart
    content and return it to the caller with the content type that must be used (as
    the content type provides a hint to the receiver about which `boundary` to check):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了一个有效的“boundary”，我们就可以使用它来生成多部分内容，并将其返回给调用者，同时提供必须使用的内容类型（因为内容类型为接收者提供了关于要检查的“boundary”的提示）：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Multipart encoding is not an easy subject; for example, encoding of names within
    the multipart body is not an easy topic.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 多部分编码并不是一个简单的主题；例如，在多部分主体中对名称的编码并不是一个简单的话题。
- en: Over the years, it was changed and discussed multiple times about what's the
    proper encoding for the name of fields and name of files within the multipart
    content.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，关于在多部分内容中对字段名称和文件名称进行正确编码的方式已经多次更改和讨论。
- en: Historically, it's safe to only rely on plain ASCII names in those fields, so
    if you want to make sure the server you are submitting data to is able to properly
    receive your data, you might want to stick to simple filenames and fields that
    don't involve Unicode characters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，在这些字段中只依赖于纯ASCII名称是安全的，因此，如果您想确保您提交的数据的服务器能够正确接收您的数据，您可能希望坚持使用简单的文件名和字段，不涉及Unicode字符。
- en: Over the years, multiple other ways to encode those fields and filenames were
    suggested. UTF-8 is one of the officially supported fallback for HTML5\. The suggested
    recipe relies on UTF-8 to encode filenames and fields, so that it's backward compatible
    with cases where plain ASCII names are used but it's still possible to rely on
    Unicode characters when the server supports them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，提出了多种其他编码这些字段和文件名的方法。UTF-8 是 HTML5 的官方支持的后备之一。建议的食谱依赖于UTF-8来编码文件名和字段，以便与使用纯ASCII名称的情况兼容，但仍然可以在服务器支持它们时依赖于Unicode字符。
- en: Building HTML
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建HTML
- en: Whenever you are building a web page, an email, or a report, you are probably
    going to rely on replacing placeholders in an HTML template with actual values
    that you need to show to your users.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您构建网页、电子邮件或报告时，您可能会依赖用实际值替换HTML模板中的占位符，以便向用户显示所需的内容。
- en: We already saw in [Chapter 2](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml), *T**ext
    Management*, how a minimal, simple template engine can be implemented, but it
    wasn't specific to HTML in any way.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml)中看到了*文本管理*，如何实现一个最小的简单模板引擎，但它并不特定于HTML。
- en: When working with HTML, it's particularly important to pay attention to escaping
    the values provided by users, as that might lead to broken pages or even XSS attacks.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理HTML时，特别重要的是要注意对用户提供的值进行转义，因为这可能导致页面损坏甚至XSS攻击。
- en: You clearly don't want your users to get mad at you just because you registered
    yourself on your website with the surname `"<script>alert('You are hacked!')</script>"`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您不希望您的用户因为您在网站上注册时使用姓氏`"<script>alert('You are hacked!')</script>"`而对您生气。
- en: For this reason, the Python standard library provides escaping tools that can
    be used to properly prepare content for insertion into HTML.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，Python标准库提供了可以用于正确准备内容以插入HTML的转义工具。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Combining the `string.Formatter` and `cgi` modules, it is possible to create
    a formatter that takes care of escaping for us:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`string.Formatter`和`cgi`模块，可以创建一个负责为我们进行转义的格式化程序：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we can use the `HTMLFormatter` and the `Markup` classes while also retaining
    the ability to inject raw `html` when needed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在需要时使用`HTMLFormatter`和`Markup`类，同时保留注入原始`html`的能力：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can also easily combine this recipe with the one regarding text template
    engines to implement a minimalistic HTML template engine with escaping.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以轻松地将此配方与有关文本模板引擎的配方相结合，以实现一个具有转义功能的极简HTML模板引擎。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Whenever the `HTMLFormatter` has to replace a value in the format string, it
    will check whether the retrieved value has a `__html__` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`HTMLFormatter`需要替换格式字符串中的值时，它将检查检索到的值是否具有`__html__`方法：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If that method exists, it's expected to return the HTML representation of the
    value. And that's expected to be a perfectly valid and escaped HTML.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在该方法，则预计返回值的HTML表示。并且预计是一个完全有效和转义的HTML。
- en: 'Otherwise, the value is expected to be a string that needs escaping:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，预计值将是需要转义的字符串：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This makes it so that any value we provide to the `HTMLFormatter` gets escaped
    by default:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们提供给`HTMLFormatter`的任何值都会默认进行转义：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we want to avoid escaping, we can rely on the `Markup` object, which can
    wrap out a string to make it pass as is without any escaping:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要避免转义，我们可以依赖`Markup`对象，它可以包装一个字符串，使其原样传递而不进行任何转义：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This works because our `Markup` object implements an `__html__` method that
    returns the string as is. As our `HTMLFormatter` ignores any value that has an
    `__html__` method, our string will get through without any form of escaping.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的`Markup`对象实现了一个`__html__`方法，该方法返回原样的字符串。由于我们的`HTMLFormatter`忽略了任何具有`__html__`方法的值，因此我们的字符串将无需任何形式的转义而通过。
- en: While `Markup` permits us to disable escaping on demand, when we know that we
    actually want HTML in there, we can apply the HTML method to any other object.
    Any object that needs to be represented in a web page can provide an `__html__` method
    and will automatically get converted to HTML according to it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Markup`允许我们根据需要禁用转义，但是当我们知道实际上需要HTML时，我们可以将HTML方法应用于任何其他对象。需要在网页中表示的任何对象都可以提供一个`__html__`方法，并将根据它自动转换为HTML。
- en: For example, you can add `__html__` to your `User` class and any time you want
    to put your user in a web page, you just need to provide the `User` instance itself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以向您的`User`类添加`__html__`，并且每当您想要将用户放在网页中时，您只需要提供`User`实例本身。
- en: Serving HTTP
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供HTTP
- en: Interacting through HTTP is one of the most frequent means of communication
    between distributed applications or even totally separated software and it's also
    the foundation of all existing web applications and web-based tools.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP进行交互是分布式应用程序或完全分离的软件之间最常见的通信手段之一，也是所有现有Web应用程序和基于Web的工具的基础。
- en: While Python has tens of great web frameworks that can satisfy most different
    needs, the standard library itself has all the foundations that you might need
    to implement a basic web application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python有数十个出色的Web框架可以满足大多数不同的需求，但标准库本身具有您可能需要实现基本Web应用程序的所有基础。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Python has a convenient protocol named WSGI to implement HTTP-based applications.
    While for more advanced needs, a web framework might be required; for very simple
    needs, the `wsgiref` implementation built into Python itself can meet our needs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个方便的协议名为WSGI来实现基于HTTP的应用程序。对于更高级的需求，可能需要一个Web框架；对于非常简单的需求，Python本身内置的`wsgiref`实现可以满足我们的需求：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then we can create a `WSGIApplication` and register any number of routes with
    it:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建一个`WSGIApplication`并向其注册任意数量的路由：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we are ready, we just need to serve the application:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备就绪，我们只需要提供应用程序：
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If everything worked properly, by pointing your browser to `http://localhost:8000`,
    you should see an Hello World text and a link leading you to further pages providing
    query arguments, URL arguments, and being served on various URLs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，通过将浏览器指向`http://localhost:8000`，您应该会看到一个Hello World文本和一个链接，引导您到进一步提供查询参数，URL参数并在各种URL上提供服务的页面。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `WSGIApplication` creates a WSGI server that is in charge of serving the
    web application itself (`self`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`WSGIApplication`创建一个负责提供Web应用程序本身（`self`）的WSGI服务器：'
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: On every request, `WSGIApplication.__call__` is called by the server to retrieve
    a response for that request.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求上，服务器都会调用`WSGIApplication.__call__`来检索该请求的响应。
- en: '`WSGIApplication.__call__` scans through all the registered routes (each route
    can be registered with `app.route(path)`, where `path` is a regular expression).
    When a regular expression matches the current URL path, the registered function
    is called to produce a response of that route:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`WSGIApplication.__call__`扫描所有注册的路由（每个路由可以使用`app.route(path)`注册，其中`path`是正则表达式）。当正则表达式与当前URL路径匹配时，将调用注册的函数以生成该路由的响应：'
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once a function matching the path is found, that function is called to get
    a response body and then the resulting body is returned to the server:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到与路径匹配的函数，就会调用该函数以获取响应主体，然后将生成的主体返回给服务器：
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Right before returning the body, `Response.send` is called to send the response
    HTTP headers and status through the `start_response` callable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回主体之前，将调用`Response.send`通过`start_response`可调用发送响应HTTP标头和状态。
- en: The `Response` and `Request` objects are instead used to keep around the environment
    of the current request (and any additional argument parsed from the URL), the
    headers, and status of the response. This is so that the actions called to handle
    the request can receive them and inspect the request or add/remove headers from
    the response before it's sent.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response`和`Request`对象用于保留当前请求的环境（以及从URL解析的任何附加参数）、响应的标头和状态。这样，处理请求的操作可以接收它们并检查请求或在发送之前添加/删除响应的标头。'
- en: There's more...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While basic HTTP-based applications can be served using the provided implementation
    of `WSGIApplication`, there is a lot that is missing or incomplete for a full
    featured application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本的基于HTTP的应用程序可以使用提供的`WSGIApplication`实现，但完整功能的应用程序还有很多缺失或不完整的地方。
- en: Parts such as caching, sessions, authentication, authorization, managing database
    connections, transactions, and administration are usually required when more complex
    web applications are involved, and they are easily provided for you by most Python
    web frameworks.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及更复杂的Web应用程序时，通常需要缓存、会话、身份验证、授权、管理数据库连接、事务和管理等部分，并且大多数Python Web框架都可以轻松为您提供这些部分。
- en: Implementing a complete web framework is out of the scope of this book and you
    should probably try to avoid reinventing the wheel when there are many great web
    frameworks available in the Python environment.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实现完整的Web框架不在本书的范围之内，当Python环境中有许多出色的Web框架可用时，您可能应该尽量避免重复造轮子。
- en: Python has a wide range of web frameworks covering everything from full-stack
    frameworks for rapid development, such as Django; API-oriented micro frameworks,
    such as Flask; to flexible solutions, such as Pyramid and TurboGears, where the
    required pieces can be enabled, disabled, or replaced on demand, ranging from
    full-stack solutions to microframeworks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有广泛的Web框架，涵盖了从用于快速开发的全栈框架（如Django）到面向API的微框架（如Flask）以及灵活的解决方案（如Pyramid和TurboGears），其中所需的部分可以根据需要启用、禁用或替换，从全栈解决方案到微框架。
- en: Serving static files
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Sometimes when working on JavaScript-based applications or static websites,
    it's necessary to be able to serve the content of a directory directly from disk.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理基于JavaScript的应用程序或静态网站时，有必要能够直接从磁盘上提供目录的内容。
- en: The Python standard library has a ready-made HTTP server that handles requests,
    mapping them to files in a directory, so we can quickly roll our own HTTP server
    to write websites without the need to install any other tool.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了一个现成的HTTP服务器，用于处理请求，并将它们映射到目录中的文件，因此我们可以快速地编写自己的HTTP服务器来编写网站，而无需安装任何其他工具。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `http.server` module provides most of what is needed to implement an HTTP
    server in charge of serving content of a directory:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.server`模块提供了实现负责提供目录内容的HTTP服务器所需的大部分内容：'
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then `serve_directory` can be started against any path, to serve the content
    of that path on `http://localhost:8000`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`serve_directory`可以针对任何路径启动，以在`http://localhost:8000`上提供该路径的内容：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Pointing your browser to `http://localhost:8000` should list the content of
    the `/tmp` directory and allow you to navigate it and see content of any file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将浏览器指向`http://localhost:8000`应该列出`/tmp`目录的内容，并允许您浏览它并查看任何文件的内容。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`ThreadingHTTPServer` joins `HTTPServer` with `ThreadingMixin`, which allows
    you to serve more than a single request at a time.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadingHTTPServer`将`HTTPServer`与`ThreadingMixin`结合在一起，这允许您一次提供多个请求。'
- en: This is especially important when serving static websites because browsers frequently
    keep connections open longer than needed, and when serving a single request at
    a time, you might be unable to fetch your CSS or JavaScript files until the browser
    closes the previous connection.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这在提供静态网站时尤其重要，因为浏览器经常保持连接时间比需要的更长，当一次只提供一个请求时，您可能无法获取您的CSS或JavaScript文件，直到浏览器关闭前一个连接。
- en: For each request, the `HTTPServer` forwards it for processing to a specified
    handler. The `SimpleHTTPRequestHandler` is able to serve the requests, mapping
    them to local files on disk, but on most Python versions, it is only able to serve
    them from the current directory.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，`HTTPServer`将其转发到指定的处理程序进行处理。`SimpleHTTPRequestHandler`能够提供请求，将其映射到磁盘上的本地文件，但在大多数Python版本中，它只能从当前目录提供服务。
- en: To be able to serve requests from any directory, we provided a custom `translate_path` method,
    which replaces the path resulting from the standard implementation that is relative
    to the `SERVED_DIRECTORY` class variable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从任何目录提供请求，我们提供了一个自定义的`translate_path`方法，它替换了相对于`SERVED_DIRECTORY`类变量的标准实现产生的路径。
- en: '`serve_directory` then puts everything together and joins `HTTPServer` with
    the customized request handler to create a server able to handle requests for
    the provided path.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`serve_directory`将所有内容放在一起，并将`HTTPServer`与定制的请求处理程序结合在一起，以创建一个能够处理提供路径的请求的服务器。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A lot has changed in more recent Python versions regarding the `http.server`
    module. The newest version, Python 3.7, already provides the `ThreadingHTTPServer`
    class out of the box and it's now possible to configure a specific directory to
    be served by `SimpleHTTPRequestHandler`, thus removing the need to customize the
    `translate_path` method to serve a specific directory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的Python版本中，关于`http.server`模块已经发生了很多变化。最新版本Python 3.7已经提供了`ThreadingHTTPServer`类，并且现在可以配置特定目录由`SimpleHTTPRequestHandler`提供服务，因此无需自定义`translate_path`方法来提供特定目录的服务。
- en: Errors in web applications
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序中的错误
- en: Usually, when a Python WSGI web application crashes, you get a traceback in
    the Terminal and an empty path in your browser.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当Python WSGI Web应用程序崩溃时，您会在终端中获得一个回溯，浏览器中的路径为空。
- en: That doesn't make it very easy to debug what's going on and unless you explicitly
    check your Terminal, it might be easy to miss that your page is not showing up
    because it actually crashed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很容易调试发生了什么，除非您明确检查终端，否则很容易错过页面没有显示出来的情况，因为它实际上崩溃了。
- en: Luckily, the Python standard library provides some basic debugging tools for
    web applications that make it possible to report crashes into the browser so you
    can see them and fix them without having to jump away from your browser.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python标准库为Web应用程序提供了一些基本的调试工具，使得可以将崩溃报告到浏览器中，这样您就可以在不离开浏览器的情况下查看并修复它们。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `cgitb` module provides tools to format an exception and its traceback
    as HTML, so we can leverage it to implement a WSGI middleware that can wrap any
    web application to provide better error reporting in the browser:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`cgitb`模块提供了将异常及其回溯格式化为HTML的工具，因此我们可以利用它来实现一个WSGI中间件，该中间件可以包装任何Web应用程序，以在浏览器中提供更好的错误报告：'
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`ErrorMiddleware` can be used to wrap any WSGI application, so that in case
    of errors, it will display the error into the web browser.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorMiddleware`可以用于包装任何WSGI应用程序，以便在出现错误时将错误显示在Web浏览器中。'
- en: 'We can, for example, grab back our `WSGIApplication` from the previous recipe,
    add a route that will cause a crash, and serve the wrapped application to see
    how errors are reported into the web browser:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以从上一个示例中重新获取我们的`WSGIApplication`，添加一个将导致崩溃的路由，并提供包装后的应用程序以查看错误如何报告到Web浏览器中：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once you point your browser to `http://localhost:8000/crash`, you should see
    a nicely formatted traceback of the triggered exception.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将浏览器指向`http://localhost:8000/crash`，您应该看到触发异常的精美格式的回溯。
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`ErrorMiddleware` receives the original application and replaces it in the
    request handling.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorMiddleware`接收原始应用程序并替换请求处理。'
- en: All HTTP requests will be received by `ErrorMiddleware`, which will then proxy
    them to the application, returning the resulting response provided by the application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTTP请求都将被`ErrorMiddleware`接收，然后将其代理到应用程序，返回应用程序提供的结果响应。
- en: If an exception arises while the application response was being consumed, it
    will stop the standard flow, and instead of consuming the response of the application
    any further, it will format the exception and send it back as the response to
    the browser.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在消耗应用程序响应时出现异常，它将停止标准流程，而不是进一步消耗应用程序的响应，它将格式化异常并将其作为响应发送回浏览器。
- en: 'This is done because `ErrorMiddleware.__call__` in fact calls the wrapped application
    and iterates over any provided result:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`ErrorMiddleware.__call__`实际上调用了包装的应用程序并迭代了任何提供的结果：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This approach works with both applications that return a normal response and
    applications that return a generator as the response.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于返回正常响应的应用程序和返回生成器作为响应的应用程序。
- en: 'If an error arises when calling the application or while consuming the response,
    the error is trapped and a new `start_response` is attempted to notify the server
    error to the browser:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用应用程序或消耗响应时出现错误，则会捕获错误并尝试使用新的`start_response`来通知服务器错误到浏览器：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If `start_response` fails, it means that the wrapped application already called
    `start_response` and thus it's not possible to change the response status code
    or headers anymore.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`start_response`失败，这意味着被包装的应用程序已经调用了`start_response`，因此不可能再更改响应状态码或标头。
- en: 'In this case, as we can''t provide the nicely formatted response anymore, we
    just fall back to providing an error on the Terminal:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们无法再提供精美格式的响应，我们只能退回到在终端上提供错误：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If `start_response` succeeded, instead, we stop returning the content of the
    application response and, instead, we return the error and traceback, nicely formatted
    by `cgitb`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`start_response`成功，我们将停止返回应用程序响应的内容，而是返回错误和回溯，由`cgitb`精美格式化：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In both cases, then, if it provided a `close` method, we close the application
    response. This way, if it was a file or any source that needs to be closed, we
    avoid leaking it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，如果它提供了`close`方法，我们将关闭应用程序响应。这样，如果它是一个需要关闭的文件或任何源，我们就可以避免泄漏它：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: More complete solutions for error reporting in web applications in Python are
    available out of the standard library. If you have further needs or want to get
    the errors notified by email or through cloud error reporting solutions, such
    as Sentry, you might want to provide an error reporting WSGI library.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库之外还提供了更完整的Web应用程序错误报告解决方案。如果您有进一步的需求或希望通过电子邮件或通过Sentry等云错误报告解决方案通知错误，您可能需要提供一个错误报告WSGI库。
- en: The `Werkzeug` debugger from Flask, the `WebError` library from the Pylons project,
    and the `Backlash` library from the TurboGears project are probably the most common
    solutions for this purpose.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Flask的`Werkzeug`调试器，来自Pylons项目的`WebError`库，以及来自TurboGears项目的`Backlash`库可能是这个目的最常见的解决方案。
- en: You might also want to check whether your web framework provides some advanced
    error reporting configuration, as many of them provide it out of the box, relying
    on those libraries or other tools.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想检查您的Web框架是否提供了一些高级的错误报告配置，因为其中许多提供了这些功能，依赖于这些库或其他工具。
- en: Handling forms and files
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单和文件
- en: When submitting forms and uploading files, they are usually sent with the `multipart/form-data`
    encoding.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交表单和上传文件时，它们通常以`multipart/form-data`编码发送。
- en: We already saw how to create data encoded in `multipart/form-data`, and submit
    it to an endpoint, but how can we handle incoming data in such a format?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何创建以`multipart/form-data`编码的数据，并将其提交到端点，但是如何处理以这种格式接收的数据呢？
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `cgi.FieldStorage` class in the standard library already provides all the
    machinery required to parse multipart data and send it back to you in a way that
    is easy to handle.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的`cgi.FieldStorage`类已经提供了解析多部分数据并以易于处理的方式发送回数据所需的所有机制。
- en: 'We will create a simple web application (based on `WSGIApplication`) to show
    how `cgi.FieldStorage` can be used to parse the uploaded file and show it back
    to the user:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的Web应用程序（基于`WSGIApplication`），以展示如何使用`cgi.FieldStorage`来解析上传的文件并将其显示给用户：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The application exposes two web pages. One is on the root of the website (through
    the `index` function) that only shows a simple form with an upload field.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序公开了两个网页。一个位于网站的根目录（通过`index`函数），只显示一个带有上传字段的简单表单。
- en: The other, the `upload` function, instead receives the uploaded file and shows
    it back if it's an image or a text file. In all other cases, it will just show
    the name of the uploaded file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`upload`函数，接收上传的文件，如果是图片或文本文件，则显示出来。在其他情况下，它将只显示上传文件的名称。
- en: 'All that is required to handle the upload in multipart format is to create
    a `cgi.FieldStorage` out of it:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多部分格式上传的唯一要求是创建一个`cgi.FieldStorage`：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The whole body of the `POST` request is always available in the `environ` request
    with the `wsgi.input` key.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`请求的整个主体始终在`environ`请求中可用，使用`wsgi.input`键。'
- en: This provides a file-like object that can be read to consume the posted data.
    Make sure you save aside the `FieldStorage` after it has been created if you need
    to use it multiple times, because once the data is consumed from `wsgi.input`,
    it becomes inaccessible.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个类似文件的对象，可以读取以消耗已发布的数据。确保在创建`FieldStorage`后将其保存，如果需要多次使用它，因为一旦从`wsgi.input`中消耗了数据，它就变得不可访问。
- en: '`cgi.FieldStorage` provides a dictionary-like interface, so we can check whether
    a file was uploaded just by checking whether the `uploadedfile` entry exists:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`cgi.FieldStorage`提供了类似字典的接口，因此我们可以通过检查`uploadedfile`条目是否存在来检查是否上传了文件：'
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That''s because in our form, we provided `uploadedfile` as the name of the
    field:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在我们的表单中，我们提供了`uploadedfile`作为字段的名称：
- en: '[PRE70]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That specific field will be accessible with `form['uploadedfile']`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 该特定字段将可以通过`form['uploadedfile']`访问。
- en: 'As it''s a file, it will return an object that provides the `type`, `filename`,
    and `file` attributes through which we can check the MIME type of uploaded file
    to see whether it''s an image:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个文件，它将返回一个对象，通过该对象我们可以检查上传文件的MIME类型，以确定它是否是一张图片：
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And if it''s an image, we can read its content to encode it in `base64` so
    that it can be displayed by the `img` tag:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一张图片，我们可以读取它的内容，将其编码为`base64`，这样它就可以被`img`标签显示出来：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `filename` attribute is instead only used if the uploaded file is of an
    unrecognized format, so that we can at least print back the name of the uploaded
    file:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`filename`属性仅在上传文件是无法识别的格式时使用，这样我们至少可以打印出上传文件的名称：'
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: REST API
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: REST with JSON has become the de facto standard in cross-application communication
    technologies for web-based applications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: REST与JSON已成为基于Web的应用程序之间的跨应用程序通信技术的事实标准。
- en: It's a very effective protocol, and the fact that the definition can be understood
    by everyone made it popular pretty quickly.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有效的协议，而且它的定义可以被每个人理解，这使得它很快就变得流行起来。
- en: Also, a rapid REST implementation can be rolled out pretty quickly compared
    to other more complex communication protocols.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他更复杂的通信协议相比，快速的REST实现可以相对快速地推出。
- en: As the Python standard library provides the foundations we needed to build WSGI-based
    applications, it's not hard to extend our existing recipe to support REST-based
    dispatch of requests.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python标准库提供了我们构建基于WSGI的应用程序所需的基础，因此很容易扩展我们现有的配方以支持基于REST的请求分发。
- en: How to do it...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are going to use `WSGIApplication` from our previous recipe, but instead
    of registering a function for a root, we are going to register a particular class
    able to dispatch based on the request method.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们之前的配方中的`WSGIApplication`，但是不是为根注册一个函数，而是注册一个能够根据请求方法进行分发的特定类。
- en: 'All the REST classes we want to implement must inherit from a single `RestController`
    implementation:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要实现的所有REST类都必须继承自单个`RestController`实现：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then we can subclass `RestController` to implement all the specific `GET`,
    `POST`, `DELETE`, and `PUT` methods and register the resources on a specific route:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以子类化`RestController`来实现所有特定的`GET`、`POST`、`DELETE`和`PUT`方法，并在特定路由上注册资源：
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This already provides basic functionalities that allow us to add, remove and
    list resources from an in-memory catalog.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经提供了基本功能，允许我们从内存目录中添加、删除和列出资源。
- en: 'To test this, we can start a server in a background thread and use the `http_request`
    function from our previous recipe:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以在后台线程中启动服务器，并使用我们之前的配方中的`http_request`函数：
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can then create a new resource:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以创建一个新的资源：
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here we list them all:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里我们列出它们全部：
- en: '[PRE78]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add a second one:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第二个：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, we see that now both resources are listed:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们看到现在列出了两个资源：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then we can ask for a specific resource out of the catalog:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以从目录中请求特定的资源：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can also delete a specific resource:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以删除特定的资源：
- en: '[PRE82]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then see that it was actually deleted:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后查看它是否已被删除：
- en: '[PRE83]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This should allow us to provide a REST interface for most simple cases relying
    on what is already available in the Python standard library itself.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该允许我们为大多数简单情况提供REST接口，依赖于Python标准库中已经可用的内容。
- en: How it works...
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Most of the magic is done by `RestController.__call__`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作由`RestController.__call__`完成：
- en: '[PRE84]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Whenever a subclass of `RestController` is called, it will look at the HTTP
    request method and look for an instance method named like the HTTP method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用`RestController`的子类时，它将查看HTTP请求方法，并查找一个命名类似于HTTP方法的实例方法。
- en: If there is one, the method is called and the response provided by the method
    itself returned. If there is none, then `self._not_found` is called, which will
    just respond a 404 error.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有的话，将调用该方法，并返回方法本身提供的响应。如果没有，则调用`self._not_found`，它将只响应404错误。
- en: This relies on the `WSGIApplication.__call__` support for classes instead of
    functions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于`WSGIApplication.__call__`对类而不是函数的支持。
- en: 'When `WSGIApplication.__call__` finds an object associated to a route through
    `app.route` that is a class, it will always create an instance of it, and then
    it will call the instance:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WSGIApplication.__call__`通过`app.route`找到与路由关联的对象是一个类时，它将始终创建它的一个实例，然后它将调用该实例：
- en: '[PRE85]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If `routed_action` is a `RestController` subclass, what will happen is that
    `routed_action = routed_action()` will replace the class with an instance of it,
    and then `routed_action(request, resp)` will call the `RestController.__call__` method
    to actually serve the request.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`routed_action`是`RestController`的子类，那么将会发生的是`routed_action = routed_action()`将用其实例替换类，然后`routed_action(request,
    resp)`将调用`RestController.__call__`方法来实际处理请求。
- en: The `RestController.__call__` method can then forward the request to the right
    instance method based on the HTTP method.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`RestController.__call__`方法可以根据HTTP方法将请求转发到正确的实例方法。
- en: 'Note that as REST resources are identified by providing the resource identifier
    in the URL, the route assigned to `RestController` must have an `id` argument
    and an optional `/`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于REST资源是通过在URL中提供资源标识符来识别的，因此分配给`RestController`的路由必须具有一个`id`参数和一个可选的`/`：
- en: '[PRE86]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Otherwise you won't be able to distinguish between a request for the whole `GET`
    resources catalog, `/resources`, and a request for a specific `GET` resource, `/resources/3`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您将无法区分对整个`GET`资源目录`/resources`的请求和对特定`GET`资源`/resources/3`的请求。
- en: 'The lack of an `id` argument is exactly the way our `GET` method decided when
    to return the content for the whole catalog or not:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少`id`参数正是我们的`GET`方法决定何时返回整个目录的内容或不返回的方式：
- en: '[PRE87]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: For methods that receive the data in the request body, such as `POST`, `PUT`,
    and `PATCH`, you will have to read the request body from `req.environ['wsgi.input']`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接收请求体中的数据的方法，例如`POST`，`PUT`和`PATCH`，您将不得不从`req.environ['wsgi.input']`读取请求体。
- en: In this case, it's important to provide exactly how many bytes to read, as the
    connection might never be closed, and the read might otherwise block forever.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重要的是提供要读取的字节数，因为连接可能永远不会关闭，否则读取可能会永远阻塞。
- en: 'The `Content-Length` header can be used to know the length of the input:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Length`头部可用于知道输入的长度：'
- en: '[PRE88]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Handling cookies
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理cookie
- en: Cookies are frequently used in web applications to store data in browsers. The
    most frequent use case is user identification.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，cookie经常用于在浏览器中存储数据。最常见的用例是用户识别。
- en: We are going to implement a very simple and insecure identification system based
    on cookies to show how to use them.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个非常简单且不安全的基于cookie的身份识别系统，以展示如何使用它们。
- en: How to do it...
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `http.cookies.SimpleCookie` class provides all the facilities required to
    parse and generate cookies.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.cookies.SimpleCookie`类提供了解析和生成cookie所需的所有设施。'
- en: 'We can rely on it to create a web application endpoint that will set a cookie:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以依赖它来创建一个将设置cookie的Web应用程序端点：
- en: '[PRE89]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can use it to create one that will parse the cookie and tell us who the
    current user is:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用它来创建一个解析cookie并告诉我们当前用户是谁的cookie：
- en: '[PRE90]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once you start the application you can point your browser to `http://localhost:8000`
    and you should see the web application complaining that you are lacking an identity:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动应用程序，您可以将浏览器指向`http://localhost:8000`，然后您应该看到Web应用程序抱怨您缺少身份：
- en: '[PRE91]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Once you click on the suggested link, you should get one and, going back to
    the index page, it should recognize you through the cookie.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 点击建议的链接后，您应该得到一个，返回到索引页面，它应该通过cookie识别您。
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SimpleCookie` class represents a cookie, as a set of one or more values.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleCookie`类表示一个或多个值的cookie。'
- en: 'Each value can be set into the cookie as if it was a dictionary:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值都可以像字典一样设置到cookie中：
- en: '[PRE92]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If the cookie `morsel` has to accept more options, those can be set with dictionary
    syntax too:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果cookie`morsel`必须接受更多选项，那么可以使用字典语法进行设置：
- en: '[PRE93]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Each cookie can contain multiple values and each one of them should be set with
    a `Set-Cookie` HTTP header.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 每个cookie可以包含多个值，每个值都应该使用`Set-Cookie` HTTP头进行设置。
- en: 'Iterating over the cookie will retrieve all the key/value pairs that constitute
    the cookie, and then calling `OutputString()` on them will return the cookie value
    encoded as expected by the `Set-Cookie` header, with all the additional attributes:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代cookie将检索构成cookie的所有键/值对，然后在它们上调用`OutputString()`将返回编码为`Set-Cookie`头部所期望的cookie值，以及所有其他属性：
- en: '[PRE94]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Practically, once the cookie is set, calling `OutputString()` will send you
    back the string you need to send to the browser:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一旦设置了cookie，调用`OutputString()`将会将您发送回浏览器的字符串：
- en: '[PRE95]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Reading back a cookie is as simple as building it from the `environ[''HTTP_COOKIE'']`
    value if it''s available:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 读取cookie与从`environ['HTTP_COOKIE']`值构建cookie一样简单，如果它可用的话：
- en: '[PRE96]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Once the cookie has parsed, the values stored within it can be accessed with
    dictionary syntax:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦cookie被解析，其中存储的值可以通过字典语法访问：
- en: '[PRE97]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: There's more...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When working with cookies, one particular condition you should pay attention
    to is their life cycle.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理cookie时，您应该注意的一个特定条件是它们的生命周期。
- en: Cookies can have an `Expires` attribute, which will state on which date they
    should die (the browser will discard them), and actually, that's the way you delete
    a cookie. Setting a cookie again with an `Expires` date in the past will delete
    it.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie可以有一个`Expires`属性，它将说明它们应该在哪个日期死亡（浏览器将丢弃它们），实际上，这就是您删除cookie的方式。使用过去日期的`Expires`日期再次设置cookie将删除它。
- en: But cookies can also have a `Max-Age` attribute, which states how long they
    should stick around or can be created as session cookies that will disappear when
    the browser window is closed.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 但是cookie也可以有一个`Max-Age`属性，它规定它们应该保留多长时间，或者可以创建为会话cookie，当浏览器窗口关闭时它们将消失。
- en: So, if you face problems with your cookies randomly disappearing or not being
    loaded back correctly, always check those properties as the cookie might just
    have been deleted by the browser.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您遇到cookie随机消失或未正确加载回来的问题，请始终检查这些属性，因为cookie可能刚刚被浏览器删除。
