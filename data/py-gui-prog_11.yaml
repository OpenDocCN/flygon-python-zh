- en: Connecting to the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到云
- en: It seems that nearly every application needs to talk to the outside world sooner
    or later, and your `ABQ data entry` application is no exception. You've received
    some new feature requests that will require some interactions with remote servers
    and services. First, the quality assurance division is doing a study of how local
    weather conditions are impacting the environmental data in each lab; they've requested
    a way to download and store local weather data in the database on demand. The
    second request is from your boss, who is still required to upload daily CSV files
    to the central corporate servers. She would like this process streamlined and
    available at a mouse click.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎几乎每个应用程序迟早都需要与外部世界交流，你的`ABQ数据录入`应用程序也不例外。您收到了一些新的功能请求，这将需要与远程服务器和服务进行一些交互。首先，质量保证部门正在研究当地天气条件如何影响每个实验室的环境数据；他们要求以按需下载和存储当地天气数据的方式。第二个请求来自您的老板，她仍然需要每天上传CSV文件到中央公司服务器。她希望这个过程能够简化，并且可以通过鼠标点击来完成。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Connecting to web services and downloading data using `urllib`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到Web服务并使用`urllib`下载数据
- en: Managing more complex HTTP interactions using the `requests` library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`requests`库管理更复杂的HTTP交互
- en: Connecting and uploading to FTP services using `ftplib`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ftplib`连接和上传到FTP服务
- en: HTTP using urllib
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`urllib`进行HTTP连接
- en: Every time you open a website in your browser, you're using the **Hyper Text
    Transfer Protocol, or HTTP**. HTTP was created over 25 years ago as a way for
    web browsers to download HTML documents, but has evolved into one of the most
    popular client-server communication protocols for any number of purposes. Not
    only can we use it to move everything from plain text to streaming video across
    the Internet, but applications can also use it to transfer data, initiate remote
    procedures, or distribute computing tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在浏览器中打开网站时，您都在使用**超文本传输协议，或HTTP**。 HTTP是在25年前创建的，作为Web浏览器下载HTML文档的一种方式，但已经发展成为最受欢迎的客户端-服务器通信协议之一，用于任何数量的目的。我们不仅可以使用它在互联网上传输从纯文本到流媒体视频的任何内容，而且应用程序还可以使用它来传输数据，启动远程过程或分发计算任务。
- en: 'A basic HTTP transaction includes a client and a server, which function as
    follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的HTTP事务包括客户端和服务器，其功能如下：
- en: '**Client**: The client creates a request.The request specifies an operation
    called a **method**. The most common methods are `GET`, for retrieving data, and
    `POST`, for submitting data. The request has a URL, which specifies the host,
    port, and path to which the request is being made, and headers which include metadata
    like the data-type or authorization tokens.  Finally, it has a payload, which
    may contain serialized data in key-value pairs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：客户端创建请求。请求指定一个称为**方法**的操作。最常见的方法是`GET`，用于检索数据，以及`POST`，用于提交数据。请求有一个URL，指定了请求所在的主机、端口和路径，以及包含元数据的标头，如数据类型或授权令牌。最后，它有一个有效负载，其中可能包含键值对中的序列化数据。'
- en: '**Server**: The server receives the request and returns a response. The response
    has a header containing metadata such as the status code or content-type of the
    response. It also has a payload containing the actual content of the response,
    such as HTML, XML, JSON, or binary data.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：服务器接收请求并返回响应。响应包含一个包含元数据的标头，例如响应的状态代码或内容类型。它还包含实际响应内容的有效负载，例如HTML、XML、JSON或二进制数据。'
- en: In a web browser, these operations take place in the background, but our application
    will deal directly with request and response objects in order to talk to remote
    HTTP servers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中，这些操作是在后台进行的，但我们的应用程序将直接处理请求和响应对象，以便与远程HTTP服务器进行通信。
- en: Basic downloading with urllib.request
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`urllib.request`进行基本下载
- en: The `urllib.request` module is a Python module for generating HTTP requests.
    It contains a number of functions and classes for generating HTTP requests, the
    most basic of which is the `urlopen()` function. The `urlopen()` function can
    create a `GET` or `POST` request and send it to a remote server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`urllib.request`模块是一个用于生成HTTP请求的Python模块。它包含一些用于生成HTTP请求的函数和类，其中最基本的是`urlopen()`函数。`urlopen()`函数可以创建`GET`或`POST`请求并将其发送到远程服务器。'
- en: 'Let''s explore how `urllib` works; open a Python shell and execute the following
    commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`urllib`的工作原理；打开Python shell并执行以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `urlopen()` function takes, at a minimum, a URL string. By default, it makes
    a `GET` request to the URL and returns an object that wraps the response received
    from the server. This `response` object exposes metadata or content received from
    the server, which we can use in our application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlopen()`函数至少需要一个URL字符串。默认情况下，它会向URL发出`GET`请求，并返回一个包装从服务器接收到的响应的对象。这个`response`对象公开了从服务器接收到的元数据或内容，我们可以在我们的应用程序中使用。'
- en: 'Much of the response''s metadata is found in the header, which we can extract
    using `getheader()` as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的大部分元数据都在标头中，我们可以使用`getheader()`来提取，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Responses have a status, indicating the error conditions encountered (if any)
    during the request process; the status has both a number and a text explanation,
    called `reason`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 响应具有状态，指示在请求过程中遇到的错误条件（如果有）；状态既有数字又有文本解释，称为`reason`。
- en: 'We can extract both from our `response` object as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的`response`对象中提取如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, a `200` status means the transaction was a success. Client-side
    errors, such as sending a bad URL or incorrect permissions, are indicated by statuses
    in the 400s, while server-side problems are indicated by statuses in the 500s.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`200`状态表示事务成功。客户端端错误，例如发送错误的URL或不正确的权限，由400系列的状态表示，而服务器端问题由500系列的状态表示。
- en: 'The payload of the `response` object can be retrieved using an interface similar
    to a file handle as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似于文件句柄的接口来检索`response`对象的有效负载，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just like a file handle, the response can only be read once, using the `read()`
    method; unlike a file handle, it can't be "rewound" using `seek()`, so it's important
    to save the response data in another variable if it needs to be accessed more
    than once. The output of `response.read()` is a bytes object, which should be
    cast or decoded into an appropriate object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像文件句柄一样，响应只能使用`read()`方法读取一次；与文件句柄不同的是，它不能使用`seek()`“倒带”，因此如果需要多次访问响应数据，重要的是将响应数据保存在另一个变量中。`response.read()`的输出是一个字节对象，应将其转换或解码为适当的对象。
- en: 'In this case, we have a `utf-8` string as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个`utf-8`字符串如下：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition to the `GET` requests, `urlopen()` can also generate `POST` requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`GET`请求之外，`urlopen()`还可以生成`POST`请求。
- en: 'To do this, we include a `data` argument as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们包括一个`data`参数如下：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `data` value needs to be a URL-encoded bytes object. The URL-encoded data
    string consists of key-value pairs separated by ampersand (`&`) symbols, with
    certain reserved characters encoded to URL-safe alternatives (for example, the
    space character is `%20`, or sometimes just `+`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`值需要是一个URL编码的字节对象。URL编码的数据字符串由用`&`符号分隔的键值对组成，某些保留字符被编码为URL安全的替代字符（例如，空格字符是`%20`，或者有时只是`+`）。'
- en: 'A string like this can be created by hand, but it''s easier to use the `urlencode`
    function provided by the `urllib.parse` module. Take a look at the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的字符串可以手工创建，但使用`urllib.parse`模块提供的`urlencode`函数更容易。看一下以下代码：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `data` argument must be bytes, not a string, so `encode()` must be called
    on the URL-encoded string before `urlopen` will accept it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`参数必须是字节，而不是字符串，因此在`urlopen`接受它之前必须对URL编码的字符串调用`encode()`。'
- en: Let's try downloading the weather data needed for our application. The site
    we'll be using is `http://weather.gov`, which provides weather data within the
    United States. The actual URL we'll be downloading is [http://w1.weather.gov/xml/current_obs/STATION.xml](http://w1.weather.gov/xml/current_obs/STATION.xml),
    where `STATION` is replaced by the call-sign of the local weather station. In
    the case of ABQ, we'll be using KBMG, located in Bloomington, Indiana.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试下载我们应用程序所需的天气数据。我们将使用`http://weather.gov`提供美国境内的天气数据。我们将要下载的实际URL是[http://w1.weather.gov/xml/current_obs/STATION.xml](http://w1.weather.gov/xml/current_obs/STATION.xml)，其中`STATION`被本地天气站的呼号替换。在ABQ的情况下，我们将使用位于印第安纳州布卢明顿的KBMG。
- en: The QA team wants you to record the temperature (in degrees Celsius), relative
    humidity, air pressure (in millibars), and sky conditions (a string, like overcast
    or fair). They also need the date and time at which the weather was observed by
    the station.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: QA团队希望您记录温度（摄氏度）、相对湿度、气压（毫巴）和天空状况（一个字符串，如阴天或晴天）。他们还需要天气站观测到天气的日期和时间。
- en: Creating a download function
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建下载函数
- en: 'We''re going to be creating several functions that access network resources
    for our application. These functions won''t be tied to any particular class, so
    we''ll just put them in their own file called `network.py`. Let''s take a look
    at the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建几个访问网络资源的函数，这些函数不会与任何特定的类绑定，因此我们将它们放在自己的文件`network.py`中。让我们看看以下步骤：
- en: Create `network.py` in the `abq_data_entry` module directory.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`abq_data_entry`模块目录中创建`network.py`。
- en: 'Now, let''s open `network.py` and start our weather download function:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开`network.py`并开始我们的天气下载功能：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our function will take a `station` string as an argument, in case we need to
    change that later or if someone wants to use this application at a different facility.
    The function begins by building the URL for the weather data and requests it using
    `urlopen()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数将以`station`字符串作为参数，以防以后需要更改，或者如果有人想在不同的设施使用这个应用程序。该函数首先通过构建天气数据的URL并使用`urlopen()`请求来开始。
- en: 'Assuming things went okay, we just need to parse out this `response` data and
    put it into a form the `Application` class can pass to the database model. To
    determine how we''ll handle the response, let''s go back to the Python shell and
    examine the data in it:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设事情进行顺利，我们只需要解析出这个`response`数据，并将其放入`Application`类可以传递给数据库模型的形式中。为了确定我们将如何处理响应，让我们回到Python
    shell并检查其中的数据：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the URL indicated, the payload of the response is an XML document, most
    of which we won''t need. After some searching, though, we can find the fields
    we''re after as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如URL所示，响应的有效负载是一个XML文档，其中大部分我们不需要。经过一些搜索，我们可以找到我们需要的字段如下：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Good, the data we need is there, so we just need to extract it from the XML
    string into a format our application can use. Let's take a moment to learn about
    parsing XML data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们需要的数据都在那里，所以我们只需要将它从XML字符串中提取出来，以便我们的应用程序可以使用。让我们花点时间了解一下解析XML数据。
- en: Parsing XML weather data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析XML天气数据
- en: The Python standard library contains an `xml` package, which consists of several
    submodules for parsing or creating XML data. The `xml.etree.ElementTree` submodule
    is a simple, lightweight parser that should meet our needs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库包含一个`xml`包，其中包含用于解析或创建XML数据的几个子模块。`xml.etree.ElementTree`子模块是一个简单、轻量级的解析器，应该满足我们的需求。
- en: 'Let''s import `ElementTree` into our `network.py` file as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`ElementTree`导入到我们的`network.py`文件中，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, back at the end of our function, we''ll parse the XML data in our `response` object
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在函数的末尾，我们将解析我们的`response`对象中的XML数据，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `fromstring()` method takes an XML string and returns an `Element` object.
    To get at the data we need, we'll need to understand what an `Element` object
    represents, and how to work with it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromstring()`方法接受一个XML字符串并返回一个`Element`对象。为了获得我们需要的数据，我们需要了解`Element`对象代表什么，以及如何使用它。'
- en: XML is a hierarchical representation of data; an element represents a node in
    this hierarchy. An element begins with a tag, which is a text string inside angle
    brackets. Each tag has a matching closing tag, which is just the tag with a forward-slash
    prepended to the tag name. Between the opening and closing tags, an element may
    have other child elements or it may have text. An element can also have attributes,
    which are key-value pairs placed inside the angle brackets of the opening tag,
    just after the tag name.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: XML是数据的分层表示；一个元素代表这个层次结构中的一个节点。一个元素以一个标签开始，这是尖括号内的文本字符串。每个标签都有一个匹配的闭合标签，这只是在标签名称前加上一个斜杠的标签。在开放和关闭标签之间，一个元素可能有其他子元素，也可能有文本。一个元素也可以有属性，这些属性是放在开放标签的尖括号内的键值对，就在标签名称之后。
- en: 'Take a look at the following example of XML:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下XML的示例：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is an (incomplete) XML description of the solar system. The root element
    has a tag of `<star_system>` with an attribute of `starname`. Under this root
    element, we have four `<planet>` elements and a `<dwarf_planet>` element, each
    of which contains a text node with the planet's name. Some of the planet nodes
    also have child `<moon>` nodes, each containing a text node with the moon's name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是太阳系的（不完整的）XML描述。根元素的标签是`<star_system>`，具有`starname`属性。在这个根元素下，我们有四个`<planet>`元素和一个`<dwarf_planet>`元素，每个元素都包含行星名称的文本节点。一些行星节点还有子`<moon>`节点，每个节点包含卫星名称的文本节点。
- en: Arguably, this data could have been structured differently; for example, planet
    names could have been in a child `<name>` node inside the planet elements, or
    listed as an attribute of the `<planet>` tag. While XML syntax is well-defined,
    the actual structure of an XML document is up to the creator, so fully parsing
    XML data requires a knowledge of the way the data is laid out in the document.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这些数据可以以不同的方式进行结构化；例如，行星名称可以在行星元素内部的子`<name>`节点中，或者作为`<planet>`标签的属性列出。虽然XML语法是明确定义的，但XML文档的实际结构取决于创建者，因此完全解析XML数据需要了解数据在文档中的布局方式。
- en: If you look at the XML weather data that we downloaded in the shell earlier,
    you'll notice it's a fairly shallow hierarchy. Under the `<current_observations>`
    node, there are a number of child elements whose tags represent specific data
    fields like temperature, humidity, windchill, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在之前在shell中下载的XML天气数据中查看，您会注意到它是一个相当浅的层次结构。在`<current_observations>`节点下，有许多子元素，它们的标签代表特定的数据字段，如温度、湿度、风寒等。
- en: 'To get at these child elements, `Element` offers us the following variety of
    methods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这些子元素，`Element`为我们提供了以下各种方法：
- en: '| **Method** | **Returns** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **返回** |'
- en: '| `iter()` | An iterator of all child nodes (recursively) |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `iter()` | 所有子节点的迭代器（递归） |'
- en: '| `find(tag)` | The first element matching the given tag |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `find(tag)` | 匹配给定标签的第一个元素 |'
- en: '| `findall(tag)` | A list of elements matching the given tag |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `findall(tag)` | 匹配给定标签的元素列表 |'
- en: '| `getchildren()` | A list of the immediate child nodes |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `getchildren()` | 直接子节点的列表 |'
- en: '| `iterfind(tag)` | An iterator of all child nodes matching the given tag (recursive)
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `iterfind(tag)` | 匹配给定标签的所有子节点的迭代器（递归） |'
- en: 'When we downloaded the XML data earlier, we identified five tags containing
    the data we want to extract from this document: `<observation_time_rfc822>`, `<weather>`,
    `<temp_c>`, `<relative_humidity>`, and `<pressure_mb>`. We''ll want our `get_local_weather()`
    function to return a Python `dict` containing each of these keys.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候我们下载XML数据时，我们确定了包含我们想要从该文档中提取的数据的五个标签：`<observation_time_rfc822>`、`<weather>`、`<temp_c>`、`<relative_humidity>`和`<pressure_mb>`。我们希望我们的`get_local_weather()`函数返回一个包含每个键的Python
    `dict`。
- en: 'Let''s add the next lines in the `network.py` file as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`network.py`文件中添加以下行：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our first line extracts the raw XML from the response and parses it into an
    `Element` tree, returning the root node to `xmlroot`. Then, we've set up `dict`
    containing the tags we want to extract from our XML data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一行从响应中提取原始XML并将其解析为`Element`树，将根节点返回给`xmlroot`。然后，我们设置了包含我们想要从XML数据中提取的标签的`dict`。
- en: 'Now, let''s get the values by executing the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行以下代码来获取值：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For each of our tag names, we're going to use the `find()` method to try to
    locate the element with a matching tag in `xmlroot`. This particular XML document
    does not use duplicate tags, so the first instance of any tag should be the only
    one. If the tag is matched, we'll get back an `Element` object; if not, we get
    back `None`, so we need to make sure `element` is not `None` before trying to
    access its `text` value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的每个标签名称，我们将使用`find()`方法来尝试在`xmlroot`中定位具有匹配标签的元素。这个特定的XML文档不使用重复的标签，所以任何标签的第一个实例应该是唯一的。如果匹配了标签，我们将得到一个`Element`对象；如果没有，我们将得到`None`，因此在尝试访问其`text`值之前，我们需要确保`element`不是`None`。
- en: To finish the function just return `weatherdata` .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成函数，只需返回`weatherdata`。
- en: 'You can test this function in the Python shell; from a command line, navigate
    to the `ABQ_Data_Entry` directory and start a Python shell:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python shell中测试此函数；从命令行，导航到`ABQ_Data_Entry`目录并启动Python shell：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should get back a `dict` with the current weather conditions in Bloomington,
    Indiana. You can find the station codes for other cities inside the U.S. at [http://w1.weather.gov/xml/current_obs/](http://w1.weather.gov/xml/current_obs/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到一个包含印第安纳州布卢明顿当前天气状况的`dict`。您可以在[http://w1.weather.gov/xml/current_obs/](http://w1.weather.gov/xml/current_obs/)找到美国其他城市的站点代码。
- en: Now that we have our weather function, we just need to build the table for storing
    the data and the interface for triggering the operation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了天气函数，我们只需要构建用于存储数据和触发操作的表格。
- en: Implementing weather data storage
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现天气数据存储
- en: To store our weather data, we'll start by creating a table in the ABQ database
    to hold the individual observation data, then build a `SQLModel` method to store
    data in it. We don't need to worry about writing code to retrieve data from it,
    since our laboratory's QA team has their own reporting tools which they'll use
    to access it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储我们的天气数据，我们将首先在ABQ数据库中创建一个表来保存单独的观测数据，然后构建一个`SQLModel`方法来存储数据。我们不需要担心编写代码来检索数据，因为我们实验室的质量保证团队有他们自己的报告工具，他们将使用它来访问数据。
- en: Creating the SQL table
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SQL表
- en: 'Open the `create_db.sql` file, and add a new `CREATE TABLE` statement as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`create_db.sql`文件，并添加一个新的`CREATE TABLE`语句如下：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We're using the `TIMESTAMP` data type on the record as a primary key; there's
    no point in saving the same timestamped observation twice, so this makes an adequate
    key. The `(0)` size after the `TIMESTAMP` data type indicates how many decimal
    places we need for the seconds' measurement. Since these measurements are taken
    approximately hourly, and we only need one every four hours or so (when the lab
    checks are done), we don't need fractions of seconds in our timestamp.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在记录上使用`TIMESTAMP`数据类型作为主键；保存相同时间戳的观测两次是没有意义的，所以这是一个足够好的键。`TIMESTAMP`数据类型后面的`(0)`大小表示我们需要多少小数位来测量秒。由于这些测量大约每小时进行一次，而且我们每四个小时或更长时间（实验室检查完成时）只需要一次，所以在我们的时间戳中不需要秒的小数部分。
- en: Notice that we're saving the time zone; always store time zone data with timestamps
    when it's available! It may not seem necessary, especially when your application
    will be run in a workplace that will never change time zones, but there are many
    edge cases such as daylight-saving time changes where the lack of a time zone
    can create major problems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们保存了时区；当时间戳可用时，始终将时区数据与时间戳一起存储！这可能看起来并不必要，特别是当您的应用程序将在永远不会改变时区的工作场所运行时，但是有许多边缘情况，比如夏令时变化，缺少时区可能会造成重大问题。
- en: Run this `CREATE` query in your database to build the table, and let's move
    on to creating our `SQLModel` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中运行这个`CREATE`查询来构建表，然后我们继续创建我们的`SQLModel`方法。
- en: Implementing the SQLModel.add_weather_data() method
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现SQLModel.add_weather_data()方法
- en: Over in `models.py`, let's add a new method to the `SQLModel` class called `add_weather_data()`,
    which takes a data `dict` as its only argument.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`中，让我们添加一个名为`add_weather_data()`的新方法到`SQLModel`类中，它只接受一个数据`dict`作为参数。
- en: 'Let''s start this method by writing an `INSERT` query as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下方式开始这个方法，编写一个`INSERT`查询：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a straightforward parameterized `INSERT` query using variable names
    that match the `dict` keys that the `get_local_weather()` function extracts from
    the XML data. We should only need to pass this query and the data `dict` into
    our `query()` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用与`get_local_weather()`函数从XML数据中提取的`dict`键匹配的变量名的参数化`INSERT`查询。我们只需要将这个查询和数据`dict`传递给我们的`query()`方法。
- en: There is one problem, however; if we get a duplicate timestamp, our query will
    fail due to a duplicate primary key. We could do another query to check first,
    but that would be slightly redundant, since PostgreSQL itself checks for duplicate
    keys before inserting a new row. When it detects such an error, `psycopg2` raises
    an `IntegrityError` exception, so we just need to catch this exception and, if
    it gets raised, do nothing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题；如果我们得到重复的时间戳，我们的查询将因为重复的主键而失败。我们可以先进行另一个查询来检查，但这有点多余，因为PostgreSQL在插入新行之前会检查重复的键。当它检测到这样的错误时，`psycopg2`会引发一个`IntegrityError`异常，所以我们只需要捕获这个异常，如果它被引发了，就什么都不做。
- en: 'To do this, we''ll wrap our `query()` call in the `try...except` blocks as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在`try...except`块中包装我们的`query()`调用如下：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, our data entry staff can call this method as often as they wish, but it
    will only save a record when there is a fresh observation to save.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据录入人员可以随意调用这个方法，但只有在有新的观测数据需要保存时才会保存记录。
- en: Updating the SettingsModel class
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`SettingsModel`类
- en: 'Before leaving `models.py`, we will need to add a new application setting to
    store the preferred weather station. Add a new entry in the `SettingsModel.variables`
    dictionary as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开`models.py`之前，我们需要添加一个新的应用程序设置来存储首选的天气站。在`SettingsModel.variables`字典中添加一个新条目如下：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We won't add a GUI for this setting, since users won't need to update it. It'll
    be up to us, or the system admin at other lab sites, to make sure this is properly
    set on each workstation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为这个设置添加GUI，因为用户不需要更新它。这将由我们或其他实验室站点的系统管理员来确保在每台工作站上正确设置。
- en: Adding the GUI elements for weather download
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加天气下载的GUI元素
- en: 'The `Application` object now needs to connect the weather download method from
    `network.py` to the database method in `SQLModel` with an appropriate callback
    method that the main menu classes can call. Follow these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`对象现在需要将`network.py`中的天气下载方法与`SQLModel`中的数据库方法连接起来，并使用适当的回调方法，主菜单类可以调用。按照以下步骤进行：'
- en: 'Open `application.py` and start a new method as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`application.py`并开始一个新的方法如下：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Recall that in an error scenario, `urlopen()` can raise any number of exceptions,
    depending on what went wrong with the HTTP transaction. There isn''t really anything
    the application can do to handle such exceptions other than inform the user and
    exit the method. Therefore, we''ll catch the generic `Exception` and display the
    text in `messagebox` as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，在错误场景中，`urlopen()`可能会引发任意数量的异常，这取决于HTTP事务出了什么问题。应用程序除了通知用户并退出方法外，实际上没有什么可以处理这些异常的。因此，我们将捕获通用的`Exception`并在`messagebox`中显示文本如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the event that `get_local_weather()` succeeds, we simply need to pass the
    data on to our model method as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`get_local_weather()`成功，我们只需要将数据传递给我们的模型方法如下：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In addition to saving the data, we've notified the user in the status bar that
    the weather was updated and displayed the timestamp of the update.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保存数据，我们还在状态栏中通知用户天气已更新，并显示更新的时间戳。
- en: 'With the callback method done, let''s add it to our `callbacks` dictionary:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调方法完成后，让我们将其添加到我们的`callbacks`字典中：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can now add a command item for the callback in the main menu. On Windows,
    functionality like this goes in the `Tools` menu, and since neither the Gnome
    nor macOS guidelines seem to indicate a more appropriate location, we''ll implement
    a `Tools` menu in the `LinxMainMenu` and `MacOsMainMenu` classes to hold this
    command, just to be consistent.  In `mainmenu.py`, starting in the generic menu
    class, add a new menu as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在主菜单中添加一个回调的命令项。在Windows上，这样的功能放在`Tools`菜单中，由于Gnome和macOS的指南似乎没有指示更合适的位置，我们将在`LinxMainMenu`和`MacOsMainMenu`类中实现一个`Tools`菜单来保存这个命令，以保持一致。在`mainmenu.py`中，从通用菜单类开始，添加一个新菜单如下：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add this same menu to the macOS and Linux menu classes, and add the command
    to the Windows main menu''s `tools_menu`. After updating the menus, you can run
    the application and try the new command from the `Tools` menu. If all went well,
    you should see an indication in the status bar as shown in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的菜单添加到macOS和Linux菜单类中，并将命令添加到Windows主菜单的`tools_menu`。更新菜单后，您可以运行应用程序并尝试从`Tools`菜单中运行新命令。如果一切顺利，您应该在状态栏中看到如下截图所示的指示：
- en: '![](assets/70ad36a4-d8f7-4fd2-ab4c-544dbb793be8.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70ad36a4-d8f7-4fd2-ab4c-544dbb793be8.png)'
- en: 'You should also connect to the database with your PostgreSQL client and check
    that the table contains some weather data now by executing the following SQL command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还应该使用您的PostgreSQL客户端连接到数据库，并通过执行以下SQL命令来检查表中是否现在包含一些天气数据：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That SQL statement should return output similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该SQL语句应返回类似以下的输出：
- en: '| `datetime` | `temperature` | `rel[hum]` | `pressure` | `conditions` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `datetime` | `temperature` | `rel[hum]` | `pressure` | `conditions` |'
- en: '| `2018-02-14 22:53:00-06` | `15.00` | `87.00` | `1014.00` | `Overcast` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `2018-02-14 22:53:00-06` | `15.00` | `87.00` | `1014.00` | `Overcast` |'
- en: HTTP using requests
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用requests进行HTTP
- en: You've been asked to create a function in your program to upload a CSV extract
    of the daily data to ABQ's corporate web services, which uses an authenticated
    REST API. While `urllib` is easy enough to use for simple one-off `GET` and `POST`
    requests, complex interactions involving authentication tokens, file uploads,
    or REST services can be frustrating and complicated using `urllib` alone. To get
    this done, we'll turn to the `requests` library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您被要求在您的程序中创建一个函数，将每日数据的CSV提取上传到ABQ的企业Web服务，该服务使用经过身份验证的REST API。虽然`urllib`足够简单，用于简单的一次性`GET`和`POST`请求，但涉及身份验证令牌、文件上传或REST服务的复杂交互令人沮丧和复杂，仅使用`urllib`就很困难。为了完成这项任务，我们将转向`requests`库。
- en: '**REST** stands for **REpresentational State Transfer**, and is the name used
    for web services built around advanced HTTP semantics. In addition to `GET` and
    `POST`, REST APIs use additional HTTP methods like `DELETE`, `PUT`, and `PATCH`,
    along with data formats like XML or JSON, to present an API with a complete range
    of interactions.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**REpresentational State Transfer**，是围绕高级HTTP语义构建的Web服务的名称。除了`GET`和`POST`，REST
    API还使用额外的HTTP方法，如`DELETE`，`PUT`和`PATCH`，以及XML或JSON等数据格式，以提供完整范围的API交互。'
- en: The third-party `requests` library is highly recommended by the Python community
    for any serious work involving HTTP (even the `urllib` documentation recommends
    it). As you'll see, `requests` removes many of the rough edges and outdated assumptions
    left in `urllib`, and provides convenient classes and wrapper functions for more
    modern HTTP transactions. Complete documentation on `requests` can be found at
    [http://docs.python-requests.org](http://docs.python-requests.org), but the next
    section will cover most of what you need to know to use it effectively.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区强烈推荐第三方的`requests`库，用于涉及HTTP的任何严肃工作（即使`urllib`文档也推荐它）。正如您将看到的，`requests`消除了`urllib`中留下的许多粗糙边缘和过时假设，并为更现代的HTTP交易提供了方便的类和包装函数。`requests`的完整文档可以在[http://docs.python-requests.org](http://docs.python-requests.org)找到，但下一节将涵盖您有效使用它所需的大部分内容。
- en: Installing and using requests
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和使用requests
- en: The `requests` package is written in pure Python, so installing it with `pip`
    requires no compiling or binary downloads. Simply type `pip install --user requests`
    in the terminal and it will be added to your system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`包是用纯Python编写的，因此使用`pip`安装它不需要编译或二进制下载。只需在终端中输入`pip install --user
    requests`，它就会被添加到您的系统中。'
- en: 'Open your Python shell, and let''s make some requests as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的Python shell，让我们进行如下请求：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`requests.request` requires, at minimum, an HTTP method and a URL. Just like
    `urlopen()`, it constructs the appropriate request packet, sends it to the URL,
    and returns an object representing the server''s response. Here, we''re making
    a `GET` request to this author''s website.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests.request`至少需要一个HTTP方法和一个URL。就像`urlopen()`一样，它构造适当的请求数据包，将其发送到URL，并返回表示服务器响应的对象。在这里，我们正在向这位作者的网站发出`GET`请求。'
- en: In addition to the `request()` function, `requests` has shortcut functions that
    correspond to the most common HTTP methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`request()`函数，`requests`还有与最常见的HTTP方法对应的快捷函数。
- en: 'Thus, the same request can be made as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以进行相同的请求如下：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `get()` method requires only the URL and performs a `GET` request. Likewise,
    the `post()`, `put()`, `patch()`, `delete()`, and `head()` functions send requests
    using the corresponding HTTP method. All of the request functions take additional
    optional arguments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法只需要URL并执行`GET`请求。同样，`post()`，`put()`，`patch()`，`delete()`和`head()`函数使用相应的HTTP方法发送请求。所有请求函数都接受额外的可选参数。'
- en: 'For example, we can send data with a `POST` request as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过`POST`请求发送数据如下：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that, unlike `urlopen()`, we can use a Python dictionary directly as
    a `data` argument; `requests` does the job of converting it to the proper bytes
    object for us.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`urlopen()`不同的是，我们可以直接使用Python字典作为`data`参数；`requests`会将其转换为适当的字节对象。
- en: 'Some of the more common arguments used with request functions are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求函数一起使用的一些常见参数如下：
- en: '| **Argument** | **Purpose** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **目的** |'
- en: '| `params` | Like `data`, but added to the query string rather than the payload
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `params` | 类似于`data`，但添加到查询字符串而不是有效负载 |'
- en: '| `json` | JSON data to include in the payload |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `json` | 要包含在有效负载中的JSON数据 |'
- en: '| `headers` | A dictionary of header data to use for the request |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `headers` | 用于请求的头数据字典 |'
- en: '| `files` | A dictionary of `{fieldnames: file objects}` to send as a multipart
    form data request |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `files` | 一个`{fieldnames: file objects}`字典，作为多部分表单数据请求发送 |'
- en: '| `auth` | Username and password tuple to use for basic HTTP digest authentication
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `auth` | 用于基本HTTP摘要身份验证的用户名和密码元组 |'
- en: The requests.session() fucntion
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: requests.session()函数
- en: Web services, particularly privately owned ones, are often password protected.
    Sometimes, this is done using the older HTTP digest authentication system, which
    we can address using the `auth` argument of the request functions. More commonly
    these days though, authentication involves posting credentials to a REST endpoint
    to obtain a session cookie or authentication token that is used to validate subsequent
    requests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务，特别是私人拥有的服务，通常是受密码保护的。有时，这是使用较旧的HTTP摘要身份验证系统完成的，我们可以使用请求函数的`auth`参数来处理这个问题。不过，如今更常见的是，身份验证涉及将凭据发布到REST端点以获取会话cookie或认证令牌，用于验证后续请求。
- en: An endpoint is simply a URL that corresponds to data or functionality exposed
    by the API. Data is sent to or retrieved from an endpoint.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 端点简单地是与API公开的数据或功能对应的URL。数据被发送到端点或从端点检索。
- en: The `requests` method makes all of this simple by providing the `Session` class.
    A `Session` object allows you to persist settings, cookies, and connections across
    multiple requests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`方法通过提供`Session`类使所有这些变得简单。`Session`对象允许您在多个请求之间持久保存设置、cookie和连接。'
- en: 'To create a `Session` object, use the `requests.session()` factory function
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Session`对象，使用`requests.session()`工厂函数如下：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can call request methods like `get()`, `post()`, and others on our
    `Session` object as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的`Session`对象上调用请求方法，如`get()`、`post()`等，如下所示：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Token and cookie handling like this happens in the background, without any explicit
    action from us. Cookies are stored in a `CookieJar` object stored as our `Session`
    object's `cookies` property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的令牌和cookie处理是在后台进行的，我们不需要采取任何明确的操作。Cookie存储在`CookieJar`对象中，存储为我们的`Session`对象的`cookies`属性。
- en: 'We can also set values on our `Session` object that will persist across requests
    as in this example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`Session`对象上设置值，这些值将在请求之间持续存在，就像这个例子中一样：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we've set the user-agent string to `Mozilla`, which will be
    used for all requests made from this `Session` object. We can also set default
    URL parameters using the `params` property or callback functions using the `hooks`
    property.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将用户代理字符串设置为`Mozilla`，这将用于从这个`Session`对象发出的所有请求。我们还可以使用`params`属性设置默认的URL参数，或者使用`hooks`属性设置回调函数。
- en: The response objects
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应对象
- en: The response objects returned from these request functions are not the same
    as those returned by `urlopen()`; they contain all the same data, but in a slightly
    different (and generally more convenient) form.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些请求函数返回的响应对象与`urlopen()`返回的对象不同；它们包含相同的数据，但以稍微不同（通常更方便）的形式返回。
- en: 'For example, the response headers are already translated into a Python `dict`
    for us, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，响应头已经被转换成Python的`dict`，如下所示：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Another difference is that `requests` does not automatically raise an exception
    on HTTP errors. However, the `.raise_for_status()` response method can be called
    to do so.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，`requests`不会自动在HTTP错误时引发异常。但是，可以调用`.raise_for_status()`响应方法来实现这一点。
- en: 'For example, this URL will give an HTTP `404` error, as shown in the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个URL将返回一个HTTP `404`错误，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This gives us the option of dealing with HTTP errors using exception handling
    or more traditional flow control logic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以选择使用异常处理或更传统的流程控制逻辑来处理HTTP错误。
- en: Implementing API upload
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API上传
- en: To start implementing our upload function, we need to figure out what kind of
    requests we're going to send. We've been provided with some documentation from
    the corporate office that describes how to interact with the REST API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现我们的上传功能，我们需要弄清楚我们将要发送的请求的类型。我们已经从公司总部得到了一些关于如何与REST API交互的文档。
- en: 'The documentation tells us the following things:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文档告诉我们以下内容：
- en: We first need to obtain an authentication token. We do this by submitting a
    `POST` request to the `/auth` endpoint. The parameters of the `POST` request should
    include `username` and `password`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要获取一个认证令牌。我们通过向`/auth`端点提交一个`POST`请求来实现这一点。`POST`请求的参数应包括`username`和`password`。
- en: With the authentication token acquired, we'll need to submit our CSV file. The
    request is a `PUT` request sent to the `/upload` endpoint. The file is uploaded
    as multipart form data specified in a `file` parameter.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得认证令牌后，我们需要提交我们的CSV文件。请求是一个发送到`/upload`端点的`PUT`请求。文件作为多部分表单数据上传，指定在`file`参数中。
- en: We already know enough to implement our REST upload function using `requests`,
    but before we do, let's create a service that we can use to test our code against
    it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道足够的知识来使用`requests`实现我们的REST上传功能，但在这之前，让我们创建一个服务，我们可以用来测试我们的代码。
- en: Creating a test HTTP service
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试HTTP服务
- en: Developing code that interoperates with an outside service can be frustrating.
    We're going to need to send a lot of bad or test data to the service while writing
    and debugging our code; we don't want to do so against a production service, and
    a "test mode" is not always available. Automated tests can use a `Mock` object
    to patch out network requests altogether, but during development, it's nice to
    be able to see what's actually going to be sent out to the web service.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 开发与外部服务互操作的代码可能会很令人沮丧。在编写和调试代码时，我们需要向服务发送大量错误或测试数据；我们不希望在生产服务中这样做，而且“测试模式”并不总是可用的。自动化测试可以使用`Mock`对象来完全屏蔽网络请求，但在开发过程中，能够看到实际发送到Web服务的内容是很好的。
- en: Let's implement a very simple HTTP server that will accept our requests and
    print out information about what it receives. We can do this using the Python
    standard library's `http.server` module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个非常简单的HTTP服务器，它将接受我们的请求并打印有关其接收到的信息。我们可以使用Python标准库的`http.server`模块来实现这一点。
- en: 'The module documentation shows the following example of a basic HTTP server:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文档显示了一个基本HTTP服务器的示例：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The server class, `HTTPServer`, defines an object that listens for HTTP requests
    on the configured address and port. The handler class, `BaseHTTPRequestHandler`,
    defines an object that receives the actual request data and returns response data.
    We'll use this code as a starting point, so save it outside the `ABQ_Data_Entry`
    directory in a file called `sample_http_server.py`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器类`HTTPServer`定义了一个对象，该对象在配置的地址和端口上监听HTTP请求。处理程序类`BaseHTTPRequestHandler`定义了一个接收实际请求数据并返回响应数据的对象。我们将使用此代码作为起点，因此请将其保存在名为`sample_http_server.py`的文件中，保存在`ABQ_Data_Entry`目录之外。
- en: If you run this code, you'll have a web service running on port `8000` on your
    local computer; however, if you make any requests to this service either using
    `requests`, a tool like `curl`, or just a web browser, you'll find it only returns
    an HTTP `501` (`unsupported method`) error. To make a server that works sufficiently,
    like our target API for testing purposes, we'll need to create our own handler
    class that can respond to the necessary HTTP methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，您将在本地计算机的端口`8000`上运行一个Web服务；但是，如果您对此服务进行任何请求，无论是使用`requests`、类似`curl`的工具，还是只是一个Web浏览器，您都会发现它只返回一个HTTP`501`（`不支持的方法`）错误。为了创建一个足够工作的服务器，就像我们的目标API用于测试目的一样，我们需要创建一个自己的处理程序类，该类可以响应必要的HTTP方法。
- en: 'To do that, we''ll create our own handler class called `TestHandler` as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将创建一个名为`TestHandler`的自定义处理程序类，如下所示：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our corporate API uses the `POST` method to receive login credentials, and the
    `PUT` method to receive files, so both of those need to work. To make an HTTP
    method work in a request handler, we need to implement a `do_VERB` method, where
    `VERB` is our HTTP method name in all uppercase.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的公司API使用`POST`方法接收登录凭据，使用`PUT`方法接收文件，因此这两种方法都需要工作。要使HTTP方法在请求处理程序中起作用，我们需要实现一个`do_VERB`方法，其中`VERB`是我们的HTTP方法名称的大写形式。
- en: 'So, for `PUT` and `POST`  add the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`PUT`和`POST`，添加以下代码：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This alone doesn't address the problem, because these methods need to result
    in our handler sending some kind of response. We don't need any particular response
    for our purposes; just something with a status of `200` (`OK`) will do fine.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅这样还不能解决问题，因为这些方法需要导致我们的处理程序发送某种响应。对于我们的目的，我们不需要任何特定的响应；只要有一个状态为`200`（`OK`）的响应就可以了。
- en: 'Since both methods need this, let''s add a third method we can call from the
    other two as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两种方法都需要这个，让我们添加一个第三种方法，我们可以从其他两种方法中调用如下：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is about the most minimal response required to satisfy most HTTP clients:
    a status of `200` and a header with a valid `Content-type`. This won''t send any
    actual data back to the client, but will tell the client its request was received
    and successfully processed.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数HTTP客户端所需的最小响应：状态为`200`，带有有效`Content-type`的标头。这不会向客户端发送任何实际数据，但会告诉客户端其请求已被接收并成功处理。
- en: Something else we'd like to do in our methods is print out any data that was
    sent, so we can make sure our client is sending the right data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的方法中还想做的另一件事是打印出发送的任何数据，以便我们可以确保我们的客户端发送了正确的数据。
- en: 'We''ll implement the following method that does this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现以下方法来实现这一点：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The handler object's `headers` property is a `dict` object containing the request
    headers, which includes the number of bytes sent (`content-length`). Apart from
    printing that information, we can also use it to read the data sent. The handler's
    `rfile` property is a file-like object containing the data; its `read()` method
    requires a length argument to specify how much data should be read, so we use
    our extracted `content-length` value. The returned data is a `bytes` object, so
    we decode it to `utf-8`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序对象的`headers`属性是一个包含请求标头的`dict`对象，其中包括发送的字节数（`content-length`）。除了打印该信息之外，我们还可以使用它来读取发送的数据。处理程序的`rfile`属性是一个类似文件的对象，其中包含数据；其`read()`方法需要一个长度参数来指定应该读取多少数据，因此我们使用我们提取的`content-length`值。返回的数据是一个`bytes`对象，因此我们将其解码为`utf-8`。
- en: 'Now that we have these two methods, let''s update `do_POST()` and `do_PUT()`
    to call them as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两种方法，让我们更新`do_POST()`和`do_PUT()`来调用它们，如下所示：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, each method will print out the length and data it receives to `POST` or
    `PUT` as well as any data. Run this script in a terminal window so you can monitor
    its output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个方法都将打印出它接收到的`POST`或`PUT`的长度和数据，以及任何数据。在终端窗口中运行此脚本，以便您可以监视其输出。
- en: 'Now, open a shell and let''s test it as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开一个shell，让我们测试它，如下所示：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the web server terminal, you should see the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web服务器终端中，您应该看到以下输出：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We could implement additional functionality, like actually checking credentials
    and returning an authentication token, but for now this server does enough to
    help us write and test our client code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现其他功能，比如实际检查凭据并返回身份验证令牌，但目前此服务器已足够帮助我们编写和测试客户端代码。
- en: Creating our network function
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的网络功能
- en: 'Now that our test service is up and running, let''s start working on the network
    function that will interact with the REST API:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试服务已经启动，让我们开始编写与REST API交互的网络功能：
- en: 'We''ll start by creating a function in `network.py` that will take a path to
    the CSV file, the upload and authentication URLs, and a username and password:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`network.py`中创建一个函数，该函数将接受CSV文件的路径、上传和身份验证URL以及用户名和密码：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since we''re going to have to deal with authentication tokens, the first thing
    we should do is create a session. We''ll call it `session` as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将不得不处理身份验证令牌，我们应该做的第一件事是创建一个会话。我们将其称为`session`，如下所示：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After creating the session, we post our username and password to the authentication
    endpoint like so:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建会话后，我们将用户名和密码发布到身份验证端点，如下所示：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `session` object will automatically store the token we receive if we're
    successful. In the event of a problem, we've called `raise_for_status()`, so that
    the function will abort and the calling code can handle any exceptions raised
    by network or data problems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，`session`对象将自动存储我们收到的令牌。如果出现问题，我们调用`raise_for_status()`，这样函数将中止，调用代码可以处理网络或数据问题引发的任何异常。
- en: 'Assuming we haven''t raised an exception, we must be authenticated at this
    point and can now submit the file. This will be done with a `put()` call as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们没有引发异常，那么在这一点上我们必须经过身份验证，现在可以提交文件了。这将通过`put()`调用完成，如下所示：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To send a file, we have to actually open it and pass it into `put()` as a file
    handle; notice we open it in binary-read mode (`rb`). The `requests` documentation
    recommends this as it ensures the correct `content-length` value will be calculated
    for the header.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 发送文件，我们实际上必须打开它并将其作为文件句柄传递给`put()`；请注意，我们以二进制读取模式（`rb`）打开它。`requests`文档建议这样做，因为它确保正确的`content-length`值将被计算到头部中。
- en: 'After sending the request, we close the file and check again for a failed status
    before ending the function, like so:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求后，我们关闭文件并再次检查失败状态，然后结束函数，如下所示：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Updating application
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新应用程序
- en: 'Before we can call our new function from `Application`, we need to implement
    a way to create a CSV extract of the daily data. This will be used by more than
    one function, so we''ll implement it separately from the function that calls the
    upload code. Follow along with these steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以从`Application`中调用新函数之前，我们需要实现一种方法来创建每日数据的CSV提取。这将被多个函数使用，因此我们将它与调用上传代码的函数分开实现。按照以下步骤进行：
- en: 'To begin, we''ll need a temporary location to store our generated CSV file. 
    The `tempfile` module includes functions to work with temporary files and directories;
    we''ll import `mkdtemp()`, which will give us a name for a platform-specific temporary
    directory.:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个临时位置来存储我们生成的CSV文件。`tempfile`模块包括用于处理临时文件和目录的函数；我们将导入`mkdtemp()`，它将为我们提供一个特定于平台的临时目录的名称。
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that `mdktemp()` doesn't actually create a directory; it merely provides
    an absolute path to a randomly named directory in the platform's preferred `temp`
    file location. We'll have to create the directory ourselves.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`mdktemp()`实际上并不创建目录；它只是在平台首选的`temp`文件位置中提供一个随机命名的目录的绝对路径。我们必须自己创建目录。
- en: 'Now, let''s start our new `Application` method as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们的新`Application`方法，如下所示：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After creating a temporary directory name, we've created an instance of our
    `CSVModel` class; even though we're no longer storing our data in the CSV files,
    we can still use the model to export a CSV file. We've passed the `Application`
    object's default filename, which is still set to `abq_data_record-CURRENTDATE.csv`,
    and also the temporary directory's path as `filepath`. Of course, our `CSVModel`
    doesn't currently take a `filepath`, but we'll fix that in a moment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 创建临时目录名称后，我们创建了我们的`CSVModel`类的一个实例；即使我们不再将数据存储在CSV文件中，我们仍然可以使用该模型导出CSV文件。我们传递了`Application`对象的默认文件名，仍然设置为`abq_data_record-CURRENTDATE.csv`，以及临时目录的路径作为`filepath`。当然，我们的`CSVModel`目前并不接受`filepath`，但我们马上就会解决这个问题。
- en: 'After creating the CSV model, we''ll extract our records from the database
    as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CSV模型后，我们将从数据库中提取我们的记录，如下所示：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Remember that our `SQLModel.get_all_records()` method returns a list of all
    records for the current day by default. If we don't happen to have any records
    for the day, it's probably best to stop right away and alert the user, rather
    than sending an empty CSV file to corporate, so we return `None` from the method
    if there are no records. Our calling code can test for a `None` return value and
    display the appropriate warning.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的`SQLModel.get_all_records()`方法默认返回当天的所有记录的列表。如果我们碰巧没有当天的记录，最好立即停止并警告用户，而不是将空的CSV文件发送给公司，因此如果没有记录，我们从方法中返回`None`。我们的调用代码可以测试`None`返回值并显示适当的警告。
- en: 'Now all we need to do is iterate through the records and save each one to the
    CSV, then return the `CSVModel` object''s filename, like this:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要遍历记录并将每个记录保存到CSV中，然后返回`CSVModel`对象的文件名，如下所示：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that we have a way to create a CSV extract file, we can write the callback
    method as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了创建CSV提取文件的方法，我们可以编写回调方法，如下所示：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To begin, we created a CSV extract file and checked if it's `None`. If it is,
    we'll display an error message and exit the method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个CSV提取文件并检查它是否为`None`。如果是，我们将显示错误消息并退出该方法。
- en: 'Before we can upload, we need to get a username and password from the user.
    Fortunately, we have the perfect class for this:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上传之前，我们需要从用户那里获取用户名和密码。幸运的是，我们有一个完美的类来做到这一点：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our login dialog serves us well here. Unlike with our database login, we're
    not going to run this in an endless loop; if the password is wrong, the user can
    just rerun the command. Recall that `result` will be `None` if the user clicks
    Cancel, so we'll just exit the callback method in that case.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录对话框在这里为我们服务。与数据库登录不同，我们不会在无限循环中运行它；如果密码错误，用户可以重新运行命令。请记住，如果用户点击取消，`result`将为`None`，因此在这种情况下我们将退出回调方法。
- en: 'Now, we can execute our network function as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以执行我们的网络函数，如下所示：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We're executing `upload_to_corporate_rest()` in a `try` block since there are
    a number of exceptions it might raise. We're passing in the upload and authentication
    URLs from our settings object; we haven't added those yet, so that will need to
    happen before we're done.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`try`块中执行`upload_to_corporate_rest()`，因为它可能引发许多异常。我们从设置对象中传递上传和身份验证URL；我们还没有添加这些，所以在完成之前需要这样做。
- en: 'Now, let''s catch a few exceptions, starting with the `RequestException`. 
    This exception would happen if there were some problem with the data we were sending
    to the API, most likely a wrong username and password. We''ll attach the exception
    string to the message we show the user, like so:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们捕获一些异常，首先是`RequestException`。如果我们发送到API的数据出现问题，最有可能是用户名和密码错误，就会发生这种异常。我们将异常字符串附加到向用户显示的消息中，如下所示：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next we''ll catch `ConnectionError`; this exception is going to be the result
    of a network problem, such as the internet connection at the lab being down, or
    the server not responding:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将捕获`ConnectionError`；这个异常将是网络问题的结果，比如实验室的互联网连接断开，或者服务器没有响应：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Any other exception will just be displayed as `General Exception`, like so:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何其他异常都将显示为`General Exception`，如下所示：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s wrap up the method with a success dialog as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用以下成功对话框结束这个方法：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s finish our changes to `Application` by adding this method to `callbacks` as
    follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过将此方法添加到`callbacks`中来完成对`Application`的更改：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Updating the models.py file
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新models.py文件
- en: 'There are a couple of things to fix in the `models.py` file before we can test
    our new functionality.  We''ll go through these steps to address them:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试新功能之前，`models.py`文件中有一些需要修复的地方。我们将按照以下步骤来解决这些问题：
- en: 'First, our `CSVModel` class needs to be able to take `filepath`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的`CSVModel`类需要能够接受`filepath`：
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If `filepath` is specified, we need to first make sure the directory exists.
    Since the `mkdtmp()` method called in the `Application` class does not actually
    create a temporary directory, we'll create it here. Once that's done, we'll join
    the `filepath` and `filename` values and store it in the `CSVModel` object's `filename`
    property.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`filepath`，我们需要首先确保目录存在。由于在`Application`类中调用的`mkdtmp()`方法实际上并没有创建临时目录，我们将在这里创建它。完成后，我们将连接`filepath`和`filename`的值，并将其存储在`CSVModel`对象的`filename`属性中。
- en: 'The other thing we need to do in `models.py` is add our new settings. Scroll
    down to the `SettingsModel` class, and add two more `variables` entries as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`models.py`中需要做的另一件事是添加我们的新设置。滚动到`SettingsModel`类，添加两个更多的`variables`条目如下：
- en: '[PRE60]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We won't be building a GUI to set these settings they'll need to be manually
    created in a user's configuration file, though for testing, we can use the defaults.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会构建一个GUI来设置这些设置，它们需要在用户的配置文件中手动创建，尽管在测试时，我们可以使用默认值。
- en: Finishing up
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收尾工作
- en: The last thing to do is add the command to our main menu.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是将命令添加到我们的主菜单中。
- en: 'Add a new entry to the `tools_menu` in each menu class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个菜单类中为`tools_menu`添加一个新条目：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, run the application and let's try it out. To make it work, you'll need
    to have at least one data entry, and you'll need to start up the `sample_http_server.py`
    script.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序，让我们试试。为了使其工作，您至少需要有一个数据输入，并且需要启动`sample_http_server.py`脚本。
- en: 'If all goes well, you should get a dialog like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会得到一个像这样的对话框：
- en: '![](assets/96de4996-9652-43f1-a4c6-a2d6bddc73de.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96de4996-9652-43f1-a4c6-a2d6bddc73de.png)'
- en: 'Your server should also have printed some output to the terminal similar to
    this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您的服务器还应该在终端上打印出类似这样的输出：
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice the `POST` and `PUT` requests, as well as the raw text of the CSV file
    in the payload of `PUT`. We have successfully met the API requirements for this
    function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`POST`和`PUT`请求，以及`PUT`有效负载中的CSV文件的原始文本。我们已成功满足了此功能的API要求。
- en: FTP using ftplib
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ftplib的FTP
- en: 'While HTTP and REST APIs are the current trend in client-server interactions,
    it''s not unusual for businesses to rely on older, time tested, and sometimes
    obsolete technology to implement data transfers. ABQ is no exception: in addition
    to the REST upload, you need to implement support for ABQ corporate''s legacy
    system that relies on FTP.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP和REST API是客户端-服务器交互的当前趋势，但企业依赖于旧的、经过时间考验的，有时是过时的技术来实现数据传输并不罕见。ABQ也不例外：除了REST上传，您还需要实现对依赖于FTP的ABQ公司的遗留系统的支持。
- en: Basic concepts of FTP
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP的基本概念
- en: '**File Transfer Protocol**, or **FTP**, dates back to the early 1970s, predating
    HTTP by almost 20 years. Nevertheless, it''s still commonly used by many organizations
    to exchange large files over the internet. FTP is considered somewhat obsolete
    in many circles due in part to the fact that it transmits data and credentials
    in clear text, though SSL-encrypted variants of FTP are also available.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件传输协议**，或**FTP**，可以追溯到20世纪70年代初，比HTTP早了近20年。尽管如此，它仍然被许多组织广泛用于在互联网上交换大文件。由于FTP以明文形式传输数据和凭据，因此在许多领域被认为有些过时，尽管也有SSL加密的FTP变体可用。'
- en: Like HTTP, FTP clients send requests containing plain text commands similar
    to HTTP methods, and the FTP server returns a response packet containing header
    and payload information.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTTP一样，FTP客户端发送包含纯文本命令的请求，类似于HTTP方法，FTP服务器返回包含头部和有效负载信息的响应数据包。
- en: 'There are, however, many significant differences between the two protocols:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种协议之间存在许多重大的区别：
- en: FTP is a **stateful connection**, meaning the client and server maintain a constant
    connection over the course of the session. In other words, FTP is more like a
    live telephone call, whereas HTTP is like two people having a dialog over voicemail.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP是**有状态连接**，这意味着客户端和服务器在会话期间保持恒定的连接。换句话说，FTP更像是一个实时电话，而HTTP则像是两个人在语音信箱中对话。
- en: FTP requires a session to be authenticated before any other commands or data
    are sent, even for anonymous users. FTP servers also implement a more complex
    set of permissions.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送任何其他命令或数据之前，FTP需要对会话进行身份验证，即使对于匿名用户也是如此。FTP服务器还实现了更复杂的权限集。
- en: FTP has separate modes for transferring text and binary data (the main difference
    being that text mode transfers automatically correct line endings and encoding
    for the receiving OS).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP有用于传输文本和二进制数据的不同模式（主要区别在于文本模式会自动纠正行尾和接收操作系统的编码）。
- en: FTP servers are less consistent in their implementation of commands.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP服务器在其命令的实现上不够一致。
- en: Creating a test FTP service
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个测试FTP服务
- en: Before we implement our FTP upload functionality, it's helpful to have a test
    FTP service, just as we did with our test HTTP service. You can, of course, download
    any of a number of free FTP servers such as FileZilla, PureFTPD, ProFTPD, or others.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现FTP上传功能之前，有一个测试FTP服务是有帮助的，就像我们测试HTTP服务一样。当然，您可以下载许多免费的FTP服务器，如FileZilla、PureFTPD、ProFTPD或其他。
- en: Rather than going to the trouble of installing, configuring, and later removing
    an FTP service on your system just for testing one function of an application,
    we can instead build a rudimentary server in Python. The third-party `pyftpdlib`
    package offers us an easy way to implement a quick-and-dirty FTP server adequate
    for test needs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为了测试应用程序的一个功能而在系统上安装、配置和后来删除FTP服务，我们可以在Python中构建一个基本的服务器。第三方的`pyftpdlib`包为我们提供了一个简单的实现快速脏FTP服务器的方法，足以满足测试需求。
- en: 'Install `pyftpdlib` using `pip`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`安装`pyftpdlib`：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Just like our simple HTTP server, the FTP service consists of a *server* object
    and a *handler* object. It also needs an *authorizer* object to handle authentication
    and permissions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们简单的HTTP服务器一样，FTP服务由*服务器*对象和*处理程序*对象组成。它还需要一个*授权者*对象来处理身份验证和权限。
- en: 'We''ll start our `basic_ftp_server.py` file by importing those:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入这些开始我们的`basic_ftp_server.py`文件：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To make sure our authentication code works properly, let''s set up our `DummyAuthorizer`
    class with a test user:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的身份验证代码正常工作，让我们用一个测试用户设置我们的`DummyAuthorizer`类：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `perm` argument takes a string of characters, each of which represents a
    specific permission on the server. In this case, we have `e` (connect), `l` (list),
    `r` (read), and `w` (write new file). There are many other permissions available,
    all of which are off by default until granted, but this is sufficient for our
    needs.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`perm`参数接受一个字符的字符串，每个字符代表服务器上的特定权限。在这种情况下，我们有`e`（连接）、`l`（列出）、`r`（读取）和`w`（写入新文件）。还有许多其他权限可用，默认情况下都是关闭的，直到授予，但这对我们的需求已经足够了。'
- en: 'Now, let''s set up the handler:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置处理程序：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice we're not instantiating the handler, just aliasing the class. The server
    class will manage the creation of handler classes. We can, however, assign our
    `auth` object as the handler's `authorizer` class, so that any created handlers
    will use our authorizer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有实例化处理程序，只是给类取了别名。服务器类将管理处理程序类的创建。但是，我们可以将我们的`auth`对象分配为处理程序的`authorizer`类，以便任何创建的处理程序都将使用我们的授权者。
- en: 'Finally, let''s set up and run the server portion:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们设置并运行服务器部分：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is simply a matter of instantiating an `FTPServer` object with an address
    tuple and handler class, then calling the object's `server_forever()` method.
    The address tuple is in the form `(ip_address, port)`, so a tuple of `('127.0.0.1',
    2100)` means we'll be serving on our computer's loopback address on port `2100`.
    The default port for FTP is usually 21, but on most operating systems, starting
    a service that listens on a port under `1024` requires root or system-admin privileges.
    For simplicity's sake, we'll just use a higher port.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地用地址元组和处理程序类实例化一个`FTPServer`对象，然后调用对象的`server_forever()`方法。地址元组的形式是`（ip_address，port）`，所以`（'127.0.0.1'，2100）`的元组意味着我们将在计算机的回环地址上的端口`2100`上提供服务。FTP的默认端口通常是21，但在大多数操作系统上，启动监听在`1024`以下端口的服务需要root或系统管理员权限。为了简单起见，我们将使用一个更高的端口。
- en: While it's possible to build production quality FTP servers with `pyftpdlib`,
    we haven't done that here. This script is adequate for testing, but please don't
    use it in production if you value security.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用`pyftpdlib`构建生产质量的FTP服务器，但我们在这里没有这样做。这个脚本对于测试是足够的，但如果您重视安全性，请不要在生产中使用它。
- en: Implementing the FTP upload function
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FTP上传功能
- en: Now that the test server is up and running, let's build our FTP upload function
    and the logic for the GUI. While the standard library doesn't contain an FTP server
    library, it does contain an FTP client library in the form of the `ftplib` module.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试服务器已经启动，让我们构建我们的FTP上传功能和GUI的逻辑。虽然标准库中没有包含FTP服务器库，但它包含了`ftplib`模块形式的FTP客户端库。
- en: 'Begin by importing `ftplib` into our `network.py` file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在我们的`network.py`文件中导入`ftplib`：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: An FTP session can be created using the `ftplib.FTP` class. Because this is
    a stateful session, it needs to be closed after we're done; to make sure we do
    this, `FTP` can be used as a context manager.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`ftplib.FTP`类创建一个FTP会话。因为这是一个有状态的会话，在完成后需要关闭；为了确保我们这样做，`FTP`可以用作上下文管理器。
- en: 'Let''s start our function by connecting to the FTP server:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从连接到FTP服务器开始我们的函数：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `upload_to_corporate()` function takes the CSV filepath and the `FTP` host,
    port, user, and password, much like our `upload_to_corporate_rest()` function
    did. We begin by creating our `FTP` object and calling `FTP.connect()` and `FTP.login`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload_to_corporate()`函数接受CSV文件路径和`FTP`主机、端口、用户和密码，就像我们的`upload_to_corporate_rest()`函数一样。我们首先创建我们的`FTP`对象，然后调用`FTP.connect()`和`FTP.login`。'
- en: Next, `connect()` takes the host and port that we're going to talk to and starts
    a session with the server. We aren't yet authenticated at this point, but we do
    have a connection going.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`connect()`接受我们要交谈的主机和端口，并与服务器开始会话。在这一点上，我们还没有经过身份验证，但我们确实建立了连接。
- en: Then, `login()` takes a username and password and attempts to authenticate our
    session. If our credentials check out, we're logged in to the server and can begin
    sending more commands; if not, an `error_perm` exception is raised. However, our
    session is still alive until we close it, and we can send additional login attempts
    if we wish.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`login()`接受用户名和密码，并尝试验证我们的会话。如果我们的凭据检查通过，我们就登录到服务器上，并可以开始发送更多的命令；如果不通过，就会引发`error_perm`异常。但是，我们的会话仍然是活动的，直到我们关闭它，并且如果需要，我们可以发送额外的登录尝试。
- en: 'To actually upload a file, we use the `storbinary()` method:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际上传文件，我们使用`storbinary()`方法：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: To send the file, we have to open it in binary-read mode, then call `storbinary`
    (yes, it's "stor", not "store"—programmers in the 1970s had a thing about dropping
    letters from words).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送文件，我们必须以二进制读取模式打开它，然后调用“storbinary”（是的，“stor”，而不是“store”—20世纪70年代的程序员对删除单词中的字母有一种偏好）。
- en: The first argument to `storbinary` is a valid FTP `STOR` command, usually `STOR
    filename`, where "filename" is what you want the uploaded data to be called on
    the server. It seems a little counter-intuitive to have to include the actual
    command string; presumably this must be specified in case the server uses slightly
    different commands or syntax.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: “storbinary”的第一个参数是一个有效的FTP“STOR”命令，通常是“STOR filename”，其中“filename”是您希望在服务器上称为上传数据的名称。必须包含实际的命令字符串似乎有点违反直觉；据推测，这必须是指定的，以防服务器使用稍有不同的命令或语法。
- en: The second argument is the file object itself. This should be opened in binary
    mode since we're sending it as binary data. This may seem odd since the CSV file
    we're sending is essentially a plain text file, but sending it as binary data
    guarantees that the server won't change the file in any way during transit; this
    is nearly always what you want when transferring files, regardless of the nature
    of the data being exchanged.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是文件对象本身。由于我们将其作为二进制数据发送，因此应该以二进制模式打开它。这可能看起来有点奇怪，因为我们发送的CSV文件本质上是一个纯文本文件，但将其作为二进制数据发送可以保证服务器在传输过程中不会以任何方式更改文件；这几乎总是在传输文件时所希望的，无论所交换数据的性质如何。
- en: This is all our network function needs to do for FTP upload. Although we only
    needed the `storbinary()` method for our program, it's worth noting a few other
    common `ftp` methods in case you find yourself having to work with an FTP server.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的网络功能需要为FTP上传完成的所有工作。尽管我们的程序只需要“storbinary()”方法，但值得注意的是，如果您发现自己不得不使用FTP服务器，还有一些其他常见的“ftp”方法。
- en: Listing files
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出文件
- en: There are three methods for listing files on an FTP server. The `mlsd()` method
    calls the `MLSD` command, which is typically the best and most complete output
    available. It can take an optional `path` argument, specifying the path to list
    (otherwise it lists the current directory), and a list of `facts` , such as "size",
    "type", or "perm", reflecting which data you'd like included with the filenames.
    The `mlsd()` command returns a generator object which can be iterated or cast
    to another sequence type.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在FTP服务器上列出文件有三种方法。“mlsd()”方法调用“MLSD”命令，通常是可用的最佳和最完整的输出。它可以接受一个可选的“path”参数，指定要列出的路径（否则它将列出当前目录），以及一个“facts”列表，例如“size”、“type”或“perm”，反映了您希望与文件名一起包括的数据。
    “mlsd()”命令返回一个生成器对象，可以迭代或转换为另一种序列类型。
- en: '`MLSD` is a newer command and not always available, so there are two other
    methods available, `nlst()` and `dir()`, which correspond to the older `NLST`
    and `DIR` commands. Both methods accept an arbitrary number of arguments that
    will be appended verbatim to the command string sent to the server.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: “MLSD”是一个较新的命令，不一定总是可用，因此还有另外两种可用的方法，“nlst()”和“dir()”，它们对应于较旧的“NLST”和“DIR”命令。这两种方法都接受任意数量的参数，这些参数将被原样附加到发送到服务器的命令字符串。
- en: Retrieving files
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索文件
- en: Downloading files from an FTP server involves either one of the `retrbinary()`
    or `retrlines()` methods, depending on whether we wish to use binary or text mode
    (as mentioned before, you should probably always use binary). Like `storbinary`,
    each method takes a command string as its first argument, but in this case it
    should be a valid `RETR` command (usually "RETR filename" will suffice).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从FTP服务器下载文件涉及“retrbinary()”或“retrlines()”方法中的一个，具体取决于我们是否希望使用二进制或文本模式（如前所述，您可能应该始终使用二进制）。与“storbinary”一样，每种方法都需要一个命令字符串作为其第一个参数，但在这种情况下，它应该是一个有效的“RETR”命令（通常“RETR
    filename”就足够了）。
- en: The second argument is a callback function which will be called on every line
    (for `retrlines()`) or chunk (for `retrbinary()`). This callback can be used to
    store the downloaded data.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个回调函数，它将在每一行（对于“retrlines()”）或每个块（对于“retrbinary()”）上调用。此回调可用于存储已下载的数据。
- en: 'For example, take a look at the following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下以下代码：
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The return value of each function is a result string containing some statistics
    about the download as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的返回值都是一个包含有关下载的一些统计信息的结果字符串，如下所示：
- en: '[PRE72]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Deleting or renaming files
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除或重命名文件
- en: Deleting and renaming files using `ftplib` is mercifully simple by comparison.
    The `delete()` method takes only a filename and attempts to delete the given file
    on the server. The `rename()` method takes only a source and destination, and
    attempts to rename the source to the destination name.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“ftplib”删除和重命名文件相对简单。 “delete()”方法只需要一个文件名，并尝试删除服务器上给定的文件。“rename()”方法只需要一个源和目标，并尝试将源重命名为目标名称。
- en: Naturally, the success of either method depends on the permissions granted to
    the login account used.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，任何一种方法的成功都取决于登录帐户被授予的权限。
- en: Adding FTP upload to the GUI
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将FTP上传添加到GUI
- en: Our FTP upload function is ready to go, so let's add the necessary bits to the
    rest of our application to make it all work together.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的FTP上传功能已经准备就绪，所以让我们将必要的部分添加到我们应用程序的其余部分，使其一起运行。
- en: 'We''ll start by adding the FTP host and port to the `SettingsModel` in `models.py`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在“models.py”中的“SettingsModel”中添加FTP主机和端口：
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Remember that our test FTP uses port `2100`, not the usual port `21`, so we'll
    make `2100` the default for now.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的测试FTP使用端口“2100”，而不是通常的端口“21”，所以现在我们将“2100”作为默认值。
- en: Now, we'll move over to `application.py` and create the callback method that
    will create the CSV file and pass it to the FTP upload function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转到“application.py”并创建回调方法，该方法将创建CSV文件并将其传递给FTP上传功能。
- en: 'Create a new method in the `Application` object:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Application”对象中创建一个新方法：
- en: '[PRE74]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The first thing we do is create our CSV file, using the method we created for
    the `REST` upload.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是使用我们为“REST”上传创建的方法创建我们的CSV文件。
- en: 'Next, we''ll ask the user for the FTP username and password:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将要求用户输入FTP用户名和密码：
- en: '[PRE75]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And now, we''ll call our network function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用我们的网络功能：
- en: '[PRE76]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We call the FTP upload function in a `try` block because there are several exceptions
    that can be raised by our FTP process.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`try`块中调用FTP上传函数，因为我们的FTP过程可能会引发多个异常。
- en: 'Rather than catching them individually, we can catch `ftplib.all_errors`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 与其逐个捕获它们，我们可以捕获`ftplib.all_errors`：
- en: '[PRE77]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that `ftplib.all_errors` is the base class for all exceptions defined in
    `ftplib`, which include, among other things, authentication errors, permission
    errors, and connectivity errors.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ftplib.all_errors`是`ftplib`中定义的所有异常的基类，其中包括认证错误、权限错误和连接错误等。
- en: 'To end this method, we''ll show a success message:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 结束这个方法时，我们将显示一个成功的消息：
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With the callback method written, we need to add it to the `callbacks` dictionary:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 写好回调方法后，我们需要将其添加到`callbacks`字典中：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The last thing we need to do is to add our callback to the main menu classes.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将我们的回调添加到主菜单类中。
- en: 'Over in `mainmenu.py`, add a new command to the `tools_menu` in each class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainmenu.py`中，为每个类的`tools_menu`添加一个新的命令：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Launch the sample FTP server in a terminal, then run your application and try
    out the FTP upload. Remember to enter `test` for the username and password!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中启动示例FTP服务器，然后运行你的应用程序并尝试FTP上传。记得输入`test`作为用户名和密码！
- en: 'You should see a success dialog like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个成功的对话框，类似这样：
- en: '![](assets/42dfde62-fea5-4555-ae37-9f3fe4037b68.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/42dfde62-fea5-4555-ae37-9f3fe4037b68.png)'
- en: Likewise, there should be a new CSV file in whatever directory you ran the sample
    FTP server from.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在你运行示例FTP服务器的目录中应该有一个新的CSV文件。
- en: 'The FTP server should have printed out some information like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: FTP服务器应该已经打印出了一些类似这样的信息：
- en: '[PRE81]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Looks like our FTP upload works great!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的FTP上传效果很棒！
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reached out to the cloud using HTTP and FTP. You learned
    how to download data using `urllib` and parse XML using `ElementTree`. You also
    discovered the `requests` library and learned the basics of interacting with a
    REST API. Finally, we learned how to download and upload files to FTP using Python's
    `ftplib`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用HTTP和FTP与云进行了交互。你学会了如何使用`urllib`下载数据并使用`ElementTree`解析XML。你还了解了`requests`库，并学会了与REST
    API进行交互的基础知识。最后，我们学会了如何使用Python的`ftplib`下载和上传文件到FTP。
