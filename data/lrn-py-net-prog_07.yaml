- en: Chapter 7. Programming with Sockets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用套接字进行编程
- en: After you have interacted with various clients/servers in Python, you will be
    keen to create your own custom clients and servers for any protocol of your choice.
    Python provides a good coverage on the low-level networking interface. It all
    starts with BSD socket interface. As you can assume, Python has a `socket` module
    that gives you the necessary functionality to work with the socket Interface.
    If you have ever done socket programming in any other language like C/C++, you
    will love the Python `socket` module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中与各种客户端/服务器进行交互后，您可能会渴望为自己选择的任何协议创建自定义客户端和服务器。Python在低级网络接口上提供了很好的覆盖。一切都始于BSD套接字接口。正如您可以想象的那样，Python有一个`socket`模块，为您提供了与套接字接口一起工作所需的功能。如果您以前在C/C++等其他语言中进行过套接字编程，您会喜欢Python的`socket`模块。
- en: In this chapter, we will explore the socket module by creating a diverse range
    of Python scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过创建各种Python脚本来探索套接字模块。
- en: 'The following are the highlights of this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的亮点如下：
- en: Basics of sockets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字基础
- en: Working with TCP sockets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TCP套接字
- en: Working with UDP sockets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UDP套接字
- en: TCP port forwarding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP端口转发
- en: Non-blocking socket I/O
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞套接字I/O
- en: Securing sockets with SSL/TLS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSL/TLS保护套接字
- en: Creating custom SSL client/server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义SSL客户端/服务器
- en: Basics of sockets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字基础
- en: Network programming in any programming language can begin with sockets. But
    what is a socket? Simply put, a network socket is a virtual end point where entities
    can perform inter-process communication. For example, one process sitting in a
    computer, exchanges data with another process sitting on the same or another computer.
    We typically label the first process which initiates the communication as the
    client and the latter one as the server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的网络编程都可以从套接字开始。但是什么是套接字？简而言之，网络套接字是实体可以进行进程间通信的虚拟端点。例如，一台计算机中的一个进程与另一台计算机上的一个进程交换数据。我们通常将发起通信的第一个进程标记为客户端，后一个进程标记为服务器。
- en: Python has quite an easy way to start with the socket interface. In order to
    understand this better, let's see the big picture first. In the following figure,
    a flow of client/server interaction is shown. This will give you an idea of how
    to use the socket API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种非常简单的方式来开始使用套接字接口。为了更好地理解这一点，让我们先了解一下整体情况。在下图中，显示了客户端/服务器交互的流程。这将让您了解如何使用套接字API。
- en: '![Basics of sockets](graphics/B03711_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![套接字基础](graphics/B03711_07_01.jpg)'
- en: client/server interaction through socket
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过套接字进行客户端/服务器交互
- en: In the interaction between a typical client and a server, the server process
    has to work a bit more, as you may have thought. After creating a socket object,
    the server process binds that socket to a particular IP address and port. This
    is much like a telephone connection with an extension number. In a corporate office,
    after a new employee has been allocated with his desk phone, usually he or she
    will be assigned to a new extension number. So, if anybody makes a phone call
    to this employee, the connection can be established using his phone number and
    extension. After the successful binding, the server process will start listening
    for a new client connection. For a valid client session, the server process can
    accept the request of the client process. At this point, we can say that the connection
    between the server and the client has been established.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型客户端和服务器之间的交互中，服务器进程必须做更多的工作，正如您可能已经想到的那样。创建套接字对象后，服务器进程将该套接字绑定到特定的IP地址和端口。这很像使用分机号的电话连接。在公司办公室中，新员工分配了他的办公电话后，通常会被分配一个新的分机号。因此，如果有人给这位员工打电话，可以使用他的电话号码和分机号建立连接。成功绑定后，服务器进程将开始监听新的客户端连接。对于有效的客户端会话，服务器进程可以接受客户端进程的请求。此时，我们可以说服务器和客户端之间的连接已经建立。
- en: Then the client/server enters into the request/response loop. The client process
    sends data to the server process, and the server process processes the data and
    returns a response to the client. When the client process finishes, it exits by
    closing down the connection. At that moment, the server process probably goes
    back to the listening state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后客户端/服务器进入请求/响应循环。客户端进程向服务器进程发送数据，服务器进程处理数据并返回响应给客户端。当客户端进程完成时，通过关闭连接退出。此时，服务器进程可能会回到监听状态。
- en: The above interaction between client and server is a very simplified representation
    of the actual reality. In practice, any production server process has multiple
    threads or subprocesses to handle concurrent connections from thousands of clients
    over respective virtual channels.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述客户端和服务器之间的交互是实际情况的一个非常简化的表示。实际上，任何生产服务器进程都有多个线程或子进程来处理来自成千上万客户端的并发连接，这些连接是通过各自的虚拟通道进行的。
- en: Working with TCP sockets
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP套接字
- en: 'Creating a socket object in Python is very straightforward. You just need to
    import the `socket` module and call the `socket()` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建套接字对象非常简单。您只需要导入`socket`模块并调用`socket()`类：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Traditionally, the class takes plenty of parameters. Some of them are listed
    in the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，该类需要大量参数。以下是其中一些：
- en: '**Socket family**: This is the domain of socket, such as `AF_INET` (about 90
    percent of the sockets of the Internet fall under this category) or `AF_UNIX,`
    which is sometimes used as well. In Python 3, you can create a Bluetooth socket
    using `AF_BLUETOOTH`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字族**：这是套接字的域，例如`AF_INET`（大约90％的互联网套接字属于此类别）或`AF_UNIX`，有时也会使用。在Python 3中，您可以使用`AF_BLUETOOTH`创建蓝牙套接字。'
- en: '**Socket type**: Depending on your need, you need to specify the type of socket.
    For example, TCP and UDP-based sockets are created by specifying `SOCK_STREAM`
    and `SOCK_DGRAM,` respectively.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字类型**：根据您的需求，您需要指定套接字的类型。例如，通过分别指定`SOCK_STREAM`和`SOCK_DGRAM`来创建基于TCP和UDP的套接字。'
- en: '**Protocol**: This specifies the variation of protocol within a socket family
    and type. Usually, it is left as zero.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：这指定了套接字族和类型内协议的变化。通常，它被留空为零。'
- en: For many reasons, socket operations may not be successful. For example, if you
    don't have permission to access a particular port as a normal user, you may not
    be able to bind to a socket. This is why it is a good idea to do proper error
    handling when creating a socket or doing some network-bound communication.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多原因，套接字操作可能不成功。例如，如果作为普通用户没有权限访问特定端口，可能无法绑定套接字。这就是为什么在创建套接字或进行一些网络绑定通信时进行适当的错误处理是个好主意。
- en: 'Let''s try to connect a client socket to a server process. The following code
    is an example of TCP client socket that makes a connection to server socket:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将客户端套接字连接到服务器进程。以下代码是一个连接到服务器套接字的TCP客户端套接字的示例：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run the preceding TCP client, an output similar to the following will
    be shown:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上述的TCP客户端，将显示类似以下的输出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, if socket creation has failed for some reason, such as invalid DNS,
    an output similar to the following will be shown:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果由于某种原因套接字创建失败，比如无效的DNS，将显示类似以下的输出：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s exchange some data with the server. The following code is an example
    of a simple TCP client:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们与服务器交换一些数据。以下代码是一个简单TCP客户端的示例：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you look carefully, you can see that the preceding code actually created
    a raw HTTP client that fetches a web page from a web server. It sends an HTTP
    `GET` request to pull the home page:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会发现上述的代码实际上创建了一个从Web服务器获取网页的原始HTTP客户端。它发送一个HTTP的`GET`请求来获取主页：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inspecting the client/server communication
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查客户端/服务器通信
- en: 'The interaction between the client and server through the exchange of network
    packets can be analyzed using any network packet capturing tool, such as Wireshark.
    You can configure Wireshark to filter packets by port or host. In this case, we
    can filter by port 80\. You can get the options under the **Capture** | **Options**
    menu and type `port 80` in the input box next to the **Capture Filter** option,
    as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交换网络数据包进行的客户端和服务器之间的交互可以使用任何网络数据包捕获工具进行分析，比如Wireshark。您可以配置Wireshark通过端口或主机过滤数据包。在这种情况下，我们可以通过端口80进行过滤。您可以在**捕获**
    | **选项**菜单下找到选项，并在**捕获过滤器**选项旁边的输入框中输入`port 80`，如下面的屏幕截图所示：
- en: '![Inspecting the client/server communication](graphics/B03711_07_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![检查客户端/服务器通信](graphics/B03711_07_02.jpg)'
- en: 'In the **Interface** option, we choose to capture packets passing through any
    interface. Now, if you run the preceding TCP client to connect to [www.linux.org](http://www.linux.org/),
    you can see the sequence of packets exchanged in Wireshark, as shown in the following
    screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在**接口**选项中，我们选择捕获通过任何接口传递的数据包。现在，如果您运行上述的TCP客户端连接到[www.linux.org](http://www.linux.org/)，您可以在Wireshark中看到交换的数据包序列，如下面的屏幕截图所示：
- en: '![Inspecting the client/server communication](graphics/B03711_07_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![检查客户端/服务器通信](graphics/B03711_07_03.jpg)'
- en: 'As you can see, the first three packets establish the TCP connection by a three-way
    handshake process between the client and server. We are more interested in the
    fourth packet that makes an HTTP `GET` request to the server. If you double-click
    the selected row, you can see the details of the HTTP request, as shown in the
    following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，前三个数据包通过客户端和服务器之间的三次握手过程建立了TCP连接。我们更感兴趣的是第四个数据包，它向服务器发出了HTTP的`GET`请求。如果您双击所选行，您可以看到HTTP请求的详细信息，如下面的屏幕截图所示：
- en: '![Inspecting the client/server communication](graphics/B03711_07_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![检查客户端/服务器通信](graphics/B03711_07_04.jpg)'
- en: 'As you can see, the HTTP `GET` request has other components such as `Request
    URI`, version, and so on. Now you can check the HTTP response from the web server
    to your client. It has come after the TCP acknowledgment packet, that is, the
    sixth packet. Here, the server typically sends an HTTP response code (in this
    case `200`), content length, and the data or web page content. The structure of
    this packet is shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，HTTP的`GET`请求还有其他组件，比如`请求URI`，版本等。现在您可以检查来自Web服务器的HTTP响应到您的客户端。它是在TCP确认数据包之后，也就是第六个数据包之后。在这里，服务器通常发送一个HTTP响应代码（在本例中是`200`），内容长度和数据或网页内容。这个数据包的结构如下面的屏幕截图所示：
- en: '![Inspecting the client/server communication](graphics/B03711_07_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![检查客户端/服务器通信](graphics/B03711_07_05.jpg)'
- en: From the preceding analysis of the interaction between the client and server,
    you can now understand, at a basic level, what happens behind the scenes when
    you visit a web page using your web browser. In the next section, you will be
    shown how to create your own TCP server and examine the interactions between your
    personal TCP client and server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对客户端和服务器之间的交互进行上述分析，您现在可以在基本层面上理解当您使用Web浏览器访问网页时发生了什么。在下一节中，您将看到如何创建自己的TCP服务器，并检查个人TCP客户端和服务器之间的交互。
- en: TCP servers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP服务器
- en: 'As you understood from the very first client/server interaction diagram, the
    server process needs to carry out a bit of extra work. It needs to bind to a socket
    address and listen for incoming connections. The following code snippet shows
    how to create a TCP server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从最初的客户端/服务器交互图中所理解的，服务器进程需要进行一些额外的工作。它需要绑定到套接字地址并监听传入的连接。以下代码片段显示了如何创建一个TCP服务器：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s modify our previous TCP client to send arbitrary data to any server.
    The following is an example of an enhanced TCP client:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的TCP客户端，向任何服务器发送任意数据。以下是一个增强型TCP客户端的示例：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the preceding TCP server in one console and the TCP client in another
    console, you can see the following interaction between the client and server.
    After running the TCP server script you will get the following output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个控制台中运行上述的TCP服务器，另一个控制台中运行TCP客户端，您可以看到客户端和服务器之间的以下交互。运行TCP服务器脚本后，您将得到以下输出：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you will run the TCP client script on another terminal then you will get
    the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在另一个终端上运行TCP客户端脚本时，您将得到以下输出：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inspecting client/server interaction
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查客户端/服务器交互
- en: 'Now, once again, you can configure Wireshark to capture packets, as discussed
    in the last section. But, in this case, you need to specify the port that your
    server is listening on (in the preceding example it''s `12345`), as shown in the
    following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以再次配置Wireshark来捕获数据包，就像上一节讨论的那样。但是，在这种情况下，您需要指定服务器正在侦听的端口（在上面的示例中是`12345`），如下面的屏幕截图所示：
- en: '![Inspecting client/server interaction](graphics/B03711_07_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![检查客户端/服务器交互](graphics/B03711_07_06.jpg)'
- en: As we are capturing packets on a non-standard port, Wireshark doesn't decode
    it in the **Data** section (as shown in the middle pane of the preceding screenshot).
    However, you can see the decoded text on the bottom pane where the server's timestamp
    is shown on the right side.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在非标准端口上捕获数据包，Wireshark不会在**数据**部分解码它（如上面屏幕截图的中间窗格所示）。但是，您可以在底部窗格上看到解码后的文本，服务器的时间戳显示在右侧。
- en: Working with UDP sockets
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UDP套接字
- en: Unlike TCP, UDP doesn't check for errors in the exchanged datagram. We can create
    UDP client/servers similar to the TCP client/servers. The only difference is you
    have to specify `SOCK_DGRAM` instead of `SOCK_STREAM` when you create the socket
    object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP不同，UDP不会检查交换的数据报中的错误。我们可以创建类似于TCP客户端/服务器的UDP客户端/服务器。唯一的区别是在创建套接字对象时，您必须指定`SOCK_DGRAM`而不是`SOCK_STREAM`。
- en: 'Let us create a UDP server. Use the following code to create the UDP server:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个UDP服务器。使用以下代码创建UDP服务器：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, you can create a UDP client to send some data to the UDP server, as shown
    in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个UDP客户端，向UDP服务器发送一些数据，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code snippet, the UDP client sends a single line of text `Hello
    UDP server` and receives the response from the server. The following screenshot
    shows the request sent from the client to the server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，UDP客户端发送一行文本`Hello UDP server`并从服务器接收响应。下面的屏幕截图显示了客户端发送到服务器的请求：
- en: '![Working with UDP sockets](graphics/B03711_07_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用UDP套接字](graphics/B03711_07_07.jpg)'
- en: The following screenshot shows the server's response sent to the client. After
    inspecting UDP client/server packets, we can easily see that UDP is much simpler
    than TCP. It's often termed as a connectionless protocol as there is no acknowledgment
    or error checking involved.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了服务器发送给客户端的响应。在检查UDP客户端/服务器数据包之后，我们可以很容易地看到UDP比TCP简单得多。它通常被称为无连接协议，因为没有涉及确认或错误检查。
- en: '![Working with UDP sockets](graphics/B03711_07_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![使用UDP套接字](graphics/B03711_07_08.jpg)'
- en: TCP port forwarding
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP端口转发
- en: One of the interesting experiments we can do with TCP socket programming is
    to set up a TCP port forwarding. This has very good use cases. Say, for example,
    if you are running an insecure program like FTP in a public server that doesn't
    have any SSL capability to do secure communication (FTP passwords can be seen
    clear-text over the wires). Since this server is accessible from Internet, you
    must not login with your password to the server without ensuring that the passwords
    are encrypted. One way of doing this is to use Secure FTP or SFTP. We can use
    a simple SSH tunnel in order to show how this approach works. So, any communication
    between your local FTP client and remote FTP server will happen via this encrypted
    channel.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用TCP套接字编程进行一些有趣的实验，比如设置TCP端口转发。这有很好的用例。例如，如果您在没有SSL能力进行安全通信的公共服务器上运行不安全的程序（FTP密码可以在传输过程中以明文形式看到）。由于这台服务器可以从互联网访问，您必须确保密码是加密的，才能登录到服务器。其中一种方法是使用安全FTP或SFTP。我们可以使用简单的SSH隧道来展示这种方法的工作原理。因此，您本地FTP客户端和远程FTP服务器之间的任何通信都将通过这个加密通道进行。
- en: Let us run the FTP program to the same SSH server host. But create an SSH tunnel
    from your local machine that will give you a local port number and will directly
    connect you to the remote FTP server daemon.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行FTP程序到同一个SSH服务器主机。但是从本地机器创建一个SSH隧道，这将给您一个本地端口号，并将直接连接您到远程FTP服务器守护程序。
- en: 'Python has a third party `sshtunnel` module that is a wrapper around the Paramiko''s
    `SSH` library. The following is a code snippet of TCP port forwarding that shows
    how the concept can be realized:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个第三方的`sshtunnel`模块，它是Paramiko的`SSH`库的包装器。以下是TCP端口转发的代码片段，显示了如何实现这个概念：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let us capture the packet transfer from the local machine `192.168.0.102` to
    the remote machine `192.168.0.101`. You will see all network traffic is encrypted.
    When you run the preceding script, you will get a local port number. Use the `ftp`
    command to connect to that local port number:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们捕获从本地机器`192.168.0.102`到远程机器`192.168.0.101`的数据包传输。您将看到所有网络流量都是加密的。当您运行上述脚本时，您将获得一个本地端口号。使用`ftp`命令连接到该本地端口号：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you run the preceding command, then you will get the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上述命令，那么您将得到以下屏幕截图：
- en: '![TCP port forwarding](graphics/B03711_07_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![TCP端口转发](graphics/B03711_07_09.jpg)'
- en: In the preceding screenshot, you cannot see any FTP traffic. As you can see,
    first we connect to local port `5815` (see the first three packets) and suddenly
    an encrypted session started with the remote host. You can continue watching the
    remote traffic, but there is no trace of FTP.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，您看不到任何FTP流量。正如您所看到的，首先我们连接到本地端口`5815`（参见前三个数据包），然后突然之间与远程主机建立了加密会话。您可以继续观察远程流量，但是没有FTP的痕迹。
- en: 'If you can also capture packets on your remote machine (`192.168.56.101`),
    you could see FTP traffic, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还可以在远程机器（`192.168.56.101`）上捕获数据包，您可以看到FTP流量，如下面的屏幕截图所示：
- en: '![TCP port forwarding](graphics/B03711_07_12.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![TCP端口转发](graphics/B03711_07_12.jpg)'
- en: 'Interestingly, you can see your FTP password sent from the local machine (over
    SSH tunnel) as clear-text only on your remote box, not over the network, as shown
    in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，您可以看到您的FTP密码从本地机器（通过SSH隧道）以明文形式发送到远程计算机，而不是通过网络发送，如下图所示：
- en: '![TCP port forwarding](graphics/B03711_07_11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: TCP端口转发
- en: So, in this way, you can hide any sensitive network traffic in an SSL tunnel.
    Not only the FTP, you can also pass remote desktop session encrypted over an SSH
    channel.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以将任何敏感的网络流量隐藏在SSL隧道中。不仅FTP，您还可以通过SSH通道加密传输远程桌面会话。
- en: A non-blocking socket I/O
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞套接字I/O
- en: 'In this section, we will see a small example code snippet to test a non-blocking
    socket I/O. This is useful if you know that the synchronous blocking connection
    is not necessary for your program. The following is an example of non-blocking
    I/O:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一个小的示例代码片段，用于测试非阻塞套接字I/O。如果您知道同步阻塞连接对您的程序不是必需的，这将非常有用。以下是非阻塞I/O的示例：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This script will run a socket server and listen in a non-blocking style. This
    means you can connect more clients who won't be necessarily blocked for I/O.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将以非阻塞方式运行套接字服务器并进行监听。这意味着您可以连接更多的客户端，他们不一定会因I/O而被阻塞。
- en: Securing sockets with TLS/SSL
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TLS/SSL保护套接字
- en: You have probably come across the discussion around secure web communication
    using **Secure Socket Layer** (**SSL**), or more precisely **Transport Layer Security**
    (**TLS**), which is adopted by many other high-level protocols. Let us see how
    we can wrap a plain sockets connection with SSL. Python has the built-in `ssl`
    module, which serves this purpose.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经遇到了使用**安全套接字层**（**SSL**）或更精确地说是**传输层安全**（**TLS**）进行安全网络通信的讨论，这已被许多其他高级协议采用。让我们看看如何使用SSL包装普通套接字连接。Python具有内置的`ssl`模块，可以实现此目的。
- en: 'In this example, we would like to create a plain TCP socket and connect to
    an HTTPS enabled web server. Then, we can wrap that connection using SSL and check
    the various properties of the connection. For example, to check the identity of
    the remote web server, we can see if the hostname is same in the SSL certificate
    as we expect it to be. The following is an example of a secure socket-based client:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们希望创建一个普通的TCP套接字并连接到启用了HTTPS的Web服务器。然后，我们可以使用SSL包装该连接并检查连接的各种属性。例如，要检查远程Web服务器的身份，我们可以查看SSL证书中的主机名是否与我们期望的相同。以下是一个基于安全套接字的客户端的示例：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run the preceding example, you will see the details of the SSL certificate
    of a remote web server such as [http://www.google.com](http://www.google.com).
    Here we have created a TCP socket and connected it to HTTPS port `443`. Then that
    socket connection is wrapped into SSL packets using our `ssl_wrap_socket()` function.
    This function takes the following parameters as arguments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述示例，您将看到远程Web服务器（例如[http://www.google.com](http://www.google.com)）的SSL证书的详细信息。在这里，我们创建了一个TCP套接字并将其连接到HTTPS端口`443`。然后，该套接字连接使用我们的`ssl_wrap_socket()`函数包装成SSL数据包。此函数将以下参数作为参数：
- en: '`sock`: TCP socket'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sock`：TCP套接字'
- en: '`keyfile`: SSL private key file path'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyfile`：SSL私钥文件路径'
- en: '`certfile`: SSL public certificate path'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certfile`：SSL公共证书路径'
- en: '`cert_reqs`: Confirmation if certificate is required from other side to make
    connection and if validation test is required'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cert_reqs`：确认是否需要来自另一方的证书以建立连接，以及是否需要验证测试'
- en: '`ca_certs`: Public certificate authority certificate path'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ca_certs`：公共证书颁发机构证书路径'
- en: '`server_hostname`: The target remote server''s hostname'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server_hostname`：目标远程服务器的主机名'
- en: '`ssl_version`: The intended SSL version to be used by the client'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssl_version`：客户端要使用的预期SSL版本'
- en: 'At the beginning of the SSL socket wrapping process, we have created an SSL
    context using the `SSLContext()` class. This is necessary to set up the SSL connection
    specific properties. Instead of using a custom context, we could also use a default
    context, supplied by default with the `ssl` module, using the `create_default_context()`
    function. You can specify whether you''d like to create client or server side
    sockets using a constant. The following is an example for creating a client side
    socket:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSL套接字包装过程开始时，我们使用`SSLContext()`类创建了一个SSL上下文。这是必要的，以设置SSL连接的特定属性。除了使用自定义上下文外，我们还可以使用`ssl`模块默认提供的默认上下文，使用`create_default_context()`函数。您可以使用常量指定是否要创建客户端或服务器端套接字。以下是创建客户端套接字的示例：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `SSLContext` object takes the SSL version argument, that in our example
    is set to `PROTOCOL_TLSv1`, or you should use the latest version. Note that SSLv2
    and SSLv3 are broken and must not be used in any production code for serious security
    issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSLContext`对象接受SSL版本参数，在我们的示例中设置为`PROTOCOL_TLSv1`，或者您应该使用最新版本。请注意，SSLv2和SSLv3已经被破解，严重的安全问题不能在任何生产代码中使用。'
- en: In the preceding example, `CERT_REQUIRED` indicates that server certificate
    is necessary for the connection to continue, and this certificate will be validated
    later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`CERT_REQUIRED`表示连接需要服务器证书，并且稍后将验证此证书。
- en: If the CA certificate parameter has been presented with a certificate path,
    the `load_verify_locations()` method is used to load the CA certificate files.
    This will be used to verify the peer server certificates. If you'd like to use
    the default certificate path on your system, you'd probably call another context
    method; `load_default_certs(purpose=Purpose.SERVER_AUTH)`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已提供CA证书参数并提供了证书路径，则使用`load_verify_locations()`方法加载CA证书文件。这将用于验证对等服务器证书。如果您想在系统上使用默认证书路径，您可能会调用另一个上下文方法；`load_default_certs(purpose=Purpose.SERVER_AUTH)`。
- en: When we operate on server side, usually the `load_cert_chain()` method is used
    to load the key and certificate file so that clients can verify the server's authenticity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器端操作时，通常使用`load_cert_chain()`方法加载密钥和证书文件，以便客户端可以验证服务器的真实性。
- en: Finally, the `wrap_socket()` method is called to return an SSL wrapped socket.
    Note that, if `OpenSSL` library comes with **Server Name Indication** (**SNI**)
    support enabled, you can pass the remote server's host name while wrapping the
    socket. This is useful when the remote server uses different SSL certificates
    for different secure services using a single IP address, for example, name-based
    virtual hosting.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`wrap_socket()`方法返回一个SSL包装套接字。请注意，如果`OpenSSL`库启用了**服务器名称指示**（**SNI**）支持，您可以在包装套接字时传递远程服务器的主机名。当远程服务器使用不同的SSL证书为单个IP地址使用不同的安全服务，例如基于名称的虚拟主机时，这将非常有用。
- en: If you run the preceding SSL client code, you will see the various properties
    of the SSL certificate of the remote server, as shown in the following screenshot.
    This is used to verify the authenticity of the remote server by calling the `getpeercert()`
    method and comparing it with the returned hostname.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述SSL客户端代码，您将看到远程服务器的SSL证书的各种属性，如下图所示。这用于通过调用`getpeercert()`方法验证远程服务器的真实性，并将其与返回的主机名进行比较。
- en: '![Securing sockets with TLS/SSL](graphics/B03711_07_13.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![使用TLS/SSL保护套接字](graphics/B03711_07_13.jpg)'
- en: Interestingly, if any other fake web server wants to pretend to be the Google's
    web server, it simply can't do that, provided that you check the SSL certificate
    that is signed by an accredited certificate authority, unless an accredited CA
    has been compromised/subverted. This form of attack to your web browser is commonly
    referred to as the **man in the middle** (**MITM**) attack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果任何其他虚假的Web服务器想要假冒Google的Web服务器，除非您检查由认可的证书颁发机构签署的SSL证书，否则它根本无法做到这一点，除非认可的CA已被破坏/颠覆。对您的Web浏览器进行的这种形式的攻击通常被称为**中间人**（**MITM**）攻击。
- en: Inspecting standard SSL client/server communication
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查标准SSL客户端/服务器通信
- en: 'The following screenshot shows the interaction between the SSL client and the
    remote server:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了SSL客户端与远程服务器之间的交互：
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_14.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![检查标准SSL客户端/服务器通信](graphics/B03711_07_14.jpg)'
- en: Let us examine the SSL handshake process between the client and the server.
    In the first step of a SSL handshake, the client sends a `Hello` message to the
    remote server saying what it is capable of, in terms handling key files, encrypting
    messages, doing message integrity checks, and so on. In the following screenshot,
    you can see that the client is presenting a set of `38` cipher suites to the server
    to choose relevant algorithms. It also sends the TLS version number `1.0` and
    a random number to generate a master secret for encrypting the subsequent message
    exchanges. This is helpful for preventing any third party to look inside the packets.
    The random numbers seen in the hello messages are used to generate the pre-master
    secret, which both ends will process further to arrive at the master secret, and
    then use that to generate the symmetric key.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看客户端和服务器之间的SSL握手过程。在SSL握手的第一步中，客户端向远程服务器发送一个“Hello”消息，说明它在处理密钥文件、加密消息、进行消息完整性检查等方面的能力。在下面的屏幕截图中，您可以看到客户端向服务器呈现了一组“38”个密码套件，以选择相关的算法。它还发送了TLS版本号“1.0”和一个随机数，用于生成用于加密后续消息交换的主密钥。这有助于防止任何第三方查看数据包内容。在“Hello”消息中看到的随机数用于生成预主密钥，双方将进一步处理以得到主密钥，然后使用该密钥生成对称密钥。
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_15.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![检查标准SSL客户端/服务器通信](graphics/B03711_07_15.jpg)'
- en: 'In the second packet from server to client, the server selects the cipher suite
    `TLS_ECDHE_RSA_WITH_RC4_128_SHA` for the purpose of connecting to the client.
    This roughly means the server wants to use the RSA algorithm for key handling,
    RC4 for encryption, and SHA for integrity checking (hashing). This is shown in
    the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器发送到客户端的第二个数据包中，服务器选择了密码套件`TLS_ECDHE_RSA_WITH_RC4_128_SHA`以连接到客户端。这大致意味着服务器希望使用RSA算法处理密钥，使用RC4进行加密，并使用SHA进行完整性检查（哈希）。这在以下屏幕截图中显示：
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_16.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![检查标准SSL客户端/服务器通信](graphics/B03711_07_16.jpg)'
- en: In the second phase of the SSL handshake, the server sends an SSL certificate
    to the client. This certificate is issued by a CA, as mentioned earlier. It contains
    a serial number, public key, validity period, and the details of the subject and
    the issuer. The following screenshot show the remote server certificate. Can you
    locate the server's public key inside the packet?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSL握手的第二阶段，服务器向客户端发送SSL证书。如前所述，此证书由CA颁发。它包含序列号、公钥、有效期和主题和颁发者的详细信息。以下屏幕截图显示了远程服务器的证书。您能在数据包中找到服务器的公钥吗？
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_17.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![检查标准SSL客户端/服务器通信](graphics/B03711_07_17.jpg)'
- en: 'In the third phase of the handshake, the client exchanges a key and calculates
    a master secret to encrypt the messages and continue further communications. Client
    also sends the request to change the cipher specification that was agreed on the
    previous phase. It then indicates to start encrypting the message. The following
    screenshot shows this process:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在握手的第三阶段，客户端交换密钥并计算主密钥以加密消息并继续进一步通信。客户端还发送更改在上一阶段达成的密码规范的请求。然后指示开始加密消息。以下屏幕截图显示了这个过程：
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_18.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![检查标准SSL客户端/服务器通信](graphics/B03711_07_18.jpg)'
- en: 'In the final task of the SSL handshake process, a new session ticket is generated
    by the server for the client''s particular session. This happens due to a TLS
    extension where the client advertises its support by sending an empty session
    ticket extension in the client `Hello` message. The server answers with an empty
    session ticket extension in its server `Hello` message. This session ticket mechanism
    enables the client to remember the whole session state, and the server becomes
    less engaged in maintaining a server-side session cache. The following screenshot
    shows an example for presenting an SSL session ticket:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSL握手过程的最后一个任务中，服务器为客户端的特定会话生成了一个新的会话票证。这是由于TLS扩展引起的，客户端通过在客户端`Hello`消息中发送一个空的会话票证扩展来宣传其支持。服务器在其服务器`Hello`消息中回答一个空的会话票证扩展。这个会话票证机制使客户端能够记住整个会话状态，服务器在维护服务器端会话缓存方面变得不那么忙碌。以下截图显示了一个呈现SSL会话票证的示例：
- en: '![Inspecting standard SSL client/server communication](graphics/B03711_07_19.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![检查标准SSL客户端/服务器通信](graphics/B03711_07_19.jpg)'
- en: Creating a custom SSL client/server
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义SSL客户端/服务器
- en: 'So far, we have been dealing more with the SSL or TLS client. Now, let us have
    a look at the server side briefly. As you are already familiar with the TCP/UDP
    socket server creation process, let''s skip that part and just concentrate on
    the SSL wrapping part. The following code snippet shows an example of a simple
    SSL server:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们更多地处理SSL或TLS客户端。现在，让我们简要地看一下服务器端。由于您已经熟悉TCP/UDP套接字服务器创建过程，让我们跳过那部分，只集中在SSL包装部分。以下代码片段显示了一个简单SSL服务器的示例：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the server socket is wrapped with the `wrap_socket()` method,
    which uses some intuitive parameters such as `certfile`, `keyfile`, and `SSL`
    version number. You can easily generate the certificate by following any step-by-step
    guide found on the Internet. For example, [http://www.akadia.com/services/ssh_test_certificate.html](http://www.akadia.com/services/ssh_test_certificate.html)
    suggests to generate the SSL certificate in a few steps.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，服务器套接字被`wrap_socket()`方法包装，该方法使用一些直观的参数，如`certfile`、`keyfile`和`SSL`版本号。您可以通过按照互联网上找到的任何逐步指南轻松生成证书。例如，[http://www.akadia.com/services/ssh_test_certificate.html](http://www.akadia.com/services/ssh_test_certificate.html)建议通过几个步骤生成SSL证书。
- en: 'Now, let''s make a simplified version of a SSL client to talk with the above
    SSL server. The following code snippet shows an example of a simple SSL client:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们制作一个简化版本的SSL客户端，与上述SSL服务器进行通信。以下代码片段显示了一个简单SSL客户端的示例：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the client/server will show output similar to the following screenshot.
    Can you see any difference in comparison to our last example client/server communication?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行客户端/服务器将显示类似于以下截图的输出。您能否看到与我们上一个示例客户端/服务器通信相比有什么不同？
- en: '![Creating a custom SSL client/server](graphics/B03711_07_20.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义SSL客户端/服务器](graphics/B03711_07_20.jpg)'
- en: Inspecting interaction between a custom SSL client/server
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查自定义SSL客户端/服务器之间的交互
- en: Let us inspect the SSL client/server interaction once again in order to observe
    the differences. The first screenshot shows the entire communication sequence.
    In the following screenshot we can see that the server's `Hello` and certificate
    are combined in the same message.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查SSL客户端/服务器的交互，以观察其中的差异。第一个截图显示了整个通信序列。在以下截图中，我们可以看到服务器的`Hello`和证书合并在同一消息中。
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_21.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![检查自定义SSL客户端/服务器之间的交互](graphics/B03711_07_21.jpg)'
- en: 'The client''s **Client Hello** packet looks pretty similar to our previous
    SSL connection, as shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的**客户端Hello**数据包看起来与我们之前的SSL连接非常相似，如下截图所示：
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_22.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![检查自定义SSL客户端/服务器之间的交互](graphics/B03711_07_22.jpg)'
- en: 'The server''s **Server Hello** packet is a bit different. Can you identify
    the differences? The cipher specification is different that is `TLS_RSA_WITH_AES_256_CBC_SHA`,
    as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的**服务器Hello**数据包有点不同。您能识别出区别吗？密码规范不同，即`TLS_RSA_WITH_AES_256_CBC_SHA`，如下截图所示：
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_23.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![检查自定义SSL客户端/服务器之间的交互](graphics/B03711_07_23.jpg)'
- en: 'The **Client key exchange** packet also looks very familiar, as shown in the
    following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端密钥交换**数据包看起来也很熟悉，如下截图所示：'
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_24.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![检查自定义SSL客户端/服务器之间的交互](graphics/B03711_07_24.jpg)'
- en: 'The following screenshot shows the **New Session Ticket** packet offered in
    this connection:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在此连接中提供的**新会话票证**数据包：
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_25.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![检查自定义SSL客户端/服务器之间的交互](graphics/B03711_07_25.jpg)'
- en: Now let's have a look at the application data. Is that encrypted? For the captured
    packet, it looks like garbage. The following screenshot shows the encrypted message
    that hides the real data. This is what we want to achieve using SSL/TLS.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下应用数据。那加密了吗？对于捕获的数据包，它看起来像垃圾。以下截图显示了隐藏真实数据的加密消息。这就是我们使用SSL/TLS想要实现的效果。
- en: '![Inspecting interaction between a custom SSL client/server](graphics/B03711_07_26.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![检查自定义SSL客户端/服务器之间的交互](graphics/B03711_07_26.jpg)'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed basic TCP/IP socket programming using Python's
    `socket` and `ssl` module. We demonstrated how simple TCP sockets can be wrapped
    with TLS and used to carry encrypted data. We also found the ways to validate
    the authenticity of a remote server using SSL certificates. Some other minor issues
    around socket programming, such as non-blocking socket I/O were also presented.
    The detailed packet analysis in each section helps us to understand what happens
    under the hood in our socket programming exercises.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用Python的`socket`和`ssl`模块进行基本的TCP/IP套接字编程。我们演示了如何将简单的TCP套接字包装为TLS，并用于传输加密数据。我们还发现了使用SSL证书验证远程服务器真实性的方法。还介绍了套接字编程中的一些其他小问题，比如非阻塞套接字I/O。每个部分中的详细数据包分析帮助我们了解套接字编程练习中发生了什么。
- en: In the next chapter, we will learn about the socket server design, particularly
    the popular multithreaded and event-driven approaches will be touched upon.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于套接字服务器设计，特别是流行的多线程和事件驱动方法。
