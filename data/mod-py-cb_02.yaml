- en: Chapter 2. Statements and Syntax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。语句和语法
- en: 'In this chapter we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看以下配方：
- en: Writing python script and module files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Python脚本和模块文件
- en: Writing long lines of code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写长行代码
- en: Including descriptions and documentation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括描述和文档
- en: Better RST markup in docstrings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文档字符串中更好的RST标记
- en: Designing complex if...elif chains
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计复杂的if...elif链
- en: Designing a while statement which terminates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个终止的while语句
- en: Avoiding a potential problem with break statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免break语句可能出现的问题
- en: Leveraging the exception matching rules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用异常匹配规则
- en: 'Avoiding a potential problem with an except: clause'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免except:子句可能出现的问题
- en: Chaining exceptions with the raise from statement
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用raise from语句链接异常
- en: Managing a context using the with statement
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用with语句管理上下文
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python syntax is designed to be very simple. There are a few rules; we'll look
    at some of the interesting statements in the language as a way to understand those
    rules. Just looking at the rules without concrete examples can be confusing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python语法设计得非常简单。有一些规则；我们将查看语言中一些有趣的语句，以了解这些规则。仅仅看规则而没有具体的例子可能会令人困惑。
- en: 'We''ll cover some basics of creating script files first. Then we''ll move on
    to looking at some of the more commonly-used statements. Python only has about
    twenty or so different kinds of imperative statements in the language. We''ve
    already looked at two kinds of statements in [Chapter 1](text00014.html#page "Chapter 1. Numbers,
    Strings, and Tuples") , *Numbers, Strings, and Tuples* : the assignment statement
    and the expression statement.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍创建脚本文件的基础知识。然后我们将继续查看一些常用语句。Python语言中只有大约二十种不同类型的命令语句。我们已经在[第1章](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples")中看过两种语句，*Numbers, Strings, and Tuples*：赋值语句和表达式语句。
- en: 'When we write something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写这样的东西时：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We're actually executing a statement that contains only the evaluation of a
    function, `print()` . This kind of statement—where we evaluate a function or a
    method of an object—is common.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上执行的是一个只包含函数`print()`评估的语句。这种语句-在其中我们评估一个函数或对象的方法-是常见的。
- en: 'The other kind of statement we''ve already seen is the assignment statement.
    Python has many variations on this theme. Most of the time, we''re assigning a
    single value to a single variable. Sometimes, however, we might be assigning two
    variables at the same time, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的另一种语句是赋值语句。Python在这个主题上有很多变化。大多数时候，我们将一个值赋给一个变量。然而，有时我们可能会同时给两个变量赋值，就像这样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These recipes will look at some of the more complex statements, including `if`
    , `while` , `for` , `try` , `with` , and `raise` . We'll touch on a few others
    as we explore the different recipes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配方将查看一些更复杂的语句，包括`if`，`while`，`for`，`try`，`with`和`raise`。在探索不同的配方时，我们还将涉及其他一些。
- en: '![](image/614271.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Writing Python script and module files – syntax basics
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Python脚本和模块文件-语法基础
- en: We'll need to write Python script files in order to do anything truly useful.
    We can experiment with the language at the interaction `>>>` prompt. For real
    work, however, we'll need to create files. The whole point of writing software
    is to create repeatable processing for our data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做任何真正有用的事情，我们需要编写Python脚本文件。我们可以在交互`>>>`提示符下尝试语言。然而，对于真正的工作，我们需要创建文件。编写软件的整个目的是为我们的数据创建可重复的处理。
- en: How can we avoid syntax errors and be sure our code matches what's in common
    use? We need to look at some common aspects of *style* —how we use whitespace
    to clarify our programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免语法错误，并确保我们的代码与常用的代码匹配？我们需要查看一些*style*的常见方面-我们如何使用空白来澄清我们的编程。
- en: We'll also look at a number of more technical considerations. For example, we
    need to be sure to save our files in the UTF-8 encoding. While ASCII encoding
    is still supported by Python, it's a poor choice for modern programming. We'll
    also need to be sure to use spaces instead of tabs. If we use Unix newlines as
    much as possible, we'll also find things are slightly simpler.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一些更多的技术考虑因素。例如，我们需要确保以UTF-8编码保存我们的文件。虽然Python仍然支持ASCII编码，但对于现代编程来说，这是一个不好的选择。我们还需要确保使用空格而不是制表符。如果我们尽可能使用Unix换行符，我们也会发现事情稍微简单一些。
- en: Most text editing tools will work properly with Unix (newline) line endings
    as well as Windows or DOS (return-newline) line endings. Any tool that can't work
    with both kinds of line endings should be avoided.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文本编辑工具都可以正确处理Unix（换行符）和Windows或DOS（回车换行符）的行尾。任何不能处理这两种行尾的工具都应该避免使用。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: To edit Python scripts, we'll need a good programming text editor. Python comes
    with a handy editor, IDLE. It works pretty well. It lets us jump back and forth
    between a file and an interactive `>>>` prompt, but it's not a great programming
    editor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑Python脚本，我们需要一个好的编程文本编辑器。Python自带一个方便的编辑器，IDLE。它工作得相当不错。它让我们可以在文件和交互`>>>`提示之间来回跳转，但它不是一个很好的编程编辑器。
- en: There are dozens and dozens of good programming editors. It's nearly impossible
    to suggest just one. So we'll suggest a few.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种优秀的编程编辑器。几乎不可能只建议一个。所以我们将建议几个。
- en: ActiveState has Komodo IDE, which is very sophisticated. The Komodo Edit version
    is free, and does some of the same things as the full Komodo IDE. This runs on
    all common OS's; it's a good first choice because it's consistent no matter where
    we're writing code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ActiveState有非常复杂的Komodo IDE。Komodo Edit版本是免费的，并且与完整的Komodo IDE做了一些相同的事情。它可以在所有常见的操作系统上运行；这是一个很好的第一选择，因为无论我们在哪里编写代码，它都是一致的。
- en: See [http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/) .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/)。
- en: Notepad++ is good for Windows developers. See [https://notepad-plus-plus.org](https://notepad-plus-plus.org)
    .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Notepad++适用于Windows开发人员。请参阅[https://notepad-plus-plus.org](https://notepad-plus-plus.org)。
- en: BBEdit is very nice for Mac OS X developers. See [http://www.barebones.com/products/bbedit/](http://www.barebones.com/products/bbedit/)
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: BBEdit非常适合Mac OS X开发人员。请参阅[http://www.barebones.com/products/bbedit/](http://www.barebones.com/products/bbedit/)。
- en: For Linux developers, there are several built-in editors, including VIM, gedit,
    or Kate. These are all good. Since Linux tends to be biased toward developers,
    the editors available are all suitable for writing Python.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux开发人员，有几个内置的编辑器，包括VIM、gedit或Kate。这些都很好。由于Linux倾向于偏向开发人员，可用的编辑器都适合编写Python。
- en: 'What''s important is that we''ll often have two windows open while we''re working:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们在工作时通常会打开两个窗口：
- en: The script or file that we're working on.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在处理的脚本或文件。
- en: Python's `>>>` prompt (perhaps from a shell or perhaps from IDLE) where we can
    try things out to see what works and what doesn't. We may be creating our script
    in Notepad++, but using IDLE to experiment with data structures and algorithms.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的`>>>`提示（可能来自shell，也可能来自IDLE），我们可以尝试一些东西，看看什么有效，什么无效。我们可能会在Notepad++中创建脚本，但使用IDLE来尝试数据结构和算法。
- en: We actually have two recipes here. First, we need to set some defaults for our
    editor. Then, once the editor is set up properly, we can create a generic template
    for our script files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们这里有两个配方。首先，我们需要为我们的编辑器设置一些默认值。然后，一旦编辑器正确设置，我们就可以为我们的脚本文件创建一个通用模板。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we'll look at the general setup that we need to do in our editor of choice.
    We'll use Komodo examples, but the basic principles apply to all editors. Once
    we've set the edit preferences, we can create our script file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下我们首选编辑器中需要做的一般设置。我们将使用Komodo示例，但基本原则适用于所有编辑器。一旦我们设置了编辑首选项，我们就可以创建我们的脚本文件。
- en: Open the editor of choice. Look at the preferences page.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开首选编辑器。查看首选项页面。
- en: Find the settings for preferred file encoding. With Komodo Edit Preferences,
    it's on the **Internationalization** tab. Set this to **UTF-8** .
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找首选文件编码的设置。使用Komodo Edit首选项，它在**国际化**选项卡上。将其设置为**UTF-8**。
- en: Find the settings for indentation. If there's a way to use spaces instead of
    tabs, check this option. With Komodo Edit, we actually do this backwards—we uncheck
    **prefer spaces over tabs** .
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找缩进设置。如果有一种方法可以使用空格而不是制表符，请检查此选项。使用Komodo Edit，我们实际上是反过来做的——我们取消**优先使用空格而不是制表符**。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The rule is this: we want *spaces* ; we do not want *tabs* .'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是：我们想要*空格*；我们不想要*制表符*。
- en: Also, set the spaces per indent to be four. That's typical for Python code.
    It allows us to have several levels of indentation and still keep the code fairly
    narrow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还要将每个缩进的空格设置为四个。这对于Python代码来说很典型。它允许我们有几个缩进级别，但仍然保持代码相当窄。
- en: 'Once we''re sure that our files will be saved in UTF-8 encoding, and we''re
    also sure we''re using spaces instead of tabs, we can create an example script
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定我们的文件将以UTF-8编码保存，并且我们也确定我们使用空格而不是制表符，我们可以创建一个示例脚本文件：
- en: 'The first line of most Python script files should look like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数Python脚本文件的第一行应该是这样的：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets an association between the file you're writing and Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你正在编写的文件和Python之间建立关联。
- en: For Windows, the file name to program association is done through a setting
    in one of the Windows control panels. Within the **Default Programs** control
    panel, there's a panel to **Set Associations** . This control panel shows that
    `.py` files are bound to the Python program. This is normally set by the installer,
    and we rarely need to change it or set it manually.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，文件名到程序的关联是通过Windows控制面板中的一个设置来完成的。在**默认程序**控制面板中，有一个**设置关联**面板。此控制面板显示`.py`文件绑定到Python程序。这通常由安装程序设置，我们很少需要更改它或手动设置它。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Windows developers can include the preamble line anyway. It will make Mac OS
    X and Linux folks happy when they download the project from GitHub.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Windows开发人员可以无论如何包含序言行。这将使Mac OS X和Linux的人们从GitHub下载项目时感到高兴。
- en: After the preamble, there should be a triple-quoted block of text. This is the
    documentation string (called a **docstring** ) for the file we're going to create.
    It's not technically mandatory, but it's essential for explaining what a file
    contains.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序言之后，应该有一个三引号的文本块。这是我们要创建的文件的文档字符串（称为**docstring**）。这在技术上不是强制性的，但对于解释文件包含的内容至关重要。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because Python triple-quoted strings can be indefinitely long, feel free to
    write as much as necessary. This should be the primary vehicle for describing
    the script or library module. This can even include examples of how it works.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python的三引号字符串可以无限长，所以可以随意写入必要的内容。这应该是描述脚本或库模块的主要方式。这甚至可以包括它是如何工作的示例。
- en: 'Now comes the interesting part of the script: the part that really does something.
    We can write all the statements we need to get the job done. For now, we''ll use
    this as a placeholder:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来到脚本的有趣部分：真正执行操作的部分。我们可以编写所有需要完成工作的语句。现在，我们将使用这个作为占位符：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this, our script does something. In other recipes we'll look at a number
    of other statements for doing things. It's common to create function and class
    definitions, as well as write statements to use the functions and classes to do
    things.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的脚本就有了作用。在其他示例中，我们将看到许多其他用于执行操作的语句。通常会创建函数和类定义，并编写语句来使用函数和类执行操作。
- en: At the top level of our scripts, all of the statements must begin at the left
    margin and must be complete on a single line. There are some complex statements
    which will have blocks of statements nested inside them. These internal blocks
    of statements must be indented. Generally—because we set indentation to four spaces—we
    can hit the *Tab* key to indent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本的顶层，所有语句必须从左边缘开始，并且必须在一行上完成。有一些复杂的语句，其中将嵌套在其中的语句块。这些内部语句块必须缩进。通常情况下，因为我们将缩进设置为四个空格，我们可以按*Tab*键进行缩进。
- en: 'Our file should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件应该是这样的：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unlike other languages, there's very little *boilerplate* in Python. There's
    only one line of *overhead* and even the `#!/usr/bin/env python3` line is generally
    optional.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，Python中几乎没有*样板*。只有一行*开销*，甚至`#!/usr/bin/env python3`行通常是可选的。
- en: Why do we set the encoding to UTF-8? The entire language is designed to work
    using just the original 128 ASCII characters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要将编码设置为UTF-8？整个语言都是设计为仅使用最初的128个ASCII字符。
- en: We often find that ASCII is limiting. It's easier to set our editor to use UTF-8
    encoding. With this setting, we can simply use any character that makes sense.
    We can use characters like `µ` as Python variables if we save our programs in
    UTF-8 encoding.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常发现ASCII有限制。将编辑器设置为使用UTF-8编码更容易。有了这个设置，我们可以简单地使用任何有意义的字符。如果我们将程序保存在UTF-8编码中，我们可以将字符如`µ`用作Python变量。
- en: 'This is legal Python if we save our file in UTF-8:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将文件保存为UTF-8，这是合法的Python：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to be consistent when choosing between spaces and tabs in Python.
    They are both more or less invisible, and mixing them can easily lead to confusion.
    Spaces are suggested.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中在选择空格和制表符之间保持一致是很重要的。它们都是几乎看不见的，混合它们很容易导致混乱。建议使用空格。
- en: When we set up our editor to use a four-space indent, we can then use the button
    labeled Tab on our keyboard to insert four spaces. Our code will align properly,
    and the indentation will show how our statements nest inside each other.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置编辑器使用四个空格缩进后，我们可以使用键盘上标有Tab的按钮插入四个空格。我们的代码将对齐，缩进将显示语句如何嵌套在彼此内。
- en: 'The initial `#!` line is a comment: everything between a `#` and the end of
    the line is ignored. OS shell programs like **bash** and **ksh** look at the first
    line of a file to see what the file contains. The first few bytes are sometimes
    called *magic* because the shell is peeking at them. Shell programs look for the
    two-character sequence of `#!` to identify the program responsible for this data.
    We prefer to use `/usr/bin/env` to start the Python program for us. We can leverage
    this to make Python-specific environment settings via the `env` program.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`#!`行是一个注释：从`#`到行尾的所有内容都会被忽略。像**bash**和**ksh**这样的操作系统shell程序会查看文件的第一行，以确定文件包含的内容。文件的前几个字节有时被称为*魔术*，因为shell程序正在窥视它们。Shell程序会寻找`#!`这个两个字符的序列，以确定负责这些数据的程序。我们更喜欢使用`/usr/bin/env`来启动Python程序。我们可以利用这一点来通过`env`程序进行Python特定的环境设置。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The *Python Standard Library* documents are derived, in part, from the documentation
    strings present in the module files. It's common practice to write sophisticated
    docstrings in modules. There are tools like Pydoc and Sphinx that can reformat
    the module docstrings into elegant documentation. We'll look at this in separate
    recipes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库*文档部分源自模块文件中存在的文档字符串。在模块中编写复杂的文档字符串是常见做法。有一些工具，如Pydoc和Sphinx，可以将模块文档字符串重新格式化为优雅的文档。我们将在单独的部分中学习这一点。'
- en: Additionally, unit test cases can be included in the docstrings. Tools like
    **doctest** can extract examples from the document string and execute the code
    to see if the answers in the documentation match the answers found by running
    the code. Most of this book is validated with doctest.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单元测试用例可以包含在文档字符串中。像**doctest**这样的工具可以从文档字符串中提取示例并执行代码，以查看文档中的答案是否与运行代码找到的答案匹配。本书的大部分内容都是通过doctest验证的。
- en: The triple-quoted documentation strings are preferred over the `#` comments.
    The text between `#` and the end of the line is ignored, and counts as a comment.
    Since this is limited to a single line, it is used sparingly. A docstring can
    be of indefinite size; they are used widely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 三引号文档字符串优于`#`注释。`#`和行尾之间的文本会被忽略，并被视为注释。由于这仅限于单行，因此使用得很少。文档字符串的大小可以是无限的；它们被广泛使用。
- en: 'In Python 3.5, we''ll sometimes see this kind of thing in a script file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.5中，我们有时会在脚本文件中看到这样的东西：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `# type: float` comment can be used by a type inferencing system to establish
    that the various data types can occur when the program is actually executed. For
    more information on this, see **Python Enhancement Proposal 484** : [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
    .'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`# type: float`注释可以被类型推断系统用来确定程序实际执行时可能出现的各种数据类型。有关更多信息，请参阅**Python Enhancement
    Proposal 484**：[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)。'
- en: There's another bit of overhead that's sometimes included in a file. The VIM
    editor lets us keep edit preferences in the file. This is called a **modeline**
    . We often have to enable modelines by including the `set modeline` setting in
    our `~/.vimrc` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时文件中还包含另一个开销。VIM编辑器允许我们在文件中保留编辑首选项。这被称为**modeline**。我们经常需要通过在我们的`~/.vimrc`文件中包含`set
    modeline`设置来启用modelines。
- en: Once we've enabled modelines, we can include a special `# vim` comment at the
    end of our file to configure VIM.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启用了modelines，我们可以在文件末尾包含一个特殊的`# vim`注释来配置VIM。
- en: 'Here''s a typical modeline that''s useful for Python:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对Python有用的典型modeline：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sets the Unicode `u+0009` TAB characters to be transformed to eight spaces
    when we hit the *Tab* key, we'll shift four spaces. This setting is carried in
    the file; we don't have to do any VIM setup to apply these settings to our Python
    script files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把Unicode `u+0009` TAB字符转换为八个空格，当我们按下*Tab*键时，我们将移动四个空格。这个设置被保存在文件中；我们不需要进行任何VIM设置来将这些设置应用到我们的Python脚本文件中。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll look at how to write useful document strings in the *Including descriptions
    and documentation* and the *Writing better RST markup in docstrings* recipes
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*包括描述和文档*和*在文档字符串中编写更好的RST标记*这两个部分中学习如何编写有用的文档字符串
- en: For more information in suggested style, see [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关建议的样式的更多信息，请参阅[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)
- en: Writing long lines of code
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写长行代码
- en: There are many times when we need to write lines of code that are so long that
    they're very hard to read. Many people like to limit the length of a line of code
    to 80 characters or fewer. It's a well-known principle of graphic design that
    a narrower line is easier to read; opinions vary, but 65 characters is often cited
    as ideal. See [http://webtypography.net/2.1.2](http://webtypography.net/2.1.2)
    .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多时候，我们需要编写非常长的代码行，以至于它们非常难以阅读。许多人喜欢将代码行的长度限制在80个字符或更少。这是一个众所周知的图形设计原则，即较窄的行更容易阅读；意见不一，但65个字符经常被认为是理想的长度。参见[http://webtypography.net/2.1.2](http://webtypography.net/2.1.2)。
- en: While shorter lines are easier on the eyes, our code can refuse to cooperate
    with this principle. Long statements are a common problem. How can we break long
    Python statements into more manageable pieces?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然较短的行更容易阅读，但我们的代码可能不遵循这个原则。长语句是一个常见的问题。我们如何将长的Python语句分解为更易处理的部分？
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Often, we''ll have a statement that''s awkwardly long and hard to work with.
    Let''s say we''ve got something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会有一个语句，它非常长且难以处理。比如说我们有这样的东西：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code includes a long formula, and a long format string into which we're
    injecting values. This looks bad when typeset in a book. It looks bad on our screen
    when trying to edit this script.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包括一个长公式和一个长格式字符串，我们要将值注入其中。这在书中排版时看起来很糟糕。在尝试编辑此脚本时，屏幕上看起来很糟糕。
- en: We can't simply break Python statements into chunks. The syntax rules are clear
    that a statement must be complete on a single *logical* line.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将Python语句分成块。语法规则明确指出语句必须在单个*逻辑*行上完成。
- en: The term logical line is a hint as to how we can proceed. Python makes a distinction
    between logical lines and physical lines; we'll leverage these syntax rules to
    break up long statements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 术语逻辑行是如何进行的一个提示。Python区分逻辑行和物理行；我们将利用这些语法规则来分解长语句。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Python gives us several ways to wrap long statements so they're more readable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python给了我们几种包装长语句使其更易读的方法。
- en: We can use `\` at the end of a line to continue onto the next line.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在行尾使用`\`继续到下一行。
- en: We can leverage Python's rule that a statement can span multiple logical lines
    because the `()` , the `[]` , and the `{}` characters must balance. In addition
    to using `()` and `\` , we can also exploit the way Python automatically concatenates
    adjacent string literals to make a single, longer literal; `("a" "b")` is the
    same as `ab` .
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以利用Python的规则，即语句可以跨越多个逻辑行，因为`()`、`[]`和`{}`字符必须平衡。除了使用`()`和`\`，我们还可以利用Python自动连接相邻字符串文字的方式，使其成为一个更长的文字；`("a"
    "b")`与`ab`相同。
- en: In some cases, we can decompose a statement by assigning intermediate results
    to separate variables.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以通过将中间结果分配给单独的变量来分解语句。
- en: We'll look at each one of these in separate parts of this recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本教程的不同部分分别讨论每一个。
- en: Using backslash to break a long statement into logical lines
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用反斜杠将长语句分解为逻辑行
- en: 'Here''s the context for this technique:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的背景是：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Python allows us to use `\` and break the line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们使用`\`并换行。
- en: 'Write the whole statement on one long line, even if it''s confusing:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个语句写在一行上，即使它很混乱：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If there''s a *logical* break, insert the `\` there. Sometimes, there''s no
    really good break:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有*逻辑*断点，在那里插入`\`。有时，没有真正好的断点：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For this to work, the `\` must be the last character on the line. We can't even
    have a single space after the `\` . This is fairly hard to see; for this reason,
    we don't encourage it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，`\`必须是行上的最后一个字符。我们甚至不能在`\`后有一个空格。这很难看出来；因此，我们不鼓励这样做。
- en: In spite of this being a little hard to see, the `\` can always be used. Think
    of it as the last resort in making a line of code more readable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这有点难以理解，但`\`总是可以使用的。把它看作是使代码行更易读的最后手段。
- en: Using the () characters to break a long statement into sensible pieces
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用()字符将长语句分解为合理的部分
- en: 'Write the whole statement on one line, even if it''s confusing:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个语句写在一行上，即使它很混乱：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the extra `()` characters that don''t change the value, but allow breaking
    the expression into multiple lines:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加额外的`()`字符不改变值，但允许将表达式分解为多行：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Break the line inside the `()` characters:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`()`字符内部断开行：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The matching `()` character's technique is quite powerful and will work in a
    wide variety of cases. This is widely used and highly recommended.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配`()`字符的技术非常强大，适用于各种情况。这是被广泛使用和强烈推荐的。
- en: We can almost always find a way to add extra `()` characters to a statement.
    In the rare cases when we can't add `()` characters, or adding `()` characters
    doesn't improve things, we can fall back on using `\` to break the statement into
    sections.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是可以找到一种方法向语句添加额外的`()`字符。在我们无法添加`()`字符或添加`()`字符无法改善情况的罕见情况下，我们可以退而使用`\`将语句分解为几个部分。
- en: Using string literal concatenation
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串文字连接
- en: 'We can combine the `()` characters with another rule that combines string literals.
    This is particularly effective for long, complex format strings:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`()`字符与另一条规则相结合，该规则结合字符串文字。这对于长而复杂的格式字符串特别有效：
- en: Wrap a long string value in the `()` characters.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`()`字符包装一个长字符串值。
- en: 'Break the string into substrings:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串分解为子字符串：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can always break a long string into adjacent pieces. Generally, this is most
    effective when the pieces are surrounded by `()` characters. We can then use as
    many physical line breaks as we need. This is limited to those situations where
    we have particularly long string values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以将长字符串分解为相邻的片段。通常，当片段被`()`字符包围时，这是最有效的。然后我们可以使用尽可能多的物理行断开。这仅限于那些我们有特别长的字符串值的情况。
- en: Assigning intermediate results to separate variables
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将中间结果分配给单独的变量
- en: 'Here''s the context for this technique:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的背景是：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can break this into three intermediate values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这分解为三个中间值。
- en: 'Identify sub-expressions in the overall expression. Assign these to variables:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别整体表达式中的子表达式。将这些分配给变量：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is generally quite simple. It may require a little care to do the algebra
    to locate sensible sub-expressions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常相当简单。可能需要一点小心来进行代数运算，以找到合理的子表达式。
- en: 'Replace the sub-expressions with the variables which were created:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用创建的变量替换子表达式：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is an essential textual replacement of the original complex sub-expression
    with a variable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对原始复杂子表达式的一个必要的文本替换，用一个变量来代替。
- en: We didn't give these variables descriptive names. In some cases, the sub-expressions
    have some semantics that we can capture with meaningful names. In this case, we
    didn't understand the expression well enough to provide deeply meaningful names.
    Instead, we chose short, arbitrary identifiers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有给这些变量起描述性的名称。在某些情况下，子表达式具有一些语义，我们可以用有意义的名称来捕捉。在这种情况下，我们没有理解表达式足够深刻，无法提供深层有意义的名称。相反，我们选择了简短的、任意的标识符。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Python Language Manual makes a distinction between logical lines and physical
    lines. A logical line contains a complete statement. It can span multiple physical
    lines through techniques called **line joining** . The manual calls the techniques
    **explicit line joining** and **implicit line joining** .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言手册对逻辑行和物理行进行了区分。逻辑行包含一个完整的语句。它可以通过称为**行连接**的技术跨越多个物理行。手册称这些技术为**显式行连接**和**隐式行连接**。
- en: The use of `\` for explicit line joining is sometimes helpful. Because it's
    easy to overlook, it's not generally encouraged. It is the method of last resort.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显式行连接的使用有时是有帮助的。因为很容易忽视，所以通常不受鼓励。这是最后的手段。
- en: 'The use of `()` for implicit line joining can be used in many cases. It often
    fits semantically with the structure of the expressions, so it is encouraged.
    We may have the `()` characters as a required syntax. For example, we already
    have `()` characters as part of the syntax for the `print()` function. We might
    do this to break up a long statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式行连接的使用可以在许多情况下使用。它通常在语义上与表达式的结构相吻合，因此是受鼓励的。我们可能需要`()`字符作为必需的语法。例如，我们已经将`()`字符作为`print()`函数的语法的一部分。我们可能这样做来分解一个长语句：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Expressions are used widely in a number of Python statements. Any expression
    can have `()` characters added. This gives us a lot of flexibility.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式广泛用于许多Python语句。任何表达式都可以添加`()`字符。这给了我们很大的灵活性。
- en: There are, however, a few places where we may have a long statement that does
    not specifically involve an expression. The most notable example of this is the
    `import` statement—it can become long, but doesn't use any expressions that can
    be parenthesized.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些地方可能有一个不涉及特定表达式的长语句。其中最显著的例子是`import`语句 - 它可能变得很长，但不使用可以加括号的任何表达式。
- en: 'The language designers, however, allow us to use `()` characters so that a
    long list of names can be broken up into multiple logical lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，语言设计者允许我们使用`()`字符，以便将一长串名称分解为多个逻辑行：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, the `()` characters are emphatically not part of an expression.
    The `()` characters are just extra syntax, included to make the statement consistent
    with other statements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`()`字符绝对不是表达式的一部分。`()`字符只是额外的语法，包括使语句与其他语句一致。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Implicit line joining also applies to the matching `[]` characters and `{}`
    characters. These apply to collection data structures that we'll look at in [Chapter
    4](text00048.html#page "Chapter 4. Built-in Data Structures – list, set, dict")
    , *Built-in Data Structures – list, set, dict* .
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式行连接也适用于匹配的`[]`字符和`{}`字符。这些适用于我们将在[第4章](text00048.html#page "第4章。内置数据结构 - 列表、集合、字典")中查看的集合数据结构，*内置数据结构
    - 列表、集合、字典*。
- en: Including descriptions and documentation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括描述和文档
- en: When we have a useful script, we often need to leave notes for ourselves—and
    others—on what it does, how it solves some particular problem, and when it should
    be used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个有用的脚本时，我们经常需要为自己和其他人留下关于它的说明，它是如何解决某个特定问题的，以及何时应该使用它的笔记。
- en: Because clarity is important, there are some formatting recipes that can help
    make the documentation very clear. This recipe also contains a suggested outline
    so that the documentation will be reasonably complete.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为清晰很重要，有一些格式化的方法可以帮助使文档非常清晰。这个方法还包含了一个建议的大纲，以便文档会相当完整。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If we've used the *Writing python script and module files - syntax basics* recipe
    to build a script file, we'll have put a small documentation string in our script
    file. We'll expand on this documentation string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用*编写Python脚本和模块文件 - 语法基础*的方法来构建一个脚本文件，我们将在我们的脚本文件中放置一个小的文档字符串。我们将扩展这个文档字符串。
- en: There are other places where documentation strings should be used. We'll look
    that these additional locations in [Chapter 3](text00039.html#page "Chapter 3. Function
    Definitions") , *Function Definitions* , and [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他应该使用文档字符串的地方。我们将在[第3章](text00039.html#page "第3章。函数定义")和[第6章](text00070.html#page
    "第6章。类和对象的基础知识")中查看这些额外的位置，*函数定义*和*类和对象的基础知识*。
- en: 'We have two general kinds of modules for which we''ll be writing summary docstrings:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种一般类型的模块，我们将编写摘要文档字符串：
- en: '**Library Modules** : These files will contain mostly function definitions
    as well as class definitions. In this case, the docstring summary can focus on
    what the module is more than what it does. The docstring can provide examples
    of using the functions and classes that are defined in the module. In [Chapter
    3](text00039.html#page "Chapter 3. Function Definitions") , *Function Definitions*
    , and [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we''ll look more closely at this idea of a
    package of functions or classes.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库模块**：这些文件将主要包含函数定义以及类定义。在这种情况下，文档字符串摘要可以侧重于模块是什么，而不是它做什么。文档字符串可以提供使用模块中定义的函数和类的示例。在[第3章](text00039.html#page
    "第3章。函数定义")，*函数定义*，和[第6章](text00070.html#page "第6章。类和对象的基础")，*类和对象的基础*，我们将更仔细地研究这个函数包或类包的概念。'
- en: '**Scripts** : These are files that we generally expect will do some real work.
    In this case, we want to focus on doing rather than being. The docstring should
    describe what it does and how to use it. The options, environment variables, and
    configuration files are important parts of this docstring.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本**：这些通常是我们期望能够完成一些实际工作的文件。在这种情况下，我们希望关注的是做而不是存在。文档字符串应该描述它的功能以及如何使用它。选项、环境变量和配置文件是这个文档字符串的重要部分。'
- en: We will sometimes create files that contain a little of both. This requires
    some careful editing to strike a proper balance between doing and being. In most
    cases, we'll simply provide both kinds of documentation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会创建包含两者的文件。这需要一些仔细的编辑来在做和存在之间取得适当的平衡。在大多数情况下，我们将简单地提供两种文档。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first step in writing documentation is the same for both library modules
    and scripts:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编写文档的第一步对于库模块和脚本是相同的：
- en: Write a brief summary of what the script or module is or does. The summary doesn't
    dig too deeply into how it works. Like a *lede* in a newspaper article, it introduces
    the who, what, when, where, how, and why of the module. Details will follow in
    the body of the docstring.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个简要概述脚本或模块是什么或做什么。摘要不要深入介绍它的工作原理。就像报纸文章中的导语一样，它介绍了模块的谁、什么、何时、何地、如何和为什么。详细信息将在文档字符串的正文中提供。
- en: The way the information is displayed by tools like sphinx and pydoc suggests
    a specific style hint. In the output from these tools, the context is pretty clear,
    therefore it's common to omit a subject in the summary sentence. The sentence
    often begins with the verb.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 工具如sphinx和pydoc显示信息的方式暗示了特定的样式提示。在这些工具的输出中，上下文是非常清晰的，因此在摘要句中通常可以省略主语。句子通常以动词开头。
- en: 'For example, a summary like this: *This script downloads and decodes the current
    Special Marine Warning (SMW) for the area AKQ* has a needless *This script* .
    We can drop that and begin with the verb phrase *Downloads and decodes...* .'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像这样的摘要：*这个脚本下载并解码了当前的特殊海洋警告（SMW）*有一个多余的*这个脚本*。我们可以去掉它，然后以动词短语*下载并解码...*开始。
- en: 'We might start our module docstring like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会这样开始我们的模块文档字符串：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll separate the other steps based on the general focus of the module.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据模块的一般重点分开其他步骤。
- en: Writing docstrings for scripts
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为脚本编写文档字符串
- en: When we document a script, we need to focus on the needs of a person who will
    use the script.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录脚本时，我们需要关注将使用脚本的人的需求。
- en: Start as shown earlier, creating a summary sentence.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像之前展示的那样开始，创建一个摘要句。
- en: Sketch an outline for the rest of the docstring. We'll be using **ReStructuredText**
    ( **RST** ) markup. Write the topic on one line, then put a line of `=` under
    the topic to make them a proper section title. Remember to leave a blank line
    between each topic.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾勒出文档字符串的其余部分的大纲。我们将使用**ReStructuredText**（**RST**）标记。在一行上写出主题，然后在主题下面放一行`=`，使它们成为一个适当的章节标题。记得在每个主题之间留下一个空行。
- en: 'Topics may include:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 主题可能包括：
- en: '**SYNOPSIS** : A summary of how to run this script. If the script uses the
    `argparse` module to process command-line arguments, the help text produced by
    `argparse` is the ideal summary text.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概要**：如何运行这个脚本的摘要。如果脚本使用`argparse`模块来处理命令行参数，那么`argparse`生成的帮助文本就是理想的摘要文本。'
- en: '**DESCRIPTION** : A more complete explanation of what this script does.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：这个脚本的更完整的解释。'
- en: '**OPTIONS** : If `argparse` is used, this is a place to put the details of
    each argument. Often we''ll repeat the `argparse` help parameter.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：如果使用了`argparse`，这是放置每个参数详细信息的地方。通常我们会重复`argparse`的帮助参数。'
- en: '**ENVIRONMENT** :If `os.environ` is used, this is the place to describe the
    environment variables and what they mean.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：如果使用了`os.environ`，这是描述环境变量及其含义的地方。'
- en: '**FILES** : Names of files that are created or read by a script are very important
    pieces of information.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：由脚本创建或读取的文件名称是非常重要的信息。'
- en: '**EXAMPLES** : Some examples of using the script are always helpful.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：始终有一些使用脚本的示例会很有帮助。'
- en: '**SEE ALSO** : Any related scripts or background information.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**另请参阅**：任何相关的脚本或背景信息。'
- en: Other topics that might be interesting include **EXIT STATUS** , **AUTHOR**
    , **BUGS** , **REPORTING BUGS** , **HISTORY** , or **COPYRIGHT** . In some cases,
    advice on reporting bugs, for instance, doesn't really belong in a module's docstring,
    but belongs elsewhere in the project's GitHub or SourceForge pages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能有趣的主题包括**退出状态**，**作者**，**错误**，**报告错误**，**历史**或**版权**。在某些情况下，例如关于报告错误的建议，实际上并不属于模块的文档字符串，而是属于项目的GitHub或SourceForge页面的其他位置。
- en: Fill in the details under each topic. It's important to be accurate. Since we're
    embedding this documentation within the same file as the code, it's easy to check
    elsewhere in the module to be sure that the content is correct and complete.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个主题下填写细节。准确性很重要。由于我们将这些文档嵌入到与代码相同的文件中，因此很容易在模块的其他地方检查内容是否正确和完整。
- en: For code samples, there's a cool bit of RST markup we can use. Recall that all
    elements are separated by blank lines. In one paragraph, use `::` by itself. In
    the next paragraph, provide the code example indented by four spaces.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于代码示例，我们可以使用一些很酷的RST标记。回想一下，所有元素都是由空行分隔的。在一个段落中，只使用`::`。在下一个段落中，将代码示例缩进四个空格。
- en: 'Here''s an example of a docstring for a script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个脚本的docstring示例：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the Synopsis section, we used `::` as a separate paragraph. In the Examples
    section, we used `::` at the end of a paragraph. Both versions are hints to the
    RST processing tools that the indented section that follows should be typeset
    as code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在概要部分，我们使用`::`作为单独的段落。在示例部分，我们在段落末尾使用`::`。这两个版本都是对RST处理工具的提示，表明接下来的缩进部分应该被排版为代码。
- en: Writing docstrings for library modules
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为库模块编写docstrings
- en: When we document a library module, we need to focus on the needs of a programmer
    who will import the module to use it in their code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们记录库模块时，我们需要关注的是那些将导入模块以在其代码中使用的程序员的需求。
- en: Sketch an outline for the rest of the docstring. We'll be using RST markup.
    Write the topic on one line. Include a line of `=` under each topic to make the
    topic into a proper heading. Remember to leave a blank line between each paragraph.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为docstring的其余部分草拟一个大纲。我们将使用RST标记。在一行上写出主题。在每个主题下面加一行`=`，使主题成为一个适当的标题。记得在每个段落之间留下一个空行。
- en: Start as shown previously, creating a summary sentence.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所示开始，创建一个摘要句子。
- en: '**DESCRIPTION** : A summary of what the modules contains and why the module
    is useful.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：模块包含的内容以及模块的用途摘要。'
- en: '**MODULE CONTENTS** : The classes and functions defined in this module.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块内容**：此模块中定义的类和函数。'
- en: '**EXAMPLES** : Examples of using the module.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例**：使用模块的示例。'
- en: Fill in the details for each topic. The module contents may be a long list of
    class or function definitions. This should be a summary. Within each class or
    function, we'll have a separate docstring with the details for that item.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个主题填写详细信息。模块内容可能是一个很长的类或函数定义列表。这应该是一个摘要。在每个类或函数内部，我们将有一个单独的docstring，其中包含该项的详细信息。
- en: For code examples, see the previous examples. Use `::` as a paragraph or the
    ending of a paragraph. Indent the code example by four spaces.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有关代码示例，请参阅前面的示例。使用`::`作为段落或段落结束。将代码示例缩进四个空格。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Over the decades the *man page* outline has evolved to contain a useful summary
    of Linux commands. This general approach to writing documentation has proven useful
    and resilient. We can capitalize on this large body of experience, and structure
    our documentation to follow the man page model.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，*man page*的大纲已经发展成为Linux命令的有用摘要。这种撰写文档的一般方法被证明是有用和有韧性的。我们可以利用这一大量的经验，并结构化我们的文档以遵循man
    page模型。
- en: These two recipes for describing software are based on summaries of many individual
    pages of documentation. The goal is to leverage the well-known set of topics.
    This makes our module documentation mirror the common practice.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种描述软件的方法都是基于许多单独页面文档的摘要。目标是利用众所周知的主题集。这使得我们的模块文档与常见做法相一致。
- en: We want to prepare module docstrings that can be used by the Sphinx Python Documentation
    Generator (see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)
    ). This is the tool used to produce Python's documentation files. The `autodoc`
    extension in Sphinx will read the docstring headers on our modules, classes, and
    functions, to produce the final documentation that looks like other modules in
    the Python ecosystem.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望准备模块docstrings，这些docstrings可以被Sphinx Python文档生成器使用（参见[http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)）。这是用于生成Python文档文件的工具。Sphinx中的`autodoc`扩展将读取我们的模块、类和函数上的docstring头，以生成最终的文档，看起来像Python生态系统中的其他模块。
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: RST has a simple syntax rule that paragraphs are separated by blank lines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: RST有一个简单的语法规则，即段落之间用空行分隔。
- en: This rule makes it easy to write documents that can be examined by the various
    RST processing tools and reformatted to look extremely nice.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则使得编写的文档可以被各种RST处理工具检查，并重新格式化得非常漂亮。
- en: 'When we want to include a block of code, we''ll have some special paragraphs:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要包含一段代码块时，我们将有一些特殊的段落：
- en: Separate the code from the text by blank lines.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用空行将代码与文本分开。
- en: Indent the code by four spaces.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码缩进四个空格。
- en: 'Provide a prefix of `::` . We can either do this as its own separate paragraph,
    or as a special double-colon at the end of the lead-in paragraph:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个`::`前缀。我们可以将其作为自己单独的段落，或者作为引导段落末尾的特殊双冒号：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `::` is used on the lead-in paragraph.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::`用于引导段落。'
- en: There are places for novelty and art in software development. Documentation
    is not really the place to push the envelope. Clever algorithms and sophisticated
    data structures can be novel and clever.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中有创新和艺术的地方。文档并不是推动创新的地方。聪明的算法和复杂的数据结构可能是新颖和聪明的。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A unique voice, or quirky presentation isn't fun for users who simply want to
    use the software. An amusing style isn't helpful when debugging. Documentation
    should be commonplace and conventional.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只想使用软件的用户来说，独特的语气或古怪的表达并不有趣。在调试时，幽默的风格也不会有帮助。文档应该是平常和常规的。
- en: It can be challenging to write good software documentation. There's a broad
    chasm between too little information and documentation which simply recapitulates
    the code. Somewhere, there's a good balance. What's important is to focus on the
    needs of a person who doesn't know too much about the software or how it works.
    Provide this *semi-knowledgeable* user the information they need to describe what
    the software does and how to use it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的软件文档可能是具有挑战性的。在太少的信息和仅仅重复代码的文档之间存在着巨大的鸿沟。在某个地方，有一个很好的平衡。重要的是要专注于那些对软件或其工作原理了解不多的人的需求。为这些*半知识*用户提供他们需要描述软件做什么以及如何使用它的信息。
- en: 'In many cases, we need to address two parts of the use cases:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们需要解决用例的两个部分：
- en: The intended use of the software
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的预期用途
- en: How to customize or extend the software
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自定义或扩展软件
- en: These may be two distinct audiences. There may be users who are distinct from
    developers. Each has a distinct perspective, and different parts of the documentation
    need to respect these two perspectives.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是两个不同的受众。可能有用户与开发人员不同。每个人都有不同的观点，文档的不同部分需要尊重这两种观点。
- en: See also
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We look at additional techniques in *Writing better RST markup in docstrings*
    .
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*在docstrings中编写更好的RST标记*中查看其他技术。
- en: If we've used the *Writing python script and module files – syntax basics* recipe,
    we'll have put a documentation string in our script file. When we build functions
    in [Chapter 3](text00039.html#page "Chapter 3. Function Definitions") , *Function
    Definitions* , and classes in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we'll look at other
    places where documentation strings can be placed.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用了*编写python脚本和模块文件-语法基础*的方法，我们将在我们的脚本文件中放置一个文档字符串。当我们在[第3章](text00039.html#page
    "第3章。函数定义")中构建函数时，*函数定义*，以及在[第6章](text00070.html#page "第6章。类和对象的基础")中构建类时，*类和对象的基础*，我们将看到其他可以放置文档字符串的地方。
- en: See [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)
    for more information on Sphinx.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Sphinx的更多信息，请参阅[http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/)。
- en: For more background on the man page outline, see [https://en.wikipedia.org/wiki/Man_page](https://en.wikipedia.org/wiki/Man_page)
    .
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关man页面大纲的更多背景信息，请参阅[https://en.wikipedia.org/wiki/Man_page](https://en.wikipedia.org/wiki/Man_page)。
- en: Writing better RST markup in docstrings
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在docstrings中编写更好的RST标记
- en: When we have a useful script, we often need to leave notes on what it does,
    how it works, and when it should be used. Many tools for producing documentation,
    including Docutils, work with RST markup. What RST features can we use to make
    documentation more readable?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个有用的脚本时，通常需要留下关于它的功能、工作原理以及何时使用的注释。许多用于生成文档的工具，包括Docutils，都使用RST标记。我们可以使用哪些RST功能来使文档更易读？
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Including descriptions and documentation* recipe, we looked at putting
    a basic set of documentation into a module. This is the starting point for writing
    our documentation. There are a large number of RST formatting rules. We'll look
    at a few which are important for creating readable documentation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在*包括描述和文档*的方法中，我们看到了将基本的文档放入模块中。这是编写我们的文档的起点。有许多RST格式规则。我们将看一些对于创建可读文档很重要的规则。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Be sure to write an outline of the key points. This may lead to creating RST
    section titles to organize the material. A section title is a two-line paragraph
    with the title followed by an underline using `=` , `-` , `^` , `~` , or one of
    the other Docutils characters for underlining.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一定要写下关键点的大纲。这可能会导致创建RST部分标题来组织材料。部分标题是一个两行的段落，标题后面跟着一个下划线，使用`=`，`-`，`^`，`~`或其他Docutils字符来划线。
- en: A heading will look like this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 标题将看起来像这样。
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The heading text is on one line, the underlining characters are on the next
    line. This must be surrounded by blank lines. There can be more underline characters
    than title characters, but not fewer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 标题文本在一行上，下划线字符在下一行上。这必须被空行包围。下划线字符可以比标题字符多，但不能少。
- en: The RST tools will deduce our pattern of using underlining characters. As long
    as the underline characters are used consistently, the algorithm for matching
    underline character to desired heading will detect the pattern. The keys to this
    are consistency and a clear understanding of section and subsection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: RST工具将推断我们使用下划线字符的模式。只要下划线字符一致使用，匹配下划线字符到期望标题的算法将检测到这种模式。这取决于一致性和对部分和子部分的清晰理解。
- en: 'When starting out, it can help to make an explicit reminder sticky note like
    this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始时，可以帮助制作一个明确的提醒便条，如下所示：
- en: '| **Character** | **Level** |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **级别** |'
- en: '| = | 1 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| = | 1 |'
- en: '| - | 2 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| - | 2 |'
- en: '| ^ | 3 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 3 |'
- en: '| ~ | 4 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| ~ | 4 |'
- en: Fill in the various paragraphs. Separate paragraphs (including the section titles)
    by blank lines. Extra blank lines don't hurt. Omitting blank lines will lead the
    RST parsers to see a single, long paragraph, which may not be what we intended.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写各种段落。用空行分隔段落（包括部分标题）。额外的空行不会有害。省略空行将导致RST解析器看到一个单一的长段落，这可能不是我们想要的。
- en: We can use inline markup for emphasis, strong emphasis, code, hyperlinks, and
    inline math, among other things. If we're planning on using Sphinx, then we have
    an even larger collection of text roles that we can use. We'll look at these techniques
    soon.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内联标记来强调、加重强调、代码、超链接和内联数学等，还有其他一些东西。如果我们打算使用Sphinx，那么我们将有一个更大的文本角色集合可以使用。我们将很快看到这些技术。
- en: If the programming editor has a spell checker, use that. This can be frustrating
    because we'll often have code samples that may include abbreviations that fail
    spell checking.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果编程编辑器有拼写检查器，请使用。这可能会令人沮丧，因为我们经常会有包含拼写检查失败的缩写的代码示例。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The docutils conversion programs will examine the document, looking for sections
    and body elements. A section is identified by a title. The underlines are used
    to organize the sections into a properly nested hierarchy. The algorithm for deducing
    this is relatively simple and has these rules:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: docutils转换程序将检查文档，寻找部分和正文元素。一个部分由一个标题标识。下划线用于将部分组织成正确嵌套的层次结构。推断这一点的算法相对简单，并具有以下规则：
- en: If the underline character has been seen before, the level is known
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果之前已经看到了下划线字符，则已知级别
- en: If the underline character has not been seen before, then it must be indented
    one level below the previous outline level
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果之前没有看到下划线字符，则必须缩进到前一个大纲级别的下一级
- en: If there is no previous level, this is level one
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有上一级，这就是第一级
- en: 'A properly nested document might have the following sequence of underline characters:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确嵌套的文档可能具有以下下划线字符序列：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can see that the first outline character, `=` , will be level one. The next,
    `-` , is unknown, but appears after a level one, so it must be level two. The
    third headline has, `^` , which is previously unknown, and must be level three.
    The next `^` is still level three. The next two, `-` and `^` , are level two and
    three respectively.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，第一个大纲字符`=`将是一级。接下来的`-`是未知的，但出现在一级之后，所以必须是二级。第三个标题有`^`，之前未知，必须是三级。下一个`^`仍然是三级。接下来的两个`-`和`^`分别是二级和三级。
- en: When we encounter the new character, `~` , it's beneath a level three and must,
    therefore, be a level four heading.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到新字符`~`时，它位于三级之下，因此必须是四级标题。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From this overview, we can see that inconsistency will lead to confusion.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个概述中，我们可以看到不一致会导致混乱。
- en: If we change our mind part-way through a document, this algorithm can't detect
    that. If—for inexplicable reasons—we decide to skip over a level and try to have
    a level four heading inside a level two section, that simply can't be done.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文档的中途改变主意，这个算法就无法检测到。如果出于莫名其妙的原因，我们决定跳过一个级别并尝试在二级部分内有一个四级标题，那是不可能的。
- en: 'There are several different kinds of body element that the RST parser can recognize.
    We''ve shown a few. The more complete list includes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: RST解析器可以识别几种不同类型的正文元素。我们展示了一些。更完整的列表包括：
- en: '**Paragraphs of text** : These might use inline markup for different kinds
    of emphasis or highlighting.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本段落**：这些可能使用内联标记来强调或突出不同种类的内容。'
- en: '**Literal blocks** : These are introduced with `::` and indented for spaces.
    They may also be introduced with the `.. parsed-literal::` directive. A doctest
    block is indented four spaces and includes the Python `>>>` prompt.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文字块**：这些是用`::`引入并缩进空格的。它们也可以用`.. parsed-literal::`指令引入。一个doctest块缩进四个空格，并包括Python的`>>>`提示符。'
- en: '**Lists, tables and block quotes** : We''ll look at these later. These can
    contain other body elements.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表、表格和块引用**：我们稍后会看到这些。这些可以包含其他正文元素。'
- en: '**Footnotes** : These are special paragraphs that can be put on the bottom
    of a page or at the end of a section. These can also contain other body elements.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚注**：这些是可以放在页面底部或章节末尾的特殊段落。这些也可以包含其他正文元素。'
- en: '**Hyperlink targets, substitution definitions, and RST comments** : These are
    specialized text items.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超链接目标、替换定义和RST注释**：这些是专门的文本项目。'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For completeness, we'll note here that RST paragraphs are separated by blank
    lines. There's quite a bit more to RST than this core rule.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们在这里指出，RST段落之间用空行分隔。RST比这个核心规则要复杂得多。
- en: 'In the *Including descriptions and documentation* recipe we looked at several
    different kinds of body elements we might use:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在*包括描述和文档*配方中，我们看了几种不同类型的正文元素：
- en: '**Paragraphs of Text** : This is a block of text surrounded by blank lines.
    Within these, we can make use of inline markup to emphasize words, or to use a
    font to show that we''re referring to elements of our code. We''ll look at inline
    markup in the *Using Inline Markup* recipe.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本段落**：这是由空行包围的文本块。在其中，我们可以使用内联标记来强调单词，或者使用字体来显示我们正在引用代码元素。我们将在*使用内联标记*配方中查看内联标记。'
- en: '**Lists** : These are paragraphs that begin with something that looks like
    a number or a bullet. For bullets, use a simple `-` or `*` . Other characters
    can be used, but these are common. We might have paragraphs like this.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：这些是以看起来像数字或项目符号开头的段落。对于项目符号，使用简单的`-`或`*`。也可以使用其他字符，但这些是常见的。我们可能有这样的段落。'
- en: 'It helps to have bullets because:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有项目符号会有帮助，因为：
- en: They can help clarify
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以帮助澄清
- en: They can help organize
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以帮助组织
- en: '**Numbered Lists** : There are a variety of patterns that are recognized. We
    might use something like this.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编号列表**：有各种被识别的模式。我们可能会使用这样的东西。'
- en: 'Four common kinds of numbered paragraphs:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 四种常见的编号段落：
- en: Numbers followed by punctuation like `.` or `)` .
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字后面跟着像`.`或`)`这样的标点符号。
- en: A letter followed by punctuation like `.` or `)` .
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字母后面跟着像`.`或`)`这样的标点符号。
- en: A roman numeral followed by punctuation.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个罗马数字后面跟着标点符号。
- en: A special case of `#` with the same punctuation used on the previous items.
    This continues the numbering from the previous paragraphs.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特殊情况是使用与前面项目相同的标点符号的`#`。这继续了前面段落的编号。
- en: '**Literal Blocks** : A code sample must be presented literally. The text for
    this must be indented. We also need to prefix the code with `::` . The `::` character
    must either be a separate paragraph or the end of a lead-in to the code example.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文字块**：代码示例必须以文字形式呈现。这个文本必须缩进。我们还需要用`::`前缀代码。`::`字符必须是一个单独的段落，或者是代码示例的引导结束。'
- en: '**Directives** : A directive is a paragraph that generally looks like `.. directive::`
    . It may have some content that''s indented so that it''s contained within the
    directive. It might look like this:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：指令是一个段落，通常看起来像`.. directive::`。它可能有一些内容，缩进以便包含在指令内。它可能看起来像这样：'
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `.. important::` paragraph is the directive. This is followed by a short
    paragraph of text indented within the directive. In this case, it creates a separate
    paragraph that includes the admonition of *important* .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`.. important::`段落是指令。这之后是一个缩进在指令内的短段落文字。在这种情况下，它创建了一个包含*important*警告的单独段落。'
- en: Using directives
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用指令
- en: Docutils has many built-in directives. Sphinx adds a large number of directives
    with a variety of features.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Docutils有许多内置指令。Sphinx添加了许多具有各种功能的指令。
- en: 'Some of the most commonly used directives are the admonition directives: *attention*
    , *caution* , *danger* , *error* , *hint* , *important* , *note* , *tip* , *warning*
    , and the generic *admonition* . These are compound body elements because they
    can have multiple paragraphs and nested directives within them.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的指令之一是警告指令：*注意*，*小心*，*危险*，*错误*，*提示*，*重要*，*注意*，*提示*，*警告*和通用*警告*。这些是复合主体元素，因为它们可以有多个段落和其中嵌套的指令。
- en: 'We might have things like this to provide appropriate emphasis:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有这样的东西来提供适当的强调：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: One of the other common directives is the `parsed-literal` directive.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的指令是`parsed-literal`指令。
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This can be handy for providing examples of code where some portion of the code
    is highlighted. A literal like this is a simple body element, which can only have
    text inside. It can't have lists or other nested structures.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于提供代码示例非常方便，其中代码的某些部分被突出显示。这样的文字就是一个简单的主体元素，里面只能有文本。它不能有列表或其他嵌套结构。
- en: Using inline markup
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内联标记
- en: 'Within a paragraph, we have several inline markup techniques we can use:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在段落中，我们可以使用几种内联标记技术：
- en: We can surround a word or phrase with `*` for `*emphasis*` .
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用`*`将单词或短语括起来以进行`*强调*`。
- en: We can surround a word or phrase with `**` for `**strong**` .
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用`**`将单词或短语括起来以进行`**强调**`。
- en: We surround references with single back-tick ([PRE30]` ) to make them look like
    [PRE31] .
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们用单个反引号（[PRE30]`）括起引用，使其看起来像[PRE31]。 '
- en: There's also a more general technique called a text role. A role is a little
    more complex-looking than simply wrapping a word or phrase in the `*` characters.
    We use `:word:` as the role name followed by the applicable word or phrase in
    single [PRE32]
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更一般的技术叫做文本角色。角色看起来比简单地用`*`字符包装一个单词或短语要复杂一些。我们使用`:word:`作为角色名称，后面跟着适用的单词或短语在单个[PRE32]中
- en: dice = die_1 + die_2
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 骰子= die_1 + die_2
- en: 'if dice in (2, 3, 12):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果骰子在（2,3,12）中：
- en: game.craps()
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: game.craps()
- en: 'elif dice in (7, 11):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果骰子在（7,11）中：
- en: game.winner()
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏.获胜者（）
- en: 'elif dice in (4, 5, 6, 8, 9, 10):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果骰子在（4,5,6,8,9,10）中：
- en: game.point(die)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏.得分（骰子）
- en: '[PRE33]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'else:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'raise Exception(''Design Problem Here: not all conditions accounted for'')'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 引发异常（'设计问题：未考虑所有条件'）
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: do something
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一些事情
- en: assert (m = a or m = b) and m > a and m > b
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（m = a或m = b）和m> a和m> b
- en: '[PRE35]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'if a >= b:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果a> = b：
- en: m = a
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: m = a
- en: 'elif b >= a:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果b> = a：
- en: m = b
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: m = b
- en: 'else:     raise Exception( ''Design Problem'')'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：引发异常（'设计问题'）
- en: assert (m = a or m = b) and m > a and m > b
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（m = a或m = b）和m> a和m> b
- en: '[PRE36]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: initialize something
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一些东西
- en: 'while # not terminated:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 而#未终止：
- en: do something
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一些事情
- en: assert password_text == confirming_password_text
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 断言密码文本==确认密码文本
- en: '[PRE37]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: initialize something
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一些东西
- en: assert the invariant new-input(password_text)
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言不变的新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: 'while # not terminated:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 而#未终止：
- en: do something
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一些事情
- en: assert the invariant new-input(password_text)
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言不变的新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: assert password_text == confirming_password_text
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 断言密码文本==确认密码文本
- en: '[PRE38]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: initialize something
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一些东西
- en: assert the invariant new-input(password_text)
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言不变的新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: 'while password_text != confirming_password_text:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 而密码文本！=确认密码文本：
- en: do something
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一些事情
- en: assert the invariant new-input(password_text)
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言不变的新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: assert password_text == confirming_password_text
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 断言密码文本==确认密码文本
- en: '[PRE39]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: password_text= getpass()
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: password_text= getpass()
- en: 'confirming_password_text= getpass("Confirm: ")'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 确认密码文本= getpass（“确认：”）
- en: assert new-input(password_text)
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: 'while password_text != confirming_password_text:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 而密码文本！=确认密码文本：
- en: do something
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做一些事情
- en: assert new-input(password_text)
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: assert password_text == confirming_password_text
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 断言密码文本==确认密码文本
- en: '[PRE40]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: password_text= getpass()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: password_text= getpass()
- en: 'confirming_password_text= getpass("Confirm: ")'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 确认密码文本= getpass（“确认：”）
- en: assert new-input(password_text)
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: 'while password_text != confirming_password_text:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 而密码文本！=确认密码文本：
- en: password_text= getpass()
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: password_text= getpass()
- en: 'confirming_password_text= getpass("Confirm: ")'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 确认密码文本= getpass（“确认：”）
- en: assert new-input(password_text)
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言新输入（密码文本）
- en: and new-input(confirming_password_text)
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 和新输入（确认密码文本）
- en: assert password_text == confirming_password_text
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 断言密码文本==确认密码文本
- en: '[PRE41]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: password_text= getpass()
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: password_text= getpass()
- en: 'confirming_password_text= getpass("Confirm: ")'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 确认密码文本= getpass（“确认：”）
- en: 'while password_text != confirming_password_text:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 而密码文本！=确认密码文本：
- en: password_text= getpass()
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: password_text= getpass()
- en: 'confirming_password_text= getpass("Confirm: ")'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 确认密码文本= getpass（“确认：”）
- en: assert password_text == confirming_password_text
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 断言密码文本==确认密码文本
- en: '[PRE42]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: assert pre-condition
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 断言前置条件
- en: S
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: S
- en: assert post-condition
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 断言后置条件
- en: '[PRE43]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**>>> sample_1 = "some_name = the_value"'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>> sample_1 = "some_name = the_value"'
- en: '>>> for position in range(len(sample_1)):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>对于范围内的位置'
- en: '...    if sample_1[position] in ''=:'':'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '...如果sample_1[position]在''：=''中：'
- en: '...        break'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '...中断'
- en: '>>> print(''name='', sample_1[:position],'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>打印（''名称='', sample_1[:position]，'
- en: '...     ''value='', sample_1[position+1:])'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '... ''value='', sample_1[position+1:]）'
- en: name= some_name  value=  the_value**
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 名称= some_name  value=  the_value**
- en: '[PRE44]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**>>> sample_2 = "name_only"'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>> sample_2 = "name_only"'
- en: '>>> for position in range(len(sample_2)):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>对于范围内的位置'
- en: '...    if sample_2[position] in ''=:'':'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '...如果sample_2[position]在''：=''中：'
- en: '...        break'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '...中断'
- en: '>>> print(''name='', sample_2[:position],'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>打印（''名称='', sample_2[:position]，'
- en: '...     ''value='', sample_2[position+1:])'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '... ''value='', sample_2[position+1:]）'
- en: name= name_onl value=**
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 名称= name_onl value=**
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: text[position] in '=:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 文本[位置]在'：='中
- en: '[PRE46]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: (len(text) == 0
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: （len（text）== 0
- en: or not('=' in text or ':' in text)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 或不是（'='在文本中或'：'在文本中）
- en: or text[position] in '=:')
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 或文本[位置]在'：='中）
- en: '[PRE47]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**>>> position = -1 # If it''s zero length'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>>位置= -1#如果长度为零'
- en: '>>> for position in range(len(sample_2)):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>对于范围内的位置'
- en: '...    if sample_2[position] in ''=:'':'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '... 如果sample_2[position]在''：=''中：'
- en: '...        break'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '... 休息'
- en: '...'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> if position == -1:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 如果位置== -1：'
- en: '...     print("name=", None, "value=", None)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '... 打印（“名称=”，无，“值=”，无）'
- en: '... elif not(text[position] == '':'' or text[position] == ''=''):'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '... 否则不是（text[position] == '':''或text[position] == ''=''）：'
- en: '...     print("name=", sample_2, "value=", None)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '... 打印（“名称=”，sample_2，“值=”，无）'
- en: '... else:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '... 其他：'
- en: '...    print(''name='', sample_2[:position],'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '... 打印（''name =''，sample_2[:position]，'
- en: '...     ''value='', sample_2[position+1:])'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '... ''value =''，sample_2[position+1:]）'
- en: name= name_only value= None**
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 名称=仅名称值=无**
- en: '[PRE48]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'if len(sample_2) > 0:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果len（sample_2）> 0：
- en: name, value = sample_2, None
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，值= sample_2，无
- en: 'else:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 其他：
- en: name, value = None, None
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，值=无，无
- en: 'for position in range(len(sample_2)):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 对于position in range（len（sample_2））：
- en: 'if sample_2[position] in ''=:'':'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果sample_2[position]在'：='中：
- en: name, value = sample_2[:position], sample2[position:]
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，值= sample_2[:position]，sample2[position:]
- en: print('name=', name, 'value=', value)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（'name ='，name，'value ='，value）
- en: '[PRE49]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'for position in range(len(sample_2)):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 对于position in range（len（sample_2））：
- en: 'if sample_2[position] in ''=:'':'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果sample_2[position]在'：='中：
- en: name, value = sample_2[:position], sample_2[position+1:]
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，值= sample_2[:position]，sample_2[position+1:]
- en: break
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: 'else:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 其他：
- en: 'if len(sample_2) > 0:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果len（sample_2）> 0：
- en: name, value = sample_2, None
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，值= sample_2，无
- en: 'else:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 其他：
- en: name, value = None, None
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 名称，值=无，无
- en: '[PRE50]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: from pathlib import Path
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 从路径导入路径
- en: import shutil
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 导入shutil
- en: import os
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 进口
- en: source_path = Path(os.path.expanduser(
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: source_path = Path（os.path.expanduser（
- en: '''~/Documents/Writing/Python Cookbook/source''))'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '''〜/Documents/Writing/Python Cookbook/source''））'
- en: target_path = Path(os.path.expanduser(
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: target_path = Path（os.path.expanduser（
- en: '''~/Dropbox/B05442/demo/''))'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '''〜/Dropbox/B05442/demo/''''）'
- en: 'for source_file_path in source_path.glob(''*/*.rst''):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对于source_file_path in source_path.glob（'* / * .rst'）：
- en: source_file_detail = source_file_path.relative_to(source_path)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: source_file_detail = source_file_path.relative_to（source_path）
- en: target_file_path = target_path / source_file_detail
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: target_file_path = target_path / source_file_detail
- en: shutil.copy( str(source_file_path), str(target_file_path
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path
- en: '[PRE51]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'FileNotFoundError: [Errno 2]'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: FileNotFoundError：[Errno 2]
- en: 'No such file or directory:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的文件或目录：
- en: '''/Users/slott/Dropbox/B05442/demo/ch_01_numbers_strings_and_tuples/index.rst'''
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '''/Users/slott/Dropbox/B05442/demo/ch_01_numbers_strings_and_tuples/index.rst'''
- en: '[PRE52]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'try:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: '[PRE53]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'try:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except FileNotFoundError:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FileNotFoundError：
- en: os.makedir( target_file_path.parent )
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: os.makedir（target_file_path.parent）
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: '[PRE54]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'try:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except FileNotFoundError:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FileNotFoundError：
- en: os.makedirs( str(target_file_path.parent) )
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: os.makedirs（str（target_file_path.parent））
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except OSError as ex:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 除了OSError as ex：
- en: print(ex)
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（ex）
- en: '[PRE55]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'except FileNotFoundError:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FileNotFoundError：
- en: os.makedirs( str(target_file_path.parent) )
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: os.makedirs（str（target_file_path.parent））
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: '[PRE56]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'try:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except FileNotFoundError:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FileNotFoundError：
- en: 'try:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: os.makedirs( str(target_file_path.parent) )
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: os.makedirs（str（target_file_path.parent））
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except OSError as ex:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 除了OSError as ex：
- en: print(ex)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（ex）
- en: 'except OSError as ex:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 除了OSError as ex：
- en: print(ex)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（ex）
- en: '[PRE57]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'try:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: 'try:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except FileNotFoundError:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FileNotFoundError：
- en: os.makedirs( str(target_file_path.parent) )
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: os.makedirs（str（target_file_path.parent））
- en: shutil.copy( str(source_file_path), str(target_file_path) )
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: shutil.copy（str（source_file_path），str（target_file_path））
- en: 'except OSError as ex:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 除了OSError as ex：
- en: print(ex)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（ex）
- en: '[PRE58]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'class Error(Exception):'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 类错误（异常）：
- en: pass
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通过
- en: '[PRE59]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'try:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: something
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 某事
- en: 'except (IndexError, NameError) as exception:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 除了（IndexError，NameError）作为异常：
- en: print("Expected", exception)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（“预期”，异常）
- en: raise Error("something went wrong") from exception
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 引发错误（“出了些问题”）来自异常
- en: 'except Exception as exception:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常作为异常：
- en: print("Unexpected", exception)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（“意外”，异常）
- en: raise
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 提高
- en: '[PRE60]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**>>> class Error(Exception):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>> 类错误（异常）：'
- en: '...     pass'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '...     pass'
- en: '>>> try:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 尝试：'
- en: '...     ''hello world''[99]'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '... ''hello world''[99]'
- en: '... except (IndexError, NameError) as exception:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '... 除了（IndexError，NameError）作为异常：'
- en: '...     raise Error("index problem") from exception'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '... 引发错误（“索引问题”）来自异常'
- en: '...'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'Traceback (most recent call last):'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 最近一次的跟踪（最近的调用）：
- en: File "<doctest default[0]>", line 2, in <module>
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 文件“<doctest default[0]>”，第2行，在<module>
- en: '''hello world''[99]'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '''hello world''[99]'
- en: 'IndexError: string index out of range**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: IndexError：字符串索引超出范围**
- en: '[PRE61]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Traceback (most recent call last):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**最近一次的跟踪（最近的调用）：'
- en: File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py",
    line 1318, in __run
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 文件“/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py”，第1318行，在__run
- en: compileflags, 1), test.globs)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: compileflags，1），test.globs）
- en: File "<doctest default[0]>", line 4, in <module>
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 文件“<doctest default[0]>”，第4行，在<module>
- en: raise Error("index problem") from exception
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 引发错误（“索引问题”）来自异常
- en: 'Error: index problem**'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：索引问题**
- en: '[PRE62]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'try:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: some_function()
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: some_function（）
- en: 'except Error as exception:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 除了错误作为异常：
- en: print(exception)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（异常）
- en: print(exception .__cause__)
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（exception .__cause__）
- en: '[PRE63]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'try:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: something
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 某事
- en: 'except ValueError as exception:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 除了ValueError作为异常：
- en: print("Some message", exceotuib)
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 打印（“一些消息”，exceotuib）
- en: '[PRE64]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**>>> import csv**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>> 导入csv**'
- en: '[PRE65]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**>>> import pathlib**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>> import pathlib**'
- en: '[PRE66]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**>>> some_source = [[2,3,5], [7,11,13], [17,19,23]]**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**>>> some_source = [[2,3,5]，[7,11,13]，[17,19,23]]**'
- en: '[PRE67]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: target_path = pathlib.Path('code/test.csv')
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: target_path = pathlib.Path（'code/test.csv'）
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 与target_path.open（'w'，newline =''）作为target_file：
- en: '[PRE68]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: target_path = pathlib.Path('code/test.csv')
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: target_path = pathlib.Path（'code/test.csv'）
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 与target_path.open（'w'，newline =''）作为target_file：
- en: writer = csv.writer(target_file)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器= csv.writer（target_file）
- en: writer.writerow(['column', 'data', 'headings'])
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: writer.writerow（['column'，'data'，'headings']）
- en: 'for data in some_source:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据中的一些源：
- en: writer.writerow(data)
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: writer.writerow（data）
- en: '[PRE69]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: target_path = pathlib.Path('code/test.csv')
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: target_path = pathlib.Path（'code/test.csv'）
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'with target_path.open(''w'', newline='''') as target_file:'
- en: writer = csv.writer(target_file)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器=csv.writer(target_file)
- en: writer.writerow(['column', 'headings'])
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器.writerow(['列', '标题'])
- en: 'for data in some_source:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些来源的数据：
- en: writer.writerow(data)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器.writerow(data)
- en: print('finished writing', target_path)
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 打印'完成写入'，目标路径
- en: '[PRE70]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'try:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: target_path = pathlib.Path('code/test.csv')
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 目标路径=pathlib.Path('code/test.csv')
- en: 'with target_path.open(''w'', newline='''') as target_file:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 'with target_path.open(''w'', newline='''') as target_file:'
- en: writer = csv.writer(target_file)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器=csv.writer(target_file)
- en: writer.writerow(['column', 'headings'])
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器.writerow(['列', '标题'])
- en: 'for data in some_source:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些来源的数据：
- en: writer.writerow(data)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 写入器.writerow(data)
- en: raise Exception("Just Testing")
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 引发异常("只是测试")
- en: 'except Exception as exc:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '除了异常 as exc:'
- en: print(target_file.closed)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 打印目标文件是否关闭
- en: print(exc)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 打印异常
- en: print('finished writing', target_path)
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 打印'完成写入'，目标路径
- en: '[PRE71]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'True'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: Just Testing
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 只是测试
- en: finished writing code/test.csv
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 完成写入代码/测试.csv
- en: '```'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This shows us that the file was properly closed. It also shows us the message
    associated with the exception to confirm that it was the exception we raised manually.
    The output `test.csv` file will only have the first row of data from the `some_source`
    variable.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明文件已经正确关闭。它还向我们显示了与异常相关的消息，以确认它是我们手动引发的异常。输出的`test.csv`文件将只包含`some_source`变量的第一行数据。
- en: There's more...
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Python offers us a number of context managers. We noted that an open file is
    a context, as is an open network connect created by `urllib.request.urlopen()`
    .
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了许多上下文管理器。我们注意到，打开的文件是一个上下文，`urllib.request.urlopen()`创建的打开网络连接也是一个上下文。
- en: For all file operations, and all network connections, we should use a `with`
    statement as a context manager. It's very difficult to find an exception to this
    rule.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有文件操作和所有网络连接，我们应该使用`with`语句作为上下文管理器。很难找到这个规则的例外。
- en: It turns out that the `decimal` module makes use of a context manager to allow
    localized changes to the way decimal arithmetic is performed. We can use the `decimal.localcontext()`
    function as a context manager to change rounding rules or precision for calculations
    isolated by a `with` statement.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`decimal`模块使用上下文管理器来允许对十进制算术执行的方式进行本地化更改。我们可以使用`decimal.localcontext()`函数作为上下文管理器，以更改由`with`语句隔离的计算的舍入规则或精度。
- en: We can define our own context managers, also. The `contextlib` module contains
    functions and decorators that can help us create context managers around resources
    that don't explicitly offer them.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义自己的上下文管理器。`contextlib`模块包含函数和装饰器，可以帮助我们在不明确提供上下文管理器的资源周围创建上下文管理器。
- en: When working with locks, the `with` context is the ideal way to acquire and
    release a lock. See [https://docs.python.org/3/library/threading.html#with-locks](https://docs.python.org/3/library/threading.html#with-locks)
    for the relationship between a lock object created by the `threading` module and
    a context manager.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理锁时，`with`上下文是获取和释放锁的理想方式。请参阅[https://docs.python.org/3/library/threading.html#with-locks](https://docs.python.org/3/library/threading.html#with-locks)了解由`threading`模块创建的锁对象与上下文管理器之间的关系。
- en: See also
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/)
    for the origins of the with statement
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/)了解with语句的起源
