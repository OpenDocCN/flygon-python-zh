- en: Styling Qt Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化Qt应用程序
- en: It is easy to appreciate the clean, native look that Qt effortlessly provides
    by default. But for less business-like applications, plain gray widgets and bog-standard
    fonts don't always set the right tone. Even the drabbest utility or data entry
    application occasionally benefits from the addition of icons or the judicious
    tweaking of fonts to enhance usability. Fortunately, Qt's flexibility allows us
    to take the look and feel of our application into our own hands.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易欣赏到Qt默认提供的清晰、本地外观。但对于不那么商业化的应用程序，普通的灰色小部件和标准字体并不总是设置正确的语气。即使是最沉闷的实用程序或数据输入应用程序偶尔也会受益于添加图标或谨慎调整字体以增强可用性。幸运的是，Qt的灵活性使我们能够自己控制应用程序的外观和感觉。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using fonts, images, and icons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字体、图像和图标
- en: Configuring colors, style sheets, and styles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置颜色、样式表和样式
- en: Creating animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you'll need all the requirements listed in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and the Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中列出的所有要求，*PyQt入门*，以及[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中的Qt应用程序模板，*使用QMainWindow构建应用程序*。
- en: Additionally, you may require PNG, JPEG, or GIF image files to work with; you
    can use those included in the example code at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能需要PNG、JPEG或GIF图像文件来使用；您可以使用示例代码中包含的这些文件：[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter06)。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5OJj6](http://bit.ly/2M5OJj6)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：[http://bit.ly/2M5OJj6](http://bit.ly/2M5OJj6)
- en: Using fonts, images, and icons
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字体、图像和图标
- en: We'll begin styling our Qt application by customizing the application's fonts,
    displaying some static images, and including dynamic icons. However, before we
    can do this, we'll need to create a **graphical user interface** (**GUI**) that
    we can work with. We'll create a game lobby dialog, which will be used for logging
    into an imaginary multiplayer game called **Fight Fighter**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过自定义应用程序的字体、显示一些静态图像和包含动态图标来开始样式化我们的Qt应用程序。但在此之前，我们需要创建一个**图形用户界面**（**GUI**），以便我们可以使用。我们将创建一个游戏大厅对话框，该对话框将用于登录到一个名为**Fight
    Fighter**的虚构多人游戏。
- en: 'To do this, open a fresh copy of your application template and add the following
    GUI code to `MainWindow.__init__()`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开应用程序模板的新副本，并将以下GUI代码添加到`MainWindow.__init__()`中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is fairly standard Qt GUI code that you should be familiar with by now;
    we''re saving a few lines of code by putting our inputs in a `dict` object and
    adding them to the layout in a loop, but otherwise, it''s relatively straightforward.
    Depending on your OS and theme settings, the dialog box probably looks something
    like the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当标准的Qt GUI代码，您现在应该对此很熟悉；我们通过将输入放入`dict`对象中并在循环中将它们添加到布局中，节省了一些代码行，但除此之外，它相对直接。根据您的操作系统和主题设置，对话框框可能看起来像以下截图：
- en: '![](assets/ce8de21f-49a5-46c4-aab8-3f45ba3b8c26.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce8de21f-49a5-46c4-aab8-3f45ba3b8c26.png)'
- en: As you can see, it's a nice form but it's a bit bland. So, let's explore whether
    we can improve the style.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这是一个不错的表单，但有点单调。因此，让我们探讨一下是否可以改进样式。
- en: Setting a font
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置字体
- en: The first thing we'll tackle is the font. Every `QWidget` class has a `font`
    property, which we can either set in the constructor or by using the `setFont()`
    accessor. The value of `font` must be a `QtGui.QFont` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的第一件事是字体。每个`QWidget`类都有一个`font`属性，我们可以在构造函数中设置，也可以使用`setFont()`访问器来设置。`font`的值必须是一个`QtGui.QFont`对象。
- en: 'Here is how you can create and use a `QFont` object:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以创建和使用`QFont`对象的方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `QFont` object contains all the attributes that describe the way text will
    be drawn to the screen. The constructor can take any of the following arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFont`对象包含描述文本将如何绘制到屏幕上的所有属性。构造函数可以接受以下任何参数：'
- en: A string indicating the font family
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示字体系列的字符串
- en: A float or integer indicating the point size
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个浮点数或整数，表示点大小
- en: A `QtGui.QFont.FontWeight` constant indicating the weight
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`QtGui.QFont.FontWeight`常量，指示权重
- en: A Boolean indicating whether the font should be italic
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，指示字体是否应该是斜体
- en: 'The remaining aspects of the font, such as the `stretch` property, can be configured
    using keyword arguments or accessor methods. We can also create a `QFont` object
    with no arguments and configure it programmatically, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 字体的其余方面，如`stretch`属性，可以使用关键字参数或访问器方法进行配置。我们还可以创建一个没有参数的`QFont`对象，并按照以下方式进行程序化配置：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting a font on a widget affects not only the widget but also all its child
    widgets. Therefore, we could configure the font for the entire form by setting
    it on `cx_form` rather than setting it on individual widgets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件上设置字体不仅会影响该小部件，还会影响所有子小部件。因此，我们可以通过在`cx_form`上设置字体而不是在单个小部件上设置字体来为整个表单配置字体。
- en: Dealing with missing fonts
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失的字体
- en: Now, if all platforms and **operating systems** (**OSes**) shipped with an infinite
    array of identically named fonts, this would be all you'd need to know about `QFont`.
    Unfortunately, that isn't the case. Most systems ship with only a handful of fonts
    built-in and only a few of these are universal across platforms or even different
    versions of a platform. Therefore, Qt has a fallback mechanism for dealing with
    missing fonts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果所有平台和**操作系统**（**OSes**）都提供了无限数量的同名字体，那么您需要了解的就是`QFont`。不幸的是，情况并非如此。大多数系统只提供了少数内置字体，并且这些字体中只有少数是跨平台的，甚至是平台的不同版本通用的。因此，Qt有一个处理缺失字体的回退机制。
- en: 'For example, suppose that we ask Qt to use a nonexistent font family, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们要求Qt使用一个不存在的字体系列，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Qt will not throw an error at this call or even register a warning. Instead,
    after not finding the font family requested, it will fall back to its `defaultFamily`
    property, which utilizes the default font set in the OS or desktop environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Qt不会在此调用时抛出错误，甚至不会注册警告。相反，在未找到请求的字体系列后，它将回退到其`defaultFamily`属性，该属性利用了操作系统或桌面环境中设置的默认字体。
- en: 'The `QFont` object won''t actually tell us that this has happened; if you query
    it for information, it will only tell you what was configured:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFont`对象实际上不会告诉我们发生了什么；如果查询它以获取信息，它只会告诉您已配置了什么：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To discover what font settings are actually being used, we need to pass our
    `QFont` object to a `QFontInfo` object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现实际使用的字体设置，我们需要将我们的`QFont`对象传递给`QFontInfo`对象：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run the script, you''ll see that, more than likely, your default screen
    font is actually being used here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行脚本，您会看到，很可能实际上使用的是默认的屏幕字体：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While this ensures that users won't be left without any text in the window,
    it would be nice if we could give Qt a better idea of what sort of font it should
    use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确保了用户不会在窗口中没有任何文本，但如果我们能让Qt更好地了解应该使用什么样的字体，那就更好了。
- en: 'We can do this by setting the font''s `styleHint` and `styleStrategy` properties,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置字体的`styleHint`和`styleStrategy`属性来实现这一点，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`styleHint` suggests a general category for Qt to fall back on, which, in this
    case, is the `Fantasy` category. Other options here include `SansSerif`, `Serif`,
    `TypeWriter`, `Decorative`, `Monospace`, and `Cursive`. What these options correspond
    to is dependent on the OS and desktop environment configuration.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`styleHint`建议Qt回退到的一般类别，在本例中是`Fantasy`类别。这里的其他选项包括`SansSerif`、`Serif`、`TypeWriter`、`Decorative`、`Monospace`和`Cursive`。这些选项对应的内容取决于操作系统和桌面环境的配置。'
- en: The `styleStrategy` property informs Qt of more technical preferences related
    to the capabilities of the chosen font, such as anti-aliasing, OpenGL compatibility,
    and whether the size will be matched exactly or rounded to the nearest non-scaled
    size. The complete list of strategy options can be found at [https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum](https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`styleStrategy`属性告诉Qt与所选字体的能力相关的更多技术偏好，比如抗锯齿、OpenGL兼容性，以及大小是精确匹配还是四舍五入到最接近的非缩放大小。策略选项的完整列表可以在[https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum](https://doc.qt.io/qt-5/qfont.html#StyleStrategy-enum)找到。'
- en: 'After setting these properties, check the font again to see whether anything
    has changed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些属性后，再次检查字体，看看是否有什么变化：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Depending on your system''s configuration, you should see different results
    from before:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据系统的配置，您应该看到与之前不同的结果：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On this system, `Fantasy` has been interpreted to mean `Impact`, and the `PreferQuality`
    strategy flag has forced the initially odd 15.233 point size to be a nice round
    `15`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统上，`Fantasy`被解释为`Impact`，而`PreferQuality`策略标志强制最初奇怪的15.233点大小成为一个漂亮的`15`。
- en: 'At this point, depending on the fonts available on your system, your application
    should look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，根据系统上可用的字体，您的应用程序应该如下所示：
- en: '![](assets/0ac336f7-5ade-4387-a6c5-48a27c8fd1b1.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0ac336f7-5ade-4387-a6c5-48a27c8fd1b1.png)'
- en: Fonts can also be bundled with the application; see the *Using Qt resource files*
    section in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 字体也可以与应用程序捆绑在一起；请参阅本章中的*使用Qt资源文件*部分。
- en: Adding images
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图像
- en: Qt offers a number of classes related to the use of images in an application,
    but, for simply displaying a picture in your GUI, the most appropriate is `QPixmap`.
    `QPixmap` is a display-optimized image class, which can load many common image
    formats including PNG, BMP, GIF, and JPEG.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了许多与应用程序中使用图像相关的类，但是，对于在GUI中简单显示图片，最合适的是`QPixmap`。`QPixmap`是一个经过优化的显示图像类，可以加载许多常见的图像格式，包括PNG、BMP、GIF和JPEG。
- en: 'To create one, we simply need to pass `QPixmap` a path to an image file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个，我们只需要将`QPixmap`传递给图像文件的路径：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once loaded, a `QPixmap` object can be displayed in a `QLabel` or `QButton`
    object, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，`QPixmap`对象可以显示在`QLabel`或`QButton`对象中，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that labels can only display a string or a pixmap, but not both.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标签只能显示字符串或像素图，但不能同时显示两者。
- en: 'Being optimized for display, the `QPixmap` objects offer only minimal editing
    functionality; however, we can do simple transformations such as scaling:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化显示，`QPixmap`对象只提供了最小的编辑功能；但是，我们可以进行简单的转换，比如缩放：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we've used the pixmap's `scaledToWidth()` method to restrict
    the logo's width to `400` pixels using a smooth transformation algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了像素图的`scaledToWidth()`方法，使用平滑的转换算法将标志的宽度限制为`400`像素。
- en: The reason why `QPixmap` objects are so limited is that they are actually stored
    in the display server's memory. The `QImage` class is similar but stores data
    in application memory, so that it can be edited more extensively. We'll explore
    this class more in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), Creating
    *2D Graphics with QPainter*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPixmap`对象如此有限的原因是它们实际上存储在显示服务器的内存中。`QImage`类似，但是它将数据存储在应用程序内存中，因此可以进行更广泛的编辑。我们将在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中更多地探讨这个类，创建*使用QPainter进行2D图形*。'
- en: '`QPixmap` also offers the handy capability to generate simple colored rectangles,
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPixmap`还提供了一个方便的功能，可以生成简单的彩色矩形，如下所示：'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By specifying a size in the constructor and using the `fill()` method, we can
    create a simple, colored rectangle pixmap. This is useful for displaying color
    swatches or to use as a quick-and-dirty image stand-in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在构造函数中指定大小并使用`fill()`方法，我们可以创建一个简单的彩色矩形像素图。这对于显示颜色样本或用作快速的图像替身非常有用。
- en: Using icons
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图标
- en: Now consider an icon on a toolbar or in a program menu. When the menu item is
    disabled, you expect the icon to be grayed out in some way. Likewise, if a user
    hovers over the button or item using a mouse cursor, you might expect it to be
    highlighted. To encapsulate this type of state-dependent image display, Qt provides
    the `QIcon` class. A `QIcon` object contains a collection of pixmaps that are
    each mapped to a widget state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑工具栏或程序菜单中的图标。当菜单项被禁用时，您期望图标以某种方式变灰。同样，如果用户使用鼠标指针悬停在按钮或项目上，您可能期望它被突出显示。为了封装这种状态相关的图像显示，Qt提供了`QIcon`类。`QIcon`对象包含一组与小部件状态相映射的像素图。
- en: 'Here is how you can create a `QIcon` object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建一个`QIcon`对象：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After creating the icon object, we use its `addPixmap()` method to assign a
    `QPixmap` object to a widget state. These states include `Normal`, `Active`, `Disabled`,
    and `Selected`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图标对象后，我们使用它的`addPixmap()`方法将一个`QPixmap`对象分配给小部件状态。这些状态包括`Normal`、`Active`、`Disabled`和`Selected`。
- en: 'The `connect_icon` icon will now be a red square when disabled, or a green
    square when enabled. Let''s add it to our submit button and add some logic to
    toggle the button''s status:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当禁用时，`connect_icon`图标现在将是一个红色的正方形，或者当启用时将是一个绿色的正方形。让我们将其添加到我们的提交按钮，并添加一些逻辑来切换按钮的状态：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you run the script at this point, you'll see that the red square appears
    in the submit button until the `Server` field contains data, at which point it
    automatically switches to green. Notice that we don't have to tell the icon object
    itself to switch states; once assigned to the widget, it tracks any changes in
    the widget's state.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此时运行脚本，您会看到红色的正方形出现在提交按钮上，直到“服务器”字段包含数据为止，此时它会自动切换为绿色。请注意，我们不必告诉图标对象本身切换状态；一旦分配给小部件，它就会跟踪小部件状态的任何更改。
- en: Icons can be used with the `QPushButton`, `QToolButton`, and `QAction` objects;
    the `QComboBox`, `QListView`, `QTableView`, and `QTreeView` items; and most other
    places where you might reasonably expect to have an icon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图标可以与`QPushButton`、`QToolButton`和`QAction`对象一起使用；`QComboBox`、`QListView`、`QTableView`和`QTreeView`项目；以及大多数其他您可能合理期望有图标的地方。
- en: Using Qt resource files
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt资源文件
- en: 'A significant problem with using image files in a program is making sure the
    program can find them at runtime. Paths passed into a `QPixmap` constructor or
    a `QIcon` constructor are interpreted as absolute (that is, if they begin with
    a drive letter or path separator), or as relative to the current working directory
    (which you cannot control). For example, try running your script from somewhere
    other than the code directory, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中使用图像文件的一个重要问题是确保程序可以在运行时找到它们。传递给`QPixmap`构造函数或`QIcon`构造函数的路径被解释为绝对路径（即，如果它们以驱动器号或路径分隔符开头），或者相对于当前工作目录（您无法控制）。例如，尝试从代码目录之外的某个地方运行您的脚本：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You'll find that your images are all missing! `QPixmap` does not complain when
    it cannot find a file, it just doesn't show anything. Without an absolute path
    to the images, you'll only be able to find them if the script is run from the
    exact directory to which your paths are relative.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现您的图像都丢失了！当`QPixmap`找不到文件时不会抱怨，它只是不显示任何东西。如果没有图像的绝对路径，您只能在脚本从相对路径相关的确切目录运行时找到它们。
- en: Unfortunately, specifying absolute paths means that your program will only work
    from one location on the filesystem, which is a major problem if you plan to distribute
    it to multiple platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，指定绝对路径意味着您的程序只能从文件系统上的一个位置工作，这对于您计划将其分发到多个平台是一个重大问题。
- en: 'PyQt offers us a solution to this problem in the form of a **PyQt Resource
    file**, which we can create using the **PyQt resource compiler** tool. The basic
    procedure is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt为我们提供了一个解决这个问题的解决方案，即**PyQt资源文件**，我们可以使用**PyQt资源编译器**工具创建。基本过程如下：
- en: Write an XML-format **Qt Resource Collection** file (`.qrc`) containing the
    paths of all the files that we want to include
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个XML格式的**Qt资源集合**文件（.qrc），其中包含我们要包括的所有文件的路径
- en: Run the `pyrcc5` tool to serialize and compress these files into data contained
    in a Python module
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`pyrcc5`工具将这些文件序列化并压缩到包含在Python模块中的数据中
- en: Import the resulting Python module into our application script
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的Python模块导入我们的应用程序脚本
- en: Now we can reference our resources using a special syntax
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用特殊的语法引用我们的资源
- en: 'Let''s step through this process—suppose that we have some team badges in the
    form of PNG files that we want to include in our program. Our first step is to
    create the `resources.qrc` file, which looks like the following code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步走过这个过程——假设我们有一些队徽，以PNG文件的形式，我们想要包含在我们的程序中。我们的第一步是创建`resources.qrc`文件，它看起来像下面的代码块：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've placed this file in the same directory as the image files listed in the
    script. Note that we've added a `prefix` value of `teams`. Prefixes allow you
    to organize resources into categories. Additionally, notice that the last file
    has an alias specified. In our program, we can use this alias rather than the
    actual name of the file to access this resource.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这个文件放在与脚本中列出的图像文件相同的目录中。请注意，我们添加了一个`prefix`值为`teams`。前缀允许您将资源组织成类别。另外，请注意，最后一个文件有一个指定的别名。在我们的程序中，我们可以使用这个别名而不是文件的实际名称来访问这个资源。
- en: 'Now, in the command line, we''ll run `pyrcc5`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在命令行中，我们将运行`pyrcc5`，如下所示：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The syntax here is `pyrcc5 -o outputFile.py inputFile.qrc`. This command should
    generate a Python file containing your resource data. If you take a moment to
    open the file and examine it, you'll find it's mostly just a large `bytes` object
    assigned to the `qt_resource_data` variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语法是`pyrcc5 -o outputFile.py inputFile.qrc`。这个命令应该生成一个包含您的资源数据的Python文件。如果您花一点时间打开文件并检查它，您会发现它主要只是一个分配给`qt_resource_data`变量的大型`bytes`对象。
- en: 'Back in our main script, we just need to import this file in the same way as
    any other Python file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的主要脚本中，我们只需要像导入任何其他Python文件一样导入这个文件：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The file doesn't have to be called `resources.py`; in fact, any name will suffice.
    You just need to import it, and the code in the file will make sure that the resources
    are available to Qt.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文件不一定要叫做`resources.py`；实际上，任何名称都可以。你只需要导入它，文件中的代码将确保资源对Qt可用。
- en: 'Now that the resource file is imported, we can specify pixmap paths using the
    resource syntax:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在资源文件已导入，我们可以使用资源语法指定像素图路径：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Essentially, the syntax is `:/prefix/file_name_or_alias.extension`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，语法是`:/prefix/file_name_or_alias.extension`。
- en: Because our data is stored in a Python file, we can place it inside a Python
    library and it will use Python's standard import resolution rules to locate the
    file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的数据存储在一个Python文件中，我们可以将它放在一个Python库中，它将使用Python的标准导入解析规则来定位文件。
- en: Qt resource files and fonts
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt资源文件和字体
- en: Resource files aren't limited to images; in fact, they can be used to include
    just about any kind of binary, including font files. For example, suppose that
    we want to include our favorite font in the program to ensure that it looks right
    on all platforms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件不仅限于图像；实际上，它们可以用于包含几乎任何类型的二进制文件，包括字体文件。例如，假设我们想要在程序中包含我们喜欢的字体，以确保它在所有平台上看起来正确。
- en: 'Just as with images, we start by including the font file in the `.qrc` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与图像一样，我们首先在`.qrc`文件中包含字体文件：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we've added a prefix of `fonts` and included a reference to the `LiberationSans-Regular.ttf`
    file. After running `pyrcc5` against this file, the font is bundled into our `resources.py`
    file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个前缀`fonts`并包含了对`LiberationSans-Regular.ttf`文件的引用。运行`pyrcc5`对这个文件进行处理后，字体被捆绑到我们的`resources.py`文件中。
- en: 'To use this font in the code, we start by adding it to the font database, as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用这个字体，我们首先要将它添加到字体数据库中，如下所示：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`QFontDatabase.addApplicationFont()` inserts the passed font file into the
    application''s font database and returns an ID number. We can then use that ID
    number to determine the font''s family string; this can be passed to `QFont`,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFontDatabase.addApplicationFont()`将传递的字体文件插入应用程序的字体数据库并返回一个ID号。然后我们可以使用该ID号来确定字体的系列字符串；这可以传递给`QFont`，如下所示：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Make sure to check the license on your font before distributing it with your
    application! Remember that not all fonts are free to redistribute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发应用程序之前，请确保检查字体的许可证！请记住，并非所有字体都可以自由分发。
- en: 'Our form is certainly looking more game-like now; run the application and it
    should look similar the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单现在看起来更像游戏了；运行应用程序，它应该看起来类似于以下截图：
- en: '![](assets/93a4b1be-2c07-49b2-9a87-7d2b740a59fc.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93a4b1be-2c07-49b2-9a87-7d2b740a59fc.png)'
- en: Configuring colors, style sheets, and styles
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置颜色、样式表和样式
- en: 'Fonts and icons have improved the look of our form, but now it''s time to ditch
    those institutional gray tones and replace them with some color. In this section,
    we''re going to look at three different approaches that Qt offers for customizing
    application colors: manipulating the **palette**, using **style sheets**, and
    overriding the **application style**.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 字体和图标改善了我们表单的外观，但现在是时候摆脱那些机构灰色调，用一些颜色来替换它们。在本节中，我们将看一下Qt为自定义应用程序颜色提供的三种不同方法：操纵**调色板**、使用**样式表**和覆盖**应用程序样式**。
- en: Customizing colors with palettes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调色板自定义颜色
- en: A palette, represented by the `QPalette` class, is a collection of colors and
    brushes that are mapped to color roles and color groups.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由`QPalette`类表示的调色板是一组映射到颜色角色和颜色组的颜色和画笔的集合。
- en: 'Let''s unpack that statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解开这个声明：
- en: Here, **color** is a literal color value, represented by a `QColor` object
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，**color**是一个文字颜色值，由`QColor`对象表示
- en: A **brush** combines a particular color with a style, such as a pattern, gradient,
    or texture, and is represented by a `QBrush` class
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画笔**将特定颜色与样式（如图案、渐变或纹理）结合在一起，由`QBrush`类表示'
- en: A **color role** represents the way a widget uses the color, such as in the
    foreground, in the background, or in the border
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色角色**表示小部件使用颜色的方式，例如前景、背景或边框'
- en: The **color group** refers to the interaction state of the widget; it can be
    `Normal`, `Active`, `Disabled`, or `Inactive`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色组**指的是小部件的交互状态；它可以是`Normal`、`Active`、`Disabled`或`Inactive`'
- en: When a widget is painted on the screen, Qt's painting system consults the palette
    to determine the color and brush used to render each piece of the widget. To customize
    this, we can create our own palette and assign it to a widget.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当小部件在屏幕上绘制时，Qt的绘图系统会查阅调色板，以确定用于渲染小部件的每个部分的颜色和画笔。要自定义这一点，我们可以创建自己的调色板并将其分配给一个小部件。
- en: 'To begin, we need to get a `QPalette` object, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取一个`QPalette`对象，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While we could just create a `QPalette` object directly, the Qt documentation
    recommends that we call `palette()` on our running `QApplication` instance to
    retrieve a copy of the palette for the currently configured style.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以直接创建一个`QPalette`对象，但Qt文档建议我们在运行的`QApplication`实例上调用`palette()`来检索当前配置样式的调色板的副本。
- en: You can always retrieve a copy of your `QApplication` object by calling `QApplication.instance()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`QApplication.instance()`来随时检索`QApplication`对象的副本。
- en: 'Now that we have the palette, let''s start overriding some of the rules:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了调色板，让我们开始覆盖一些规则：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`QtGui.QPalette.Button` and `QtGui.QPalette.ButtonText` are color role constants
    and, as you might guess, they represent the background and foreground colors,
    respectively, of all the Qt button classes. We''re overriding them with new colors.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtGui.QPalette.Button`和`QtGui.QPalette.ButtonText`是颜色角色常量，正如你可能猜到的那样，它们分别代表所有Qt按钮类的背景和前景颜色。我们正在用新颜色覆盖它们。'
- en: 'To override the color for a particular button state, we need to pass in a color
    group constant as the first argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖特定按钮状态的颜色，我们需要将颜色组常量作为第一个参数传递：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we're changing the colors used when a button is in the `Disabled`
    state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在更改按钮处于`Disabled`状态时使用的颜色。
- en: 'To apply this new palette, we have to assign it to a widget, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个新的调色板，我们必须将它分配给一个小部件，如下所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`setPalette()` assigns the provided palette to the widget and all the child
    widgets as well. So, rather than assigning this to individual widgets, we could
    create a single palette and assign it to our `QMainWindow` class to apply it to
    all objects.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPalette()`将提供的调色板分配给小部件和所有子小部件。因此，我们可以创建一个单独的调色板，并将其分配给我们的`QMainWindow`类，以将其应用于所有对象，而不是分配给单个小部件。'
- en: Working with QBrush objects
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QBrush对象
- en: If we want something fancier than a solid color, then we can use a `QBrush`
    object. Brushes are capable of filling colors in patterns, gradients, or textures
    (that is, image-based patterns).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要比纯色更花哨的东西，那么我们可以使用`QBrush`对象。画笔可以填充颜色、图案、渐变或纹理（即基于图像的图案）。
- en: 'For example, let''s create a brush that paints a white stipple fill:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个绘制白色点划填充的画笔：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Dense2Pattern` is one of 15 patterns available. (You can refer to [https://doc.qt.io/qt-5/qt.html#BrushStyle-enum](https://doc.qt.io/qt-5/qt.html#BrushStyle-enum)
    for the full list.) Most of these are varying degrees of stippling, cross-hatching,
    or alternating line patterns.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dense2Pattern`是15种可用图案之一。（你可以参考[https://doc.qt.io/qt-5/qt.html#BrushStyle-enum](https://doc.qt.io/qt-5/qt.html#BrushStyle-enum)获取完整列表。）其中大多数是不同程度的点划、交叉点划或交替线条图案。'
- en: 'Patterns have their uses, but gradient-based brushes are perhaps more interesting
    for modern styling. However, creating one is a little more involved, as shown
    in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图案有它们的用途，但基于渐变的画笔可能更适合现代风格。然而，创建一个可能会更复杂，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To use a gradient in a brush, we first have to create a gradient object. Here,
    we've created a `QLinearGradient` object, which implements a basic linear gradient.
    The arguments are the starting and ending coordinates for the gradient, which
    we've specified as the top-left (0, 0), and the bottom-right (width, height) of
    the main window.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画笔中使用渐变，我们首先必须创建一个渐变对象。在这里，我们创建了一个`QLinearGradient`对象，它实现了基本的线性渐变。参数是渐变的起始和结束坐标，我们指定为主窗口的左上角（0,
    0）和右下角（宽度，高度）。
- en: Qt also offers the `QRadialGradient` and `QConicalGradient` classes for additional
    gradient options.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还提供了`QRadialGradient`和`QConicalGradient`类，用于提供额外的渐变选项。
- en: After creating the object, we then specify color stops using `setColorAt()`.
    The first argument is a float value between 0 and 1 that specifies the percentage
    between the start and finish, and the second argument is the `QColor` object that
    the gradient should be at that point.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象后，我们使用`setColorAt()`指定颜色停止。第一个参数是0到1之间的浮点值，指定起始和结束之间的百分比，第二个参数是渐变应该在该点的`QColor`对象。
- en: After creating the gradient, we pass it to the `QBrush` constructor to create
    a brush that paints with our gradient.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建渐变后，我们将其传递给`QBrush`构造函数，以创建一个使用我们的渐变进行绘制的画笔。
- en: 'We can now apply our brushes to a palette using the `setBrush()` method, as
    follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`setBrush()`方法将我们的画笔应用于调色板，如下所示：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Just as with `QPalette.setColor()`, we can assign our brush with or without
    specifying a specific color group. In this case, our gradient brush will be used
    to paint the main window regardless of its state, but our dotted brush will only
    be used when the widget is active (that is, the currently active window).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`QPalette.setColor()`一样，我们可以分配我们的画笔，无论是否指定了特定的颜色组。在这种情况下，我们的渐变画笔将用于绘制主窗口，而我们的点画画笔只有在小部件处于活动状态时才会使用（即当前活动窗口）。
- en: Customizing the appearance with Qt Style Sheets (QSS)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt样式表（QSS）自定义外观
- en: For developers who have worked with web technologies, styling an application
    using palette, brush, and color objects may seem verbose and unintuitive. Fortunately,
    Qt offers you an alternative known as QSS, which is very similar to the **Cascading
    Style Sheets** (**CSS**) used in web development. It is an easy way to apply some
    simple changes to our widgets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经使用过Web技术的开发人员来说，使用调色板、画笔和颜色对象来设计应用程序可能会显得啰嗦和不直观。幸运的是，Qt为您提供了一种称为QSS的替代方案，它与Web开发中使用的**层叠样式表**（**CSS**）非常相似。这是一种简单的方法，可以对我们的小部件进行一些简单的更改。
- en: 'You can use QSS as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式使用QSS：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, a style sheet is just a string containing style directives, which we can
    assign to a widget's `styleSheet` property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，样式表只是一个包含样式指令的字符串，我们可以将其分配给小部件的`styleSheet`属性。
- en: 'The syntax, which should be familiar to anyone who has worked with CSS, is
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法对于任何使用过CSS的人来说应该很熟悉，如下所示：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you run the program at this point, you''ll find, to your dismay, that (depending
    on your system theme) it may look something like the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行程序，你会发现（取决于你的系统主题），它可能看起来像以下的截图：
- en: '![](assets/5aa10114-bea6-4980-b9a0-6d011e653a36.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5aa10114-bea6-4980-b9a0-6d011e653a36.png)'
- en: Here, the interface has mostly gone black apart from the text and images. Our
    buttons and checkbox, in particular, are indistinguishable from the background.
    So, why did this happen?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，界面大部分变成了黑色，除了文本和图像。特别是我们的按钮和复选框与背景几乎无法区分。那么，为什么会发生这种情况呢？
- en: Well, when you add a QSS style to a widget class, the style change carries down
    to all its subclasses. Since we styled `QWidget`, all the other `QWidget` derived
    classes (such as `QCheckbox` and `QPushButton`) inherited this style.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向小部件类添加QSS样式时，样式更改会传递到所有其子类。由于我们对`QWidget`进行了样式设置，所有其他`QWidget`派生类（如`QCheckbox`和`QPushButton`）都继承了这种样式。
- en: 'Let''s fix this by overriding the styles for those subclasses, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过覆盖这些子类的样式来修复这个问题，如下所示：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Just as with CSS, applying a style to a more specific class overrides the more
    general case. For example, our `QPushButton` background color overrides the `QWidget`
    background color.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像CSS一样，将样式应用于更具体的类会覆盖更一般的情况。例如，我们的`QPushButton`背景颜色会覆盖`QWidget`背景颜色。
- en: Note the use of colons with `QCheckBox`—the double colon in QSS allows us to
    reference a subelement of a widget. In this case, this is the indicator portion
    of the `QCheckBox` class (as opposed to its label portion). We can also use a
    single colon to reference a widget state, as, in this case, we're setting a different
    style depending on whether or not the checkbox is checked or unchecked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在`QCheckBox`中使用冒号 - QSS中的双冒号允许我们引用小部件的子元素。在这种情况下，这是`QCheckBox`类的指示器部分（而不是其标签部分）。我们还可以使用单个冒号来引用小部件状态，就像在这种情况下，我们根据复选框是否选中或未选中来设置不同的样式。
- en: 'If you wanted to restrict a change to a particular class only and not any of
    its subclasses, simply add a period (`.`) to the name, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想将更改限制为特定类，而不是其任何子类，只需在名称后添加一个句点（`。`），如下所示：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This preceding example also demonstrates how to use images in QSS. Just like
    in CSS, we can provide a file path that is wrapped in the `url()` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例还演示了如何在QSS中使用图像。就像在CSS中一样，我们可以提供一个包装在`url()`函数中的文件路径。
- en: QSS also accepts resource paths if you've serialized your images with `pyrcc5`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用`pyrcc5`序列化了图像，QSS还接受资源路径。
- en: If you want to apply a style to a particular widget rather than a whole class
    of widgets, there are two ways to do so.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将样式应用于特定小部件而不是整个小部件类，有两种方法可以实现。
- en: 'The first method is to rely on the `objectName` property, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是依赖于`objectName`属性，如下所示：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our style sheet, an object name must be preceded by a
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的样式表中，对象名称前必须加上一个
- en: '`#` symbol to identify it as an object name rather than a class.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`#`符号用于将其标识为对象名称，而不是类。'
- en: The other way to set styles on individual widgets is to call t
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个小部件上设置样式的另一种方法是调用t
- en: 'he widget''s `setStyleSheet()` method with some style sheet directives, as
    follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小部件的`setStyleSheet()`方法和一些样式表指令，如下所示：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we want to apply a style directly to the widget we're calling, we don't need
    to specify class names or object names; we can simply pass in the properties and
    values.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要直接将样式应用于我们正在调用的小部件，我们不需要指定类名或对象名；我们可以简单地传递属性和值。
- en: 'Having made all these changes, our application now looks a lot more like a
    game GUI:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些更改，我们的应用程序现在看起来更像是一个游戏GUI：
- en: '![](assets/ec30b7cf-f46b-4f79-955c-9af210c2281f.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec30b7cf-f46b-4f79-955c-9af210c2281f.png)'
- en: The downside of QSS
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSS的缺点
- en: As you can see, QSS is a very powerful styling method and is accessible for
    any developer who has worked with web development; however, it does have some
    disadvantages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，QSS是一种非常强大的样式方法，对于任何曾经从事Web开发的开发人员来说都是可访问的；但是，它确实有一些缺点。
- en: QSS is an abstraction over the palette and style objects and must be translated
    to the actual system. This makes them slower for large applications, and it also
    means that there is no default style sheet that you can retrieve and edit – you're
    starting from scratch each time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: QSS是对调色板和样式对象的抽象，必须转换为实际系统。这使它们在大型应用程序中变得更慢，这也意味着没有默认样式表可以检索和编辑 - 每次都是从头开始。
- en: As we've already seen, QSS can have unpredictable results when applied to high-level
    widgets, since it inherits through the class hierarchy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，当应用于高级小部件时，QSS可能会产生不可预测的结果，因为它通过类层次结构继承。
- en: Finally, bear in mind that QSS is a modest subset of CSS 2.0 with a few additions
    or changes—it is not CSS. Therefore, transitions, animations, flexbox containers,
    relative units, and other modern CSS goodies are completely absent. So, while
    web developers may find its basic syntax familiar, the limited set of options
    may be frustrating and its different behaviors confusing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，QSS是CSS 2.0的一个较小子集，带有一些添加或更改 - 它不是CSS。因此，过渡、动画、flexbox容器、相对单位和其他现代CSS好东西完全不存在。因此，尽管Web开发人员可能会发现其基本语法很熟悉，但有限的选项集可能会令人沮丧，其不同的行为也会令人困惑。
- en: Customizing the appearance with QStyle
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QStyle自定义外观
- en: Palettes and style sheets can take us a long way towards customizing the look
    of a Qt application, and for most cases, that's all you'll ever need. To really
    dig into the heart of a Qt application's appearance, we need to understand the
    style system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 调色板和样式表可以帮助我们大大定制Qt应用程序的外观，对于大多数情况来说，这就是您所需要的。要真正深入了解Qt应用程序外观的核心，我们需要了解样式系统。
- en: Every running instance of a Qt application has a single style, which is in charge
    of telling the graphics system how to draw each widget or GUI component. Styles
    are dynamic and pluggable, so that different OS platforms have different styles,
    and users can install their own Qt styles to use in Qt applications. This is how
    Qt applications are able to have a native look on different OSes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行的Qt应用程序实例都有一个样式，负责告诉图形系统如何绘制每个小部件或GUI组件。样式是动态和可插拔的，因此不同的OS平台具有不同的样式，用户可以安装自己的Qt样式以在Qt应用程序中使用。这就是Qt应用程序能够在不同的操作系统上具有本机外观的原因。
- en: In [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt,* we learned that `QApplication` should be passed a copy of `sys.argv`
    when created, so that it can process some Qt-specific arguments. One such argument
    is `-style`, which allows the user to set a custom style for their Qt application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中，*使用PyQt入门*，我们学到`QApplication`在创建时应传递`sys.argv`的副本，以便它可以处理一些特定于Qt的参数。其中一个参数是`-style`，它允许用户为其Qt应用程序设置自定义样式。
- en: 'For example, let''s run the calendar application from [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml),
    *Handling Events with Signals and Slots,* with the `Windows` style:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用`Windows`样式运行[第3章](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml)中的日历应用程序，*使用信号和槽处理事件*：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now try it using the `Fusion` style, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用`Fusion`样式，如下所示：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the difference in appearance, especially in the input controls.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意外观上的差异，特别是输入控件。
- en: Capitalization counts with styles; **windows** is not a valid style, whereas
    **Windows** is!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 样式中的大小写很重要；**windows**不是有效的样式，而**Windows**是！
- en: 'The styles that are available on common OS platforms are shown in the following
    table:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 常见OS平台上可用的样式如下表所示：
- en: '| OS | Styles |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| OS | 样式 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Windows 10 | `windowsvista`, `Windows`, and `Fusion` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Windows 10 | `windowsvista`，`Windows`和`Fusion` |'
- en: '| macOS | `macintosh`, `Windows`, and `Fusion` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| macOS | `macintosh`，`Windows`和`Fusion` |'
- en: '| Ubuntu 18.04 | `Windows` and `Fusion` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu 18.04 | `Windows`和`Fusion` |'
- en: On many Linux distributions, additional Qt styles are available from the package
    repositories. A list of currently installed styles can be obtained by calling
    `QtWidgets.QStyleFactory.keys()`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多Linux发行版中，可以从软件包存储库中获取其他Qt样式。可以通过调用`QtWidgets.QStyleFactory.keys()`来获取当前安装的样式列表。
- en: 'Styles can also be set inside the application itself. In order to retrieve
    a style class, we need to use the `QStyleFactory` class, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 样式也可以在应用程序内部设置。为了检索样式类，我们需要使用`QStyleFactory`类，如下所示：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`QStyleFactory.create()` will attempt to find an installed style with the given
    name and return a `QCommonStyle` object; if the style requested is not found,
    then it will return `None`. The style object can then be used to set the `style`
    property of our `QApplication` object. (A value of `None` will just cause it to
    use the default.)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStyleFactory.create()`将尝试查找具有给定名称的已安装样式，并返回一个`QCommonStyle`对象；如果未找到请求的样式，则它将返回`None`。然后可以使用样式对象来设置我们的`QApplication`对象的`style`属性。（`None`的值将导致其使用默认值。）'
- en: If you plan to set a style inside the application, it's best to do it as early
    as possible before any widgets are drawn to avoid visual glitches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在应用程序中设置样式，最好在绘制任何小部件之前尽早进行，以避免视觉故障。
- en: Customizing Qt styles
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Qt样式
- en: Building a Qt style is an involved process that requires a deep understanding
    of Qt's widgets and painting system, and few developers will ever need to create
    one. We might, however, want to override some aspects of the running style to
    accomplish some things that aren't possible through manipulation of the palette
    or style sheets. We can do this by subclassing `QtWidgets.QProxyStyle`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Qt样式是一个复杂的过程，需要深入了解Qt的小部件和绘图系统，很少有开发人员需要创建一个。但是，我们可能希望覆盖运行样式的某些方面，以完成一些无法通过调色板或样式表的操作来实现的事情。我们可以通过对`QtWidgets.QProxyStyle`进行子类化来实现这一点。
- en: A proxy style is an overlay that we can use to override methods of the actual
    style that's running. In this way, it doesn't matter what actual style the user
    chooses, our proxy style's methods (where implemented) will be used instead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 代理样式是我们可以使用来覆盖实际运行样式的方法的覆盖层。这样，用户选择的实际样式是什么并不重要，我们的代理样式的方法（在实现时）将被使用。
- en: 'For example, let''s create a proxy style that forces all the screen text to
    be in uppercase, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个代理样式，强制所有屏幕文本都是大写的，如下所示：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`drawItemText()` is the method called on the style whenever text must be drawn
    to the screen. It receives a number of arguments, but the one we''re most concerned
    with is the `text` argument that is to be drawn. We''re simply going to intercept
    this text and make it uppercase before passing all the arguments back to `super().drawTextItem()`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawItemText()`是在必须将文本绘制到屏幕时在样式上调用的方法。它接收许多参数，但我们最关心的是要绘制的`text`参数。我们只是要拦截此文本，并在将所有参数传回`super().drawTextItem()`之前将其转换为大写。'
- en: 'This proxy style can then be applied to our `QApplication` object in the same
    way as any other style:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将此代理样式应用于我们的`QApplication`对象，方式与任何其他样式相同：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you run the program at this point, you'll see that all the text is now uppercase.
    Mission accomplished!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行程序，您会看到所有文本现在都是大写。任务完成！
- en: Drawing widgets
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制小部件
- en: Now let's try something a bit more ambitious. Let's change all our `QLineEdit`
    entry boxes to a green rounded rectangle outline. So, how do we go about doing
    this in a proxy style?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一些更有野心的事情。让我们将所有的`QLineEdit`输入框更改为绿色的圆角矩形轮廓。那么，我们如何在代理样式中做到这一点呢？
- en: 'The first step is to figure out what element of the widget we''re trying to
    modify. These can be found as enum constants of the `QStyle` class, and they''re
    divided into three main classes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是弄清楚我们要修改的小部件的元素是什么。这些可以在`QStyle`类的枚举常量中找到，它们分为三个主要类别：
- en: '`PrimitiveElement`, which includes fundamental, non-interactive GUI elements
    such as frames or backgrounds'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrimitiveElement`，其中包括基本的非交互式GUI元素，如框架或背景'
- en: '`ControlElement`, which includes interactive elements such as buttons or tabs'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlElement`，其中包括按钮或选项卡等交互元素'
- en: '`ComplexControl`, which includes complex interactive elements such as combo
    boxes and sliders'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComplexControl`，其中包括复杂的交互元素，如组合框和滑块'
- en: Each of these classes of items is drawn by a different method of `QStyle`; in
    this case, it turns out that we want to modify the `PE_FrameLineEdit` element,
    which is a primitive element (as indicated by the `PE_` prefix). This type of
    element is drawn by `QStyle.drawPrimitive()`, so we'll need to override that method
    in our proxy style.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别中的每个项目都由`QStyle`的不同方法绘制；在这种情况下，我们想要修改的是`PE_FrameLineEdit`元素，这是一个原始元素（由`PE_`前缀表示）。这种类型的元素由`QStyle.drawPrimitive()`绘制，因此我们需要在代理样式中覆盖该方法。
- en: 'Add this method to `StyleOverrides`, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法添加到`StyleOverrides`中，如下所示：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To control the drawing of an element, we need to issue commands to its `painter`
    object, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制元素的绘制，我们需要向其`painter`对象发出命令，如下所示：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Painter objects and the drawing will be fully covered in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter,* but, for now, understand that the preceding
    code draws a green rounded rectangle if the `element` argument matches `QStyle.PE_FrameLineEdit`.
    Otherwise, it passes the arguments to the superclass's `drawPrimitive()` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图对象和绘图将在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中完全介绍，*使用QPainter创建2D图形*，但是，现在要理解的是，如果`element`参数匹配`QStyle.PE_FrameLineEdit`，则前面的代码将绘制一个绿色的圆角矩形。否则，它将将参数传递给超类的`drawPrimitive()`方法。
- en: Notice that we do not call the superclass method after drawing our rectangle.
    If we did, then the superclass would draw its style-defined widget element on
    top of our green rectangle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在绘制矩形后，我们不调用超类方法。如果我们这样做了，那么超类将在我们的绿色矩形上方绘制其样式定义的小部件元素。
- en: As you can see in this example, while working with `QProxyStyle` is considerably
    more esoteric than using palettes or style sheets, it does give us almost limitless
    control over how our widgets appear.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个例子中看到的，使用`QProxyStyle`比使用调色板或样式表要复杂得多，但它确实让我们几乎无限地控制我们的小部件的外观。
- en: It doesn't matter whether you use QSS or styles and palettes to restyle an application;
    however, it is highly advised that you stick to one or the other. Otherwise, your
    style modifications can fight with one another and give unpredictable results
    across platforms and desktop settings.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用QSS还是样式和调色板来重新设计应用程序都没有关系；然而，强烈建议你坚持使用其中一种。否则，你的样式修改可能会相互冲突，并在不同平台和桌面设置上产生不可预测的结果。
- en: Creating animations
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画
- en: Nothing quite adds a sophisticated edge to a GUI like the tasteful use of animations.
    Dynamic GUI elements that fade smoothly between changes in color, size, or position
    can add a modern touch to any interface.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比动画的巧妙使用更能为GUI增添精致的边缘。在颜色、大小或位置的变化之间平滑地淡入淡出的动态GUI元素可以为任何界面增添现代感。
- en: Qt's animation framework allows us to create simple animations on our widgets
    using the `QPropertyAnimation` class. In this section, we'll explore how to use
    this class to spice up our game lobby with some animations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的动画框架允许我们使用`QPropertyAnimation`类在我们的小部件上创建简单的动画。在本节中，我们将探讨如何使用这个类来为我们的游戏大厅增添一些动画效果。
- en: Because Qt style sheets override another widget- and palette-based styling,
    you will need to comment out all the style sheet code for these animations to
    work correctly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Qt样式表会覆盖另一个基于小部件和调色板的样式，所以你需要注释掉所有这些动画的样式表代码才能正常工作。
- en: Basic property animations
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本属性动画
- en: A `QPropertyAnimation` object is used to animate a single Qt property of a widget.
    The class automatically creates an interpolated series of steps between two numeric
    property values and applies the changes over time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPropertyAnimation`对象用于动画小部件的单个Qt属性。该类会自动在两个数值属性值之间创建插值步骤序列，并在一段时间内应用这些变化。'
- en: 'For example, let''s animate our logo so that it scrolls out from left to right.
    You can begin by adding a property animation object, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们动画我们的标志，让它从左向右滚动。你可以通过添加一个属性动画对象来开始，如下所示：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`QPropertyAnimation` requires two arguments: a widget (or another type of `QObject`
    class) to be animated, and a `bytes` object indicating the property to be animated
    (note that this is a `bytes` object and not a string).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPropertyAnimation`需要两个参数：一个要被动画化的小部件（或其他类型的`QObject`类），以及一个指示要被动画化的属性的`bytes`对象（请注意，这是一个`bytes`对象，而不是一个字符串）。'
- en: 'Next, we need to configure our animation object as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置我们的动画对象如下：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: At the very least, we need to set a `startValue` value and an `endValue` value
    for the property. Naturally, these values must be of the data type required by
    the property. We can also set `duration` in milliseconds (the default is 250).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们需要为属性设置一个`startValue`值和一个`endValue`值。当然，这些值必须是属性所需的数据类型。我们还可以设置毫秒为单位的`duration`（默认值为250）。
- en: 'Once configured, we just need to tell the animation to start, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好后，我们只需要告诉动画开始，如下所示：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There are a few requirements that limit what `QPropertyAnimation` objects can
    do:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些要求限制了`QPropertyAnimation`对象的功能：
- en: The object to be animated must be a `QObject` subclass. This includes all widgets
    but excludes some Qt classes such as `QPalette`.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要动画的对象必须是`QObject`的子类。这包括所有小部件，但不包括一些Qt类，如`QPalette`。
- en: The property to be animated must be a Qt property (not just a Python member
    variable).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要动画的属性必须是Qt属性（不仅仅是Python成员变量）。
- en: The property must have read-and-write accessor methods that require only a single
    value. For example, `QWidget.size` can be animated but not `QWidget.width`, because
    there is no `setWidth()` method.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性必须具有读写访问器方法，只需要一个值。例如，`QWidget.size`可以被动画化，但`QWidget.width`不能，因为没有`setWidth()`方法。
- en: 'The property value must be one of the following types: `int`, `float`, `QLine`,
    `QLineF`, `QPoint`, `QPointF`, `QSize`, `QSizeF`, `QRect`, `QRectF`, or `QColor`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性值必顺为以下类型之一：`int`、`float`、`QLine`、`QLineF`、`QPoint`、`QPointF`、`QSize`、`QSizeF`、`QRect`、`QRectF`或`QColor`。
- en: Unfortunately, for most widgets, these limitations exclude a number of aspects
    that we might want to animate—in particular, colors. Fortunately, we can work
    around this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于大多数小部件，这些限制排除了我们可能想要动画的许多方面，特别是颜色。幸运的是，我们可以解决这个问题。
- en: Animating colors
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画颜色
- en: As you learned earlier in this chapter, widget colors are not properties of
    the widget – rather they are properties of the palette. The palette cannot be
    animated, because `QPalette` is not a subclass of `QObject`, and because `setColor()`
    requires more than just a single value.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章前面学到的，小部件颜色不是小部件的属性，而是调色板的属性。调色板不能被动画化，因为`QPalette`不是`QObject`的子类，而且`setColor()`需要的不仅仅是一个单一的值。
- en: Colors are something that we'd like to animate, though; to make that happen,
    we need to subclass our widget and make its color settings into Qt properties.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是我们想要动画的东西，为了实现这一点，我们需要对小部件进行子类化，并将其颜色设置为Qt属性。
- en: 'Let''s do that with a button; start a new class at the top of the script, as
    follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个按钮来做到这一点；在脚本的顶部开始一个新的类，如下所示：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have a `QPushButton` subclass with accessor methods for the palette's
    `ButtonText` color. However, note that these are Python methods; in order to animate
    this property, we need `color` to be an actual Qt property. To correct this, we'll
    use the `QtCore.pyqtProperty()` function to wrap our accessor methods and create
    a property on the underlying Qt object.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`QPushButton`子类，其中包含用于调色板`ButtonText`颜色的访问器方法。但是，请注意这些是Python方法；为了对此属性进行动画处理，我们需要`color`成为一个实际的Qt属性。为了纠正这一点，我们将使用`QtCore.pyqtProperty()`函数来包装我们的访问器方法，并在底层Qt对象上创建一个属性。
- en: 'You can do this as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式操作：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The property name we use will be the name of the Qt property. The first argument
    passed is the data type required by the property, and the next two arguments are
    the getter and setter methods.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的属性名称将是Qt属性的名称。传递的第一个参数是属性所需的数据类型，接下来的两个参数是getter和setter方法。
- en: '`pyqtProperty()` can also be used as a decorator, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyqtProperty()`也可以用作装饰器，如下所示：'
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that, in this approach, both methods must be named identically using
    the property name we intend to create.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种方法中，两个方法必须使用我们打算创建的属性名称相同的名称。
- en: 'Now that our properties are in place, we need to replace our regular `QPushButton`
    objects with `ColorButton` objects:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的属性已经就位，我们需要用`ColorButton`对象替换我们的常规`QPushButton`对象：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With these changes made, we can animate the color values, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们可以如下地对颜色值进行动画处理：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This works like a charm. We''ve also added a couple of additional configuration
    settings here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常有效。我们还在这里添加了一些额外的配置设置：
- en: '`setLoopCount()` will set how many times the animation restarts. A value of
    `-1` will make it loop forever.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLoopCount()`将设置动画重新启动的次数。值为`-1`将使其永远循环。'
- en: '`setEasingCurve()` changes the curve along which the values are interpolated.
    We''ve chosen `InOutQuad`, which slows the rate of the start and finish of the
    animation.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setEasingCurve()`改变了值插值的曲线。我们选择了`InOutQuad`，它减缓了动画开始和结束的速率。'
- en: 'Now, when you run the script, note that the color fades from white to gray
    and then immediately loops back to white. If we want an animation to move from
    one value to another and then smoothly back again, we can use the `setKeyValue()`
    method to put a value in the middle of the animation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行脚本时，请注意颜色从白色渐变到灰色，然后立即循环回白色。如果我们希望动画从一个值移动到另一个值，然后再平稳地返回，我们可以使用`setKeyValue()`方法在动画的中间放置一个值：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this case, our start and end values are the same, and we've added a value
    at 0.5 (50% of the way through the animation) set to a second color. This animation
    will fade from black to dark red and back again. You can add as many key values
    as you wish and make quite complex animations.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的起始值和结束值是相同的，并且我们在动画的中间添加了一个值为0.5（动画进行到一半时）设置为第二个颜色。这个动画将从黑色渐变到深红色，然后再返回。您可以添加任意多个关键值并创建相当复杂的动画。
- en: Using animation groups
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画组
- en: As we add more and more animations to a GUI, we may find it necessary to group
    them together so that we can control the animations as a group. This can be done
    using the animation group classes, `QParallelAnimationGroup` and `QSequentialAnimationGroup`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向GUI添加越来越多的动画，我们可能会发现有必要将它们组合在一起，以便我们可以将动画作为一个组来控制。这可以使用动画组类`QParallelAnimationGroup`和`QSequentialAnimationGroup`来实现。
- en: Both of these classes allow us to add multiple animations to the group and start,
    stop, pause, and resume the animations as a group.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都允许我们向组中添加多个动画，并作为一个组开始、停止、暂停和恢复动画。
- en: 'For example, let''s group our button animations as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将按钮动画分组如下：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`QParallelAnimationGroup` plays all animations in parallel whenever its `start()`
    method is called. In contrast, `QSequentialAnimationGroup` will playback its animations
    one at a time in the order added, as shown in the following code block:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`QParallelAnimationGroup`在调用其`start()`方法时会同时播放所有动画。相反，`QSequentialAnimationGroup`将按添加的顺序依次播放其动画，如下面的代码块所示：'
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By adding animation groups to other animation groups as we've done here, we
    can choreograph complex arrangements of animations into one object that can be
    started, stopped, or paused altogether.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像我们在这里所做的那样将动画组添加到其他动画组中，我们可以将复杂的动画安排成一个对象，可以一起启动、停止、暂停和恢复。
- en: Comment out all the other animation `start()` calls and launch the script. Note
    that the button animations start only after the heading animation has finished.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉所有其他动画的`start()`调用并启动脚本。请注意，按钮动画仅在标题动画完成后开始。
- en: We will explore more uses of `QPropertyAnimation` in *Chapter 12*, *2D Graphics
    with QPainter*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第12章* *使用QPainter进行2D图形*中探索更多`QPropertyAnimation`的用法。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to customize the look and feel of a PyQt application.
    We also learned how to manipulate screen fonts and add images. Additionally, we
    learned how to package image and font resources in a way that is resilient to
    path changes. We also explored how to alter the color and appearance of the application
    using palettes and style sheets, and how to override style methods to implement
    nearly limitless style changes. Finally, we explored widget animation using Qt's
    animation framework and learned how to add custom Qt properties to our classes
    so that we can animate them.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何自定义PyQt应用程序的外观和感觉。我们还学习了如何操纵屏幕字体并添加图像。此外，我们还学习了如何以对路径更改具有弹性的方式打包图像和字体资源。我们还探讨了如何使用调色板和样式表改变应用程序的颜色和外观，以及如何覆盖样式方法来实现几乎无限的样式更改。最后，我们探索了使用Qt的动画框架进行小部件动画，并学习了如何向我们的类添加自定义Qt属性，以便我们可以对其进行动画处理。
- en: In the next chapter, we're going to explore the world of multimedia applications
    using the `QtMultimedia` library. You'll learn how to work with cameras to take
    pictures and videos, how to display video content, and how to record and playback
    audio.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用`QtMultimedia`库探索多媒体应用程序的世界。您将学习如何使用摄像头拍照和录制视频，如何显示视频内容，以及如何录制和播放音频。
- en: Questions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您从本章学到的知识：
- en: You are preparing to distribute your text editor application, and want to ensure
    that the user is given a monospaced font by default, no matter what platform they
    use. What two ways can you use to accomplish this?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在准备分发您的文本编辑器应用程序，并希望确保用户无论使用什么平台，都会默认获得等宽字体。您可以使用哪两种方法来实现这一点？
- en: 'As closely as possible, try to mimic the following text using `QFont`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能地，尝试使用`QFont`模仿以下文本：
- en: '![](assets/07c03999-3b51-4ee3-8a01-aaaf1e4cf5c3.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07c03999-3b51-4ee3-8a01-aaaf1e4cf5c3.png)'
- en: Can you explain the difference between `QImage`, `QPixmap`, and `QIcon`?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能解释一下`QImage`，`QPixmap`和`QIcon`之间的区别吗？
- en: You have defined the following `.qrc` file for your application, run `pyrcc5`,
    and imported the resource library in your script. How would you load this image
    into `QPixmap`?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已为应用程序定义了以下`.qrc`文件，运行了`pyrcc5`，并在脚本中导入了资源库。您会如何将此图像加载到`QPixmap`中？
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using `QPalette`, how would you tile the background of a `QWidget` object with
    the `tile.png` image?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QPalette`，如何使用`tile.png`图像在`QWidget`对象的背景上铺砌？
- en: You are trying to make a delete button pink using QSS, but it's not working.
    What is wrong with your code?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您试图使用QSS使删除按钮变成粉色，但没有成功。您的代码有什么问题？
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Which style sheet string will turn the background colors of your `QLineEdit`
    widget black?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个样式表字符串将把您的`QLineEdit`小部件的背景颜色变成黑色？
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Build a simple app with a combo box that allows you to change the Qt style to
    any style installed on your system. Include some other widgets so that you can
    see how they look in the different styles.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个简单的应用程序，其中包含一个下拉框，允许您将Qt样式更改为系统上安装的任何样式。包括一些其他小部件，以便您可以看到它们在不同样式下的外观。
- en: 'You feel very happy about learning how to style PyQt apps and want to create
    a `QProxyStyle` class that will force all pixmaps in a GUI to be `smile.gif`.
    How would you do this? Hint: You will need to research some other drawing methods
    of `QStyle` than the ones discussed in this chapter.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您对学习如何为PyQt应用程序设置样式感到非常高兴，并希望创建一个`QProxyStyle`类，该类将强制GUI中的所有像素图像为`smile.gif`。您会如何做？提示：您需要研究`QStyle`的一些其他绘图方法，而不是本章讨论的方法。
- en: 'The following animation doesn''t work; figure out why it doesn''t work:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下动画不起作用；找出它为什么不起作用：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Further reading
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下内容：
- en: A more detailed description of how fonts are resolved can be found in the `QFont`
    documentation at [https://doc.qt.io/qt-5/qfont.html#details](https://doc.qt.io/qt-5/qfont.html#details)
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关字体如何解析的更详细描述可以在[https://doc.qt.io/qt-5/qfont.html#details](https://doc.qt.io/qt-5/qfont.html#details)的`QFont`文档中找到
- en: This Qt styling example in C++ ([https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html](https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html))
    demonstrates how to create a comprehensive Qt Proxy Style
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个C++中的Qt样式示例([https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html](https://doc.qt.io/qt-5/qtwidgets-widgets-styles-example.html))演示了如何创建一个全面的Qt代理样式
- en: The overview of the Qt's animation framework at [https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)
    offers additional details on how to use property animations and what their limitations
    are
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt的动画框架概述在[https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)提供了如何使用属性动画以及它们的限制的额外细节
