- en: Development Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Debugging—how to leverage the Python built-in debugger
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试-如何利用Python内置调试器
- en: Testing—writing test suites with the Python standard library test framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试-使用Python标准库测试框架编写测试套件
- en: Mocking—patching objects to simulate fake behaviors in tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟-在测试中修补对象以模拟虚假行为
- en: Reporting errors in production—getting crashes reported by email
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产中报告错误-通过电子邮件报告崩溃
- en: Benchmarking—how to benchmark functions with the standard library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试-如何使用标准库对函数进行基准测试
- en: Inspection—inspecting the type, attributes, and methods provided by an object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查-检查对象提供的类型、属性和方法
- en: Code evaluation—running Python code within Python code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码评估-在Python代码中运行Python代码
- en: Tracing—how to trace which lines of code were executed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪-如何跟踪执行了哪些代码行
- en: Profiling—how to trace bottlenecks in code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析-如何跟踪代码中的瓶颈
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When writing software, you need tools that make achieving your goal easier and
    tools that help you to manage the complexity of the code base, which can get millions
    of line of code and can involve other people's code that you are not experienced
    with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，您需要工具来更轻松地实现目标，以及帮助您管理代码库的复杂性，代码库可能包含数百万行代码，并且可能涉及您不熟悉的其他人的代码。
- en: Even for small projects, if you are involving third-party libraries, frameworks,
    and tools, you are, in fact, bringing other people's code into yours and you will
    need a set of tools to understand what's going on when you rely on this code and
    to keep your own code under control and free from bugs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是对于小型项目，如果涉及第三方库、框架和工具，实际上是将其他人的代码引入到自己的代码中，您将需要一套工具来理解在依赖于此代码时发生了什么，并且保持自己的代码受控并且没有错误。
- en: Here is where techniques such as testing, debugging, profiling, and tracing
    can come in handy to verify the code base, understand what's going on, spot bottlenecks,
    and see what was executed and when.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，诸如测试、调试、性能分析和跟踪等技术可以派上用场，以验证代码库，了解发生了什么，发现瓶颈，并查看执行了什么以及何时执行。
- en: The Python standard library comes with many of the tools you will need during
    daily development to implement most best practices and techniques in software
    development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了许多您在日常开发中需要实现大多数最佳实践和软件开发技术的工具。
- en: Debugging
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: While developing, you might face an unexpected behavior of your code or a crash,
    and you will want to dive into it, see the state of the variables, and check what's
    going on to understand how to handle the unexpected situation so that the software
    behaves properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您可能会遇到代码的意外行为或崩溃，并且希望深入了解，查看变量的状态，并检查发生了什么，以了解如何处理意外情况，以便软件能够正常运行。
- en: This is typically part of debugging and usually requires dedicated tools, debuggers,
    to make your life easier (ever found yourself throwing `print` statements everywhere
    around the code just to see value of some variable?).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是调试的一部分，通常需要专用工具、调试器，以使您的生活更轻松（是否曾经发现自己在代码中到处添加`print`语句，只是为了查看某个变量的值？）。
- en: The Python standard library comes with a very powerful debugger, and while other
    third-party solutions exist, the internal `pdb` debugger is very powerful and
    is able to help you in nearly all situations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了一个非常强大的调试器，虽然存在其他第三方解决方案，但内部的`pdb`调试器非常强大，并且能够在几乎所有情况下帮助您。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you want to stop code execution at a specific point and interactively move
    it forward while checking how your variables change and what flow the execution
    takes, you just want to set a tracing point where you want to stop, so that you
    will enter an interactive session in the shell where your code is running:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在特定点停止代码执行，并在交互式地向前移动，同时检查变量如何变化以及执行的流程，您只需设置一个跟踪点，然后您将进入一个交互式会话，在那里您的代码正在运行：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we call the `divide` function, we will enter an interactive debugger
    that lets us see the value of `x` and `y` and move forward with the execution:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用`divide`函数，我们将进入一个交互式调试器，让我们看到`x`和`y`的值，并继续执行：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `pdb` module exposes a `set_trace` function which, when called, stops execution
    and enters the interactive debugger.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`模块公开了一个`set_trace`函数，当调用时，会停止执行并进入交互式调试器。'
- en: From here on, your prompt will change (to `Pdb`) and you can send commands to
    the debugger or print variable values just by writing their name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，您的提示将更改（为`Pdb`），您可以向调试器发送命令，或者只需写出变量名称即可打印变量值。
- en: 'The `pdb` debugger has many commands; the most useful ones are the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`调试器有许多命令；最有用的命令如下：'
- en: '`next`: To continue execution of code one line at a time'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：逐行执行代码'
- en: '`continue`: To continue execution of code until the next breakpoint is reached'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`：继续执行代码，直到达到下一个断点'
- en: '`list`: To print the code that is currently being executed'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`：打印当前正在执行的代码'
- en: To see a complete list of commands, you can use the `help` command, which will
    list all the available commands. And you can use the `help` command to get help
    on a specific command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的命令列表，您可以使用`help`命令，它将列出所有可用的命令。您还可以使用`help`命令获取有关特定命令的帮助。
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Since version 3.7 of Python, it is no longer required to do the odd `import
    pdb`; `pdb.set_trace()` dance. You can just write `breakpoint()` and you will
    enter `pdb`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.7版本以来，不再需要进行奇怪的`import pdb`；`pdb.set_trace()`操作。您只需编写`breakpoint()`，就会进入`pdb`。
- en: Even better, if you have more advanced debuggers configured on your system,
    you will rely on those as `breakpoint()` uses the currently configured debugger
    instead of only relying on `pdb`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，如果您的系统配置了更高级的调试器，您将依赖于这些调试器，因为`breakpoint()`使用当前配置的调试器，而不仅仅依赖于`pdb`。
- en: Testing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: To ensure that your code is correct and doesn't break on future changes, writing
    tests is usually one of the best things you can do.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的代码正确，并且不会在将来的更改中出现问题，编写测试通常是您可以做的最好的事情之一。
- en: In Python, there are a few frameworks to implement test suites that can automatically
    verify code reliability, implement different patterns such as **behavior-driver
    development** (**BDD**), or even automatically find corner cases for you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一些框架可以实现自动验证代码可靠性的测试套件，实现不同的模式，比如**行为驱动开发**（**BDD**），甚至可以自动为您找到边界情况。
- en: But simple automatic tests can be written just by relying on the standard library
    itself, so that you will need third-party testing frameworks only if you need
    specific plugins or patterns.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，只需依赖标准库本身就可以编写简单的自动测试，因此只有在需要特定插件或模式时才需要第三方测试框架。
- en: The standard library has the `unittest` module, which allows us to write tests
    for our software, run them, and report the state of the test suite.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有`unittest`模块，它允许我们为我们的软件编写测试，运行它们，并报告测试套件的状态。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the following steps are to be performed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要执行以下步骤：
- en: 'Say we have a `divide` function we want to write tests for:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个`divide`函数，我们想为它编写测试：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to create a file named `test_divide.py` (it''s important that files
    containing tests are named `test_*.py` or the tests won''t run). Within the `test_divide.py` file,
    we can put all our tests:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`test_divide.py`的文件（包含测试的文件必须命名为`test_*.py`，否则测试将无法运行）。在`test_divide.py`文件中，我们可以放置所有的测试：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, given that the `test_divide.py` module is within the same directory,
    we can run our tests with `python -m unittest`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，假设`test_divide.py`模块在同一个目录中，我们可以用`python -m unittest`来运行我们的测试：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we want to also see which tests are running, we can also provide the `-v`
    option:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还想看到哪些测试正在运行，我们也可以提供`-v`选项：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `unittest` module provides two major features:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块提供了两个主要功能：'
- en: The `unittest.TestCase` class, which provides foundations to write tests and
    fixtures
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest.TestCase`类提供了编写测试和固定的基础'
- en: The `unittest.TestLoader` class, which provides the foundation for finding and
    running multiple tests from multiple sources, in a single run; the result can
    then be provided to a runner to run them all and report their progress
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest.TestLoader`类提供了从多个来源找到并运行多个测试的基础，一次运行；然后可以将结果提供给运行器来运行它们所有并报告它们的进度。'
- en: By creating a `unittest.TestCase` class, we can gather multiple tests under
    the same set of fixtures, which are provided by the class as the `setUp` and `setUpClass`
    methods. The `setUpClass` method is performed once for the whole class, while
    the `setUp` method is performed once for every test. Tests are all the class methods
    whose name starts with `test*`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个`unittest.TestCase`类，我们可以在相同的固定集下收集多个测试，这些固定集由类作为`setUp`和`setUpClass`方法提供。`setUpClass`方法对整个类执行一次，而`setUp`方法对每个测试执行一次。测试是所有名称以`test*`开头的类方法。
- en: Once the tests have been completed, the `tearDown` and `tearDownClass` methods
    can be used to clean up the state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试完成，`tearDown`和`tearDownClass`方法可以用来清理状态。
- en: 'So our `TestDivision` class will provide a `self.num` attribute for each test
    declared within it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`TestDivision`类将为其中声明的每个测试提供一个`self.num`属性：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And then will have three tests, two of which (`test_int_division` and `test_float_division`)
    assert that the result of the division is the expected one (through `self.assertEqual`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将有三个测试，其中两个（`test_int_division`和`test_float_division`）断言除法的结果是预期的（通过`self.assertEqual`）：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the third test (`test_divide_zero`) checks that our `divide` function
    actually raises the expected exception when a `0` is provided as the divisor:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第三个测试（`test_divide_zero`）检查我们的`divide`函数在提供`0`作为除数时是否实际引发了预期的异常：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And then checks that the exception message is also the expected one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查异常消息是否也是预期的。
- en: Those tests are then saved in a file named `test_divide.py`, so that `TestLoader`
    is able to find them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这些测试保存在一个名为`test_divide.py`的文件中，以便`TestLoader`能够找到它们。
- en: When `python -m unittest` is executed, what actually happens is that `TestLoader.discover`
    is called. This looks for all modules and packages named `test*` in the local
    directory and runs all the tests declared in those modules.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`python -m unittest`时，实际发生的是调用了`TestLoader.discover`。这将查找本地目录中命名为`test*`的所有模块和包，并运行这些模块中声明的所有测试。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The standard library `unittest` module provides nearly all you need to write
    tests for your libraries or applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库`unittest`模块几乎提供了您为库或应用程序编写测试所需的一切。
- en: But if you find you need more features, such as retrying flaky tests, reporting
    in more formats, and support for driving browsers, you might want to try a testing
    framework such as `pytest`. Those usually provide a plugin infrastructure that
    permits you to expand their behavior with additional features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您发现需要更多功能，比如重试不稳定的测试、以更多格式报告和支持驱动浏览器，您可能想尝试像`pytest`这样的测试框架。这些通常提供了一个插件基础架构，允许您通过附加功能扩展它们的行为。
- en: Mocking
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mocking
- en: When testing your code, you might face the need to replace the behavior of an
    existing function or class and to track whether a function was called or not with
    the proper arguments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码时，您可能会面临替换现有函数或类的行为并跟踪函数是否被调用以及是否使用了正确的参数的需求。
- en: 'For example, say you have a function such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个如下的函数：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To test it, we don't want to go to the screen and check the output, but we still
    want to know whether the printed value was the expected one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们不想去屏幕上检查输出，但我们仍然想知道打印的值是否是预期的。
- en: So a possible approach might be to replace `print` with something that doesn't
    print anything, but allows us to track the provided argument (which is the value
    that would be printed).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个可能的方法是用不打印任何东西的东西来替换`print`，但允许我们跟踪提供的参数（这是将要打印的值）。
- en: 'This is exactly the meaning of mocking: replacing an object or function in
    the code base with one that does nothing but allows us to inspect the call.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是mocking的意思：用一个什么都不做但允许我们检查调用的对象或函数替换代码库中的对象或函数。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You need to perform the following steps for this recipe:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来完成此操作：
- en: 'The `unittest` package provides a `mock` module that allows us to create `Mock`
    objects and to `patch` existing objects, so we can rely on it to replace the behavior
    of `print`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`unittest`包提供了一个`mock`模块，允许我们创建`Mock`对象和`patch`现有对象，因此我们可以依赖它来替换`print`的行为：'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we know that the mocked `print` was actually called with `2`, which is
    the value we expected, we can go even further and print all the arguments that
    it received:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们知道模拟的`print`实际上是用`2`调用的，这是我们预期的值，我们甚至可以进一步打印它接收到的所有参数：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, it's not very helpful as there was a single argument, but in cases
    where you only want to check some arguments instead of the whole call, it might
    be convenient to be able to access some of the arguments.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这并不是很有帮助，因为只有一个参数，但在只想检查部分参数而不是整个调用的情况下，能够访问其中一些参数可能会很方便。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`mock.patch` replaces, within the context, the specified object or class with
    a `Mock` instance.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`mock.patch`在上下文中用`Mock`实例替换指定的对象或类。'
- en: '`Mock` will do nothing when called, but will track their arguments and will
    allow you to check that they were called as expected.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`在被调用时不会执行任何操作，但会跟踪它们的参数，并允许您检查它们是否按预期被调用。'
- en: 'So with `mock.patch`, we replace `print` with `Mock` and we keep a reference
    to `Mock` as `mprint`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过`mock.patch`，我们用`Mock`替换`print`，并将`Mock`的引用保留为`mprint`：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This allows us to check that `print` was called with the expected arguments,
    through `Mock`, later on:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够检查`print`是否通过`Mock`以预期的参数被调用：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Mock` objects are actually not constrained to doing nothing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`对象实际上并不受限于什么都不做。'
- en: By providing the `side_effect` argument to `mock.patch`, you can have them raise
    exceptions when called. This is helpful in simulating failures in your code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`mock.patch`提供`side_effect`参数，您可以在调用时引发异常。这对于模拟代码中的故障非常有帮助。
- en: Or you can even replace their behavior with a totally different object by providing
    `new` to `mock.patch`, which is great to inject fake objects in place of the real
    implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您甚至可以通过为`mock.patch`提供`new`来将它们的行为替换为完全不同的对象，这对于在实现的位置注入伪造对象非常有用。
- en: So, generally, `unittest.mock` can be used to replace the behavior of existing
    classes and objects with anything else, from mock objects, to fake objects, to
    different implementations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常情况下，`unittest.mock`可以用来替换现有类和对象的行为，从模拟对象到伪造对象，再到不同的实现，都可以。
- en: But pay attention when using them, because if the caller had a reference to
    the original object saved aside, `mock.patch` might be unable to replace the function
    for it, as it's still constrained to the fact that Python is a reference-based
    language and if you have a reference to an object, there is no easy way for third-party
    code to hijack that reference.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在使用它们时要注意，因为如果调用者保存了对原始对象的引用，`mock.patch`可能无法为其替换函数，因为它仍然受到Python是基于引用的语言这一事实的限制，如果您有一个对象的引用，第三方代码就无法轻松地劫持该引用。
- en: So always make sure you apply `mock.patch` before using the things you are patching,
    to reduce the risk of references to the original object to be around.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请务必在使用要打补丁的对象之前应用`mock.patch`，以减少对原始对象的引用风险。
- en: Reporting errors in production
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产中报告错误
- en: One of the most important aspects of production software is being notified in
    case of errors. As we are not the user of the software itself, we can only know
    that something is wrong if the software notifies us (or when it's too late and
    users are complaining).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 生产软件中最重要的一个方面是在发生错误时得到通知。由于我们不是软件本身的用户，所以只有在软件通知我们时（或者当为时已晚并且用户在抱怨时）才能知道出了什么问题。
- en: Based on the Python standard library, we can easily build a solution that notifies
    developers in case of a crash by email.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Python标准库，我们可以轻松构建一个解决方案，以便在发生崩溃时通过电子邮件通知开发人员。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `logging` module has a way to report exceptions by email, so we can set
    up a logger and trap the exceptions to log them by email:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块有一种通过电子邮件报告异常的方法，因此我们可以设置一个记录器，并捕获异常以通过电子邮件记录它们：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once the two functions are in place, we can configure `logging` and then decorate
    our main code base entry point so that all exceptions in our code base are reported
    by email:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这两个函数就位，我们可以配置`logging`，然后装饰我们的主代码入口点，以便代码库中的所有异常都通过电子邮件报告：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `logging` module is able to send messages to any handler attached to logger,
    and has a feature to explicitly log crashes by logging an exception and its traceback
    through `.exception`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块能够向附加到记录器的任何处理程序发送消息，并且具有通过`.exception`显式记录崩溃的功能。'
- en: 'So the root of our solution to send exceptions by email is to wrap the main
    function of our code base with a decorator that traps all exceptions and invokes
    the logger:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们解决方案的根本是用装饰器包装代码库的主函数，以捕获所有异常并调用记录器：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `crashlogger.exception` method will build a message that contains our custom
    text (which reports the name of the decorated function) plus the traceback for
    the crash, and will send it to the associated handler.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`crashlogger.exception`方法将构建一个包含我们自定义文本的消息（报告装饰函数的名称）以及崩溃的回溯，并将其发送到关联的处理程序。'
- en: 'Through the `configure_crashreport` method, we provided a custom handler for
    `crashlogger`. A handler then sends the messages by email:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`configure_crashreport`方法，我们为`crashlogger`提供了自定义处理程序。然后处理程序通过电子邮件发送消息：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The additional `_configured` flag is used as a guard to prevent the handler
    from being added twice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的`_configured`标志用作保护，以防止处理程序被添加两次。
- en: 'Then we just have to invoke `configure_crashreport` to provide the credentials
    for the email service:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需调用`configure_crashreport`来提供电子邮件服务的凭据：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And all exceptions in the function will be logged in `crashlogger` and thus
    sent by email through the associated handler.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并且函数中的所有异常都将在`crashlogger`中记录，并通过关联的处理程序发送电子邮件。
- en: Benchmarking
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: When writing software, it's frequently important to ensure that some performance
    constraints are guaranteed. The standard library has most of the tools needed
    to ensure the timing and resource consumption of the functions we write.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，通常需要确保某些性能约束得到保证。标准库中有大部分我们编写的函数的时间和资源消耗的工具。
- en: 'Say we have two functions and we want to know which one is faster:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个函数，我们想知道哪一个更快：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `timeit` module provides a bunch of utilities to time a function or whole
    script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit`模块提供了一堆实用程序来计时函数或整个脚本：'
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the reported timing, we know that `function2` is twice as fast as `function1`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从报告的时间中，我们知道`function2`比`function1`快两倍。
- en: There's more...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Normally, such a function would run in a few milliseconds, but the reported
    timings are in the order of seconds.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这样的函数会在几毫秒内运行，但报告的时间是以秒为单位的。
- en: That's because, by default, `timeit.timeit` will run the benchmarked code 1
    million times to provide a result where any temporary change in speed of the execution
    won't impact the final result much.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，默认情况下，`timeit.timeit`将运行被基准测试的代码100万次，以提供一个结果，其中执行速度的任何临时变化都不会对最终结果产生太大影响。
- en: Inspection
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查
- en: Being a powerful dynamic language, Python allows us to change its runtime behavior
    based on the state of objects it's working with.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种强大的动态语言，Python允许我们根据它正在处理的对象的状态来改变其运行时行为。
- en: Inspecting the state of objects is the foundation of every dynamic language,
    and the standard library `inspect` module has most of the features needed for
    such a case.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 检查对象的状态是每种动态语言的基础，标准库`inspect`模块具有大部分这种情况所需的功能。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the following steps are to be performed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，需要执行以下步骤：
- en: 'Based on the `inspect` module, we can quickly create a helper function that
    will tell us major object properties and type for most objects:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`inspect`模块，我们可以快速创建一个辅助函数，它将告诉我们大多数对象的主要属性和类型：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, if we apply it to any object, we will get the details about its type,
    attributes, methods, and, if it''s a function, its arguments. We can even make
    a custom type:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们将其应用于任何对象，我们将获得有关其类型、属性、方法的详细信息，如果它是一个函数，还有关其参数。我们甚至可以创建一个自定义类型：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We inspect its methods:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查它的方法：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An instance of that type:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型的一个实例：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or the class itself:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者类本身：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`inspect_object` relies on `inspect.isfunction`, `inspect.ismethod`, and `inspect.isclass`
    to decide the kind of argument that was provided.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect_object`依赖于`inspect.isfunction`、`inspect.ismethod`和`inspect.isclass`来决定提供的参数的类型。'
- en: Once it's clear that the object provided fits into one of those types, it provides
    the more reasonable information for that kind of object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清楚提供的对象适合其中一种类型，它就会为该类型的对象提供更合理的信息。
- en: 'For functions and methods, it looks at the signature of the function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数和方法，它查看函数的签名：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `inspect.signature` function returns a `Signature` object that contains
    all the details about arguments accepted by the given method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect.signature`函数返回一个包含给定方法接受的所有参数详细信息的`Signature`对象。'
- en: 'When printed, those arguments are listed on screen, which is what we expected:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印时，这些参数会显示在屏幕上，这正是我们所期望的：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In case of a class, we are mostly interested in the methods that the class
    exposes. So we are going to use `inspect.getmembers` to grab all attributes of
    the class, and then `inspect.isfunction` to filter those only for functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，我们主要关注类公开的方法。因此，我们将使用`inspect.getmembers`来获取类的所有属性，然后使用`inspect.isfunction`来仅过滤函数：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second argument of `inspect.getmembers` can be any predicate that will be
    used to filter the members.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect.getmembers`的第二个参数可以是任何谓词，用于过滤成员。'
- en: In the case of objects, we want to show the attributes and methods of the object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象，我们想要显示对象的属性和方法。
- en: 'Objects usually have tens of methods that are provided by default in Python
    to support the standard operators and behaviors. Those are the so-called magic
    methods, which we usually don''t care about. So we have to only list the public
    methods and attributes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通常有数十种方法，这些方法在Python中默认提供，以支持标准操作符和行为。这些就是所谓的魔术方法，我们通常不关心。因此，我们只需要列出公共方法和属性：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we know, `inspect.getmembers` accepts a predicate to filter which members
    to return. But the predicate can only act on the member itself; it has no way
    to know its name. So we have to filter the result of `inspect.getmembers` ourselves
    with a list comprehension that removes any attribute whose name starts with a
    `dunder (__)`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`inspect.getmembers`接受一个谓词来过滤要返回的成员。但是谓词只能作用于成员本身；它无法知道它的名称。因此，我们必须使用列表推导来过滤`inspect.getmembers`的结果，删除任何名称以`dunder（__）`开头的属性。
- en: 'The results are the public attributes and methods of the provided object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是提供的对象的公共属性和方法：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We also printed the `__class__` of the object itself to provide a hint about
    what kind of object we are looking at.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印了对象本身的`__class__`，以提供关于我们正在查看的对象类型的提示。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `inspect` module has tens of functions that can be used to dive deep into
    Python objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect`模块有数十个函数，可以用来深入了解Python对象。'
- en: It can be a really powerful tool when investigating third-party code or when
    implementing heavily dynamic code that has to cope with objects of unknown shape
    and type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查第三方代码或实现必须处理未知形状和类型的对象的高度动态代码时，它可以是一个非常强大的工具。
- en: Code evaluation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码评估
- en: Python is an interpreted language, and the interpreter features are exposed
    in the standard library too.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种解释性语言，解释器的功能也暴露在标准库中。
- en: This means that we can evaluate expressions and statements coming from files
    or text sources and have them run as Python code within Python code itself.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以评估来自文件或文本源的表达式和语句，并让它们作为Python代码在Python代码本身中运行。
- en: It's also possible to evaluate code in a fairly safe way that allows us to create
    objects from expressions but prevents the execution of any function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以以相当安全的方式评估代码，允许我们从表达式中创建对象，但阻止执行任何函数。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的步骤如下：
- en: 'The `eval`, `exec`, and `ast` functions and modules provide most of the machinery
    needed for execution of code from strings:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`eval`、`exec` 和 `ast` 函数和模块提供了执行字符串代码所需的大部分机制：'
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `run_python` function in `evalsafe` mode allows us to run basic Python
    expressions in a safe way. This means that we can create Python objects from their
    literal representation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`evalsafe` 模式中的 `run_python` 函数允许我们以安全的方式运行基本的 Python 表达式。这意味着我们可以根据它们的文字表示创建
    Python 对象：'
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can''t run functions or perform more advanced commands such as indexing:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能运行函数或执行更高级的命令，比如索引：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we want to run those, we need to `eval` in a non-safe manner:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要运行这些，我们需要以不安全的方式 `eval`：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is discouraged, because it allows execution of malicious code in the current
    interpreter session. But even if it allows more widespread execution, it still doesn''t
    allow more complex statements such as definition of functions:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是不鼓励的，因为它允许在当前解释器会话中执行恶意代码。但即使它允许更广泛的执行，它仍然不允许更复杂的语句，比如函数的定义：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To allow full Python support, we need to use the `exec` mode, which will allow
    execution of all Python code, but won''t give us back the result of the expression
    anymore (as the provided code might not be an expression at all):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许完整的 Python 支持，我们需要使用 `exec` 模式，这将允许执行所有 Python 代码，但不再返回表达式的结果（因为提供的代码可能根本不是表达式）：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tracing code
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪代码
- en: The `trace` module provides a powerful and easy tool to trace which lines of
    code were executed during a run.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace` 模块提供了一个强大且易于使用的工具，可以跟踪运行过程中执行了哪些代码行。'
- en: Tracing can be used both to ensure testing coverage and to see the behavior
    of our software or third-party function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪可以用于确保测试覆盖率，并查看我们的软件或第三方函数的行为。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps for this recipe:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来完成此教程：
- en: 'We can implement a function that traces the execution of a provided function
    and returns the modules that were executed and the lines for each module:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以实现一个函数，跟踪提供的函数的执行并返回执行的模块以及每个模块的行：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, once we have the tracing, we need to actually print it so that it''s
    human-readable. To do that, we are going to read the source code for each traced
    module and print it with a `+` marker that is going to signal whether a line was
    executed or not:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一旦我们有了跟踪，我们需要实际打印它，以便人类能够阅读。为此，我们将阅读每个被跟踪模块的源代码，并使用 `+` 标记打印它，该标记将指示哪些行被执行或未执行：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Given any function, we can see which lines of code are being executed in various
    conditions:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定任何函数，我们都可以看到在各种条件下执行的代码行：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, we can print the tracing for the function with `should_print=False`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 `should_print=False` 打印函数的跟踪：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we can check what happens with `should_print=True`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以检查 `should_print=True` 时会发生什么：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can see that line `0005` is now marked with the `+` sign as it was executed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到行 `0005` 现在标记为 `+`，因为它被执行了。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `report_tracing` function is the one actually in charge of tracing the execution
    of another function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`report_tracing` 函数实际上负责跟踪另一个函数的执行。'
- en: 'First of all, as the execution is per module, it creates `defaultdict`, where
    the tracing can be stored. The key will be the module, and the value will be a
    list containing information for each line of that module:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于执行是按模块进行的，它创建了 `defaultdict`，用于存储跟踪。键将是模块，值将是包含该模块每行信息的列表：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, it creates the actual tracing machinery. The `trace=False` option is
    especially important to avoid the tracing being printed on screen. Right now,
    we want to save it aside, not print it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它创建了实际的跟踪机制。`trace=False` 选项特别重要，以避免在屏幕上打印跟踪。现在，我们希望将其保存在一边，而不是打印出来。
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once the tracer is available, we can use it to run the provided function with
    any given argument:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦跟踪器可用，我们就可以使用它来运行提供的函数并提供任何给定的参数：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result of the tracing is saved into the tracer itself, so we can access
    it with `tracing.results()`. What we are interested in is whether a line of code
    was executed at least once, so we are going to look for the counts, and add each
    line of code that was executed to the set of executed lines of code for the given
    module:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的结果保存在跟踪器本身中，因此我们可以使用 `tracing.results()` 访问它。我们感兴趣的是代码行是否至少执行了一次，因此我们将寻找计数，并将每个执行的代码行添加到给定模块的执行代码行集合中：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The resultant `traced` dictionary contains all the lines of code that were actually
    executed for a given module. It doesn't, by the way, contain any detail about
    those that were not executed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`traced` 字典包含了给定模块实际执行的所有代码行。顺便说一句，它不包含任何关于未执行的代码行的详细信息。'
- en: So far, we only have the line number, and no other detail about the executed
    lines of code. We, of course, also want the line of code itself, and we want to
    have all lines of code, not just the executed ones, so we can print back the source
    code with no gaps.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有行号，没有关于执行的代码行的其他细节。当然，我们也希望有代码行本身，并且希望有所有代码行，而不仅仅是执行的代码行，这样我们就可以打印出没有间隙的源代码。
- en: 'That''s why `report_tracing` then opens the source code for each executed module
    and reads its content. For each line, it checks whether it''s in the set of the
    executed ones for that module and stores aside a tuple containing the line number,
    a Boolean value that states whether it was executed or not, and the line content
    itself:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 `report_tracing` 打开每个执行模块的源代码并读取其内容。对于每一行，它检查它是否在该模块的执行集合中，并存储一对元组，其中包含行号、一个布尔值，指示它是否被执行，以及行内容本身：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, the resultant dictionary contains all modules that were executed,
    with their source code, annotated with details about the line number and whether
    it was executed or not:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果字典包含了所有被执行的模块，以及它们的源代码，注释了关于行号和是否执行的详细信息：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`print_traced_execution` is then far easier: its only purpose is to take the
    data we gathered and print it on screen, so that a human being can see the source
    code and what was executed.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_traced_execution`则更容易：它的唯一目的是获取我们收集的数据并将其打印到屏幕上，以便人类可以看到源代码和执行的内容。'
- en: 'The function iterates on every traced module and prints the `filename` module:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数会迭代每个被跟踪的模块并打印`filename`模块：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, for each module, it iterates over the tracing details and prints the
    line number (as a four-digit number, so that code is indented properly for any
    line number up to 9999), a `+` sign if the line was executed, and the line content
    itself:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个模块，它会迭代跟踪详细信息并打印行号（作为四位数，以便对任何行号最多到9999进行正确缩进），如果执行了该行，则打印一个`+`号，以及行内容本身：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using tracing, you can easily check whether the code you wrote was executed
    or not by your tests. You just have to limit the tracing to the modules you wrote
    and you are interested in.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用跟踪，您可以轻松地检查您编写的代码是否被测试执行。您只需将跟踪限制在您编写并感兴趣的模块上即可。
- en: There are third-party modules that specialize in coverage reporting of tests;
    the most widespread one is probably the `coverage` module twhich has support for
    the most common testing frameworks, such as `pytest` and `nose`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些第三方模块专门用于测试覆盖率报告；最广泛使用的可能是`coverage`模块，它支持最常见的测试框架，如`pytest`和`nose`。
- en: Profiling
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: When you need to speed up your code or understand where a bottleneck is, profiling
    is one of the most effective techniques.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要加快代码速度或了解瓶颈所在时，性能分析是最有效的技术之一。
- en: The Python standard library provides a built-in profiler that traces the execution
    and timing for each function and allows you to spot the functions that are more
    expensive or that run too many times, consuming most of the execution time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了一个内置的分析器，用于跟踪每个函数的执行和时间，并允许您找出更昂贵或运行次数过多的函数，消耗了大部分执行时间。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the following steps are to be performed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，需要执行以下步骤：
- en: 'We can take any function we want to profile (which can even be the main entry
    point of the program):'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以选择任何要进行性能分析的函数（甚至可以是程序的主入口点）：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can profile it using the `cProfile` module:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`cProfile`模块对其进行性能分析。
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That will print the timing for the function and the slowest functions called
    by the profiled one:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打印函数的时间以及分析函数调用的最慢函数：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `cProfile.Profile` object is able to run any function with provided arguments
    and gather execution statistics with a minor overload.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile.Profile`对象能够使用少量负载运行任何函数并收集执行统计信息。'
- en: 'The `runcall` function is the one that actually runs the function providing
    the passed arguments (in this case, `True` is provided as the first function argument,
    which means `goslow=True`):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`runcall`函数是实际运行函数并提供传递的参数的函数（在本例中，`True`作为第一个函数参数提供，这意味着`goslow=True`）：'
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once the profiling data is gathered, we can print it on screen to provide details
    about what was executed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集到了性能分析数据，我们可以将其打印到屏幕上，以提供关于执行的详细信息：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The printed output includes the list of functions executed during the call,
    the total time it took for each of those functions, the time each function took
    on each call, and the total number of calls:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出包括在调用期间执行的函数列表，每个函数所花费的总时间，每个调用中每个函数所花费的时间，以及调用的总次数：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can see that the major bottleneck of `slowfunc` was the `time.sleep` call:
    it took `1.181` out of the total `1.183` time it took to run whole `slowfunc`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`slowfunc`的主要瓶颈是`time.sleep`调用：它占用了总共`1.183`时间中的`1.181`。
- en: 'We can try to call `slowfunc` with `goslow=False` and see how the timing changes:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用`goslow=False`调用`slowfunc`，并查看时间的变化：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And, in this case, we see that the whole function runs in `0.000` instead of
    `1.183` and there is no more reference to `time.sleep`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，在这种情况下，我们看到整个函数运行时间为`0.000`而不是`1.183`，并且不再提到`time.sleep`：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
