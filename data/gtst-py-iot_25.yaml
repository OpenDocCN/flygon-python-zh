- en: Recognizing Humans with Jarvis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用贾维斯识别人类
- en: By now  we have understood in the last chapter how multiple layers of conditions
    can be clubbed together to get the functionality that is desired. We have just
    completed the first step in making Jarvis work for you. Now, it's time to make
    it even more capable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在上一章中了解到如何将多层条件组合在一起以获得所需的功能。我们刚刚完成了让贾维斯为您工作的第一步。现在，是时候让它变得更加强大了。
- en: In this chapter, we will make it control more electronics at your home, which
    can be controlled autonomously without you telling anything to the system. So
    without delay, let's get straight into it and see what we have in our bucket.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使其控制更多您家中的电子设备，这些设备可以在您没有告诉系统任何内容的情况下自主控制。所以，不要拖延，让我们直接进入并看看我们的收获。
- en: Turn on the light Jarvis
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开灯，贾维斯
- en: One of the basic functionalities of a smart home is to turn on the lights for
    you whenever you are around. It is one of the most basic things that any system
    can do for you. We will start off by turning on the light as soon as you come
    inside the room, thereafter, we will make the system more and more intelligent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居的基本功能之一是在您附近时为您打开灯光。这是任何系统可以为您做的最基本的事情之一。我们将从您进入房间时打开灯光开始，然后我们将使系统变得更加智能。
- en: So, the first thing we need to do is recognize whether you are in a room or
    not. There are multiple ways to do that. One important characteristic of life
    is the presence of movement. You may say plants don't move, well they do; they
    grow, don't they? So detecting movement can be a key step in detecting whether
    someone is there or not!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做的第一件事是识别您是否在房间里。有多种方法可以做到这一点。生活的一个重要特征就是运动的存在。您可能会说植物不会移动，但它们会生长，不是吗？因此，检测运动可能是检测某人是否在场的关键步骤！
- en: 'This step will not be so difficult for you, as we have already interfaced this
    sensor previously. We are talking about the good old PIR sensor. So the sensor
    will sense any movement in the area. If there is any movement, then Jarvis will
    switch on the lights. I am sure this is something you can do by yourself by now.
    You can still refer to the code and the circuit diagram here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步对您来说并不那么困难，因为我们之前已经接口化了这个传感器。我们说的是老式的PIR传感器。因此，传感器将感知区域内的任何运动。如果有任何运动，那么贾维斯将打开灯光。我相信这是您现在可以自己做到的事情。您仍然可以参考这里的代码和电路图：
- en: '![](Images/d18f3ec7-4d2a-452c-bf98-a522f1c87325.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d18f3ec7-4d2a-452c-bf98-a522f1c87325.png)'
- en: 'Now upload the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上传以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we are simply turning on the light as soon as the motion
    is detected, but the problem is that it will only switch on the light for the
    time the motion is there. What does that mean? Simple, while there is some movement,
    will keep the lights on and as soon as the movement stops, it will switch off
    the light.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们只是在检测到运动时立即打开灯光，但问题是它只会在有运动的时候打开灯光。这是什么意思？简单来说，只要有一些运动，灯就会保持开启，一旦运动停止，灯就会关闭。
- en: 'This can be a very good code for a person who wants to lose weight, but for
    most of us, it will be annoying. So, let''s include a small loop, which we have
    used in the previous chapter and make this a little better:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要减肥的人来说，这可能是一个很好的代码，但对于我们大多数人来说，这将是令人讨厌的。因此，让我们包含一个小循环，我们在上一章中使用过，并使其变得更好一些：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, in this program, all we have done is we have added a `for` loop, which switches
    on the light for a set amount of time. How long that time will be can be toggled
    by changing the value of the variable `TIME`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们所做的就是添加了一个`for`循环，它会在设定的时间内打开灯光。这段时间有多长可以通过改变变量`TIME`的值来切换。
- en: 'There is one more interesting part in that loop which is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个循环中还有一个有趣的部分，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Why did we do this you might wonder? Whenever the light will be switched on,
    it will remain on for 5 minutes. Then, it will switch off and wait for movement
    to occur. So, essentially, the problem with this code will be that if you are
    in the room and the light switches on, then for 5 minutes it will see if there
    is any motion detected or not. There is a chance that you will be in motion when
    it searches for the motion after 5 minutes. But for most of the time, it won't
    be the case. So we are detecting the movement using the PIR sensor. Whenever movement
    is detected, the value of `M_final` is incremented using the line `M_final = M_final
    + 1`, thereby increasing the time until which the light will be switched on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们要这样做？每当灯光被打开时，它将保持开启5分钟。然后，它将关闭并等待运动发生。因此，基本上，这段代码的问题是，如果您在房间里，灯光打开后，它将在5分钟内查看是否有运动被检测到。有可能在5分钟后寻找运动时您正在运动。但大多数情况下，这不会发生。因此，我们使用PIR传感器来检测运动。每当检测到运动时，通过`M_final
    = M_final + 1`这一行来增加`M_final`的值，从而延长灯光打开的时间。
- en: Understanding motion
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运动
- en: By now you must have figured that the PIR sensor is not the most idealistic
    sensor for us to switch the lights on or off. Mostly because, although the motion
    is one of the best indicators of presence, there can be times when you might not
    move at all, for example, while resting, reading a book, watching a movie, and
    so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一定已经意识到PIR传感器并不是我们打开或关闭灯光的最理想传感器。主要是因为，尽管运动是存在的最佳指标之一，但有时您可能根本不会移动，例如休息、阅读书籍、观看电影等。
- en: What do we do now? Well, we can do a little trick. Remember in the last chapter
    we used our proximity sensor to sense whether a person has crossed a specific
    area or not? We will implant a similar logic here; but rather than just copy pasting
    the code, we will improve it and make it even better.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们该怎么办？嗯，我们可以做一个小技巧。还记得在上一章中我们使用我们的接近传感器来感知一个人是否穿过了特定区域吗？我们将在这里植入类似的逻辑；但不只是简单地复制粘贴代码，我们将改进它，使其变得更好。
- en: 'So rather than using one single IR proximity sensor, we will be using two of
    these things. The mounting will be as shown in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用两个红外接近传感器，而不是使用一个。安装如下图所示：
- en: '![](Images/ec73b93a-776b-4d21-b548-77a79d33417a.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ec73b93a-776b-4d21-b548-77a79d33417a.png)'
- en: Now it is very evident that whenever a person walks in from the door side to
    the room side the **Sensor 1** will show a lower reading when detecting a body.
    Then, while he is walking towards the room side, **Sensor 2** will show a similar
    reading.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，每当有人从门边走进房间边时，**传感器1**在检测到人体时会显示较低的读数。然后，当他朝房间一侧走去时，**传感器2**将显示类似的读数。
- en: If first **Sensor 1** is triggered and thereafter **Sensor 2** is triggered,
    then we can safely assume that the person is travelling from the door side to
    the room side. Similarly, if the opposite is happening, then it is understood
    that the person is walking out of the room.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果首先触发**传感器1**，然后触发**传感器2**，那么我们可以安全地假设这个人是从门边走向房间边。同样，如果相反发生，那么可以理解这个人是从房间里走出去。
- en: 'Now, this is fairly simple. But how do we implement it in a real-life situation?
    Firstly, we need to connect the circuit as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这相当简单。但是我们如何在现实生活中实现它呢？首先，我们需要按以下方式连接电路：
- en: '![](Images/f26bc00c-738b-49c4-b2d2-9ab5ea6176f3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f26bc00c-738b-49c4-b2d2-9ab5ea6176f3.png)'
- en: 'Once that is done, upload the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，上传以下代码：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's see what are we doing here. As always, most of the syntax is very
    simple and straightforward. The most important part is the logic. So, let's understand
    in proper steps as to what we are doing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在这里做了什么。和往常一样，大部分语法都非常简单明了。最重要的部分是逻辑。因此，让我们逐步了解我们在做什么。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding lines of code, we are taking the value of the IR proximity
    sensor and calculating the distance corresponding to it and storing that value
    in a variable called `F1`. Once that is done, we are stopping for a brief period
    of `0.1` seconds using the `time.sleep(0.1)` function. Thereafter, we are taking
    the reading from the same sensor again and storing the value in a variable called
    `F2`. Why are we doing this? We have already understood that in the previous chapters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码行中，我们正在获取红外接近传感器的值，并计算相应的距离，将该值存储在一个名为`F1`的变量中。一旦完成，我们将使用`time.sleep(0.1)`函数停止0.1秒。然后，我们再次从同一传感器读取并将值存储在名为`F2`的变量中。为什么我们要这样做？我们在之前的章节中已经理解了。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the value of `F1` and `F0` is acquired, we will calculate the difference
    to find out whether someone has passed through it or not. If no one has passed,
    then the reading will almost be the same and the difference will not be considerable.
    However, if a person does pass, then the reading will be considerable and that
    value will be stored in a variable called `F0_final`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了`F1`和`F0`的值，我们将计算差值以找出是否有人通过。如果没有人通过，那么读数几乎相同，差异不会很大。但是，如果有人通过，那么读数将是相当大的，并且该值将存储在一个名为`F0_final`的变量中。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the value of the `F0` or the difference in distance between the first and
    the second reading is more than 10 centimeters, then the `if` condition will be
    true. Once true, it will set the value of the `Time0` variable as the current
    value of time. The `time.time()` function will make a note of the exact time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`F0`的值或第一次和第二次读数之间的距离差大于10厘米，则`if`条件将为真。一旦为真，它将将`Time0`变量的值设置为当前时间值。`time.time()`函数将记录下确切的时间。
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we'll perform the exact same step for **Sensor 2** as well. There is nothing
    new to tell here; it's all self explanatory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对**传感器2**执行完全相同的步骤。这里没有什么新的要告诉的；一切都很简单明了。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once all of this is done, we compare `if Time1 > Time0`. Why are we comparing
    it? Because `Time0` is the time noted for **Sensor 1**. If the person is moving
    inside, then **Sensor 1** would be the first one to be triggered and then the
    **Sensor 2** would be triggered. Hence, the time noted would be greater for **Sensor
    2** and relatively earlier for **Sensor 1**. If that happens, then we can assume
    that the person is coming inside. Well, if a person is coming inside, then we
    simply need to switch the light on, which is exactly what we are doing here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些都完成了，我们比较`Time1 > Time0`。为什么我们要比较呢？因为`Time0`是**传感器1**的记录时间。如果人在里面移动，那么**传感器1**将首先被触发，然后**传感器2**将被触发。因此，**传感器2**的记录时间会更长，相对于**传感器1**来说更早。如果发生这种情况，那么我们可以假设人正在进来。如果有人进来，我们只需要打开灯，这正是我们在这里要做的。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similarly, when a person is going out, the first sensor to be triggered would
    be **Sensor 2**, thereafter **Sensor 1** will be triggered. Making the time noted
    for `Time1` earlier than `Time2`; hence, whenever this condition is true, we will
    know that the person is moving out of the room and the lights can be switched
    off.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当一个人走出去时，首先触发的传感器将是**传感器2**，然后将触发**传感器1**。使得记录在`Time1`中的时间比`Time2`更早；因此，每当这个条件为真时，我们就会知道这个人正在离开房间，灯可以关闭。
- en: Go ahead and mount it near the door and see how it reacts. I'm sure this will
    be way better than what we had done through PIR. Have fun with it and try to find
    any flaws that it might have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继续安装在门附近，看看它的反应。我相信这将比我们之前通过PIR做的要好得多。玩得开心，并尝试找出它可能存在的任何缺陷。
- en: Perfecting motion
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善运动
- en: Were you able to find any flaws in the previous code? They are not hard to find;
    the code works brilliantly when it's only a single person in the room. If this
    is installed somewhere where multiple people are coming and going, then it might
    be challenging. This is because whenever a person moves outside, the light will
    be turned off.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在以前的代码中找到任何缺陷吗？它们并不难找到；当房间里只有一个人时，代码运行得很好。但是如果安装在有多人出入的地方，可能会有挑战。这是因为每当有人走出去时，灯就会熄灭。
- en: 'So now that the problem is evident, it''s time to make the code even more better.
    To do this, the hardware will remain exactly the same; we simply need to make
    the code smarter. Let''s see how we can do that:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题显而易见，是时候让代码变得更加智能了。为了做到这一点，硬件将保持完全相同；我们只需要让代码更加智能。让我们看看我们可以如何做到：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What we have done is something really basic. We have declared a variable called `PCount`.
    This variable is declared to count the number of people who are there inside a
    room or a home. As you can see in the first few lines of the code, we have declared
    the value of `PCount` as `0`. We are assuming that once we start this, the number
    of people inside would be `0`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是非常基础的。我们声明了一个名为`PCount`的变量。这个变量被声明为计算房间或家里的人数。正如你在代码的前几行中所看到的，我们声明了`PCount`的值为`0`。我们假设一旦我们开始，房间内的人数将为`0`。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Whenever the condition `if Time1 > Time0:` is satisfied, the `PCount` value
    is incremented by `1`. As we all know, the condition will only be true when a
    person is walking inside the home.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每当条件`if Time1 > Time0:`满足时，`PCount`的值就会增加`1`。众所周知，只有当有人在房子里走动时，条件才会成立。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similarly, when a person is walking outside, the condition `if Time1 < Time0:`
    is true; whenever that happens, the value of `PCount` is decremented by `1`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当一个人在外面走的时候，条件`if Time1 < Time0:`是真的；每当这种情况发生时，`PCount`的值就会减少`1`。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have started counting the number of people in the room, we are now
    applying the condition, which will turn on if the number of `PCount` is more than
    `0`. Hence, the light will be on for the time when the number of people inside
    the home is more than `0`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始计算房间内的人数，我们现在应用条件，如果`PCount`的数量大于`0`，则会打开。因此，当房屋内的人数大于`0`时，灯将亮起。
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In a very similar fashion, the lights will be turned off if the value of `PCount`
    or the number of people inside the home gets to `0`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以非常相似的方式，如果`PCount`的值或者房屋内的人数达到`0`，灯将被关闭。
- en: Hence, nailed!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完美！
- en: Controlling the intensity
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制强度
- en: We have controlled a lot of light now. It's time that we control our fans and
    other air circulation systems. Whenever we talk about fans or any other air circulation
    devices, then essentially we are talking about motors. As we have learned earlier,
    motors are simple devices, which can be controlled every easily using a motor
    driver. But as you know, back then we were controlling DC motors. DC motors are
    extremely simple devices. But when we talk about our household appliances, then
    most of these devices will be working on AC or alternating current. I am assuming
    that you must be aware of what that is and how it is different from DC.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经控制了很多灯。现在是时候控制我们的风扇和其他空气循环系统了。每当我们谈论风扇或任何其他空气循环设备时，本质上我们在谈论电机。正如我们之前学到的，电机是简单的设备，可以使用电机驱动器非常容易地进行控制。但是你知道，当时我们控制的是直流电机。直流电机是非常简单的设备。但是当我们谈论我们的家用电器时，那么大多数这些设备将使用交流电或交流电流。我假设你一定知道那是什么，以及它与直流电的区别。
- en: Now that you know that the motors used in our households are working on AC,
    you must also think about the fact that their control mechanism will be much different
    to DC motors. You are right, if you thought so. However, the good thing about
    electronics is, nothing is really difficult or complicated. The basics are pretty
    much the same. So, let's see how we can control the speed of the motors in AC
    supply.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道我们家用的电机是交流电机，你也必须考虑到他们的控制机制将与直流电机大不相同。如果你这样想，你是对的。然而，电子产品的好处是，没有什么真的困难或复杂。基本原理基本上是一样的。所以，让我们看看如何在交流电源中控制电机的速度。
- en: 'As we have seen earlier, we can simply have a PWM signal given to the DC motor
    and the motor will run at the speed of the average voltage as a result of the
    PWM signal. Now, you must be thinking that this can be applied to AC as well.
    The thing is, yes it can be done if you want to control a light or similar devices,
    which do not have any major change in the characteristics in case the wave form
    is distorted. However, when we are talking about any other component, then we
    come across a big problem. The AC wave form looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们可以简单地给直流电机一个PWM信号，电机将以PWM信号的平均电压速度运行。现在，你一定在想，这也可以应用于交流。事实是，是的，如果你想控制灯或类似设备，这是可以做到的，这些设备在波形失真的情况下没有任何主要特性变化。然而，当我们谈论其他组件时，我们遇到了一个大问题。交流波形看起来像这样：
- en: '![](Images/e6c88285-4f38-493f-8a73-ab5d0a621507.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e6c88285-4f38-493f-8a73-ab5d0a621507.png)'
- en: This basically means that the potential is changing periodically. In most of
    the households, this is 50 times per second. Now, imagine if we have a PWM-controlled
    device that is switching the circuit that only lets the power supply to pass at
    certain intervals. Then, the different parts of the sinusoidal waves would be
    passed on to the final output.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着电位定期变化。在大多数家庭中，这是每秒50次。现在，想象一下，如果我们有一个PWM控制的设备，它在特定间隔开关电路，只允许电源通过。然后，正弦波的不同部分将传递到最终输出。
- en: '![](Images/d3c74564-5890-4819-8bd8-c37da64c8c2c.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d3c74564-5890-4819-8bd8-c37da64c8c2c.png)'
- en: As you can see in the preceding PWM, fortunately the PWM signal has matched
    with the phase of the AC power; however, due to this, only the positive end of
    the phase is being transferred to the final output and not the negative end. This
    will cause a severe problem to our load and there is a very good chance that the
    appliance that is connected will not work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的PWM中所看到的，幸运的是PWM信号与交流电源的相位匹配；然而，由于这个原因，只有相位的正端被传输到最终输出，而不是负端。这将给我们的负载造成严重问题，有很大的机会连接的设备将无法工作。
- en: '![](Images/3d28446a-d7a4-4893-85e7-87dfa8a9a994.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3d28446a-d7a4-4893-85e7-87dfa8a9a994.png)'
- en: We have another example in which the PWM is random and it lets random parts
    of the wave pass by. In this, we can clearly see that randomly any part of the
    wave is being transferred and the positive and negative end voltage is not in
    sync, which again will be a huge problem. Hence, instead of using PWM, we use
    something really interesting.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个例子，其中PWM是随机的，它让波的随机部分通过。在这种情况下，我们可以清楚地看到随机地传输波的任何部分，正负端电压不同步，这将是一个巨大的问题。因此，我们不使用PWM，而是使用一些非常有趣的东西。
- en: 'The method that is most commonly used is called **phase fired control**. Sometimes
    it is also called phase angle control or phase cutting. What it essentially does
    is, it cuts the wave at certain parts of the phase letting the rest of the wave
    cross by. Confused? Let me show you here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的方法称为**相位触发控制**。有时也称为相角控制或相位切割。它的本质是在相位的某些部分切割波，让其余的波通过。困惑吗？让我在这里给你展示：
- en: '![](Images/047edc17-d0c2-4d67-9659-cf416b3bb5af.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/047edc17-d0c2-4d67-9659-cf416b3bb5af.png)'
- en: 'Now, as you can see the phase behind the second half of the AC wave is getting
    chopped and is not getting passed in the final output. This makes the final output
    to be only 50% of the overall input. What this technique does is, it maintains
    the AC nature of the power supply while still being able to reduce the overall
    resulting voltage. Likewise, as you can see in the next diagram, the wave is getting
    chopped after 75% of the wave has already passed. This results in the output being
    relatively lower:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所看到的，交流波的后半部分的相位被切割了，没有传递到最终输出。这使得最终输出只有总输入的50%。这种技术的作用是，在减小总体输出电压的同时，保持电源的交流特性。同样，如下图所示，波在已经传递了75%后被切割。这导致输出相对较低：
- en: '![](Images/3b77b2b6-78b7-4683-b2c7-eea349d43a3c.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b77b2b6-78b7-4683-b2c7-eea349d43a3c.png)'
- en: Now you must be asking, how did we actually go ahead and do this? It is done
    by a relatively complex circuit that detects the phase angle of the wave and then
    opens or controls a triac, which is a high power bi-directional semiconductor.
    This leads the power supply to pass or to be stopped at certain phases. We will
    leave the exact working of this circuit for the next time as it is fairly complex
    and will not be relevant to this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问，我们到底是如何做到这一点的？这是通过一个相对复杂的电路来完成的，它检测波的相位角，然后打开或控制一个双向高功率半导体晶闸管。这导致电源在某些相位通过或停止。我们将把这个电路的确切工作留到下一次，因为它相当复杂，与本书无关。
- en: Now coming to the basic point, we know what phase cutting is, we also know that
    triac is the basic device that lets us do that. But how do we go ahead and do
    it using Raspberry Pi is the question.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来到基本点，我们知道相位切割是什么，我们也知道晶闸管是让我们做到这一点的基本设备。但如何使用树莓派来实现这一点是个问题。
- en: So firstly, we will need an AC-dimmer module. This module already has all the
    components of phase detection and chopping. So all we need to do is simply control
    it using simple PWM.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个交流调光模块。这个模块已经具备了相位检测和切割的所有组件。所以我们需要做的就是简单地使用PWM来控制它。
- en: 'Though I might not have to demonstrate how to connect the circuit or what the
    code should be, for the sake of understanding, let''s connect a light bulb to
    our Arduino using this module and then control the bulb. Now, the first thing
    to remember is that the load should be a bulb and not anything else such as an
    LED light. So go ahead and connect the circuit as shown in the following figure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我可能不需要演示如何连接电路或代码应该是什么，但为了理解起见，让我们使用这个模块将灯泡连接到我们的Arduino，然后控制灯泡。现在，首先要记住的是负载应该是灯泡，而不是其他任何东西，比如LED灯。所以继续按照下图所示连接电路：
- en: '![](Images/26e340ef-6b20-41d1-9951-8d8bd3b1850c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26e340ef-6b20-41d1-9951-8d8bd3b1850c.png)'
- en: 'Once this is done, go ahead and upload the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，上传以下代码：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As expected, the attached light will start to glow very faintly first and will
    increase the intensity gradually until it reaches 100%. That is how simple it
    is to control such a complex process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，连接的灯将首先微弱发光，然后逐渐增加强度，直到达到100%。控制这样一个复杂的过程是如此简单。
- en: Intelligent temperature control
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能温度控制
- en: Now that the basics are done, let's go ahead and build something meaningful
    using this system. Isn't it difficult to set your air-conditioner to the perfect temperature?
    No matter what you do, you end up feeling not in the most comfortable spot. This
    happens due to physiological changes in the body temperature over the course of
    the day.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础知识已经掌握，让我们继续使用这个系统构建有意义的东西。将空调设置到完美的温度是不是很困难？无论你做什么，最终都感觉不是最舒适的位置。这是由于身体在一天中温度的生理变化所致。
- en: When you wake up, your body temperature is relatively low. It is as much as
    1° F, which is lower than the normal body temperature. As the day progresses,
    the body temperature rises until the time you hit the bed. Once you sleep, again
    your body temperature starts to dip reaching its lowest point around 4:00-6:00
    am in the morning. That's the reason why what might feel warm while you go to
    bed, can be pretty cold when you wake up. Modern air-conditioners have something
    called a sleep mode. What this does is, it simply increases the temperature through
    the night. So that you do not feel cold at any point. But then again, how well
    it works is also a question.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你醒来时，你的体温相对较低。它比正常体温低多达1°F。随着一天的进展，体温会上升，直到你上床睡觉。一旦你入睡，你的体温又开始下降，直到早上4:00-6:00达到最低点。这就是为什么当你上床睡觉时感觉温暖，但醒来时可能会感觉很冷的原因。现代空调有一个叫做睡眠模式的功能。它的作用是通过整个夜晚逐渐提高温度，这样你在任何时候都不会感到寒冷。但它的工作效果如何也是一个问题。
- en: So, now that we know the robotics very well, we will go ahead and make a system
    of our own that will take care of everything.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对机器人技术非常了解，我们将继续制作一个系统，来照顾一切。
- en: 'In this part, we will connect both the air-conditioner and your fan together
    so that they can both work in tandem and make you sleep well. Now, before jumping
    straight into it, I would like you to see the ratings that are mentioned on the
    relay. As you can see, the relay can handle only 250V and 5 ampere. Now, if you
    go through the brochure of your air-conditioner, you will easily understand why
    I am showing all of this to you. The power consumption of the air-conditioner
    will be much higher than what your relays can handle. So, if you try to run your
    air conditioner using the normal relays, then you will surely end up blowing the
    relay. There might be a chance that your appliance will be of a lower current
    rating than your relay. But with any device that has motors in it just keep in
    mind that the initial power consumption of that device is much higher than the
    nominal power consumption. Hence, if your air-conditioner needs 10 ampere nominal,
    then the starting load may be as much as 15 ampere. You must be thinking, it''s
    not a problem, why don''t we just purchase a relay that has a higher rating. Well,
    correct! That''s exactly what we will be doing. But the naming of electronics
    can be tricky at times. The devices that deal with a higher-power higher-voltage
    electro-mechanical switching is generally called contractor instead of relay.
    Technically, they have the same working principal; However, there are construction
    differences, which at this point would not be our concern. So we will be using
    a contractor for the air conditioner switching and a dimmer for the fan speed
    control. Now that this has been cleared up, let''s go ahead and attach the hardware
    as shown in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将空调和风扇连接在一起，这样它们可以一起工作，让你睡得更好。现在，在直接开始之前，我想让你看一下继电器上标明的额定值。正如你所看到的，继电器只能处理250V和5安培。现在，如果你查看空调的宣传册，你很容易就能明白我为什么要向你展示所有这些。空调的功耗将远远高于你的继电器所能承受的。因此，如果你尝试使用普通继电器来运行空调，那么你肯定会把继电器烧坏。你的电器可能的电流等级低于你的继电器。但是对于任何带有电机的设备，要记住该设备的初始功耗远高于额定功耗。因此，如果你的空调需要额定10安培，那么起动负载可能高达15安培。你可能会想，这不是问题，为什么我们不购买一个额定更高的继电器呢。好吧，正确！这正是我们将要做的。但是，电子设备的命名有时可能会很棘手。处理更高功率更高电压的电机开关设备通常被称为接触器，而不是继电器。从技术上讲，它们有相同的工作原理；然而，在这一点上的构造差异，这不是我们关心的问题。因此，我们将使用接触器来控制空调开关和调速器来控制风扇速度。既然这一点已经澄清，让我们继续并按照以下图表连接硬件：
- en: '![](Images/44f748e3-7a93-46e6-afa7-765a6447d0ad.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/44f748e3-7a93-46e6-afa7-765a6447d0ad.png)'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The logic used here is pretty basic. Let''s see what it is doing:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的逻辑非常基本。让我们看看它在做什么：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we are taking the value of `humidity` and `temperature`. So far so good,
    but can we take it a step further and make it even more intelligent? The previous
    logic must have helped you sleep better, but can we make it just perfect for you?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取了`湿度`和`温度`的值。到目前为止一切都很好，但我们能否更进一步，使它变得更智能？以前的逻辑可能已经帮助你睡得更好，但我们能否让它对你来说更加完美？
- en: There are multiple indicators in our body that give us an idea of what the state
    of the body is. For example, if you are tired, you will probably not be walking
    very fast or talking very loud. Instead, you would be doing the opposite! Similarly,
    there are multiple factors that indicate how our sleep cycle is going.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们身体中有多个指标可以让我们了解身体的状态。例如，如果你累了，你可能不会走得很快或者说得很大声。相反，你会做相反的事情！同样，有多个因素表明我们的睡眠周期是如何进行的。
- en: 'Some of these factors are: body temperature, respiration rate, REM sleep, and
    body movements. Measuring the exact body temperature or respiration rate and REM
    sleep is something of a challenge. But when we talk about body movements, I think
    we have already perfected it. So based on the body movements, we will be sensing
    how well we are sleeping and what kind of temperature adjustment is needed.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些因素是：体温、呼吸频率、快速动眼期睡眠和身体运动。测量准确的体温或呼吸频率和快速动眼期睡眠是一项挑战。但是当我们谈论身体运动时，我认为我们已经完善了。因此，基于身体运动，我们将感知我们的睡眠质量以及需要进行何种温度调节。
- en: If you notice, whenever someone is sleeping and starts feeling cold, the body
    will go to a fetal position and will move much less. This happens automatically.
    However, when a person is comfortable, there are some inevitable movements such
    as changing sides and movement of arms or legs. This does not happen when a person
    is feeling cold. So with these movements we can figure out whether a person is
    feeling cold or not. Now that we have understood the physiological changes of
    the body, let's try to build a program around it and see what we can achieve.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，每当有人睡觉并开始感到冷时，身体会呈胎儿姿势并且动作会少得多。这是自动发生的。然而，当一个人感到舒适时，会有一些不可避免的动作，比如翻身和手臂或腿部的运动。当一个人感到冷时，这是不会发生的。因此，通过这些动作，我们可以判断一个人是否感到冷。现在我们已经了解了身体的生理变化，让我们尝试围绕它构建一个程序，看看我们能实现什么。
- en: 'To do this, firstly, we need to connect the circuit as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先，我们需要按照以下方式连接电路：
- en: '![](Images/48c7ea27-075b-4caa-9601-797e8dc31680.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/48c7ea27-075b-4caa-9601-797e8dc31680.png)'
- en: 'Once this is done, go ahead and write the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，继续编写以下代码：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s have a look at what is going on under the hood:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看引擎盖下面发生了什么：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing you will see is that we have a condition: `if H,= 6 && H<= 22:`.
    This condition will only be true if the time frame is between 10 o'clock in the
    morning and  6 o'clock in the night. That is because this is the time when we
    generally sleep. Hence, the logic under this head will only work if it's time
    to sleep.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到的第一件事是我们有一个条件：`if H,= 6 && H<= 22:`。只有在时间范围在上午10点到晚上6点之间时，这个条件才会成立。这是因为这是我们通常睡觉的时间。因此，在这个条件下的逻辑只有在睡觉的时候才会起作用。
- en: The second condition is `if M <= 58`, which will be true only when the time
    is between `0` and `58` minutes. So when the time is `M = 59`, then this condition
    will not work. We will see the reason for having this logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件是`如果M <= 58`，只有当时间在`0`和`58`分钟之间时才为真。因此，当时间为`M = 59`时，这个条件将不起作用。我们将看到为什么要有这个逻辑的原因。
- en: 'Thereafter, we are calculating the time and storing the value in a variable
    called `M`. We are also calculating the humidity and temperature values and storing
    it in variables called `temperature` and `humidity`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们正在计算时间并将值存储在一个名为`M`的变量中。我们还在计算湿度和温度值，并将其存储在名为`temperature`和`humidity`的变量中：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, in this line, we are implementing a condition which will be true if the
    reading from the PIR is high. That is, there is some motion that will be detected.
    Whenever this happens, the `Movement` variable will be incremented by `1`. Finally,
    we are using the `time.sleep(10)` function to wait for `10` seconds. This is done
    as the PIR might be high for a momentary period. In that case, the condition will
    be true over and over again which in turn will increment the value of `Movement`
    multiple times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这一行中，我们正在实施一个条件，如果从PIR读取到的值很高，那么条件将为真。也就是说，会检测到一些运动。每当这种情况发生时，`Movement`变量将增加`1`。最后，我们使用`time.sleep(10)`函数等待`10`秒。这是因为PIR可能会在短暂的时间内保持高电平。在这种情况下，条件将一遍又一遍地为真，从而多次增加`Movement`的值。
- en: Our purpose of incrementing the value of `Movement` is to count the number of
    times the person has moved. Hence, incrementing it multiples times in one single
    time will defy the objective.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加`Movement`的值的目的是为了计算人移动的次数。因此，在一个时间内多次增加它将违背这个目标。
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have another condition, which says `if temperature < 28`. Not much explanation
    is needed for when the condition will be true. So whenever the condition is true
    and if the counted number of `Movement` is more than `5`, the value of `Duty`
    will be incremented by `10`. Therefore, we are sending the PWM to the AC dimmer,
    which in turn will increase the speed of the fan. Finally, we are resetting the
    value of `Movement` to `0`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有另一个条件，即`如果温度<28`。对于条件何时为真，不需要太多解释。因此，每当条件为真，如果计数的`Movement`次数超过`5`，那么`Duty`的值将增加`10`。因此，我们将PWM发送到空调调光器，从而增加风扇的速度。最后，我们将`Movement`的值重置为`0`。
- en: So essentially, we are just counting the number of movements. This movement
    is counted only if the temperature is less than 28° C. If the movement is more
    than `5`, then we will increase the speed of the fan by 10%.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只是在计算移动次数。只有当温度低于28°C时才计算这一移动。如果移动次数超过`5`，那么我们将增加风扇速度10%。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous section, the logic will only work when the time is between `0`
    and `58`, that is, the time in which the counting will happen. When the value
    of `M` is `59`, then the condition `if Movement = 0` will be checked, and if true,
    then the value of `Duty` will be decremented by `10`. This in turn will reduce
    the speed of the fan by 10%. Also, once this condition is executed, the value
    of `Movement` will be reset to `0`. So then a new cycle can start for the next
    hour.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，逻辑只有在时间在`0`和`58`之间时才有效，也就是计数将发生的时间。当`M`的值为`59`时，那么条件`if Movement = 0`将被检查，如果为真，那么`Duty`的值将减少`10`。这将减慢风扇的速度10%。此外，一旦执行了这个条件，`Movement`的值将被重置为`0`。因此，下一个小时可以开始一个新的循环。
- en: Now what it basically means is that counting will happen on an hourly basis.
    If the `Movement` is more than `5` then immediately the value of the `Duty` would
    be increased. However, if that is not the case, then the program will wait until
    the minute approaches the value of `59` and whenever that happens, it will check
    whether there is any movement, in which case, the fan speed will be decreased.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着计数将以小时为单位进行。如果`Movement`超过`5`，那么`Duty`的值将立即增加。但是，如果不是这种情况，程序将等待直到分钟接近`59`的值，每当发生这种情况时，它将检查是否有任何运动，如果有，风扇速度将降低。
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All of this code is very straightforward. If the temperature is less than `22`,
    then the AC will be switched off. Furthermore, if the temperature is equal to
    or more than `24`, and time is between 10:00 p.m. and 6:00 a.m., then the AC will
    be turned on. Finally, if the temperature is more than `27`, then the fan will
    be switch on to 100% speed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码都非常直接。如果温度低于`22`，则空调将关闭。此外，如果温度等于或超过`24`，并且时间在晚上10:00到早上6:00之间，则空调将打开。最后，如果温度超过`27`，则风扇将以100%的速度打开。
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we are making sure by using the condition `for H > 7 && H <20` that
    during this time the AC is always switched off. Also, if `H = 20`, then the AC
    should be turned on so that the room is cooled before you are ready to sleep.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用条件`for H > 7 && H <20`来确保在这段时间内空调始终处于关闭状态。此外，如果`H = 20`，则应打开空调，以便在准备睡觉之前冷却房间。
- en: Adding more
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多
- en: As you would have understood by now, we can control any AC electrical appliances
    as per our needs. We have understood switching and have also perfected the way
    we can vary the intensity of light and the speed of fans. But did you notice one
    thing? Sooner or later as our system gets more and more complex, the number of
    GPIOs needed will increase. There will come a moment when you will want to have
    more and more devices connected to your Raspberry Pi; however, you will not be
    able to do so due to lack of physical ports.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经了解的那样，我们可以根据自己的需求控制任何空调电器。我们已经理解了开关，并且已经完善了我们可以改变灯光强度和风扇速度的方式。但你有没有注意到一件事？随着我们的系统变得越来越复杂，所需的GPIO数量将会增加。总有一个时刻，你会想要连接更多的设备到你的树莓派上；然而，由于物理端口的不足，你将无法这样做。
- en: This is a very common situation in electronics. As always, there is a solution
    for this problem as well. This solution is known as a multiplexer. The basic job
    of a multiplexer is to multiply the number of ports in any computer system. Now
    you must be thinking, how is it able to do so?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这在电子学中是非常常见的情况。和往常一样，这个问题也有解决方案。这个解决方案被称为复用器。复用器的基本工作是在任何计算机系统中扩大端口的数量。现在你一定在想，它是如何做到的呢？
- en: 'The concept is extremely simple. Let''s first look at the diagram of a multiplexer
    here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念非常简单。让我们首先看一下复用器的图表：
- en: '![](Images/aea10593-2bf8-4d57-9d45-65505431998a.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aea10593-2bf8-4d57-9d45-65505431998a.png)'
- en: In the preceding diagram, you can see that there are two ends to the multiplexer—one
    being the signal output lines and the other opposite to it. The first thing we
    need to understand is that the multiplexer is a bidirectional device, that is,
    it sends the data from the multiplexer to the connected devices and also vice
    versa.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到复用器有两端—一个是信号输出线，另一个是相对的。我们需要首先了解的是，复用器是一个双向设备，即它从复用器向连接的设备发送数据，反之亦然。
- en: 'Now, firstly, we have the power line, which is pretty basic. It is there to
    power up the multiplexer itself. Then, we have **Signal Lines**, which have two
    ports, the **Sig** and **EN**. **EN** stands for enable, which means that until
    the time **EN** is not high, the data communication will not happen either way.
    Then we have something called **Sig**. This is the port that is connected to the
    GPIO of Raspberry Pi for data communication. Next we have the selection line.
    As you can see, we have four ports for it, namely, **S0**, **S1**, **S2**, and **S3**.
    The selection lines have a purpose of selecting a particular port that needs to
    be selected. The following is a table that will clarify what exactly is happening:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先是电源线，这很基本。它用于给复用器本身供电。然后，我们有**信号线**，它有两个端口，**Sig**和**EN**。**EN**代表使能，这意味着在**EN**不高的情况下，数据通信也不会发生。然后我们有一个叫做**Sig**的东西。这是连接到树莓派GPIO的用于数据通信的端口。接下来是选择线。正如您所看到的，我们有四个端口，分别是**S0**、**S1**、**S2**和**S3**。选择线的目的是选择需要选择的特定端口。以下是一个将澄清发生了什么的表：
- en: '| **S0** | **S1** | **S3** | **S4** | **Selected output** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **S0** | **S1** | **S3** | **S4** | **选定输出** |'
- en: '| 0 | 0 | 0 | 0 | C0 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | C0 |'
- en: '| 1 | 0 | 0 | 0 | C1 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | C1 |'
- en: '| 0 | 1 | 0 | 0 | C2 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | C2 |'
- en: '| 1 | 1 | 0 | 0 | C3 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | C3 |'
- en: '| 0 | 0 | 1 | 0 | C4 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | C4 |'
- en: '| 1 | 0 | 1 | 0 | C5 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | C5 |'
- en: '| 0 | 1 | 1 | 0 | C6 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | C6 |'
- en: '| 1 | 1 | 1 | 0 | C7 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0 | C7 |'
- en: '| 0 | 0 | 0 | 1 | C8 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 1 | C8 |'
- en: '| 1 | 0 | 0 | 1 | C9 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | C9 |'
- en: '| 0 | 1 | 0 | 1 | C10 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | C10 |'
- en: '| 1 | 1 | 0 | 1 | C11 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 | C11 |'
- en: '| 0 | 0 | 1 | 1 | C12 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | C12 |'
- en: '| 1 | 0 | 1 | 1 | C13 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | C13 |'
- en: '| 0 | 1 | 1 | 1 | C14 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | C14 |'
- en: '| 1 | 1 | 1 | 1 | C15 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | C15 |'
- en: In the preceding table, you can see that by using various logic combinations
    on the selection lines, various lines can be addressed. Let's say, for example,
    we have the following sequence on the selection pins—S0 = 1, S1 = 0, S2 = 1, S3
    = 1\. If this is the input on the selection pins from Raspberry Pi, then the pin
    number C13 will be selected. This basically means that now C13 can communicate
    the data to and from the pin **Sig** for the multiplexer. Also, we must remember
    that the enable pin must be high for the data transfer to happen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，您可以看到通过在选择线上使用各种逻辑组合，可以寻址各种线路。例如，假设我们在选择引脚上有以下序列—S0 = 1，S1 = 0，S2 = 1，S3
    = 1。如果这是来自树莓派的选择引脚的输入，那么将选择引脚号C13。这基本上意味着现在C13可以与复用器的引脚**Sig**进行数据通信。此外，我们必须记住，使能引脚必须高才能进行数据传输。
- en: In a similar fashion, we can go ahead and address all the 16 pins of the multiplexer.
    Hence, if we see it logically, then by using six pins of Raspberry Pi, we can
    go ahead and utilize 16 GPIOs. Now that we have understood the basics of multiplexing,
    let's go ahead and try using one of them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以继续处理复用器的所有16个引脚。因此，从逻辑上看，通过使用树莓派的六个引脚，我们可以继续利用16个GPIO。既然我们已经了解了复用的基础知识，让我们继续尝试使用其中的一个。
- en: '![](Images/d1d03c85-d1df-49df-8adb-5f7c95c895ed.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d1d03c85-d1df-49df-8adb-5f7c95c895ed.png)'
- en: 'Once the hardware is connected, let''s go ahead and upload the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦硬件连接好了，让我们继续上传以下代码：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, what we are essentially doing is, triggering the selection lines one by
    one to address every single port where the LED is connected. Whenever that happens,
    the LED corresponding to it glows. Also, the reason it glows is because the signal
    port `Sig` is connected to 3.3V of Raspberry Pi. Hence, send a logic high to whichever
    port it is connected to.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们所做的实质上是，逐个触发选择线，以寻址LED连接的每个单个端口。每当发生这种情况时，相应的LED会发光。此外，它发光的原因是因为信号端`Sig`连接到树莓派的3.3V。因此，向其连接的任何端口发送逻辑高电平。
- en: This is one of the basic ways in which the multiplexer works. This can be incredibly
    useful when we will be using multiple devices and sensors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是复用器工作的基本方式之一。当我们使用多个设备和传感器时，这可能非常有用。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we enabled Jarvis to automate your home appliances under different
    conditions, also applying various properties to the system. So go on and try many
    other scenarios under which you can enhance your home automation system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使Jarvis能够在不同条件下自动化您的家用电器，并将各种属性应用于系统。因此，请继续尝试许多其他情景，以增强您的家庭自动化系统。
- en: In the next chapter, we will enable Jarvis IoT, thus controlling the appliances
    from your mobile phone using Wi-Fi and the internet.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将启用Jarvis IoT，从而使用Wi-Fi和互联网从您的手机控制电器。
