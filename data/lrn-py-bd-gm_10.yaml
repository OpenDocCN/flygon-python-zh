- en: Upgrading the Snake Game with Turtle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Turtle升级蛇游戏
- en: Most computer gamers regard games as exciting and appealing due to their appearance.
    To some extent, this is true. Computer games must be visually attractive so that
    the player feels like they are physically participating in them. Most game developers
    and game designers spend a profuse amount of time developing game graphics and
    animations so as to provide a better experience to the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数电脑游戏玩家认为游戏因其外观而令人兴奋和吸引人。在某种程度上，这是真的。计算机游戏必须在视觉上具有吸引力，以便玩家感觉自己在其中参与。大多数游戏开发人员和游戏设计师花费大量时间开发游戏图形和动画，以提供更好的体验给玩家。
- en: This chapter will teach you how to build the basic layout of games from scratch
    using the Python `turtle` module. As we know, the `turtle` module allows us to
    make games with a two-dimensional (2D) motion; thus, we will only be making 2D
    games such as flappy bird, pong, and snake in this chapter. The concept that we
    will be covering in this chapter is extremely important in order to bind movements
    with user actions for the game character.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教您如何使用Python的`turtle`模块从头开始构建游戏的基本布局。正如我们所知，`turtle`模块允许我们制作具有二维（2D）运动的游戏；因此，本章我们将只制作2D游戏，如flappy
    bird、pong和snake。本章将涵盖的概念非常重要，以便将运动与游戏角色的用户操作绑定起来。
- en: By the end of this chapter, you will have learned how to implement data models
    by creating 2D animations and games. Consequently, you will learn how to deal
    with the different components of game logic, such as defining collisions, boundaries,
    projections, and screen tap events. By learning about such aspects of game programming,
    you will be able to learn how to define and design game components using the `turtle`
    module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将学会通过创建2D动画和游戏来实现数据模型。因此，您将学会如何处理游戏逻辑的不同组件，例如定义碰撞、边界、投影和屏幕点击事件。通过学习游戏编程的这些方面，您将能够学会如何使用`turtle`模块定义和设计游戏组件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of computer pixels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机像素概述
- en: Simple animation using the Turtle module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Turtle模块进行简单动画
- en: Upgrading the snake game using Turtle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Turtle升级蛇游戏
- en: The pong game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乒乓球游戏
- en: The flappy bird game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: flappy bird游戏
- en: Game testing and possible modifications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You are expected to have the following resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下资源：
- en: Python 3.5 or newer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5或更新版本
- en: Python IDLE (Python's inbuilt IDE)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python IDLE（Python内置的IDE）
- en: A text editor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: A web browser
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络浏览器
- en: The files for this chapter can be found here: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件可以在这里找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10)
- en: 'Check out the following video to see the code in action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码运行情况：
- en: '[http://bit.ly/2oJLeTY](http://bit.ly/2oJLeTY)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oJLeTY](http://bit.ly/2oJLeTY)'
- en: Exploring computer pixels
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索计算机像素
- en: 'When you observe the computer screen closely, you might find small dots forming
    rows and columns. From a certain distance, the matrix of dots represents images,
    which we normally see when we look at the screen. These dots are called pixels.
    Since computer games should be made to be pleasantly visual in nature, we have
    to work with these pixels in order to create and customize the game screen, and
    even use them to make a player move in the game, which will be shown on the screen.
    Whenever a player presses any key on the keyboard, changes in movement must be
    reflected in the pixels of the screen. For example, when a player presses the
    **RIGHT** key, a specific character must move a number of units in pixels to the
    right on the screen in order to represent motion. We discussed vectored motion
    in the previous chapter, which is able to override the methods of some classes
    in order to implement motion. We will use the technique of vectors to make pixel
    movement for the game characters. Let''s observe the following outline, which
    we are going to adapt for making any games using vectors and the turtle module:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您仔细观察计算机屏幕时，您可能会发现形成行和列的小点。从一定距离上看，这些点的矩阵代表图像，这是我们在屏幕上看到的。这些点称为像素。由于计算机游戏应该在视觉上令人愉悦，我们必须使用这些像素来创建和自定义游戏屏幕，甚至使用它们来使玩家在游戏中移动，这将显示在屏幕上。每当玩家在键盘上按下任何键时，移动的变化必须反映在屏幕的像素上。例如，当玩家按下**右**键时，特定字符必须在屏幕上向右移动若干个像素单位，以表示运动。我们在上一章中讨论了矢量运动，它能够覆盖一些类的方法以实现运动。我们将使用矢量的技术来使游戏角色进行像素移动。让我们观察以下大纲，我们将使用矢量和turtle模块来制作任何游戏：
- en: Make a `Vector` class, which will have methods such as `__add__()`, `__mul__()`,
    and `__div__()`, which will perform arithmetic operations on our vector points.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个`Vector`类，其中将具有`__add__()`、`__mul__()`和`__div__()`等方法，这些方法将对我们的向量点执行算术运算。
- en: Use the `Vector` class to instantiate a player on the game screen, with its
    aiming target or movements.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Vector`类在游戏屏幕上实例化玩家，并设置其瞄准目标或移动。
- en: Make a game boundary using the `turtle` module.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`turtle`模块制作游戏边界。
- en: Draw game characters using the `turtle` module.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`turtle`模块绘制游戏角色。
- en: Operations such as rotate, forward, and move should be used from the `Vector`
    class in order to make a game character move.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用`Vector`类的旋转、前进和移动等操作，以使游戏角色移动。
- en: Handle user events using the main loop.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用主循环处理用户事件。
- en: 'We will learn about pixel representation by making a simple **Mario** pixel
    art. The following code shows the representation of pixels in the multi-dimensional
    list, which is a list of lists. We have stored each pixel on a single line using
    the multi-dimensional list:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过制作简单的**Mario**像素艺术来学习像素表示。以下代码显示了多维列表中像素的表示，这是一个列表的列表。我们使用多维列表将每个像素存储在单独的行中：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding grid consists of three lines that represent the pixel positions.
    Similar to the list element extract method, the `>>> grid[1][4]` statement returns
    a positional value of '0' from the second list (that is, [0,1,0,1,0,1]) of the
    grid. (Refer to [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml), *Data
    Structures and Functions*, to learn more about list operations.) Thus, we can
    access any cell within the grid.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的网格由三行组成，代表像素位置。类似于列表元素提取方法，`>>> grid[1][4]`语句从网格的第二个列表（即[0,1,0,1,0,1]）中返回'0'的位置值。
    （请参考[第4章](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml)，*数据结构和函数*，以了解更多关于列表操作的信息。）因此，我们可以访问网格内的任何单元格。
- en: 'The following code should be written inside the Python script. By creating
    a `mario.py` file, we will use it to create Mario pixel art:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该写在Python脚本中。通过创建一个`mario.py`文件，我们将用它来创建马里奥像素艺术：
- en: Start by importing turtle—`import turtle`—the only module we are going to use.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入turtle——`import turtle`——这是我们将要使用的唯一模块。
- en: Instantiate the turtle module using the `>>> Pen = turtle.Turtle()` command.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`>>> Pen = turtle.Turtle()`命令实例化`turtle`模块。
- en: 'Specify two properties for the pen using speed and color attributes:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用速度和颜色属性为画笔指定两个属性：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We must make a `new` function, named `box`, which will draw a box by drawing
    the square shape using turtle methods. This box size represents the dimension
    for the pixel art:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须创建一个名为`box`的`new`函数，该函数将使用画笔方法绘制正方形形状来绘制一个盒子。这个盒子大小代表像素艺术的尺寸：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We must position the pen to start painting from the top-left position of the
    screen. These commands should be defined outside of the `box()` function:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将画笔定位到屏幕左上角的位置开始绘画。这些命令应该在`box()`函数之外定义：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the box size, which represents the dimension of the pixel art that we
    are going to draw:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义盒子大小，代表我们要绘制的像素艺术的尺寸：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the second phase, you have to declare pixels in the form of multi-dimensional
    lists, which represents the position of each pixel. The following `grid_of_pixels` variable
    represents the grid of lines that represent the positions of the pixels. The following
    line of code must be added outside the `box` function definition. (Refer to [https://github.com/PacktPublishing/Learning-Python-by-building-games](https://github.com/PacktPublishing/Learning-Python-by-building-games)
    to locate the game file, that is, `mario.py`.):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，您必须以多维列表的形式声明像素，这些像素代表每个像素的位置。以下的`grid_of_pixels`变量代表了代表像素位置的线网格。下面的代码行必须添加到`box`函数定义之外。（请参考[https://github.com/PacktPublishing/Learning-Python-by-building-games](https://github.com/PacktPublishing/Learning-Python-by-building-games)来定位游戏文件，即`mario.py`。）：
- en: Remember that a combination of pixels in a single form represents a straight
    line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，单个形式的像素组合代表一条直线。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define the color palette for the pixel art using colors. We will use color
    code to define the colors for the art, as shown in the following code. The hexadecimal
    color code (HEX) represents the color combination of red, green, and blue (#RRGGBB).
    Refer to [https://htmlcolorcodes.com/](https://htmlcolorcodes.com/) in order to
    analyze the different codes for different colors:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用颜色定义像素艺术的调色板。我们将使用颜色代码来定义艺术品的颜色，如下面的代码所示。十六进制颜色代码（HEX）代表红色、绿色和蓝色的颜色组合（#RRGGBB）。请参考[https://htmlcolorcodes.com/](https://htmlcolorcodes.com/)以分析不同颜色的不同代码：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we should start drawing the pixel art using a grid of pixels and the
    color palette that we defined in *steps 7* and *step 8*. We have to use the `box`
    class that we made previously using the `box()` function to make the pixel art.
    The pixel art consists of rows and columns; thus, we have to declare two loops
    for drawing art. The following code calls different functions from the turtle
    module, such as `forward()`, `penup()`, and `pendown()`. We studied them in the
    previous chapter; they will make use of the pen to draw, based on the list of
    lists that were defined by the grid of pixels:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该开始使用我们在*步骤7*和*步骤8*中定义的像素网格和调色板来绘制像素艺术。我们必须使用我们之前制作的`box()`函数来制作像素艺术。像素艺术由行和列组成；因此，我们必须声明两个循环来绘制艺术品。以下代码调用了`turtle`模块的不同函数，如`forward()`、`penup()`和`pendown()`。我们在上一章中学习了它们；它们将利用画笔根据像素网格的列表来绘制。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's digest the previous code snippet. It contains a `for` loop, which loops
    from an initial value of 0 to the length of the grid of pixels that represent
    positions in the canvas. Each pixel represents one position, where we must draw
    using the pen; thus, we loop on each of those pixels, one at a time. Inside the
    2D `for` loop, we fetch the color from the palette and call the `box` method,
    which creates a rectangular box where our Mario art should be rendered. We draw
    inside this box with the turtle pen by using the `forward()` function. We do the
    same operation in the rows of pixels, as indicated by the i^(th) loop.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们消化前面的代码片段。它包含一个`for`循环，从0的初始值循环到代表画布中位置的像素网格的长度。每个像素代表一个位置，我们必须使用画笔进行绘制；因此，我们逐个循环每个像素。在二维`for`循环内，我们从调色板中获取颜色并调用`box`方法，该方法创建一个矩形框，我们的马里奥艺术应该在其中呈现。我们使用`turtle`画笔在这个框内绘制，使用`forward()`函数。我们在像素的行中执行相同的操作，如第i个循环所示。
- en: 'Once we have finished combining the preceding code, that is, we have carried
    out the `box` method, initialization, and two main `for` loops, we are ready to
    run the code and observe the following Mario pixel art. After running our code,
    the pen from the `turtle` module will start drawing, and eventually it will give
    us the following art:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了前面的代码组合，也就是我们执行了`box`方法、初始化和两个主要的`for`循环，我们就可以运行代码并观察以下马里奥像素艺术。运行我们的代码后，`turtle`模块的画笔将开始绘制，最终会给我们以下艺术品：
- en: '![](Images/ffcd57a4-69b5-4504-aedf-e409af2f5370.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ffcd57a4-69b5-4504-aedf-e409af2f5370.png)'
- en: Since we are familiar with the concept of pixels and vectored motion, it's time
    to make games using 2D graphics. We will be using the `turtle` module, along with
    data models, in order to create game characters and make them move. We will start
    this adventure by making a simple animation in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们熟悉像素和矢量运动的概念，现在是使用2D图形制作游戏的时候了。我们将使用`turtle`模块以及数据模型来创建游戏角色并使它们移动。我们将通过在下一节中制作一个简单的动画来开始这个冒险。
- en: Understanding simple animation using the Turtle module
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Turtle模块理解简单动画
- en: 'By now, we are probably familiar with the different methods of the `turtle`
    module. This means we won''t have any problem creating characters for the game.
    Similarly, motions for game characters are provided using vectored movements.
    Operations such as vectored addition and subtraction provide linear movement in
    a straight line through the rotation of objects (refer to [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml),
    *Data Model Implementation*, for more information). The `move` operation that
    is defined in the following code snippet will provide random movements to game
    characters. The `move` method will take another vector as a catalyst and will
    perform mathematical operations in order to update the current position, while
    also considering the direction of the game character:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能已经熟悉了`turtle`模块的不同方法。这意味着我们不会在创建游戏角色时遇到任何问题。同样，游戏角色的运动是使用矢量运动来实现的。矢量加法和减法等操作通过对象的旋转提供直线运动（有关更多信息，请参阅[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)，*数据模型实现*）。以下代码片段中定义的`move`操作将为游戏角色提供随机移动。`move`方法将以另一个矢量作为催化剂，并执行数学运算以更新当前位置，同时考虑游戏角色的方向：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `rotate` method will rotate the vector counter-clockwise by a specific
    angle (in-place). The following sample represents the `rotate` method call:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate`方法将按逆时针方向旋转矢量特定角度（原地）。以下示例表示`rotate`方法的调用：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have to define the preceding two methods inside the `Vector` class. Follow
    this procedure to implement the `Vector` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`Vector`类中定义前面两种方法。按照以下步骤实现`Vector`类：
- en: 'You have to start by defining the `Vector` class with the class keyword. We
    will define slots as class attributes, which will contain three attributes. The
    slots represent an attribute, which contains three pieces of critical information:
    *x*, *y,* and hash. The values *x* and *y* are the current position of the game
    character, while hash is used to locate the data record. For instance, if the
    `Vector` class is instantiated with *x* and *y* coordinates, then the hash attribute
    will be activated. Otherwise, it remains deactivated.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须从使用class关键字定义`Vector`类开始。我们将定义slots作为类属性，其中包含三个属性。slots表示一个包含三个关键信息的属性：*x*、*y*和hash。*x*和*y*的值是游戏角色的当前位置，而hash用于定位数据记录。例如，如果使用*x*和*y*坐标实例化`Vector`类，则将激活hash属性。否则，它将保持未激活状态。
- en: 'The coordinates of the vectored elements, that is, (5,6), are represented by
    *x* and *y,* where *x = 5* and *y = 6*, and the hash variable represents whether
    the slot is empty. The hash variable is used to locate the data records and to
    check whether the `Vector` class is instantiated. If the slot attribute already
    contains *x* and *y*, this hash attribute will restrain from further assignment
    to the slots. We will also define the `PRECISION` attribute (user-defined), which
    will round the coordinates of *x* and *y* to a certain level. In order to make
    things clear, several examples have been added inside the code, and you can observe
    this inside three-line comments:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矢量元素的坐标，即(5,6)，由*x*和*y*表示，其中*x=5*，*y=6*，hash变量表示插槽是否为空。hash变量用于定位数据记录并检查`Vector`类是否已实例化。如果插槽属性已经包含*x*和*y*，则hash属性将阻止对插槽的进一步赋值。我们还将定义`PRECISION`属性（用户定义），它将把*x*和*y*的坐标四舍五入到一定的级别。为了使事情清楚，代码中添加了几个示例，并且您可以在三行注释中观察到这一点：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we need to define the first member of the class. We know that the first
    member of the class is the `__init__()` method. We will define it in order to
    initialize the class attributes, which are *x* and *y*. We have rounded the values
    of *x* and *y* to a certain level of precision, as indicated by the `PRECISION`
    attribute. `round()` is a built-in function of Python. The following line of code
    contains a constructor, where we initialize the vector coordinates (*x*, *y*)
    using the `round` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义类的第一个成员。我们知道类的第一个成员是`__init__()`方法。我们将定义它以初始化类属性，即*x*和*y*。我们已经将*x*和*y*的值四舍五入到`PRECISION`属性指示的一定精度级别。`round()`是Python的内置函数。以下代码行包含一个构造函数，我们在其中使用`round`方法初始化矢量坐标（*x*，*y*）：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You might have observed that you have made *x* and *y* attributes as private
    attributes, as they begin with a single underscore (`_x`, `_y`). Thus, direct
    initialization cannot be done in these types of attributes, which leads to **data
    encapsulation**, which we covered back in the object-oriented paradigms topic.
    Now, in order to fetch and set the values of these attributes, you have to use
    the `getter` and `setter` methods. These two methods will be a property of the
    `Vector` class. The following code represents how to implement `getter` and `setter`
    for our `Vector` class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到，您已将*x*和*y*属性作为私有属性，因为它们以单下划线(`_x`, `_y`)开头。因此，无法直接初始化这些类型的属性，这导致了**数据封装**，这是我们在面向对象范例主题中讨论过的。现在，为了获取和设置这些属性的值，您必须使用`getter`和`setter`方法。这两种方法将成为`Vector`类的属性。以下代码表示如何为我们的`Vector`类实现`getter`和`setter`：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Along with the `getter` and `setter` methodologies, you may have observed `_hash`,
    which represents if the slot is already allocated or not. In order to check whether
    the slot is already appropriated, we have to implement a data model, that is, `__hash__()`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`getter`和`setter`方法之外，您可能已经注意到了`_hash`，它表示插槽是否已分配。为了检查插槽是否已经被分配，我们必须实现一个数据模型，即`__hash__()`。
- en: 'Just a quick review: data models, or magic functions, allow us to change the
    implementation of a method that is provided by one of its ancestors.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简单回顾一下：数据模型或魔术函数允许我们更改由其祖先之一提供的方法的实现。
- en: 'Now, we will define the `hash` method on our `Vector` class and implement it
    differently:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的`Vector`类上定义`hash`方法，并以不同的方式实现它：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you have to implement two main methods in the `Vector` class: `move()`
    and `rotate()`. We will start with the `move` method. The `move` method will move
    the vector by other (in-place). Here, other is the argument that is passed to
    the `move` method. For example, `(1, 2).move(2, 3)` will result in (3, 5). Remember:
    movement is done by any of the vectored arithmetic operations, that is, add, multiply,
    divide, and so on. We will use the `__add__()` magic function (refer to [Chapter
    9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model Implementation*) in
    order to create movement for the vector. Before that, we have to make a copy method
    that will return the copy of the vector. The `copy()` method is essential because
    we don''t want the operations to harm our original vector; instead, we will perform
    arithmetic operations on the copy of the original vector:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您必须在`Vector`类中实现两个主要方法：`move()`和`rotate()`。我们将从`move`方法开始。`move`方法将移动向量到其他位置（原地）。这里，其他是传递给`move`方法的参数。例如，`(1,
    2).move(2, 3)`将得到(3, 5)。记住：移动是通过任何向量算术运算来完成的，即加法、乘法、除法等。我们将使用`__add__()`魔术函数（参考[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)，*数据模型实现*）来为向量创建移动。在此之前，我们必须创建一个返回向量副本的`copy`方法。`copy()`方法很重要，因为我们不希望操作损害我们的原始向量；相反，我们将在原始向量的副本上执行算术运算：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You have to implement the `iadd` magic function before implementing the `add`
    function. We use the `__iadd__` method to implement the extended `add` operator
    assignment. We can implementing the `__iadd__()` magic function inside the `Vector`
    class as follows. We saw its implementation in the previous chapter ([Chapter
    9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model Implementation)*:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现`add`函数之前，您必须实现`iadd`魔术函数。我们使用`__iadd__`方法来实现扩展的`add`运算符赋值。我们可以在`Vector`类中实现`__iadd__()`魔术函数，如下所示。我们在上一章中看到了它的实现（[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)，*数据模型实现*）：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you have to make a new method, `__add__`, which will call the preceding
    `__iadd__()` method on the copy of the original vector. The last statement, `__radd__
    = __add__`, has significant meaning. Let''s observe the following diagrammatic
    relationship between `radd` and add. It works like this: Python tries to evaluate
    the expression, *Vector(1,4) + Vector(4,5)*. First, it calls `int.__add__((1,4),
    (4,5))`, which raises an exception. After this, it will try to invoke `Vector.__radd__((1,4),
    (4,5))`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要创建一个新的方法`__add__`，它将在原始向量的副本上调用前面的`__iadd__()`方法。最后一条语句`__radd__ = __add__`具有重要的意义。让我们观察一下`radd`和`add`之间的下面的图示关系。它的工作原理是这样的：Python尝试评估表达式*Vector(1,4)
    + Vector(4,5)*。首先，它调用`int.__add__((1,4), (4,5))`，这会引发异常。之后，它将尝试调用`Vector.__radd__((1,4),
    (4,5))`：
- en: '![](Images/3bc12aac-5ec9-44c4-b189-2339422283c9.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3bc12aac-5ec9-44c4-b189-2339422283c9.png)'
- en: 'It''s easy to recognize that the implementation of `__radd__` is analogous
    to `add`: (refer to the example code defined inside the comments in the `__add__()`
    method):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，`__radd__`的实现类似于`add`：（参考`__add__()`方法中注释中定义的示例代码）：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we are ready to make the first movement sequence for our animation.
    We will start by defining the `move` method in our class. The `move()` method
    will take a single argument as a vector and add it to the current vector that
    represents the current position of the game character. The `move` method will
    implement a straight line addition. The following code represents the definition
    of the `move` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们准备为我们的动画制作第一个移动序列。我们将从在我们的类中定义`move`方法开始。`move()`方法将接受一个向量作为参数，并将其添加到表示游戏角色当前位置的当前向量中。`move`方法将实现直线加法。以下代码表示了`move`方法的定义：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we need to create the `rotate()` method. This method is quite tricky
    to create, as it will rotate the vector counter-clockwise by a specified angle
    (in-place). This method will use trigonometric operations such as the sine and
    cosine of the angle; thus, we have to import a math module first: `import math`.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`rotate()`方法。这个方法相当棘手，因为它会逆时针旋转向量一个指定的角度（原地）。这个方法将使用三角函数操作，比如角度的正弦和余弦；因此，我们首先要导入一个数学模块：`import
    math`。
- en: 'The following code depicts the way of defining the rotate method; inside it,
    we have added comments to make this operation clear to you. At first, we have
    converted the angle into a radian with the: `angle*π/ 180.0` command/formula.
    After that, we fetched *x* and *y* coordinates of the vector class and performed
    the `x = x*cosθ - y*sinθ` and `y = y*cosθ + x*sinθ` operations:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码描述了定义旋转方法的方式；在其中，我们添加了注释以使这个操作对您清晰明了。首先，我们用`angle*π/ 180.0`命令/公式将角度转换为弧度。之后，我们获取了向量类的*x*和*y*坐标，并执行了`x
    = x*cosθ - y*sinθ`和`y = y*cosθ + x*sinθ`操作：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The mathematical formula, *x = x*cosθ - y*sin**θ*, is significant in vectored
    motion. This formula is used to provide rotational movements to the game characters. *x*cosθ*
    represents the base *x*-axis movements, while *y*sinθ* represents the vertical
    *y*-axis movements. Thus, this formula facilitates the rotation of a point in
    a 2D plane with an angle of θ.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数学公式*x = x*cosθ - y*sin**θ*在向量运动中非常重要。这个公式用于为游戏角色提供旋转运动。*x*cosθ*代表基础*x*轴运动，而*y*sinθ*代表垂直*y*轴运动。因此，这个公式实现了在二维平面上以角度θ旋转一个点。
- en: 'Finally, we have completed two methods: `move()` and `rotate()`. These two
    methods are completely unique, but they both represent vectored motion. The `move()`
    method has implemented the `__iadd_()` magic function, while the `rotate()` method
    has its own custom trigonometric implementation. The combination of these two
    methods can form complete movement for game characters on the canvas or game screen.
    To construct any type of 2D game, we have to implement similar kinds of movements.
    Now, we will make a simple animation of an ant game in order to begin our tour
    of our gaming adventure.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了两个方法：`move()`和`rotate()`。这两种方法完全独特，但它们都代表向量运动。`move()`方法实现了`__iadd_()`魔术函数，而`rotate()`方法具有自己的自定义三角函数实现。这两种方法的组合可以形成游戏角色在画布或游戏屏幕上的完整运动。为了构建任何类型的2D游戏，我们必须实现类似的运动。现在，我们将制作一个蚂蚁游戏的简单动画，以开始我们的游戏冒险之旅。
- en: 'The following steps depict the procedure of making any animation for 2D games:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了制作2D游戏动画的过程：
- en: Firstly, you have to import the necessary module. Since we have to give random
    vector coordinates to the previously made `move()` method, we can predict that
    we will need a random module.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须导入必要的模块。由于我们必须为先前制作的`move()`方法提供随机向量坐标，我们可以预测我们将需要一个随机模块。
- en: After that, we need another module—a `turtle` module—which will allow us to
    call methods such as ontimer and setup. We also need the methods of a vector class,
    that is, `move()` and `rotate()`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要另一个模块——`turtle`模块，它将允许我们调用`ontimer`和`setup`等方法。我们还需要向量类的方法，即`move()`和`rotate()`。
- en: 'We have to import it if that class is maintained in any other module or file.
    Create two files: `base.py` for vector movements and `animation.py` for animation.
    Then, import the following statements:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该类维护在任何其他模块或文件中，我们必须导入它。创建两个文件：`base.py`用于向量运动和`animation.py`用于动画。然后，导入以下语句：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first two statements are going to import everything from the random and
    `turtle` modules. The third statement is going to import the vector class from
    the base file or module.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前两个语句将从random和turtle模块中导入所有内容。第三个语句将从基本文件或模块中导入向量类。
- en: 'Next, we need to define the initial position for the game character, along
    with its aim. It should be initialized as an instance of the vector class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为游戏角色定义初始位置以及其目标。它应该被初始化为向量类的一个实例：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you have to define the wrap method. This method takes *x* and *y* positions
    as an argument that is referred to as `value` and returns it. In the upcoming
    games, such as flappy bird and Pong, we will extend this function and make it
    wrap the value around certain boundary points:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要定义wrap方法。该方法以*x*和*y*位置作为参数，称为`value`，并返回它。在即将推出的游戏中，如flappy bird和Pong，我们将扩展此功能，并使其将值环绕在某些边界点周围：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The main controlling unit of the game is the `draw()` function, which calls
    a method to make game character move. It also draws a screen for the game. From
    the `Vector` class, we are going to call the `move` and `rotate` methods. From
    the turtle module, we are going to call the `goto`, `dot`, and `ontimer` methods.
    The `goto` method will move the turtle pen to a specified position on the game
    screen, the `dot` method will create a small dot of a specified length when called,
    and the `ontimer(function, t)` method will install a timer, which calls that function
    after `t` milliseconds:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏的主控单元是`draw()`函数，它调用一个方法来使游戏角色移动。它还为游戏绘制屏幕。我们将从`Vector`类中调用`move`和`rotate`方法。从turtle模块中，我们将调用`goto`、`dot`和`ontimer`方法。`goto`方法将在游戏屏幕上的指定位置移动海龟画笔，`dot`方法在调用时创建指定长度的小点，`ontimer(function,
    t)`方法将安装一个定时器，在`t`毫秒后调用该函数：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, the `running` variable was not declared. We will do
    it now, outside the definition of the `draw()` method. We will also set up the
    game screen using the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述代码中，`running`变量尚未声明。我们现在将在`draw()`方法的定义之外进行声明。我们还将使用以下代码设置游戏屏幕：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, we have completed a simple 2D animation. It consists of a simple dot
    of a length of 10 pixels, but more importantly, it has motion attached to it,
    which is the result of implementing magic functions inside the `Vector` class.
    The next section will teach us how to use the magic functions that we implemented
    in this section in order to make a more robust game, which is the Snake game.
    We will make a Snake game using the turtle module and magic functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了一个简单的2D动画。它由一个长度为10像素的简单点组成，但更重要的是，它具有附加的运动，这是在`Vector`类中实现魔术函数的结果。下一节将教我们如何使用本节中实现的魔术函数来制作更健壮的游戏，即蛇游戏。我们将使用turtle模块和魔术函数制作蛇游戏。
- en: Upgrading the snake game using Turtle
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Turtle升级蛇游戏
- en: 'As it turns out, we have been building the snake game in the previous chapters
    of this book: in [Chapter 5](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml), *Learning
    About Curses by Building a Snake Game*, using the curses module; in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml),
    *Object-Oriented Programming*; and in [Chapter 7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml), *List
    Comprehension and Properties,* by refining it using properties and list comprehension.
    We started with the curses module ([Chapter 5](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml), *Learning
    About Curses by Building a Snake Game*), and modified it using an object-0riented
    paradigm. The curses module was able to provide a character-based Terminal game
    screen, which eventually made the game character look awful. Although, we learned
    how to build logic using **OOP** and curses, along with making the Snake game,
    it should be noted that games are primarily concerned with visuals: how a player
    sees and interacts with the characters. Thus, our primary concern is to make games
    visually appealing. In this section, we will try to upgrade the Snake game using
    both the turtle module and vectored movements. Since there is only one possible
    movement in the case of the Snake game, which is a straight-line movement by pressing
    the **LEFT, RIGHT, UP,** or **DOWN** key, we don''t have to define anything new
    inside the vector class of the base file. The `move()` method, which we made previously,
    is enough to provide the movements for the snake game.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，在本书的前几章中我们一直在构建贪吃蛇游戏：在[第5章](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml)中，使用curses模块学习贪吃蛇游戏；在[第6章](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml)中，面向对象编程；以及在[第7章](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml)中，通过属性和列表推导式进行改进。我们从curses模块开始([第5章](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml)，*学习使用curses构建贪吃蛇游戏*)，并使用面向对象的范例进行修改。curses模块能够提供基于字符的终端游戏屏幕，这最终使游戏角色看起来很糟糕。尽管我们学会了如何使用OOP和curses构建逻辑，以及制作贪吃蛇游戏，但应该注意到游戏主要关注视觉：玩家如何看到角色并与之交互。因此，我们的主要关注点是使游戏具有视觉吸引力。在本节中，我们将尝试使用turtle模块和向量化移动来升级贪吃蛇游戏。由于在贪吃蛇游戏中只有一种可能的移动方式，即通过按**左、右、上**或**下**键进行直线移动，我们不必在基本文件的向量类中定义任何新内容。我们之前创建的`move()`方法足以为贪吃蛇游戏提供移动。
- en: 'Let''s start coding the Snake game using the turtle module and `Vector` class,
    by following these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用turtle模块和`Vector`类编写贪吃蛇游戏，按照以下步骤进行：
- en: 'As usual, start by importing the necessary modules, as shown in the following
    code. It is not compulsory for you to import everything first; we can do it along
    with coding other stuff too, but it''s good practice to import everything at once
    so that we don''t forget anything afterward:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，首先导入必要的模块，如下面的代码所示。您不必先导入所有内容；我们也可以在编写其他内容时一起导入，但一次导入所有内容是一个好习惯，这样我们之后就不会忘记任何东西：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s brainstorm a little bit. We can''t use sprites or images yet. We
    will learn about these in the upcoming chapters, after we get started with Pygame.
    For now, we have to make a shape that represents a 2D snake, which is our main
    character. You have to open the `base.py` file, where we created a `Vector` class
    and defined a `Square` method. Note that the `Square` method is declared outside
    the `Vector` class. The following code is a simple implementation of the turtle
    methods that will create square shapes using the turtle pen:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进行一些头脑风暴。我们暂时不能使用精灵或图像。在开始使用Pygame之后，我们将在即将到来的章节中学习这些内容。现在，我们必须制作一个代表2D蛇角色的形状。您必须打开`base.py`文件，在那里我们创建了`Vector`类并定义了`Square`方法。请注意，`Square`方法是在`Vector`类之外声明的。以下代码是使用turtle方法创建正方形形状的简单实现：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, import this newly made method inside the Snake game module. Now, we can
    call the square method inside our Snake game''s Python file:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在贪吃蛇游戏模块中导入这个新方法。现在，我们可以在贪吃蛇游戏的Python文件中调用square方法：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After importing everything, we will declare variables such as food, snake,
    and aim. The food represents the vector coordinates, which is an instance of the
    `Vector` class, for example, vector(0,0). The snake represents the initial vectored
    position for the snake character, that is, (vector(10,0)), while the body of the
    snake must be a list of representations for the vector, that is, (vector(10,0),
    vector(10,1), and vector(10,2)) for a snake of length 3\. The `aim` vector represents
    the unit that must be added or subtracted to the current snake vector, based on
    the user''s keyboard actions:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所有内容后，我们将声明变量，如food、snake和aim。food表示向量坐标，是`Vector`类的一个实例，例如vector(0,0)。snake表示蛇角色的初始向量位置，即(vector(10,0))，而蛇的身体必须是向量表示的列表，即(vector(10,0)、vector(10,1)和vector(10,2))表示长度为3的蛇。`aim`向量表示必须根据用户的键盘操作添加或减去到当前蛇向量的单位：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside the `snake-Python` file (the main file), after importing everything
    and declaring its attributes, we will start by defining the boundary for the Snake
    game, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`snake-Python`文件（主文件）中导入所有内容并声明其属性后，我们将开始定义贪吃蛇游戏的边界，如下所示：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should also define another important method of the Snake game, which is
    known as `move()`, since this will take care of the movement of the Snake character
    on the game screen, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还应该定义贪吃蛇游戏的另一个重要方法，即`move()`，因为这将负责在游戏屏幕上移动贪吃蛇角色，如下所示：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s start by understanding the code line by line:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们逐行理解代码：
- en: At the beginning of the `move` method, we fetched `snakehead` and performed
    a copy operation, which is defined inside the `Vector` class, and we made a snake
    move one segment ahead automatically because we want the snake to move automatically
    as soon as the user starts playing the game.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`move`方法的开始，我们获取了`snakehead`并执行了一个复制操作，这个操作是在`Vector`类中定义的，我们让蛇自动向前移动了一个段落，因为我们希望蛇在用户开始玩游戏时自动移动。
- en: After that, the `if not inside(head) or head in snake` statement is used to
    check for any collisions. If there are any, we will return by rendering the `Red` color
    to the snake.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，`if not inside(head) or head in snake`语句用于检查是否有任何碰撞。如果有，我们将通过将`红色`渲染到蛇上来返回。
- en: In the next line of the statement, `head == food`, we checked whether the snake
    was able to eat food or not. As soon as the player eats the food, we will make
    food appear in another random position, as well as print the score in the Python
    console.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在语句的下一行`head == food`中，我们检查蛇是否能够吃到食物。一旦玩家吃到食物，我们将在另一个随机位置生成食物，并在Python控制台中打印分数。
- en: 'In the `for body in snake: ..` statement, we looped into the entire body of
    the snake and rendered the `black` color to it.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在`for body in snake: ..`语句中，我们循环遍历了蛇的整个身体，并将其渲染为`黑色`。'
- en: The `square` method, which is defined inside the `Vector` class, is called to
    create food for the game.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Vector`类内部定义的`square`方法被调用以为游戏创建食物。
- en: At the last statement of the code, the `ontimer()` method was called, which
    takes the `move()` function, and it will install a timer that will call in the
    `move` method every 100 milliseconds.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码的最后一条语句中，调用了`ontimer()`方法，该方法接受`move()`函数，并将安装一个定时器，每100毫秒调用一次`move`方法。
- en: 'After defining the `move()` method, you have to set up the game screen and
    handle the turtle screen. The parameters that are passed with the `setup` method
    are the `width`, `height`, `setx`, and `sety` positions:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了`move()`方法之后，您必须设置游戏屏幕并处理乌龟屏幕。与`setup`方法一起传递的参数是`宽度`、`高度`、`setx`和`sety`位置：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last part of our game is to handle the user events. We have to make the
    user play the game; thus, we must call the appropriate functions whenever a keyboard
    input is received from the user. As Snake is simple game, consisting of only a
    few movements, we will address it in the next section. As soon as the user presses
    any key, we have to handle it by changing the snake''s direction. Thus, we have
    to make one quick method for handling the user''s actions. The following `change()`
    method is going to change the snake''s direction, based on the user events. Here,
    we''ve used the `listen` interface provided by the turtle module, which will listen
    for any incoming user events or keyboard inputs. `onkey()` takes the function,
    which will call the change method based on the user events. For example, when
    `Up` is pressed, we will make changes in the *y* coordinate by increasing the
    current `y` value by 10 units:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们游戏的最后部分是处理用户事件。我们必须让用户玩游戏；因此，每当用户从键盘输入时，我们必须调用适当的函数。由于Snake是一个简单的游戏，只有几个移动，我们将在下一节中介绍它。一旦用户按下任意键，我们必须通过改变蛇的方向来处理它。因此，我们必须为处理用户操作制作一个快速的方法。以下的`change()`方法将根据用户事件改变蛇的方向。在这里，我们使用了turtle模块提供的`listen`接口，它将监听任何传入的用户事件或键盘输入。`onkey()`接受一个函数，该函数将根据用户事件调用change方法。例如，当按下`Up`键时，我们将通过增加当前`y`值10个单位来改变*y*坐标：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s time to run our game, but before that, remember to keep both files (the
    file containing the `vector` and the `square` class, and the file containing the
    Snake game) in the same directory. The output of the game looks something like
    this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行我们的游戏了，但在此之前，请记住将包含`vector`和`square`类的文件（以及包含Snake游戏的文件）放在同一个目录中。游戏的输出看起来像这样：
- en: '![](Images/f5bbd336-8dfb-4c54-aeb5-520decddd003.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f5bbd336-8dfb-4c54-aeb5-520decddd003.png)'
- en: 'Along with the turtle graphics, we can look at the score printed right next
    to it within the Python terminal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了乌龟图形，我们还可以在Python终端中打印分数：
- en: '![](Images/984005d2-933c-48b4-9b5d-73f9e654662a.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/984005d2-933c-48b4-9b5d-73f9e654662a.png)'
- en: Now that we have covered the Snake game by making use of several methods provided
    by the Python module and the OOP paradigm, we can reuse these things over and
    over again in the upcoming games. The `Vector` class that was defined in the `base.py`
    file can be revisited time and again for many 2D games. Thus, the reutilization
    of code is one of the prime merits that is provided by OOP. We will make several
    games, such as Pong and flappy bird, in the upcoming sections using only the `Vector`
    class. In the next section, we are going to build the Pong game from scratch.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过使用Python模块和面向对象编程范式提供的多种方法来完成了Snake游戏，我们可以在即将到来的游戏中一次又一次地重复使用这些东西。在`base.py`文件中定义的`Vector`类可以在许多2D游戏中反复使用。因此，代码的重复使用是面向对象编程提供的主要优点之一。我们将在接下来的几节中只使用`Vector`类制作几个游戏，例如乒乓球和飞翔的小鸟。在下一节中，我们将从头开始构建乒乓球游戏。
- en: Exploring the Pong game
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索乒乓球游戏
- en: 'Now that we have covered the Snake game (although it''s cliche, it''s perfect
    to grasp the knowledge of 2D game programming) now, it''s time to make another
    interesting game. The game we are going to cover in this section is the Pong game.
    If you have played it before, you might find it easier to grasp the concept that
    we will cover in this section. For those who haven''t played it before, don''t
    worry! We will cover everything in this section, which will help you make your
    very own Pong game and play it or even share it with your friends. The following
    diagram is the pictorial representation of the Pong game:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过使用Python模块和面向对象编程范式提供的多种方法来完成了Snake游戏（尽管它很陈词滥调，但它非常适合掌握2D游戏编程的知识），现在是时候制作另一个有趣的游戏了。我们将在本节中介绍的游戏是乒乓球游戏。如果您以前玩过，您可能会发现更容易理解我们将在本节中介绍的概念。对于那些以前没有玩过的人，不用担心！我们将在本节中涵盖一切，这将帮助您制作自己的乒乓球游戏并玩它，甚至与朋友分享。以下的图表是乒乓球游戏的图形表示：
- en: '![](Images/4e32203e-d7f5-4984-8af8-cbba3d9b6b76.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4e32203e-d7f5-4984-8af8-cbba3d9b6b76.png)'
- en: 'The preceding diagram depicts the playground for the Pong game, where two players
    are two rectangles. They can move up and down, but not left to right. The **dot** in
    the center is the ball, which has to be hit by either player. We have to address
    two types of motion for the game characters in this game:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表描述了乒乓游戏的游戏场地，其中两个玩家是两个矩形。他们可以上下移动，但不能左右移动。中间的**点**是球，必须由任一玩家击中。在这个游戏中，我们必须为游戏角色的两种运动类型解决问题：
- en: For the ball, which can move in any position, but if the player on either side
    fails to receive the ball, they lose, and the opposing player wins.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于球来说，它可以在任何位置移动，但如果任一方的玩家未接到球，他们将输掉比赛，而对方玩家将获胜。
- en: 'For the player, they should only move either up or down: four keyboard key
    actions should be handled for two players.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于玩家，他们只能向上或向下移动：应该处理两个玩家的四个键盘动作。
- en: 'Apart from the motion, it is even trickier to specify the boundary for the
    game. The horizontal line, which can move up and down, is the position from where
    the ball must be hit and reflected in the other direction, but if the ball hits
    either the left or right vertical boundary, the game should be halted and the
    player who missed the ball will lose. Now, let''s brainstorm so that we know about
    the essentials before actually starting to code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运动之外，为游戏指定边界甚至更加棘手。水平线可以上下移动，是球必须击中并在另一个方向上反射的位置，但如果球击中左侧或右侧的垂直边界，游戏应该停止，错过球的玩家将输掉比赛。现在，让我们进行头脑风暴，以便在实际开始编码之前了解必要的要点：
- en: Create a random function, which may return a random value but within the same
    range that is determined by the screen's height and width. The value that is returned
    from this function might be useful to make it aim, which is a random movement
    for the ball in the game.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个随机函数，它可以返回一个随机值，但在屏幕高度和宽度确定的范围内。从这个函数返回的值可能对使球在游戏中进行随机移动很有用。
- en: Create a method that will draw two rectangles on the screen, which are, in fact,
    our players of the game.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个方法，在屏幕上绘制两个矩形，实际上是我们游戏的玩家。
- en: The third function should be declared, which will draw the game and move the
    Pong ball across the screen. We can use the `move()` method, which is defined
    inside the previously made `Vector` class, which will move the vector by other
    (in-place).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该声明第三个函数，它将绘制游戏并将乒乓球移动到屏幕上。我们可以使用在先前制作的`Vector`类中定义的`move()`方法，该方法将移动向量（就地）。
- en: 'Now that we are done with the logistics, we can start to code. Follow these
    steps in order to make your own Pong game:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了后勤工作，可以开始编码了。按照以下步骤制作自己的乒乓游戏：
- en: 'Start by importing the necessary modules, that is, random, turtle, and our
    custom-made module, named `base`, which has a bunch of methods for vectored motion:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入必要的模块，即random、turtle和我们自定义的名为`base`的模块，其中包含一堆用于向量运动的方法：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code represents the definition for the `value()` method, and
    three assignments of variables. The `value()` method will randomly generate values
    between (-5, -3) and (3, 5). The three assignment statements are understandable
    by their names:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码表示`value()`方法的定义，以及三个变量的赋值。`value()`方法将在(-5, -3)和(3, 5)之间随机生成值。这三个赋值语句根据它们的名称是可以理解的：
- en: The first statement represents the initial position of the ball.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个语句表示球的初始位置。
- en: The second statement is the further aim of the ball.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个语句是球的进一步目标。
- en: 'The third statement is the `state` variable, which tracks the status of the
    two players:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个语句是`state`变量，用于跟踪两个玩家的状态：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next function is an interesting one; this will render the rectangular shape
    onto the game screen. We can use the turtle module and its method to render any
    shape, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数很有趣；这将在游戏屏幕上呈现矩形形状。我们可以使用turtle模块及其方法来呈现任何形状，如下所示：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After we make the function to draw a rectangle, we need to make a new method
    that can call the methods that were defined in the preceding steps. Along with
    this, the new method should also move the Pong ball flawlessly onto the game screen:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作绘制矩形的函数后，我们需要制作一个新的方法，该方法可以调用在前面步骤中定义的方法。除此之外，新方法还应该将乒乓球无缝地移动到游戏屏幕上：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, it''s time to address the main riddle of the game: what happens when the
    ball hits the horizontal and vertical boundaries, or when it hits the player''s
    rectangular bat ? We can use the `setup` method to create the game screen with
    a custom height and width. The following code should be added within the `draw()`
    function:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候解决游戏的主要难题了：当球击中水平和垂直边界，或者当球击中玩家的矩形球拍时会发生什么？我们可以使用`setup`方法创建具有自定义高度和宽度的游戏屏幕。以下代码应该添加到`draw()`函数中：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we''ve addressed the movement for the game characters, we have to
    make the game screen and find a way to handle user events. The following code
    will set up the game screen, which is called in from the turtle module:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经解决了游戏角色的移动问题，我们需要制作游戏屏幕并找到处理用户事件的方法。以下代码将设置游戏屏幕，该屏幕从turtle模块中调用：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After we make a game screen, we have to listen to and handle the user''s key
    events by making a custom function. We will make the `move()` function, which
    will move the player''s position by a certain number of units that are passed
    while calling this function. This move function will take care of the up and down
    movements of the rectangular bat:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作游戏屏幕后，我们必须通过制作自定义函数来监听和处理用户的键盘事件。我们将制作`move()`函数，该函数将通过在调用此函数时传递的一定数量的单位来移动玩家的位置。这个移动函数将处理矩形球拍的上下移动：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we will use the `listen` interface that is provided by the turtle
    method to handle incoming key events. Since there are four possible movements,
    that is, up and down for each player, we will reserve four keyboard keys [*W*, *S*,
    *I*, and *K*], which will have the listener attached internally by turtle, as
    shown in the code that follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用turtle方法提供的`listen`接口来处理传入的键盘事件。由于有四种可能的移动，即每个玩家的上下移动，我们将保留四个键盘键[*W*、*S*、*I*和*K*]，这些键将由turtle内部附加监听器，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous steps are quite simple to understand, but let's grasp the concepts
    we defined in *step 4* and *step 5* more eloquently. In *step 4*, the first two
    lines of code after the `clear()` method will create a rectangular geometrical
    shape of a specified height and width. `state[1]` represents the first player,
    while `state[2]` represents the second player. The `ball.move(aim)` statement
    is a call to the `move` method that is declared inside the vector class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤非常简单易懂，但让我们更加流畅地掌握*步骤4*和*步骤5*中定义的概念。在*步骤4*中，`clear()`方法之后的前两行代码将创建指定高度和宽度的矩形几何形状。`state[1]`代表第一个玩家，而`state[2]`代表第二个玩家。`ball.move(aim)`语句是对矢量类内声明的`move`方法的调用。
- en: This method call will perform the addition between the specified vectors, which
    results in a straight line of motion. The `dot(10)` statement will create a ball
    of a width of 10 units.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法调用将执行指定矢量之间的加法，结果是直线运动。`dot(10)`语句将创建一个宽度为10个单位的球。
- en: Similarly, in *step 5*, we used the `>>> setup(420, 420, 370, 0)` statement
    to create a screen that has a width of 420px and a height of 420px. There must
    be a change in direction when the ball hits the upper and lower boundaries by
    some amount, and the amount is exactly the negative of the current *y* (*-y* reverses
    the direction). However, when the ball hits either the left or right boundary,
    the game must terminate. After we check for the upper and lower boundaries, we
    make a comparison for the *x* coordinate and check for low and high states. If
    the ball is under these values, it must have collided with the bat, otherwise
    we return the `from` function. Make sure you add this code inside the previously
    defined `draw()` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在*步骤5*中，我们使用了`>>> setup(420, 420, 370, 0)`语句来创建一个宽度为420px，高度为420px的屏幕。当球击中上下边界时，必须改变方向一定量，而该量恰好是当前*y*的负值（*-y*改变方向）。然而，当球击中左边界或右边界时，游戏必须终止。在检查上下边界之后，我们对*x*坐标进行比较，并检查低和高状态。如果球在这些值下面，它必定与球拍碰撞，否则我们返回`from`函数。确保将此代码添加到先前定义的`draw()`函数中。
- en: When you run your Pong game file, you will observe two screens; one screen will
    have a turtle graphics screen consisting of two players ready to play your very
    own Pong game. The output will be similar to the diagram we saw previously when
    brainstorming the Pong game. Now that you know a lot about the ways of handling
    keyboard actions, and making a call to the custom functions with the turtle `ontimer` function,
    let's make something new, which will have a controller. It will listen for screen
    tap actions and provide responses to them. We need this in games such as flappy
    bird, where the user taps on the screen and changes the position of the bird.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Pong游戏文件时，您会看到两个屏幕；一个屏幕将有一个乌龟图形屏幕，其中包含两个玩家准备玩您自己的Pong游戏。输出将类似于我们在头脑风暴Pong游戏时之前看到的图表。现在您已经了解了处理键盘操作的方式，以及使用turtle的`ontimer`函数调用自定义函数，让我们做一些新的事情，这将有一个控制器。它将监听屏幕点击操作并对其做出响应。我们在诸如Flappy
    Bird这样的游戏中需要这个功能，用户在屏幕上点击并改变鸟的位置。
- en: Understanding the flappy bird game
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Flappy Bird游戏
- en: Whenever we talk about games having a screen-tap action or onscreen click action,
    flappy bird comes to mind. If you haven't played it before, make sure you check
    it out at [https://flappybird.io/](https://flappybird.io/) in order to get familiar
    with it. Although the interface that you see in this website won't be the same
    as the flappy bird game we are going to make in this section, don't worry—we will
    emulate its interface after we learn about Python's GUI module, known as *Pygame*.
    But for now, we will make a simple 2D flappy bird game using the Python turtle
    module and vectored motion. We have been using the `onkey` method to handle keyboard
    actions, and in the preceding section, we used the `onkey` method to embed a listener
    to the specific keyboard keys.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们谈论有屏幕点击操作或屏幕点击操作的游戏时，Flappy Bird就会浮现在脑海中。如果您以前没有玩过，确保您在[https://flappybird.io/](https://flappybird.io/)上查看它，以便熟悉它。尽管您在该网站看到的界面与我们将在本节中制作的Flappy
    Bird游戏不同，但不用担心——在学习Python的GUI模块*Pygame*之后，我们将模拟其界面。但现在，我们将使用Python turtle模块和矢量运动制作一个简单的2D
    Flappy Bird游戏。我们一直在使用`onkey`方法来处理键盘操作，在前面的部分中，我们使用`onkey`方法来嵌入特定键盘键的监听器。
- en: 'However, there are also games that can be played using mouse actions—by clicking
    onto the game screen. In this section, we are going to follow these steps in order
    to create Flappy, a game inspired by flappy bird:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些可以使用鼠标操作玩的游戏——通过点击游戏屏幕。在本节中，我们将按照以下步骤创建Flappy，这是一款受到Flappy Bird启发的游戏：
- en: First of all, you should define a boundary for the gameplay. You can make a
    function that takes an argument as a vector point and checks if it is inside the
    boundary or not and accordingly returns `True` or `False`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您应该为游戏玩法定义一个边界。您可以创建一个函数，该函数以矢量点作为参数，并检查它是否在边界内，然后相应地返回“True”或“False”。
- en: You have to make a rendering function that will draw game characters onto the
    screen. As we know, turtle is unable to handle many images or sprites in the GUI;
    therefore, your game character will resemble geometrical shapes. You can represent
    your bird character by making any shape. If possible, try to make it small.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须制作一个渲染函数，用于将游戏角色绘制到屏幕上。正如我们所知，turtle无法处理GUI中的许多图像或精灵；因此，您的游戏角色将类似于几何形状。您可以通过制作任何形状来代表您的鸟角色。如果可能的话，尽量使它小一些。
- en: After making a render function, you have to create a function that will be able
    to update the objects' positions. This function should be able to handle the `tap` action.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作了一个渲染函数之后，您需要创建一个能够更新对象位置的函数。这个函数应该能够处理`tap`动作。
- en: 'We can use the predefined `Vector` blueprint throughout the coding of the flappy
    bird game. The previous roadmap clearly implies that we can make a simple flappy
    bird game by defining three functions. Let''s define each of these functions,
    one by one:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在整个Flappy Bird游戏的编码过程中使用预定义的`Vector`蓝图。之前的路线图清楚地暗示了我们可以通过定义三个函数来制作一个简单的Flappy
    Bird游戏。让我们逐个定义这些函数：
- en: 'Firstly, you have to set up the screen. This screen represents the output game
    console where you will play our flappy bird game. You can create a game screen
    using the turtle module by using `setup()`. Let''s create a screen which has a
    width of 420 pixels and a height of 420 pixels:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要设置屏幕。这个屏幕代表了输出游戏控制台，在这里您将玩我们的Flappy Bird游戏。您可以使用海龟模块通过`setup()`来创建一个游戏屏幕。让我们创建一个宽度为420像素，高度为420像素的屏幕：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should define a function that will check whether the user has tapped or
    touched inside the boundary. This function should be a Boolean and should return
    `True` if the tapped-point is inside the boundary; otherwise, it should return `False`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该定义一个函数，用来检查用户是否在边界内点击或触摸。这个函数应该是一个布尔值，如果点击点在边界内，应该返回`True`；否则，应该返回`False`：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I have already recommended that you take a tour of the flappy bird game if
    you haven''t played it before. While playing it, you will observe that the goal
    of the game is to protect the *bird* character from the obstacles. In a real-world
    game, we have obstacles in the form of vertical pipes. Since we don''t have enough
    resources to use while coding with the turtle module, we won''t be able to use
    such sprites or interfaces in this section. As I have already told you, we are
    going to make cool interfaces by ourselves while learning about Pygame, but for
    now, instead of the GUI, we will be focusing highly on the game logic. Thus, we
    will give some random shapes to the game character; small round shapes for the
    bird character and big round shapes for the obstacles. The bird will be instantiated
    from the vector class, which represents its initial position. The ball (obstacles)
    must be made as a list because we want obstacles to be in the path of the bird:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经建议您如果以前没有玩过Flappy Bird游戏，可以去试试。在玩游戏时，您会发现游戏的目标是保护*小鸟*角色免受障碍物的影响。在现实世界游戏中，我们有垂直管道形式的障碍物。由于我们在使用海龟模块编码时没有足够的资源来使用这样的精灵或界面，我们将无法在本节中使用。正如我已经告诉过您的，我们将在学习Pygame时自己制作很酷的界面，但现在，我们将高度关注游戏逻辑，而不是GUI。因此，我们将给游戏角色一些随机形状；小圆形状的小鸟角色和大圆形状的障碍物。小鸟将从向量类实例化，表示其初始位置。球（障碍物）必须作为列表制作，因为我们希望障碍物在小鸟的路径上：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that you are familiar with the game characters, you can render them by
    creating some functions. In the function, we have passed `alive` as a variable,
    which will be a Boolean, and this will check whether the player is dead or not.
    If the bird is alive, we jump to that position using `goto()` and render a dot
    with a green color to it. If the bird is dead, we render the dot with a red color.
    The for loop in the following code will render a number of obstacles:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了游戏角色，可以通过创建一些函数来渲染它们。在函数中，我们已经传递了`alive`作为一个变量，它将是一个布尔值，这将检查玩家是否死亡。如果小鸟还活着，我们使用`goto()`跳转到该位置，并用绿色渲染一个点。如果小鸟死了，我们用红色渲染这个点。以下代码中的for循环将渲染一些障碍物：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As we discussed in the previous blueprint, next up is the main controller of
    the game. This function must perform multiple tasks, but all of them will be related
    to updating the objects'' position. It will be hard for the users who haven''t
    played flappy bird before to understand the following code; that is why I had
    encouraged you to take a tour of original flappy bird game. If you inspect the
    movement of the bird in the game, it is restricted to moving in only the *y*-axis,
    that is, either up or down. Similarly for the obstacles, they must move from right
    to left, the same as vertical pipes in the real-world game. The following `move()`
    function consists of the initial motion for the bird. Initially, we want it to
    fall by 5 units, and decrease it accordingly. For the part of bird as obstacles,
    we want it to move from right to left by 3 units:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在之前的蓝图中讨论的，接下来是游戏的主控制器。这个函数必须执行多个任务，但所有这些任务都与更新对象的位置有关。对于那些以前没有玩过Flappy
    Bird的用户来说，他们可能很难理解下面的代码；这就是为什么我鼓励您去玩原版Flappy Bird游戏。如果您检查游戏中小鸟的移动，您会发现它只能在*y*轴上移动，即上下移动。同样对于障碍物，它们必须从右向左移动，就像现实世界游戏中的垂直管道一样。以下的`move()`函数包括了小鸟的初始运动。最初，我们希望它下降5个单位，并相应地减少。对于障碍物的部分，我们希望它向左移动3个单位：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You have to explicitly create numbers of obstacles inside the `move` function.
    Since obstacles should spawn randomly, we can use a random module to create it:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须在`move`函数内明确地创建多个障碍物。由于障碍物应该随机生成，我们可以使用随机模块来创建它：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we need to check whether the player is able to prevent the bird from
    touching the obstacles. The method to check this is simple. If the ball, or obstacle,
    is out of the left vertical boundary, we can remove it from the list of balls.
    Initially, we made the `inside` function to check whether any point is within
    the boundary; now, we can use it to check whether the obstacle is within the boundary.
    It should look something like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查玩家是否能够阻止小鸟触碰障碍物。检查的方法很简单。如果球或障碍物超出了左边界，我们可以将它从球的列表中移除。最初，我们制作了`inside`函数来检查任何点是否在边界内；现在，我们可以用它来检查障碍物是否在边界内。它应该看起来像这样：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that we have added a condition for the obstacles; now, it''s time to
    add a condition to check whether the bird is alive. If the bird falls down and
    touches the lower boundary, the program should be terminated:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们已经为障碍物添加了一个条件；现在是时候添加一个条件来检查小鸟是否还活着。如果小鸟掉下来并触及下边界，程序应该终止：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we will add another condition—one that will check whether the obstacle
    has collided with the bird. There are several ways of doing this, but for now,
    we will do this by checking the position of the ball and the obstacle. Firstly,
    you have to check the size of the obstacle and the bird: the obstacle or ball
    has a size of 20 pixels, and the bird has a size of 10 pixels (defined at point
    number 4); thus, we can assume that they have collided when the distance between
    them is 0\. Thus, the `>>> if abs(ball - bird) < 15` expression will check whether
    the distance between them is less than 15 (considering the width of the ball and
    the bird):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加另一个条件——检查障碍物是否与小鸟发生了碰撞。有几种方法可以做到这一点，但现在，我们将通过检查球和障碍物的位置来实现这一点。首先，您必须检查障碍物和小鸟的大小：障碍物或球的大小为20像素，小鸟的大小为10像素（在第4点定义）；因此，我们可以假设它们在彼此之间的距离为0时发生了碰撞。因此，`>>>
    if abs(ball - bird) < 15`表达式将检查它们之间的距离是否小于15（考虑到球和小鸟的宽度）：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that we are done updating the object''s position, we need to handle user
    events—this is what should be implemented when the player taps the game screen.
    When the user taps the screen, we want the bird to rise up by a certain number
    of pixels. The argument that is passed to the tap function (*x,y*) is the coordinates
    of the clicked point on the game screen:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了更新对象的位置，我们需要处理用户事件——这是当玩家轻击游戏屏幕时应该实现的内容。当用户轻击屏幕时，我们希望小鸟上升一定数量的像素。传递给轻击函数（*x，y*）的参数是游戏屏幕上点击点的坐标：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, it''s time to add a listener using the turtle module. We will use
    the `onscreenclick()` function, which will take any user-defined function as an
    argument (in our case, it is the `tap()` function), which will be called with
    the coordinates of the clicked point (*x, y*) on the canvas. We have used the
    tap function to call this listener:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候使用turtle模块添加一个监听器了。我们将使用`onscreenclick()`函数，它将以用户定义的任何函数作为参数（在我们的情况下是`tap()`函数），并将以画布上点击点的坐标（*x，y*）调用该函数。我们已经使用tap函数来调用这个监听器：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This seems like a lot of work, right? It is indeed. We have covered so many
    things in this section: ways to define boundaries, rendering game objects, updating
    object positions, and handling tap events or mouse events. I feel that we have
    already studied a lot about 2D game architecture using the turtle module. Although
    the games that are made by using the turtle module are not very appealing, the
    logic we learned about by building these games will be used repeatedly in the
    upcoming chapters. In these types of games, we don''t care about the interface
    too much, but we will run our game into the Python shell and observe how it looks.
    The outcome of the preceding program will be something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是很多工作，对吧？的确是。在本节中，我们已经涵盖了很多内容：定义边界的方法，渲染游戏对象，更新对象位置以及处理轻击事件或鼠标事件。我觉得我们已经学到了很多关于使用turtle模块构建2D游戏的逻辑。尽管使用turtle模块制作的游戏并不是很吸引人，但我们通过构建这些游戏学到的逻辑将在接下来的章节中反复使用。在这类游戏中，我们并不太关心界面，而是会在Python
    shell中运行我们的游戏并观察它的外观。上述程序的结果将是这样的：
- en: '![](Images/6d05307b-b062-4ca1-9cbb-bf7c212d3805.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6d05307b-b062-4ca1-9cbb-bf7c212d3805.png)'
- en: '**Error message**: No module named ''base''. This is because you haven''t added
    your `Base` module (the Python file that contains the `Vector` class, which we
    made in the *Simple animation using Turtle module* section) and the Python game
    file to the same directory. Make sure you create a new directory and store the
    two files together, or grab the code from the following GitHub link: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误消息**：没有名为''base''的模块。这是因为您还没有将您的`Base`模块（包含我们在*使用Turtle模块进行简单动画*部分中制作的`Vector`类的Python文件）和Python游戏文件添加到同一个目录中。确保您创建一个新目录并将这两个文件存储在一起，或者从以下GitHub链接获取代码：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter10)。'
- en: There is little place for modifying the games that are made out of Turtle. However,
    I strongly suggest that you to go through it, test the game, and uncover the possible
    modifications by yourself. If you get any, try to implement them. In the next
    section, we will cover how to test the game properly and apply modifications so
    that these games will become more sturdy than before.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由Turtle制作的游戏，修改的空间很小。但我强烈建议您自行测试游戏，并发现可能的修改。如果您发现了任何修改，尝试实现它们。在下一节中，我们将介绍如何正确测试游戏并应用修改，使这些游戏比以前更加稳固。
- en: Game testing and possible modifications
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: 'The fallacious misconception that many people believe is that, in order to
    become a proficient game tester, you should be a gamer. This may be true to some
    extent, but mostly, game testers don''t care about the frontend design of the
    game. They primarily focus on the backend part, which deals with *data* communicating
    between game servers and client computers. I will take you through the game testing
    and modification process for our Pong game, while covering the following points:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人错误地认为，要成为一名熟练的游戏测试人员，您应该是一名游戏玩家。这在某种程度上可能是正确的，但大多数情况下，游戏测试人员并不关心游戏的前端设计。他们主要关注处理游戏服务器和客户端计算机之间的*数据*通信的后端部分。我将带您了解我们的Pong游戏的游戏测试和修改过程，同时涵盖以下几点：
- en: '**Enhancing game characters**: The following code represents the new model
    for the game characters. We implement it solely using the turtle module. The *Paddle* is
    the rectangular box, which represents the player of the pong game. There are two
    of them, namely paddle A and paddle B:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**增强游戏角色**：以下代码代表游戏角色的新模型。我们仅使用乌龟模块来实现它。*挡板*是代表乒乓球游戏玩家的矩形框。有两个，即挡板A和挡板B：'
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Adding the main character in the game** (**a ball**): Similar to the creation
    of the A and B paddles, we will use the turtle module along with commands such
    as `speed()`, `shape()`, and `color()` to create a ball character and add such
    functionalities to it:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在游戏中添加主角**（一个球）：与创建A和B挡板类似，我们将使用乌龟模块以及`speed()`、`shape()`和`color()`等命令来创建一个球角色并为其添加功能：'
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Adding a score interface to the game**:We will use the turtle pen to draw
    an interface for the points scored by each player. The following code consists
    of a method call from the turtle module, that is, the `write()` method, which
    writes text. It puts the string representation of *arg* in the specified position:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为游戏添加得分界面**：我们将使用乌龟画笔为每个玩家得分绘制一个界面。以下代码包括了从乌龟模块调用的方法，即`write()`方法，用于写入文本。它将*arg*的字符串表示放在指定位置：'
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Keyboard binding with proper actions**: In the following code, we have bound
    the keyboard with proper functions. Each keyboard key, when pressed, will call
    the specified function by using `onkeypress`; this is known as **event handling**.
    Confused with methods such as `paddle_a_up` and `paddle_b_up`? Be sure to revise
    *The Pong game* section:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**键盘绑定与适当的动作**：在以下代码中，我们已经将键盘与适当的函数绑定。每当按下键盘键时，将使用`onkeypress`调用指定的函数；这就是**事件处理**。对于`paddle_a_up`和`paddle_b_up`等方法感到困惑吗？一定要复习*乒乓球游戏*部分：'
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Turtle screen and main game loop**:The following couple of method calls represent
    the setup for the turtle screen: the screen size and title for the game. The `bgcolor()`
    method will render the background of the turtle canvas with a specified color.
    Here, the background of the screen will be a black color:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**乌龟屏幕和主游戏循环**：以下几个方法调用代表了乌龟屏幕的设置：游戏的屏幕大小和标题。`bgcolor()`方法将以指定颜色渲染乌龟画布的背景。这里，屏幕的背景将是黑色：'
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The main game loop looks a bit trickier, but if you take a look, you will see
    that we have already learned about this concept. The main loop starts by setting
    the ball in motion. The values of `dx` and `dy` are constant units for its movement.
    For the part of **#border checking**, we start by checking the condition if the
    ball hits the upper or lower wall. If so, we reverse its direction so that the
    ball comes back into the gameplay. For **#2: For RIGHT boundary**, we check if
    the ball hit the right-hand side vertical boundary, and if so, we write the score
    to another player and we end the game. The same goes for the LEFT boundary:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 主游戏循环看起来有点棘手，但如果你仔细看，你会发现我们已经了解了这个概念。主循环从设置球的运动开始。`dx`和`dy`的值是其运动的恒定单位。对于**#边界检查**部分，我们首先检查球是否击中了上下墙壁。如果是，我们就改变它的方向，让球重新进入游戏。对于**#2：对于右边界**，我们检查球是否击中了右侧的垂直边界，如果是，我们就将得分写给另一个玩家，然后结束游戏。左边界也是一样的：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we have to address the condition where the ball hits the paddle of the
    player. The following two conditions represent the collision between the paddle
    and the ball: the former one is for paddle B and the latter for paddle A. Since
    paddle B is at the right-hand side of the screen, we check whether the ball''s
    coordinate is the same as the paddle''s coordinate, plus its width. If so, we
    reverse the ball''s direction using the `ball.dx *= -1` command. The `setx` method
    will change the first coordinate of the ball to **340**, and leaves the *y* coordinate
    unchanged. The logic here is similar to the logic that we used while making the
    Snake game, when the snake''s head collided with the food:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须处理球击中玩家的挡板的情况。以下两个条件代表了挡板和球之间的碰撞：前一个是针对挡板B的，后一个是针对挡板A的。由于挡板B位于屏幕的右侧，我们检查球的坐标是否与挡板的坐标加上其宽度相同。如果是，我们使用`ball.dx
    *= -1`命令来改变球的方向。`setx`方法将把球的第一个坐标改为**340**，而将*y*坐标保持不变。这里的逻辑与我们制作贪吃蛇游戏时使用的逻辑类似，当蛇头与食物碰撞时：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The benefit of implementing such a rigorous modification is to not only enhance
    the game characters, but also to control the inconsistent frame rate—the rate
    at which consecutive images, **frames**, appear on our display screen. We will
    learn about this in detail in the upcoming chapter about *Pygame*, where we will
    customize the turtle-based Snake game by using our own sprites. Before summarizing
    this chapter, let''s run the customized Pong game and observe the result, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 实施如此严格的修改的好处不仅在于增强游戏角色，还在于控制不一致的帧速率——即连续图像（帧）在显示屏上出现的速率。我们将在即将到来的关于*Pygame*的章节中详细了解这一点，在那里我们将使用自己的精灵来定制基于乌龟的贪吃蛇游戏。在总结本章之前，让我们运行定制的乒乓球游戏并观察结果，如下所示：
- en: '![](Images/ef58bc53-4a0b-4aaa-91bc-f82cd598211b.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ef58bc53-4a0b-4aaa-91bc-f82cd598211b.png)'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the world of 2D turtle graphics, along with vectored
    motions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了2D乌龟图形的世界，以及矢量运动。
- en: I tried to make this chapter as comprehensive as I can, especially when dealing
    with vectored motion. We have created two separate files; one for the `Vector`
    class and another for the game file itself. The `Vector` class provided a way
    to represent the 2D coordinates in the *x* and *y* positions. We performed multiple
    operations, such as *move* and *rotation* using data models—overriding its actual
    behavior in our custom-made `Vector` class. We briefly observed a way of working
    with computer pixels by creating Mario pixel art. We made a grid of pixels (list
    of lists) to represent the positions of the pixels, and eventually used turtle
    methods to render the pixel art. After that, we made a simple animation using
    the turtle module by defining a separate `Vector` class which represents the position
    of the game characters. We used the turtle module and our custom-made `Vector`
    class throughout the game. Although I feel that you are ready to begin your career
    as a 2D game programmer, as we say, *Practice makes Perfect*, and you need to
    experiment with it a lot before you get comfortable with it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量使这一章尽可能全面，特别是在处理矢量运动时。我们创建了两个单独的文件；一个是`Vector`类，另一个是游戏文件本身。`Vector`类提供了一种表示*x*和*y*位置的2D坐标的方法。我们执行了多个操作，比如*move*和*rotation*，使用数据模型——覆盖了我们自定义的`Vector`类的实际行为。我们简要地观察了通过创建马里奥像素艺术来处理计算机像素的方法。我们制作了一个像素网格（列表的列表）来表示像素的位置，并最终使用turtle方法来渲染像素艺术。之后，我们通过定义一个独立的`Vector`类来制作了一个简单的动画，该类表示游戏角色的位置。我们在整个游戏过程中都使用了turtle模块和我们自定义的`Vector`类。虽然我觉得你已经准备好开始你的2D游戏程序员生涯了，但正如我们所说，“熟能生巧”，在你感到舒适之前，你需要大量尝试。
- en: This chapter was a breakthrough for all of us who want to become game programmers.
    We learned the basics of building games with Python using the turtle module, and
    we learned how to handle different user events such as a mouse and a keyboard.
    Finally, we also learned how to create different game characters using the turtle
    module. As you continue to work through this book, you will find out how extremely
    important these concepts of turtle are, so make sure that you revise them before
    moving on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章对于我们所有想成为游戏程序员的人来说都是一个突破。我们学习了使用Python和turtle模块构建游戏的基础知识，学会了如何处理鼠标和键盘等不同的用户事件。最后，我们还学会了如何使用turtle模块创建不同的游戏角色。当你继续阅读本书时，你会发现turtle的这些概念是非常重要的，所以确保在继续之前复习它们。
- en: In the next chapter, we will learn about the Pygame module—the most important
    platform for building interactive games with Python. From the next chapter onward,
    we will delve into topics about where you can load images or sprites and making
    your own game animations. You will also find out how easy it is to build games
    with Python in comparison to C or C++.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Pygame模块——这是使用Python构建交互式游戏最重要的平台。从下一章开始，我们将深入探讨一些话题，比如你可以加载图像或精灵，制作自己的游戏动画。你还会发现，与C或C++相比，使用Python构建游戏是多么容易。
