- en: Graphs and Other Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图和其他算法
- en: In this chapter, we are going to talk about graphs. This is a concept that comes
    from the branch of mathematics called graph theory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论图。 这是来自称为图论的数学分支的概念。
- en: Graphs are used to solve a number of computing problems. They also have much
    less structure than other data structures we have looked at and things like traversal
    can be much more unconventional, as we shall see.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图用于解决许多计算问题。 它们的结构比我们所看到的其他数据结构要少得多，遍历等操作可能更加不寻常，我们将会看到。
- en: 'By the end of this chapter, you should be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够做到以下几点：
- en: Understand what graphs are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解图是什么
- en: Know the types of graphs and their constituents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解图的类型及其组成部分
- en: Know how to represent a graph and traverse it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何表示图并遍历它
- en: Get a fundamental idea of what priority queues are
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对优先队列有一个基本的概念
- en: Be able to implement a priority queue
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够实现优先队列
- en: Be able to determine the ith smallest element in a list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够确定列表中第i个最小元素
- en: Graphs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: A graph is a set of vertices and edges that form connections between the vertices.
    In a more formal approach, a graph G is an ordered pair of a set V of vertices
    and a set E of edges given as `G = (V, E)` in formal mathematical notation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一组顶点和边，它们之间形成连接。 在更正式的方法中，图G是顶点集V和边集E的有序对，以`G = (V, E)`的形式给出。
- en: 'An example of a graph is given here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了一个图的示例：
- en: '![](assets/314da5e8-4407-450b-b87c-582443b5a40e.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/314da5e8-4407-450b-b87c-582443b5a40e.png)'
- en: 'Let''s now go through some definitions of a graph:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一些图的定义：
- en: '**Node or vertex**: A point, usually represented by a dot in a graph. The vertices
    or nodes are A, B, C, D, and E.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点或顶点**：图中通常由一个点表示。 顶点或节点是A、B、C、D和E。'
- en: '**Edge**: This is a connection between two vertices. The line connecting A
    and B is an example of an edge.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：这是两个顶点之间的连接。 连接A和B的线就是边的一个例子。'
- en: '**Loop**: When an edge from a node is incident on itself, that edge forms a
    loop.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环**：当来自节点的边与自身相交时，该边形成一个环。'
- en: '**Degree of a vertex**: This is the number of vertices that are incident on
    a given vertex. The degree of vertex B is `4`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点的度**：这是与给定顶点相交的顶点数。 顶点B的度为`4`。'
- en: '**Adjacency**: This refers to the connection(s) between a node and its neighbor.
    The node C is adjacent to node A because there is an edge between them.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻接**：这指的是节点与其邻居之间的连接。 节点C与节点A相邻，因为它们之间有一条边。'
- en: '**Path**: A sequence of vertices where each adjacent pair is connected by an
    edge.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：一系列顶点，其中每对相邻的顶点都由一条边连接。'
- en: Directed and undirected graphs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向和无向图
- en: 'Graphs can be classified based on whether they are undirected or directed.
    An undirected graph simply represents edges as lines between the nodes. There
    is no additional information about the relationship between the nodes than the
    fact that they are connected:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以根据它们是无向的还是有向的进行分类。 无向图简单地将边表示为节点之间的线。 除了它们连接在一起这一事实之外，关于节点之间关系的其他信息都没有：
- en: '![](assets/a00af33a-cce6-410c-87a6-b3a8127808a5.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a00af33a-cce6-410c-87a6-b3a8127808a5.jpg)'
- en: 'In a directed graph, the edges provide orientation in addition to connecting
    nodes. That is, the edges, which will be drawn as lines with an arrow, will point
    in which direction the edge connects the two nodes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边除了连接节点外还提供方向。 也就是说，边将被绘制为带有箭头的线，箭头指示边连接两个节点的方向：
- en: '![](assets/fa6d3a7d-d3ba-4c05-bf97-2ff2cc3ee21e.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fa6d3a7d-d3ba-4c05-bf97-2ff2cc3ee21e.png)'
- en: The arrow of an edge determines the flow of direction. One can only move from
    **A** to **B** in the preceding diagram. Not **B** to **A**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 边的箭头确定了方向的流动。 在上图中，只能从**A**到**B**。 而不能从**B**到**A**。
- en: Weighted graphs
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权图
- en: 'A weighted graph adds a bit of extra information to the edges. This can be
    a numerical value that indicates something. Let''s say, for example, that the
    following graph indicates different ways to get from point **A** to point **D**.
    You can either go straight from **A** to **D**, or choose to pass through **B**
    and **C**. Associated with each edge is the amount of time in minutes the journey
    to the next node will take:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图在边上添加了一些额外的信息。 这可以是指示某些内容的数值。 例如，假设以下图表表示从点**A**到点**D**的不同路径。 您可以直接从**A**到**D**，也可以选择通过**B**和**C**。
    与每条边相关的是到达下一个节点所需的时间（以分钟为单位）：
- en: '![](assets/297e002c-8a8f-467a-a1c8-ef7abeaa99c0.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/297e002c-8a8f-467a-a1c8-ef7abeaa99c0.jpg)'
- en: Perhaps the journey **AD** would require you to ride a bike (or walk). **B**
    and **C** might represent bus stops. At **B** you would have to change to a different
    bus. Finally, **CD** may be a short walk to reach **D**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也许旅程**AD**需要您骑自行车（或步行）。 **B**和**C**可能代表公交车站。 在**B**，您需要换乘另一辆公交车。 最后，**CD**可能是到达**D**的短途步行。
- en: In this example, **AD** and **ABCD** represent two different paths. **A** path
    is simply a sequence of edges that you *pass through* between two nodes. Following
    these paths, you see that the total journey **AD** takes **40** minutes, whereas
    the journey **ABCD** takes **25** minutes. If your only concern is time, you would
    be better off traveling along **ABCD**, even with the added inconvenience of changing
    buses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**AD**和**ABCD**代表两条不同的路径。 **路径**只是两个节点之间*穿过*的边的序列。 沿着这些路径，您会发现总共需要**40**分钟的旅程**AD**，而旅程**ABCD**需要**25**分钟。
    如果您唯一关心的是时间，即使需要换乘公交车，您也最好沿着**ABCD**行驶。
- en: The fact that edges can be directed and may hold other information, such as
    time taken or whatever other value the move along a path is associated with, indicates
    something interesting. In previous data structures that we have worked with, the
    *lines* we have drawn between nodes have simply been connectors. Even when they
    had arrows pointing from a node to another, that was easy to represent in the
    node class by using `next` or `previous`, `parent` or `child`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 边可以是有向的，并且可能包含其他信息，例如所花费的时间或路径上关联的其他值，这表明了一些有趣的事情。在我们之前使用的数据结构中，我们绘制的*线*只是连接器。即使它们有箭头从一个节点指向另一个节点，也可以通过在节点类中使用`next`或`previous`、`parent`或`child`来表示。
- en: With graphs, it makes sense to see edges as objects just as much as nodes. Just
    like nodes, edges can contain extra information that is necessary to follow a
    particular path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图来说，将边视为对象与节点一样是有意义的。就像节点一样，边可以包含跟随特定路径所必需的额外信息。
- en: Graph representation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表示
- en: Graphs can be represented in two main forms. One way is to use an adjacency
    matrix and the other is to use an adjacency list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以用两种主要形式表示。一种方法是使用邻接矩阵，另一种方法是使用邻接表。
- en: 'We shall be working with the following figure to develop both types of representation
    for graphs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下图来开发图的两种表示形式：
- en: '![](assets/ae318786-366f-4a2f-858c-bbf6dd4b14e0.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae318786-366f-4a2f-858c-bbf6dd4b14e0.png)'
- en: Adjacency list
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'A simple list can be used to present a graph. The indices of the list will
    represent the nodes or vertices in the graph. At each index, the adjacent nodes
    to that vertex can be stored:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用简单的列表来表示图。列表的索引将表示图中的节点或顶点。在每个索引处，可以存储该顶点的相邻节点：
- en: '![](assets/e8839a93-3591-4613-8321-298d514d2271.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e8839a93-3591-4613-8321-298d514d2271.png)'
- en: The numbers in the box represent the vertices. Index **0** represents vertex
    **A**, with its adjacent nodes being **B** and **C**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子中的数字代表顶点。索引**0**代表顶点**A**，其相邻节点为**B**和**C**。
- en: 'Using a list for the representation is quite restrictive because we lack the
    ability to directly use the vertex labels. A dictionary is therefore more suited.
    To represent the graph in the diagram, we can use the following statements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表进行表示相当受限，因为我们缺乏直接使用顶点标签的能力。因此，使用字典更合适。为了表示图中的图表，我们可以使用以下语句：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we easy establish that vertex **A** has the adjacent vertices **B** and
    **C**. Vertex F has vertex **C** as its only neighbor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们很容易确定顶点**A**有相邻顶点**B**和**C**。顶点F只有顶点**C**作为其邻居。
- en: Adjacency matrix
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: Another approach by which a graph can be represented is by using an adjacency
    matrix. A matrix is a two-dimensional array. The idea here is to represent the
    cells with a 1 or 0 depending on whether two vertices are connected by an edge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以使用邻接矩阵来表示的另一种方法。矩阵是一个二维数组。这里的想法是用1或0来表示两个顶点是否通过一条边连接。
- en: 'Given an adjacency list, it should be possible to create an adjacency matrix.
    A sorted list of keys of graph is required:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 给定邻接表，应该可以创建邻接矩阵。需要一个图的键的排序列表：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The length of the keys is used to provide the dimensions of the matrix which
    are stored in `cols` and `rows`. These values in `cols` and `rows` are equal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 键的长度用于提供矩阵的维度，这些维度存储在`cols`和`rows`中。这些值在`cols`和`rows`中是相等的：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We then set up a `cols` by `rows` array, filling it with zeros. The `edges_list`
    variable will store the tuples that form the edges of in the graph. For example,
    an edge between node A and B will be stored as (A, B).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置了一个`cols`乘以`rows`的数组，并用零填充它。`edges_list`变量将存储构成图中边的元组。例如，节点A和B之间的边将存储为(A,
    B)。
- en: 'The multidimensional array is filled using a nested for loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套的for循环填充多维数组：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The neighbors of a vertex are obtained by `graph[key]`. The key in combination
    with the `neighbor` is then used to create the tuple stored in `edges_list`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点的邻居是通过`graph[key]`获得的。然后，结合`neighbor`使用`edges_list`中存储的元组。
- en: 'The output of the iteration is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代的输出如下：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What needs to be done now is to fill the our multidimensional array by using
    1 to mark the presence of an edge with the line `adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要做的是通过使用1来填充我们的多维数组，以标记边的存在，使用行`adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `matrix_elements` array has its `rows` and `cols` starting from A through
    to E with the indices 0 through to 5\. The `for` loop iterates through our list
    of tuples and uses the `index` method to get the corresponding index where an
    edge is to be stored.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix_elements`数组的`rows`和`cols`从A到E，索引从0到5。`for`循环遍历我们的元组列表，并使用`index`方法获取要存储边的相应索引。'
- en: 'The adjacency matrix produced looks like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的邻接矩阵如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At column 1 and row 1, the 0 there represents the absence of an edge between
    A and A. On column 2 and row 3, there is an edge between C and B.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1列和第1行，0表示A和A之间没有边。在第2列和第3行，C和B之间有一条边。
- en: Graph traversal
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图遍历
- en: Since graphs don't necessarily have an ordered structure, traversing a graph
    can be more involving. Traversal normally involves keeping track of which nodes
    or vertices have already been visited and which ones have not. A common strategy
    is to follow a path until a dead end is reached, then walking back up until there
    is a point where there is an alternative path. We can also iteratively move from
    one node to another in order to traverse the full graph or part of it. In the
    next section, we will discuss breadth and depth-first search algorithms for graph
    traversal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图不一定具有有序结构，遍历图可能更加复杂。遍历通常涉及跟踪已经访问过的节点或顶点以及尚未访问过的节点或顶点。一个常见的策略是沿着一条路径走到死胡同，然后向上走，直到有一个可以选择的路径。我们也可以迭代地从一个节点移动到另一个节点，以遍历整个图或部分图。在下一节中，我们将讨论用于图遍历的广度优先搜索和深度优先搜索算法。
- en: Breadth-first search
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: The breadth-first search algorithm starts at a node, chooses that node or vertex
    as its root node, and visits the neighboring nodes, after which it explores neighbors
    on the next level of the graph.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索算法从一个节点开始，选择该节点或顶点作为其根节点，并访问相邻节点，然后探索图的下一级邻居。
- en: 'Consider the following diagram as a graph:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表作为图：
- en: '![](assets/a504a846-1f62-4eda-a404-e822ab78931b.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a504a846-1f62-4eda-a404-e822ab78931b.png)'
- en: The diagram is an example of an undirected graph. We continue to use this type
    of graph to help make explanation easy without being too verbose.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该图是一个无向图的示例。我们继续使用这种类型的图来帮助解释，而不会太啰嗦。
- en: 'The adjacency list for the graph is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图的邻接列表如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In trying to traverse this graph breadth first, we will employ the use of a
    queue. The algorithm creates a list to store the nodes that have been visited
    as the traversal process proceeds. We shall start our traversal from node A.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以广度优先的方式遍历这个图，我们将使用队列。算法创建一个列表来存储已访问的节点，随着遍历过程的进行。我们将从节点A开始遍历。
- en: Node A is queued and added to the list of visited nodes. Afterward, we use a
    `while` loop to effect traversal of the graph. In the `while` loop, node A is
    dequeued. Its unvisited adjacent nodes B, G, and D are sorted in alphabetical
    order and queued up. The queue will now contain the nodes B, D, and G. These nodes
    are also added to the list of visited nodes. At this point, we start another iteration
    of the `while` loop because the queue is not empty, which also means we are not
    really done with the traversal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 节点A被排队并添加到已访问节点的列表中。之后，我们使用`while`循环来实现对图的遍历。在`while`循环中，节点A被出队。它未访问的相邻节点B、G和D按字母顺序排序并排队。队列现在包含节点B、D和G。这些节点也被添加到已访问节点的列表中。此时，我们开始`while`循环的另一个迭代，因为队列不为空，这也意味着我们并没有真正完成遍历。
- en: Node B is dequeued. Out of its adjacent nodes A, F, and E, node A has already
    been visited. Therefore, we only enqueue the nodes E and F in alphabetical order.
    Nodes E and F are then added to the list of visited nodes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 节点B被出队。在它的相邻节点A、F和E中，节点A已经被访问。因此，我们只按字母顺序排队节点E和F。然后将节点E和F添加到已访问节点的列表中。
- en: 'Our queue now holds the following nodes at this point: D, G, E, and F. The
    list of visited nodes contains A, B, D, G, E, F.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的队列中包含以下节点：D、G、E和F。已访问节点的列表包含A、B、D、G、E、F。
- en: Node D is dequeued but all of its adjacent nodes have been visited so we simply
    dequeue it. The next node at the front of the queue is G. We dequeue node G but
    we also find out that all its adjacent nodes have been visited because they are
    in the list of visited nodes. Node G is also dequeued. We dequeue node E too because
    all of its nodes have been visited. The only node in the queue now is node F.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 节点D被出队，但是它的所有相邻节点都已经被访问过，所以我们只是出队它。队列前面的下一个节点是G。我们出队节点G，但是我们也发现它的所有相邻节点都已经被访问，因为它们在已访问节点的列表中。节点G也被出队。我们也出队节点E，因为它的所有节点都已经被访问。现在队列中唯一的节点是节点F。
- en: Node F is dequeued and we realize that out of its adjacent nodes B, D, and C,
    only node C has not been visited. We then enqueue node C and add it to the list
    of visited nodes. Node C is dequeued. Node C has the adjacent nodes F and H but
    F has already been visited, leaving node H. Node H is enqueued and added to the
    list of visited nodes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 节点F被出队，我们意识到它的相邻节点B、D和C中，只有节点C还没有被访问。然后我们将节点C排队并将其添加到已访问节点的列表中。节点C被出队。节点C有相邻节点F和H，但F已经被访问，只剩下节点H。节点H被排队并添加到已访问节点的列表中。
- en: Finally, the last iteration of the `while` loop will lead to node H being dequeued.
    Its only adjacent node C has already been visited. Once the queue is completely
    empty, the loop breaks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`while`循环的最后一次迭代将导致节点H被出队。它唯一的相邻节点C已经被访问过。一旦队列完全为空，循环就会中断。
- en: The output of the traversing the graph in the diagram is A, B, D, G, E, F, C,
    H.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中遍历的输出是A、B、D、G、E、F、C、H。
- en: 'The code for a breadth-first search is given as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索的代码如下所示：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we want to find out whether a set of nodes are in the list of visited nodes,
    we use the statement `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
    This uses the set object's difference method to find the nodes that are in `adj_nodes`
    but not in `visited_vertices`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要找出一组节点是否在已访问节点的列表中时，我们使用语句`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`。这使用了集合对象的差异方法来找出在`adj_nodes`中但不在`visited_vertices`中的节点。
- en: In the worst-case scenario, each vertex or node and edge will be traversed,
    thus the time complexity of the algorithm is `O(|V| + |E|)`, where `|V|` is the
    number of vertices or nodes while `|E|` is the number of edges in the graph.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，每个顶点或节点和边都将被遍历，因此算法的时间复杂度是`O(|V| + |E|)`，其中`|V|`是顶点或节点的数量，而`|E|`是图中边的数量。
- en: Depth-first search
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: 'As the name suggests, this algorithm traverses the depth of any particular
    path in the graph before traversing its breadth. As such, child nodes are visited
    first before sibling nodes. It works on finite graphs and requires the use of
    a stack to maintain the state of the algorithm:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，该算法在遍历广度之前遍历图中任何特定路径的深度。因此，首先访问子节点，然后访问兄弟节点。它适用于有限图，并需要使用堆栈来维护算法的状态：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The algorithm begins by creating a list to store the visited nodes. The `graph_stack`
    stack variable is used to aid the traversal process. For continuity's sake, we
    are using a regular Python list as a stack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先创建一个列表来存储已访问的节点。`graph_stack`堆栈变量用于辅助遍历过程。为了连贯起见，我们使用普通的Python列表作为堆栈。
- en: 'The starting node, called `root`, is passed with the graph''s adjacency matrix,
    graph. `root` is pushed onto the stack. `node = root` holds the first node in
    the stack:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 起始节点称为`root`，并与图的邻接矩阵`graph`一起传递。`root`被推入堆栈。`node = root`保存堆栈中的第一个节点：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The body of the `while` loop will be executed provided the stack is not empty.
    If `node` is not in the list of visited nodes, we add it. All adjacent nodes to
    `node` are collected by `adj_nodes = graph[node]`. If all the adjacent nodes have
    been visited, we pop that node from the stack and set `node` to `graph_stack[-1]`.
    `graph_stack[-1]` is the top node on the stack. The `continue` statement jumps
    back to the beginning of the while loop's test condition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的主体将被执行，前提是堆栈不为空。如果`node`不在已访问节点的列表中，我们将其添加进去。`node`的所有相邻节点都被`adj_nodes
    = graph[node]`收集起来。如果所有相邻节点都已经被访问过，我们就从堆栈中弹出该节点，并将`node`设置为`graph_stack[-1]`。`graph_stack[-1]`是堆栈顶部的节点。`continue`语句跳回到`while`循环的测试条件的开头。'
- en: If, on the other hand, not all the adjacent nodes have been visited, the nodes
    that are yet to be visited are obtained by finding the difference between the
    `adj_nodes` and `visited_vertices` with the statement `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果并非所有相邻节点都已经被访问，那么通过使用语句`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`来找到尚未访问的节点。
- en: The first item within `sorted(remaining_elements)` is assigned to `first_adj_node`,
    and pushed onto the stack. We then point the top of the stack to this node.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sorted(remaining_elements)`中的第一个项目被分配给`first_adj_node`，并被推入堆栈。然后我们将堆栈的顶部指向这个节点。
- en: When the `while` loop exists, we will return the `visited_vertices`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环结束时，我们将返回`visited_vertices`。
- en: 'Dry running the algorithm will prove useful. Consider the following graph:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对算法进行干扰运行将会很有用。考虑以下图表：
- en: '![](assets/9d0766e9-a5f6-44e9-94e9-430d7e17d19e.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d0766e9-a5f6-44e9-94e9-430d7e17d19e.png)'
- en: 'The adjacency list of such a graph is given as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个图的邻接列表如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Node A is chosen as our beginning node. Node A is pushed onto the stack and
    added to the `visisted_vertices` list. In doing so, we mark it as having been
    visited. The stack `graph_stack` is implemented with a simple Python list. Our
    stack now has A as its only element. We examine node A''s adjacent nodes B and
    S. To test whether all the adjacent nodes of A have been visited, we use the if
    statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 节点A被选择为我们的起始节点。节点A被推入堆栈，并添加到`visisted_vertices`列表中。这样做时，我们标记它已经被访问。堆栈`graph_stack`是用简单的Python列表实现的。我们的堆栈现在只有A一个元素。我们检查节点A的相邻节点B和S。为了测试节点A的所有相邻节点是否都已经被访问，我们使用if语句：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If all the nodes have been visited, we pop the top of the stack. If the stack
    `graph_stack` is not empty, we assign the node on top of the stack to `node` and
    start the beginning of another execution of the body of the `while` loop. The
    statement `set(adj_nodes).issubset(set(visited_vertices))` will evaluate to `True`
    if all the nodes in `adj_nodes` are a subset of `visited_vertices`. If the if
    statement fails, it means that some nodes remain to be visited. We obtain that
    list of nodes with `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都已经被访问，我们就弹出堆栈的顶部。如果堆栈`graph_stack`不为空，我们就将堆栈顶部的节点赋给`node`，并开始另一个`while`循环主体的执行。语句`set(adj_nodes).issubset(set(visited_vertices))`将在`adj_nodes`中的所有节点都是`visited_vertices`的子集时评估为`True`。如果if语句失败，这意味着还有一些节点需要被访问。我们可以通过`remaining_elements
    = set(adj_nodes).difference(set(visited_vertices))`获得这些节点的列表。
- en: 'From the diagram, nodes **B** and **S** will be stored in `remaining_elements`.
    We will access the list in alphabetical order:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中，节点**B**和**S**将被存储在`remaining_elements`中。我们将按字母顺序访问列表：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We sort `remaining_elements` and return the first node to `first_adj_node`.
    This will return B. We push node B onto the stack by appending it to the `graph_stack`.
    We prepare node B for access by assigning it to `node`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`remaining_elements`进行排序，并将第一个节点返回给`first_adj_node`。这将返回B。我们通过将其附加到`graph_stack`来将节点B推入堆栈。我们通过将其分配给`node`来准备访问节点B。
- en: On the next iteration of the `while` loop, we add node B to the list of `visited
    nodes`. We discover that the only adjacent node to B, which is A, has already
    been visited. Because all the adjacent nodes of B have been visited, we pop it
    off the stack, leaving node A as the only element on the stack. We return to node
    A and examine whether all of its adjacent nodes have been visited. The node A
    now has S as the only unvisited node. We push S to the stack and begin the whole
    process again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的下一次迭代中，我们将节点B添加到`visited nodes`列表中。我们发现B的唯一相邻节点A已经被访问过。因为B的所有相邻节点都已经被访问，我们将其从堆栈中弹出，只留下节点A。我们返回到节点A，并检查它的所有相邻节点是否都已经被访问。现在节点A只有S是未访问的节点。我们将S推入堆栈，并重新开始整个过程。
- en: The output of the traversal is A-B-S-C-D-E-H-G-F.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的输出是A-B-S-C-D-E-H-G-F。
- en: Depth-first searches find application in solving maze problems, finding connected
    components, and finding the bridges of a graph, among others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索在解决迷宫问题、查找连通分量和查找图的桥梁等方面有应用。
- en: Other useful graph methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的图方法
- en: Very often, you are concerned with finding a path between two nodes. You may
    also want to find all the paths between nodes. Another useful method would be
    to find the shortest path between nodes. In an unweighted graph, this would simply
    be the path with the lowest number of edges between them. In a weighted graph,
    as you have seen, this could involve calculating the total weight of passing through
    a set of edges.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常关心的是找到两个节点之间的路径。您可能还希望找到节点之间的所有路径。另一个有用的方法是找到节点之间的最短路径。在无权图中，这只是它们之间边的最小数量的路径。在加权图中，正如您所见，这可能涉及计算通过一组边的总权重。
- en: Of course, in a different situation, you may want to find the longest or shortest
    path.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在不同的情况下，您可能希望找到最长或最短的路径。
- en: Priority queues and heaps
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列和堆
- en: A priority queue is basically a type of queue that will always return items
    in order of priority. This priority could be, for example, that the lowest item
    is always popped off first. Although it is called a queue, priority queues are
    often implemented using a heap, since it is very efficient for this purpose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列基本上是一种按优先级顺序返回项目的队列类型。这个优先级可以是，例如，最低的项目总是先弹出。虽然它被称为队列，但优先队列通常使用堆来实现，因为对于这个目的来说非常高效。
- en: Consider that, in a store, customers queue in a line where service is only rendered
    at the front of the queue. Each customer will spend some time in the queue to
    get served. If the waiting times for the customers in the queue are 4, 30, 2,
    and 1, then the average time spent in the queue becomes `(4 + 34 + 36 + 37)/4`,
    which is `27.75`. However, if we change the order of service such that customers
    with the least amount of waiting time are served first, then we obtain a different
    average waiting time. In doing so, we calculate our new average waiting time by
    `(1 + 3 + 7 + 37)/4`, which now equals `12`, a better average waiting time. Clearly,
    there is merit to serving the customers from the least waiting time upward. This
    method of selecting the next item by priority or some other criterion is the basis
    for creating priority queues.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到，在商店中，顾客排队等候，服务只在队列的前面提供。每个顾客都会花一些时间在队列中等待服务。如果队列中顾客的等待时间分别为4、30、2和1，那么队列中的平均等待时间变为`(4
    + 34 + 36 + 37)/4`，即`27.75`。然而，如果我们改变服务顺序，使等待时间最短的顾客先接受服务，那么我们会得到不同的平均等待时间。这样做，我们通过`(1
    + 3 + 7 + 37)/4`计算我们的新平均等待时间，现在等于`12`，一个更好的平均等待时间。显然，按照等待时间最少的顾客开始服务是有益的。按照优先级或其他标准选择下一个项目的方法是创建优先队列的基础。
- en: A heap is a data structure that satisfies the heap property. The heap property
    states that there must be a certain relationship between a parent node and its
    child nodes. This property must apply through the entire heap.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是满足堆属性的数据结构。堆属性规定父节点和其子节点之间必须存在一定的关系。这个属性必须适用于整个堆。
- en: In a min heap, the relationship between parent and children is that the parent
    must always be less than or equal to its children. As a consequence of this, the
    lowest element in the heap must be the root node.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小堆中，父节点和子节点之间的关系是父节点必须始终小于或等于其子节点。由于这个关系，堆中最小的元素必须是根节点。
- en: In a max heap, on the other hand, the parent is greater than or equal to its
    child or its children. It follows from this that the largest value makes up the
    root node.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在最大堆中，父节点大于或等于其子节点。由此可知，最大值组成了根节点。
- en: As you can see from what we just mentioned, heaps are trees and, to be more
    specific, binary trees.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们刚刚提到的内容中可以看出，堆是树，更具体地说，是二叉树。
- en: 'Although we are going to use a binary tree, we will actually use a list to
    represent it. This is possible because the heap will store a complete binary tree.
    A complete binary tree is one in which each row must be fully filled before starting
    to fill the next row:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将使用二叉树，但实际上我们将使用一个列表来表示它。这是可能的，因为堆将存储一个完全二叉树。完全二叉树是指在开始填充下一行之前，每一行必须完全填满：
- en: '![](assets/69b6c928-300f-4b6f-a4f3-5e4d84c63cae.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/69b6c928-300f-4b6f-a4f3-5e4d84c63cae.jpg)'
- en: 'To make the math with indexes easier, we are going to leave the first item
    in the list (index 0) empty. After that, we place the tree nodes into the list,
    from top to bottom, left to right:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使索引的数学运算更容易，我们将保留列表中的第一项（索引0）为空。之后，我们将树节点从上到下、从左到右放入列表中：
- en: '![](assets/908ee528-61fc-4fe4-8ed4-f9c34a763f6f.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/908ee528-61fc-4fe4-8ed4-f9c34a763f6f.jpg)'
- en: If you observe carefully, you will notice that you can retrieve the children
    of any node n very easily. The left child is located at `2n` and the right child
    is located at `2n + 1`. This will always hold true.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会注意到你可以很容易地检索任何节点n的子节点。左子节点位于`2n`，右子节点位于`2n + 1`。这总是成立的。
- en: 'We are going to look at a min heap implementation. It shouldn''t be difficult
    to reverse the logic in order to get a max heap:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个最小堆的实现。反过来得到最大堆的逻辑应该不难。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We initialize our heap list with a zero to represent the dummy first element
    (remember that we are only doing this to make the math simpler). We also create
    a variable to hold the size of the heap. This would not be necessary as such,
    since we could check the size of the list, but we would always have to remember
    to reduce it by one. So we chose to keep a separate variable instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用零初始化我们的堆列表，以表示虚拟的第一个元素（请记住，我们只是为了简化数学而这样做）。我们还创建一个变量来保存堆的大小。这不是必需的，因为我们可以检查列表的大小，但我们总是要记得减去一个。所以我们选择保持一个单独的变量。
- en: Inserting
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: Inserting an item is very simple in itself. We add the new element to the end
    of the list (which we understand to be the bottom of the tree). Then we increment
    the size of the heap by one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个项目本身非常简单。我们将新元素添加到列表的末尾（我们理解为树的底部）。然后我们将堆的大小增加一。
- en: 'But after each insert, we need to float the new element up if needed. Bear
    in mind that the lowest element in the min heap needs to be the root element.
    We first create a helper method called `float` that takes care of this. Let us
    look at how it is meant to behave. Imagine that we have the following heap and
    want to insert the value `2`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在每次插入后，如果需要，我们需要将新元素浮动起来。请记住，最小堆中最小的元素需要是根元素。我们首先创建一个名为`float`的辅助方法来处理这个问题。让我们看看它应该如何行为。想象一下我们有以下堆，并且想要插入值`2`：
- en: '![](assets/e6a9c152-f5f6-4ca7-a420-cb01171a9ff2.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e6a9c152-f5f6-4ca7-a420-cb01171a9ff2.jpg)'
- en: 'The new element has occupied the last slot in the third row or level. Its index
    value is **7**. Now we compare that value with its parent. The parent is at index
    `7/2 = 3` (integer division). That element holds **6** so we swap the **2**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素占据了第三行或级别中的最后一个插槽。它的索引值是**7**。现在我们将该值与其父元素进行比较。父元素位于索引`7/2 = 3`（整数除法）。该元素持有**6**，所以我们交换**2**：
- en: '![](assets/1646d43e-9a53-45d8-813b-7deece8019e7.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1646d43e-9a53-45d8-813b-7deece8019e7.jpg)'
- en: 'Our new element has been swapped and moved up to index **3**. We have not reached
    the top of the heap yet (`3 / 2 > 0`), so we continue. The new parent of our element
    is at index `3/2 = 1`. So we compare and, if necessary, swap again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新元素已经被交换并移动到索引**3**。我们还没有到达堆的顶部（`3 / 2 > 0`），所以我们继续。我们元素的新父节点在索引`3/2 = 1`。所以我们比较并且如果需要的话再次交换：
- en: '![](assets/f1653f9b-b5d1-4651-a409-efb01743a112.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f1653f9b-b5d1-4651-a409-efb01743a112.jpg)'
- en: 'After the final swap, we are left with the heap looking as follows. Notice
    how it adheres to the definition of a heap:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次交换之后，我们得到了以下堆。请注意它如何符合堆的定义：
- en: '![](assets/e9ef20a5-3355-455b-a953-453641987aa6.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9ef20a5-3355-455b-a953-453641987aa6.jpg)'
- en: 'Here follows an implementation of what we have just described:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们刚刚描述的实现：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are going to loop until we have reached the root node so that we can keep
    floating the element up as high as it needs to go. Since we are using integer
    division, as soon as we get below 2, the loop will break out:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环直到达到根节点，以便我们可以将元素浮动到需要到达的最高位置。由于我们使用整数除法，一旦我们低于2，循环就会中断：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compare parent and child. If the parent is greater than the child, swap the
    two values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 比较父节点和子节点。如果父节点大于子节点，则交换两个值：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let''s not forget to move up the tree:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记向上移动树：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This method ensures that the elements are ordered properly. Now we just need
    to call this from our `insert` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法确保元素被正确排序。现在我们只需要从我们的`insert`方法中调用它：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the last line in insert calls the `float()` method to reorganize the
    heap as necessary.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`insert`中的最后一行调用了`float()`方法来根据需要重新组织堆。
- en: Pop
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出
- en: Just like insert, `pop()` is by itself a simple operation. We remove the root
    node and decrement the size of the heap by one. However, once the root has been
    popped off, we need a new root node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像插入一样，`pop()`本身是一个简单的操作。我们移除根节点并将堆的大小减一。然而，一旦根节点被弹出，我们需要一个新的根节点。
- en: 'To make this as simple as possible, we just take the last item in the list
    and make it the new root. That is, we move it to the beginning of the list. But
    now we might not have the lowest element at the top of the heap, so we perform
    the opposite of the float operation: we let the new root node sink down as required.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简单，我们只需取列表中的最后一个项目并将其作为新的根。也就是说，我们将它移动到列表的开头。但现在我们可能不会在堆的顶部有最小的元素，所以我们执行与`float`操作相反的操作：让新的根节点根据需要下沉。
- en: 'As we did with insert, let us have a look at how the whole operation is meant
    to work on an existing heap. Imagine the following heap. We pop off the `root`
    element, leaving the heap temporarily rootless:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入一样，让我们看看整个操作在现有堆上是如何工作的。想象一下以下堆。我们弹出`root`元素，暂时使堆没有根：
- en: '![](assets/1eb8cd9b-d17d-4c76-8854-5bb8ca4edb34.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1eb8cd9b-d17d-4c76-8854-5bb8ca4edb34.jpg)'
- en: 'Since we cannot have a rootless heap, we need to fill this slot with something.
    If we choose to move up one of the children, we will have to figure out how to
    rebalance the entire tree structure. So instead, we do something really interesting.
    We move up the very last element in the list to fill the position of the `root`
    element:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能有一个没有根的堆，我们需要用某物填充这个位置。如果我们选择将一个子节点移上去，我们将不得不弄清楚如何重新平衡整个树结构。所以，我们做一些非常有趣的事情。我们将列表中的最后一个元素移上去填充`root`元素的位置：
- en: '![](assets/85ef095d-22b3-450c-87b7-6e51d530ac49.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85ef095d-22b3-450c-87b7-6e51d530ac49.jpg)'
- en: 'Now this element clearly is not the lowest in the heap. This is where we begin
    to sink it down. First we need to determine where to sink it down. We compare
    the two children, so that the lowest element will be the one to float up as the
    root sinks down:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个元素显然不是堆中最小的。这就是我们开始将其下沉的地方。首先我们需要确定将其下沉到哪里。我们比较两个子节点，以便较小的元素将作为根节点下沉时浮动上去：
- en: '![](assets/13caacb4-06e6-4206-823c-720d634f2268.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13caacb4-06e6-4206-823c-720d634f2268.jpg)'
- en: 'The right child is clearly less. Its index is **3**, which represents the root
    index `* 2 + 1`. We go ahead and compare our new root node with the value at this
    index:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 右子节点显然更小。它的索引是**3**，代表根索引`* 2 + 1`。我们继续将我们的新根节点与该索引处的值进行比较：
- en: '![](assets/c99e234d-5ac4-4f47-8083-768d443bb116.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c99e234d-5ac4-4f47-8083-768d443bb116.jpg)'
- en: 'Now our node has jumped down to index **3**. We need to compare it to the lesser
    of its children. However, now we only have one child, so we don''t need to worry
    about which child to compare against (for a min heap, it is always the lesser
    child):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的节点跳到了索引**3**。我们需要将其与较小的子节点进行比较。然而，现在我们只有一个子节点，所以我们不需要担心要与哪个子节点进行比较（对于最小堆来说，它总是较小的子节点）：
- en: '![](assets/601969bf-ac39-4be8-8160-e2ec826e6e9a.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/601969bf-ac39-4be8-8160-e2ec826e6e9a.jpg)'
- en: There is no need to swap here. Since there are no more rows either, we are done.
    Notice again how, after the `sink()` operation is completed, our heap adheres
    to the definition of a heap.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要交换。由于没有更多的行，我们完成了。请再次注意，在`sink()`操作完成后，我们的堆符合堆的定义。
- en: 'Now we can begin implementing this. Before we do the `sink()` method itself,
    notice how we need to determine which of the children to compare our parent node
    against. Well, let us put that selection in its own little method, just to make
    the code look a little simpler:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现这个。在执行`sink()`方法之前，注意我们需要确定要将父节点与哪个子节点进行比较。好吧，让我们把这个选择放在自己的小方法中，这样代码看起来会简单一些：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We may get beyond the end of the list, in which case we return the index of
    the left child:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会超出列表的末尾，在这种情况下，我们返回左子节点的索引：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Otherwise, we simply return the index of the lesser of the two children:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们只需返回较小的两个子节点的索引：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can create the `sink` function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`sink`函数：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As before, we are going to loop so that we can sink our element down as far
    as is needed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们将循环以便将我们的元素下沉到所需的位置：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next we need to know which of the left or the right child to compare against.
    This is where we make use of the `minindex()` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道左侧还是右侧的子节点进行比较。这就是我们使用`minindex()`函数的地方：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we did in the `float()` method, we compare parent and child to see whether
    we need to swap:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`float()`方法中所做的那样，我们比较父节点和子节点，看看是否需要交换：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And we need to make sure that we move down the tree so that we don''t get stuck
    in a loop:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保向下移动树，以免陷入循环：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The only thing remaining now is to implement `pop()` itself. This is very straightforward
    as the grunt work is performed by the `sink()` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的就是实现`pop()`本身。这非常简单，因为`sink()`方法执行了大部分工作：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Testing the heap
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试堆
- en: 'Now we just need some code to test the heap. We begin by creating our heap
    and inserting some data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一些代码来测试堆。我们首先创建我们的堆并插入一些数据：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can print the heap list, just to inspect how the elements are ordered. If
    you redraw this as a tree structure, you should notice that it meets the required
    properties of a heap:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印堆列表，只是为了检查元素的排序方式。如果你将其重新绘制为树形结构，你应该注意到它满足堆的所需属性：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we will pop off the items, one at a time. Notice how the items come out
    in a sorted order, from lowest to highest. Also notice how the heap list changes
    after each pop. It is a good idea to take out a pen and paper and to redraw this
    list as a tree after each pop, to fully understand how the `sink()` method works:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将一个一个地弹出项目。注意项目是如何按照从低到高的顺序出来的。还要注意每次弹出后堆列表是如何改变的。最好拿出纸和笔，在每次弹出后重新绘制这个列表作为一棵树，以充分理解`sink()`方法的工作原理：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the chapter on sorting algorithms, we will reorganize the code for the heap
    sort algorithm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序算法的章节中，我们将重新组织堆排序算法的代码。
- en: Once you have the min heap working properly and understand how it works, it
    should be a simple task to implement a max heap. All you have to do is to reverse
    the logic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的最小堆正常工作并且了解它的工作原理，实现最大堆应该是一项简单的任务。你所需要做的就是颠倒逻辑。
- en: Selection algorithms
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: Selection algorithms fall under a class of algorithms that seek to answer the
    problem of finding the ith-smallest element in a list. When a list is sorted in
    ascending order, the first element in the list will be the smallest item in the
    list. The second element in the list will be the second-smallest element in the
    list. The last element in the list will be the last-smallest element in the list
    but that will also qualify as the largest element in the list.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 选择算法属于一类算法，旨在解决在列表中找到第i小元素的问题。当列表按升序排序时，列表中的第一个元素将是列表中最小的项。列表中的第二个元素将是列表中第二小的元素。列表中的最后一个元素将是列表中最小的元素，但也将符合列表中最大的元素。
- en: In creating the heap data structure, we have come to the understanding that
    a call to the `pop` method will return the smallest element in the heap. The first
    element to pop off a min heap is the first-smallest element in the list. Similarly,
    the seventh element to be popped off the min heap will be the seventh-smallest
    element in the list. Therefore, to find the ith-smallest element in a list will
    require us to pop the heap *i* number of times. That is a very simple and efficient
    way of finding the ith-smallest element in a list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建堆数据结构时，我们已经了解到调用`pop`方法将返回堆中最小的元素。从最小堆中弹出的第一个元素是列表中第一个最小的元素。同样，从最小堆中弹出的第七个元素将是列表中第七小的元素。因此，要找到列表中第i小的元素，我们需要弹出堆*i*次。这是在列表中找到第i小的元素的一种非常简单和高效的方法。
- en: But in [Chapter 14](d284cb2f-9636-47b1-b416-c84eb5be9fd2.xhtml), *Selection
    Algorithms*, we will study another approach by which we can find the ith-smallest
    element in a list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但在[第14章](d284cb2f-9636-47b1-b416-c84eb5be9fd2.xhtml)中，*选择算法*，我们将学习另一种方法，通过这种方法我们可以在列表中找到第i小的元素。
- en: Selection algorithms have applications in filtering out noisy data, finding
    the median, smallest, and largest elements in a list, and can even be applied
    in computer chess programs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 选择算法在过滤嘈杂数据、查找列表中的中位数、最小和最大元素以及甚至可以应用于计算机国际象棋程序中。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Graphs and heaps have been treated in this chapter. We looked at ways to represent
    a graph in Python using lists and dictionaries. In order to traverse the graph,
    we looked at breadth-first searches and depth-first searches.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了图和堆。我们研究了使用列表和字典在Python中表示图的方法。为了遍历图，我们研究了广度优先搜索和深度优先搜索。
- en: We then switched our attention to heaps and priority queues to understand their
    implementation. The chapter ended with using the concept of a heap to find the
    ith-smallest element in a list.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将注意力转向堆和优先队列，以了解它们的实现。本章以使用堆的概念来找到列表中第i小的元素而结束。
- en: The subject of graphs is very complicated and just one chapter will not do justice
    to it. The journey with nodes will end with this chapter. The next chapter will
    usher us into the arena of searching and the various means by which we can efficiently
    search for items in lists.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图的主题非常复杂，仅仅一章是不够的。与节点的旅程将在本章结束。下一章将引领我们进入搜索的领域，以及我们可以有效搜索列表中项目的各种方法。
