- en: Python Design Patterns II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python设计模式II
- en: 'In this chapter, we will be introduced to several more design patterns. Once
    again, we''ll cover the canonical examples as well as any common alternative implementations
    in Python. We''ll be discussing the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍更多的设计模式。我们将再次介绍经典示例以及Python中常见的替代实现。我们将讨论以下内容：
- en: The adapter pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The facade pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观模式
- en: Lazy initialization and the flyweight pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化和享元模式
- en: The command pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The abstract factory pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The composition pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合模式
- en: The adapter pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Unlike most of the patterns we reviewed in the previous chapter, the adapter
    pattern is designed to interact with existing code. We would not design a brand
    new set of objects that implement the adapter pattern. Adapters are used to allow
    two preexisting objects to work together, even if their interfaces are not compatible.
    Like the display adapters that allow you to plug your Micro USB charging cable
    into a USB-C phone, an adapter object sits between two different interfaces, translating
    between them on the fly. The adapter object's sole purpose is to perform this
    translation. Adapting may entail a variety of tasks, such as converting arguments
    to a different format, rearranging the order of arguments, calling a differently
    named method, or supplying default arguments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一章中审查的大多数模式不同，适配器模式旨在与现有代码交互。我们不会设计一组全新的实现适配器模式的对象。适配器用于允许两个现有对象一起工作，即使它们的接口不兼容。就像显示适配器允许您将Micro
    USB充电线插入USB-C手机一样，适配器对象位于两个不同接口之间，在其间进行实时翻译。适配器对象的唯一目的是执行这种翻译。适配可能涉及各种任务，例如将参数转换为不同格式，重新排列参数的顺序，调用不同命名的方法或提供默认参数。
- en: 'In structure, the adapter pattern is similar to a simplified decorator pattern.
    Decorators typically provide the same interface that they replace, whereas adapters
    map between two different interfaces. This is depicted in UML form in the following
    diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构上，适配器模式类似于简化的装饰器模式。装饰器通常提供与其替代物相同的接口，而适配器在两个不同的接口之间进行映射。这在以下图表中以UML形式表示：
- en: '![](assets/f676a8bb-86fa-4186-8fc0-16d8bfb0f58a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f676a8bb-86fa-4186-8fc0-16d8bfb0f58a.png)'
- en: Here, **Interface1 **is expecting to call a method called **make_action(some,
    arguments)**. We already have this perfect **Interface2** class that does everything
    we want (and to avoid duplication, we don't want to rewrite it!), but it provides
    a method called **different_action(other, arguments)** instead. The **Adapter**
    class implements the **make_action** interface and maps the arguments to the existing
    interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**Interface1**期望调用一个名为**make_action(some, arguments)**的方法。我们已经有了完美的**Interface2**类，它做了我们想要的一切（为了避免重复，我们不想重写它！），但它提供的方法名为**different_action(other,
    arguments)**。**Adapter**类实现了**make_action**接口，并将参数映射到现有接口。
- en: The advantage here is that the code that maps from one interface to another
    is all in one place. The alternative would be really ugly; we'd have to perform
    the translation in multiple places whenever we need to access this code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势在于，从一个接口映射到另一个接口的代码都在一个地方。另一种选择将会非常丑陋；每当我们需要访问这段代码时，我们都必须在多个地方执行翻译。
- en: 'For example, imagine we have the following preexisting class, which takes a
    string date in the format `YYYY-MM-DD` and calculates a person''s age on that
    date:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下现有类，它接受格式为`YYYY-MM-DD`的字符串日期并计算该日期时的人的年龄：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a pretty simple class that does what it's supposed to do. But we have
    to wonder what the programmer was thinking, using a specifically formatted string
    instead of using Python's incredibly useful built-in `datetime` library. As conscientious
    programmers who reuse code whenever possible, most of the programs we write will
    interact with `datetime` objects, not strings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类，它完成了它应该完成的工作。但我们不得不思考程序员当时在想什么，为什么要使用特定格式的字符串，而不是使用Python中非常有用的内置`datetime`库。作为尽可能重用代码的负责任的程序员，我们编写的大多数程序将与`datetime`对象交互，而不是字符串。
- en: We have several options to address this scenario. We could rewrite the class
    to accept `datetime` objects, which would probably be more accurate anyway. But
    if this class had been provided by a third party and we don't know how to or can't
    change its internal structure, we need an alternative. We could use the class
    as it is, and whenever we want to calculate the age on a `datetime.date` object,
    we could call `datetime.date.strftime('%Y-%m-%d')` to convert it to the proper
    format. But that conversion would be happening in a lot of places, and worse,
    if we mistyped the `%m` as `%M`, it would give us the current minute instead of
    the  month entered. Imagine if you wrote that in a dozen different places only
    to have to go back and change it when you realized your mistake. It's not maintainable
    code, and it breaks the DRY principle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种选择来解决这种情况。我们可以重写类以接受`datetime`对象，这可能更准确。但如果这个类是由第三方提供的，我们不知道如何或不能改变它的内部结构，我们需要另一种选择。我们可以使用原样的类，每当我们想要计算`datetime.date`对象上的年龄时，我们可以调用`datetime.date.strftime('%Y-%m-%d')`将其转换为正确的格式。但这种转换会发生在很多地方，更糟糕的是，如果我们将`%m`误写为`%M`，它会给我们当前的分钟而不是输入的月份。想象一下，如果您在十几个不同的地方写了这个，然后当您意识到错误时不得不返回并更改它。这不是可维护的代码，它违反了DRY原则。
- en: 'Instead, we can write an adapter that allows a normal date to be plugged into
    a normal `AgeCalculator` class, as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以编写一个适配器，允许将普通日期插入普通的`AgeCalculator`类，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This adapter converts `datetime.date` and `datetime.time` (they have the same
    interface to `strftime`) into a string that our original `AgeCalculator` can use.
    Now we can use the original code with our new interface. I changed the method
    signature to `get_age` to demonstrate that the calling interface may also be looking
    for a different method name, not just a different type of argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个适配器将`datetime.date`和`datetime.time`（它们具有相同的接口到`strftime`）转换为一个字符串，以便我们原始的`AgeCalculator`可以使用。现在我们可以使用原始代码与我们的新接口。我将方法签名更改为`get_age`，以演示调用接口可能也在寻找不同的方法名称，而不仅仅是不同类型的参数。
- en: 'Creating a class as an adapter is the usual way to implement this pattern,
    but, as usual, there are other ways to do it in Python. Inheritance and multiple
    inheritance can be used to add functionality to a class. For example, we could
    add an adapter on the `date` class so that it works with the original `AgeCalculator`
    class, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类作为适配器是实现这种模式的常规方法，但是，通常情况下，在Python中还有其他方法可以实现。继承和多重继承可以用于向类添加功能。例如，我们可以在`date`类上添加一个适配器，以便它与原始的`AgeCalculator`类一起使用，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s code like this that makes one wonder whether Python should even be legal.
    We have added a `split` method to our subclass that takes a single argument (which
    we ignore) and returns a tuple of year, month, and day. This works flawlessly
    with the original `AgeCalculator` class because the code calls `strip` on a specially
    formatted string, and `strip`, in that case, returns a tuple of year, month, and
    day. The `AgeCalculator` code only cares if `strip` exists and returns acceptable
    values; it doesn''t care if we really passed in a string. The following code really
    works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的代码让人怀疑Python是否应该合法。我们已经为我们的子类添加了一个`split`方法，它接受一个参数（我们忽略），并返回一个年、月和日的元组。这与原始的`AgeCalculator`类完美配合，因为代码在一个特殊格式的字符串上调用`strip`，而在这种情况下，`strip`返回一个年、月和日的元组。`AgeCalculator`代码只关心`strip`是否存在并返回可接受的值；它并不关心我们是否真的传入了一个字符串。以下代码确实有效：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It works but it's a stupid idea. In this particular instance, such an adapter
    would be hard to maintain. We'd soon forget why we needed to add a `strip` method
    to a `date` class. The method name is ambiguous. That can be the nature of adapters,
    but creating an adapter explicitly instead of using inheritance usually clarifies
    its purpose.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效，但这是一个愚蠢的想法。在这种特定情况下，这样的适配器将很难维护。我们很快会忘记为什么需要向`date`类添加一个`strip`方法。方法名称是模糊的。这可能是适配器的性质，但是显式创建一个适配器而不是使用继承通常可以澄清其目的。
- en: Instead of inheritance, we can sometimes also use monkey-patching to add a method
    to an existing class. It won't work with the `datetime` object, as it doesn't
    allow attributes to be added at runtime.  In normal classes, however, we can just
    add a new method that provides the adapted interface that is required by calling
    code. Alternatively, we could extend or monkey-patch the `AgeCalculator` itself
    to replace the `calculate_age` method with something more amenable to our needs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承，有时我们还可以使用猴子补丁来向现有类添加方法。它不适用于`datetime`对象，因为它不允许在运行时添加属性。然而，在普通类中，我们可以添加一个新方法，提供调用代码所需的适配接口。或者，我们可以扩展或猴子补丁`AgeCalculator`本身，以用更符合我们需求的东西替换`calculate_age`方法。
- en: Finally, it is often possible to use a function as an adapter; this doesn't
    obviously fit the actual design of the adapter pattern, but if we recall that
    functions are essentially objects with a `__call__` method, it becomes an obvious
    adapter adaptation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常可以将函数用作适配器；这显然不符合适配器模式的实际设计，但是如果我们记得函数本质上是具有`__call__`方法的对象，那么它就成为一个明显的适配器适应。
- en: The facade pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: 'The facade pattern is designed to provide a simple interface to a complex system
    of components. For complex tasks, we may need to interact with these objects directly,
    but there is often a *typical* usage for the system for which these complicated
    interactions aren''t necessary. The facade pattern allows us to define a new object
    that encapsulates this typical usage of the system. Any time we want access to
    common functionality, we can use the single object''s simplified interface. If
    another part of the project needs access to more complicated functionality, it
    is still able to interact with the system directly. The UML diagram for the facade
    pattern is really dependent on the subsystem, but in a cloudy way, it looks like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式旨在为复杂的组件系统提供一个简单的接口。对于复杂的任务，我们可能需要直接与这些对象交互，但通常对于系统的*典型*使用，这些复杂的交互并不是必要的。外观模式允许我们定义一个新对象，封装系统的典型使用。每当我们想要访问常见功能时，我们可以使用单个对象的简化接口。如果项目的另一部分需要访问更复杂的功能，它仍然可以直接与系统交互。外观模式的UML图表实际上取决于子系统，但在模糊的方式下，它看起来像这样：
- en: '![](assets/92ac1454-3982-42bb-9fc3-e000d407a1d6.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92ac1454-3982-42bb-9fc3-e000d407a1d6.png)'
- en: A facade is, in many ways, like an adapter. The primary difference is that a
    facade tries to abstract a simpler interface out of a complex one, while an adapter
    only tries to map one existing interface to another.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 外观在许多方面类似于适配器。主要区别在于，外观试图从复杂的接口中抽象出一个简单的接口，而适配器只试图将一个现有的接口映射到另一个接口。
- en: Let's write a simple facade for an email application. The low-level library
    for sending email in Python, as we saw in [Chapter 20](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml),
    *Python Object-Oriented Shortcuts*, is quite complicated. The two libraries for
    receiving messages are even worse.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为一个电子邮件应用程序编写一个简单的外观。Python中用于发送电子邮件的低级库，正如我们在[第20章](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml)中看到的那样，*Python面向对象的快捷方式*，非常复杂。用于接收消息的两个库甚至更糟。
- en: 'It would be nice to have a simple class that allows us to send a single email,
    and list the emails currently in the inbox on an IMAP or POP3 connection. To keep
    our example short, we''ll stick with IMAP and SMTP: two totally different subsystems
    that happen to deal with email. Our facade performs only two tasks: sending an
    email to a specific address, and checking the inbox on an IMAP connection. It
    makes some common assumptions about the connection, such as that the host for
    both SMTP and IMAP is at the same address, that the username and password for
    both is the same, and that they use standard ports. This covers the case for many
    email servers, but if a programmer needs more flexibility, they can always bypass
    the facade and access the two subsystems directly.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的类可以让我们发送单封电子邮件，并列出当前在IMAP或POP3连接中收件箱中的电子邮件，这将是很好的。为了让我们的例子简短，我们将坚持使用IMAP和SMTP：两个完全不同的子系统，碰巧处理电子邮件。我们的外观只执行两个任务：向特定地址发送电子邮件，并在IMAP连接上检查收件箱。它对连接做了一些常见的假设，比如SMTP和IMAP的主机位于同一个地址，用户名和密码相同，并且它们使用标准端口。这涵盖了许多电子邮件服务器的情况，但如果程序员需要更灵活性，他们总是可以绕过外观直接访问这两个子系统。
- en: 'The class is initialized with the hostname of the email server, a username,
    and a password to log in:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用电子邮件服务器的主机名、用户名和密码进行初始化：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `send_email` method formats the email address and message, and sends it using
    `smtplib`. This isn''t a complicated task, but it requires quite a bit of fiddling to
    massage the *natural* input parameters that are passed into the facade to the
    correct format to enable `smtplib` to send the message, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_email`方法格式化电子邮件地址和消息，并使用`smtplib`发送。这不是一个复杂的任务，但需要相当多的调整来将传递到外观的*自然*输入参数正确格式化，以使`smtplib`能够发送消息，如下所示：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `if` statement at the beginning of the method is catching whether or not
    the `username` is the entire *from* email address or just the part on the left-hand
    side of the `@` symbol; different hosts treat the login details differently.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方法开头的`if`语句捕获了`username`是否是整个*from*电子邮件地址，或者只是`@`符号左边的部分；不同的主机对登录详细信息的处理方式不同。
- en: 'Finally, the code to get the messages currently in the inbox is a royal mess.
    The IMAP protocol is painfully over-engineered, and the `imaplib` standard library
    is only a thin layer over the protocol. But we get to simplify it, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取当前收件箱中的消息的代码是一团糟。IMAP协议过度设计，`imaplib`标准库只是协议的薄层。但我们可以简化它，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, if we add all this together, we have a simple facade class that can send
    and receive messages in a fairly straightforward manner; much simpler than if
    we had to interact with these complex libraries directly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把所有这些加在一起，我们就有了一个简单的外观类，可以以相当直接的方式发送和接收消息；比起直接与这些复杂的库进行交互，要简单得多。
- en: Although it is rarely mentioned by name in the Python community, the facade
    pattern is an integral part of the Python ecosystem. Because Python emphasizes
    language readability, both the language and its libraries tend to provide easy-to-comprehend
    interfaces to complicated tasks. For example, `for` loops, `list` comprehensions,
    and generators are all facades into a more complicated iterator protocol. The
    `defaultdict` implementation is a facade that abstracts away annoying corner cases
    when a key doesn't exist in a dictionary. The third-party **requests** library
    is a powerful facade over less readable libraries for HTTP requests, which are
    themselves a facade over managing the text-based HTTP protocol yourself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Python社区很少提到它的名字，但外观模式是Python生态系统的一个组成部分。因为Python强调语言的可读性，语言及其库往往提供了易于理解的接口来处理复杂的任务。例如，`for`循环，`list`推导和生成器都是更复杂的迭代器协议的外观。`defaultdict`实现是一个外观，它在字典中键不存在时抽象出烦人的边缘情况。第三方的**requests**库是一个强大的外观，可以使HTTP请求的库更易读，它们本身是管理基于文本的HTTP协议的外观。
- en: The flyweight pattern
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级模式
- en: The flyweight pattern is a memory optimization pattern. Novice Python programmers
    tend to ignore memory optimization, assuming the built-in garbage collector will
    take care of them. This is usually perfectly acceptable, but when developing larger
    applications with many related objects, paying attention to memory concerns can
    have a huge payoff.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式是一种内存优化模式。新手Python程序员往往忽视内存优化，认为内置的垃圾收集器会处理它们。这通常是完全可以接受的，但是在开发具有许多相关对象的较大应用程序时，关注内存问题可能会有巨大的回报。
- en: The flyweight pattern ensures that objects that share a state can use the same
    memory for that shared state. It is normally implemented only after a program
    has demonstrated memory problems. It may make sense to design an optimal configuration
    from the beginning in some situations, but bear in mind that premature optimization
    is the most effective way to create a program that is too complicated to maintain.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级模式确保共享状态的对象可以使用相同的内存来存储该共享状态。通常只有在程序显示出内存问题后才会实现它。在某些情况下，从一开始设计一个最佳配置是有意义的，但请记住，过早优化是创建一个过于复杂以至于无法维护的程序的最有效方式。
- en: 'Let''s have a look at the following UML diagram for the flyweight pattern:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下轻量级模式的以下UML图表：
- en: '![](assets/e72ec0b1-cc5e-4be1-a5b4-7f3aa040af2b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e72ec0b1-cc5e-4be1-a5b4-7f3aa040af2b.png)'
- en: Each **Flyweight** has no specific state. Any time it needs to perform an operation
    on **SpecificState**, that state needs to be passed into the **Flyweight** by
    the calling code. Traditionally, the factory that returns a flyweight is a separate
    object; its purpose is to return a flyweight for a given key identifying that
    flyweight. It works like the singleton pattern we discussed in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml),
    *Python Design Patterns I*; if the flyweight exists, we return it; otherwise,
    we create a new one. In many languages, the factory is implemented, not as a separate
    object, but as a static method on the `Flyweight` class itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个**享元**都没有特定的状态。每当它需要对**具体状态**执行操作时，该状态都需要被调用代码传递给**享元**。传统上，返回享元的工厂是一个单独的对象；它的目的是为了根据标识该享元的给定键返回一个享元。它的工作原理类似于我们在[第22章](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml)中讨论的单例模式，*Python设计模式I*；如果享元存在，我们就返回它；否则，我们创建一个新的。在许多语言中，工厂被实现为`Flyweight`类本身上的静态方法，而不是作为一个单独的对象。
- en: Think of an inventory system for car sales. Each individual car has a specific
    serial number and is a specific color. But most of the details about that car
    are the same for all cars of a particular model. For example, the Honda Fit DX
    model is a bare-bones car with few features. The LX model has A/C, tilt, cruise,
    and power windows and locks. The Sport model has fancy wheels, a USB charger,
    and a spoiler. Without the flyweight pattern, each individual car object would
    have to store a long list of which features it did and did not have. Considering
    the number of cars Honda sells in a year, this would add up to a huge amount of
    wasted memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下汽车销售的库存系统。每辆汽车都有特定的序列号和特定的颜色。但是对于特定模型的所有汽车来说，大部分关于汽车的细节都是相同的。例如，本田Fit DX型号是一辆几乎没有功能的汽车。LX型号有空调、倾斜、巡航和电动窗户和锁。Sport型号有时尚的轮毂、USB充电器和扰流板。如果没有享元模式，每个单独的汽车对象都必须存储一个长长的列表，其中包含它具有或不具有的功能。考虑到本田一年销售的汽车数量，这将导致大量的内存浪费。
- en: Using the flyweight pattern, we can instead have shared objects for the list
    of features associated with a model, and then simply reference that model, along
    with a serial number and color, for individual vehicles. In Python, the flyweight
    factory is often implemented using that funky `__new__` constructor, similar to
    what we did with the singleton pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用享元模式，我们可以为与模型相关的功能列表共享对象，然后只需为单个车辆引用该模型，以及序列号和颜色。在Python中，享元工厂通常使用那个奇怪的`__new__`构造函数来实现，类似于我们在单例模式中所做的。
- en: Unlike the singleton pattern, which only needs to return one instance of the
    class, we need to be able to return different instances depending on the keys.
    We could store the items in a dictionary and look them up based on the key. This
    solution is problematic, however, because the item will remain in memory as long
    as it is in the dictionary. If we sold out of LX model Fits, the Fit flyweight
    would no longer be necessary, yet it would still be in the dictionary. We could
    clean this up whenever we sell a car, but isn't that what a garbage collector
    is for?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与只需要返回类的一个实例的单例模式不同，我们需要能够根据键返回不同的实例。我们可以将项目存储在字典中，并根据键查找它们。然而，这种解决方案存在问题，因为只要项目在字典中，它就会一直保留在内存中。如果我们卖完了LX型号的Fit，那么Fit享元将不再需要，但它仍然会留在字典中。我们可以在卖车时清理这些内容，但这不是垃圾收集器的作用吗？
- en: We can solve this by taking advantage of Python's `weakref` module. This module
    provides a `WeakValueDictionary` object, which basically allows us to store items
    in a dictionary without the garbage collector caring about them. If a value is
    in a weak referenced dictionary and there are no other references to that object
    stored anywhere in the application (that is, we sold out of LX models), the garbage
    collector will eventually clean up for us.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Python的`weakref`模块来解决这个问题。该模块提供了一个`WeakValueDictionary`对象，基本上允许我们在字典中存储项目，而垃圾收集器不会关心它们。如果一个值在一个弱引用字典中，并且在应用程序的任何其他地方都没有对该对象的其他引用（也就是说，我们已经卖完了LX型号），垃圾收集器最终会为我们清理掉它。
- en: 'Let''s build the factory for our car flyweights first, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们构建我们汽车享元的工厂，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Basically, whenever we construct a new flyweight with a given name, we first
    look up that name in the weak referenced dictionary; if it exists, we return that
    model; if not, we create a new one. Either way, we know the `__init__` method
    on the flyweight will be called every time, regardless of whether it is a new
    or existing object. Our `__init__` method can therefore look like the following
    code snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每当我们使用给定名称构造一个新的享元时，我们首先在弱引用字典中查找该名称；如果存在，我们就返回该模型；如果不存在，我们就创建一个新的。无论哪种方式，我们都知道`__init__`方法在每次都会被调用，无论它是一个新的还是现有的对象。因此，我们的`__init__`方法可以看起来像以下代码片段：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `if` statement ensures that we only initialize the object the first time
    `__init__` is called. This means we can call the factory later with just the model
    name and get the same flyweight object back. However, because the flyweight will
    be garbage-collected if no external references to it exist, we must be careful
    not to accidentally create a new flyweight with null values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保我们只在第一次调用`__init__`时初始化对象。这意味着我们以后可以只用模型名称调用工厂，并得到相同的享元对象。然而，如果享元没有外部引用存在，它将被垃圾收集，我们必须小心不要意外地创建一个具有空值的新享元。'
- en: 'Let''s add a method to our flyweight that hypothetically looks up a serial
    number on a specific model of vehicle, and determines whether it has been involved
    in any accidents. This method needs access to the car''s serial number, which
    varies from car to car; it cannot be stored with the flyweight. Therefore, this
    data must be passed into the method by the calling code, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的享元添加一个假设的方法，该方法查找特定车型的车辆上的序列号，并确定它是否曾经参与过任何事故。这个方法需要访问汽车的序列号，这个序列号因车而异；它不能与享元一起存储。因此，这些数据必须由调用代码传递给方法，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can define a class that stores the additional information, as well as a
    reference to the flyweight, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个类，该类存储附加信息，以及对flyweight的引用，如下所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also keep track of the available models, as well as the individual cars
    on the lot, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以跟踪可用的模型，以及停车场上的各个汽车，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s demonstrate the weak referencing at work in the following code
    snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下代码片段中演示弱引用的工作：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `id` function tells us the unique identifier for an object. When we call
    it a second time, after deleting all references to the LX model and forcing garbage
    collection, we see that the ID has changed. The value in the `CarModel __new__`
    factory dictionary was deleted and a fresh one was created. If we then try to
    construct a second `CarModel` instance, however, it returns the same object (the
    IDs are the same), and, even though we did not supply any arguments in the second
    call, the `air` variable is still set to `True`. This means the object was not
    initialized the second time, just as we designed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`函数告诉我们对象的唯一标识符。当我们在删除对LX型号的所有引用并强制进行垃圾回收后第二次调用它，我们发现ID已经改变。`CarModel __new__`工厂字典中的值被删除，然后创建了一个新的值。然后，如果我们尝试构建第二个`CarModel`实例，它会返回相同的对象（ID相同），即使在第二次调用中没有提供任何参数，`air`变量仍然设置为`True`。这意味着对象第二次没有被初始化，就像我们设计的那样。'
- en: Obviously, using the flyweight pattern is more complicated than just storing
    features on a single car class. When should we choose to use it? The flyweight
    pattern is designed for conserving memory; if we have hundreds of thousands of
    similar objects, combining similar properties into a flyweight can have an enormous
    impact on memory consumption.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用flyweight模式比只在单个汽车类上存储特性更复杂。我们应该在什么时候选择使用它？flyweight模式旨在节省内存；如果我们有成千上万个相似的对象，将相似的属性合并到flyweight中对内存消耗会产生巨大影响。
- en: It is common for programming solutions that optimize CPU, memory, or disk space
    to result in more complicated code than their unoptimized brethren. It is therefore
    important to weigh up the trade-offs when deciding between code maintainability
    and optimization. When choosing optimization, try to use patterns such as flyweight
    to ensure that the complexity introduced by optimization is confined to a single
    (well-documented) section of the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于优化CPU、内存或磁盘空间的编程解决方案来说，通常会导致比未经优化的代码更复杂。因此，在决定代码可维护性和优化之间的权衡时，权衡是很重要的。在选择优化时，尝试使用flyweight等模式，以确保优化引入的复杂性局限于代码的一个（有良好文档的）部分。
- en: If you have a lot of Python objects in one program, one of the quickest ways
    to save memory is through the use of `__slots__`. The `__slots__` magic method
    is beyond the scope of this book, but there is plenty of information available
    if you check online. If you are still low on memory, flyweight may be a reasonable
    solution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序中有很多Python对象，通过使用`__slots__`是节省内存的最快方法之一。`__slots__`魔术方法超出了本书的范围，但是如果您查看在线信息，会有很多信息可用。如果内存仍然不足，flyweight可能是一个合理的解决方案。
- en: The command pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: The command pattern adds a level of abstraction between actions that must be
    done and the object that invokes those actions, normally at a later time. In the
    command pattern, client code creates a `Command` object that can be executed at
    a later date. This object knows about a receiver object that manages its own internal
    state when the command is executed on it. The `Command` object implements a specific
    interface (typically, it has an `execute` or `do_action` method, and also keeps
    track of any arguments required to perform the action. Finally, one or more `Invoker`
    objects execute the command at the correct time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式在必须执行的操作和调用这些操作的对象之间增加了一个抽象级别，通常是在以后的某个时间。在命令模式中，客户端代码创建一个可以在以后执行的`Command`对象。这个对象知道一个接收者对象，在命令在其上执行时管理自己的内部状态。`Command`对象实现了一个特定的接口（通常有一个`execute`或`do_action`方法，并且还跟踪执行操作所需的任何参数。最后，一个或多个`Invoker`对象在正确的时间执行命令。
- en: 'Here''s the UML diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是UML图：
- en: '![](assets/f4330a13-f32a-4858-8f94-66117207ae14.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4330a13-f32a-4858-8f94-66117207ae14.png)'
- en: A common example of the command pattern is actions on a graphical window. Often,
    an action can be invoked by a menu item on the menu bar, a keyboard shortcut,
    a toolbar icon, or a context menu. These are all examples of `Invoker` objects.
    The actions that actually occur, such as `Exit`, `Save`, or `Copy`, are implementations
    of `CommandInterface`. A GUI window to receive exit, a document to receive save,
    and `ClipboardManager` to receive copy commands, are all examples of possible
    `Receivers`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的一个常见示例是对图形窗口的操作。通常，操作可以通过菜单栏上的菜单项、键盘快捷键、工具栏图标或上下文菜单来调用。这些都是`Invoker`对象的示例。实际发生的操作，如`Exit`、`Save`或`Copy`，是`CommandInterface`的实现。接收退出的GUI窗口，接收保存的文档，接收复制命令的`ClipboardManager`，都是可能的`Receivers`的示例。
- en: 'Let''s implement a simple command pattern that provides commands for `Save`
    and `Exit` actions. We''ll start with some modest receiver classes, themselves
    with the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的命令模式，为`Save`和`Exit`操作提供命令。我们将从一些适度的接收者类开始，它们本身具有以下代码：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These mock classes model objects that would likely be doing a lot more in a
    working environment. The window would need to handle mouse movement and keyboard
    events, and the document would need to handle character insertion, deletion, and
    selection. But for our example, these two classes will do what we need.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模拟类模拟了在工作环境中可能会做更多工作的对象。窗口需要处理鼠标移动和键盘事件，文档需要处理字符插入、删除和选择。但是对于我们的示例，这两个类将做我们需要的事情。
- en: 'Now let''s define some invoker classes. These will model toolbar, menu, and
    keyboard events that can happen; again, they aren''t actually hooked up to anything,
    but we can see how they are decoupled from the command, receiver, and client code
    in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一些调用者类。这些将模拟可能发生的工具栏、菜单和键盘事件；同样，它们实际上并没有连接到任何东西，但我们可以看到它们如何与命令、接收者和客户端代码解耦在以下代码片段中：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how the various action methods each call the `execute` method on their
    respective commands? This code doesn't show the `command` attribute being set
    on each object. They could be passed into the `__init__` function, but because
    they may be changed (for example, with a customizable keybinding editor), it makes
    more sense to set the attributes on the objects afterwards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意各种操作方法如何调用其各自命令的`execute`方法？这段代码没有显示`command`属性被设置在每个对象上。它们可以传递到`__init__`函数中，但因为它们可能会被更改（例如，使用可自定义的键绑定编辑器），所以更合理的是在对象之后设置属性。
- en: 'Now, let''s hook up the commands themselves with the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码连接命令本身：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands are straightforward; they demonstrate the basic pattern, but
    it is important to note that we can store state and other information with the
    command if necessary. For example, if we had a command to insert a character,
    we could maintain state for the character currently being inserted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令很简单；它们演示了基本模式，但重要的是要注意，如果必要，我们可以存储状态和其他信息。例如，如果我们有一个插入字符的命令，我们可以维护当前正在插入的字符的状态。
- en: 'Now all we have to do is hook up some client and test code to make the commands
    work. For basic testing, we can just include the following code at the end of
    the script:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是连接一些客户端和测试代码，使命令生效。对于基本测试，我们只需在脚本的末尾包含以下代码：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we create two receivers and two commands. Then, we create several of
    the available invokers and set the correct command on each of them. To test, we
    can use `python3``-i``filename.py` and run code such as `exit_menu.click()`, which
    will end the program, or `save_keystroke.keystroke()`, which will save the fake
    file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个接收者和两个命令。然后，我们创建几个可用的调用者，并在每个调用者上设置正确的命令。为了测试，我们可以使用`python3 -i filename.py`并运行诸如`exit_menu.click()`的代码，这将结束程序，或者`save_keystroke.keystroke()`，这将保存虚拟文件。
- en: Unfortunately, the preceding examples do not feel terribly Pythonic. They have
    a lot of "boilerplate code" (code that does not accomplish anything, but only
    provides structure to the pattern), and the `Command` classes are all eerily similar
    to each other. Perhaps we could create a generic command object that takes a function
    as a callback?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，前面的例子并不像Python。它们有很多“样板代码”（不完成任何任务，只提供模式结构），而且`Command`类彼此之间都非常相似。也许我们可以创建一个通用的命令对象，以函数作为回调？
- en: 'In fact, why bother? Can we just use a function or method object for each command?
    Instead of an object with an `execute()` method, we can write a function and use
    that as the command directly. The following is a common paradigm for the command
    pattern in Python:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为什么要麻烦呢？我们可以为每个命令使用函数或方法对象吗？我们可以编写一个函数，直接将其用作命令，而不是具有`execute()`方法的对象。以下是Python中命令模式的常见范例：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that looks a lot more like Python. At first glance, it looks like we've
    removed the command pattern altogether, and we've tightly connected the `menu_item`
    and `Window` classes. But if we look closer, we find there is no tight coupling
    at all. Any callable can be set up as the command on `MenuItem`, just as before.
    And the `Window.exit` method can be attached to any invoker. Most of the flexibility
    of the command pattern has been maintained. We have sacrificed complete decoupling
    for readability, but this code is, in my opinion, and that of many Python programmers,
    more maintainable than the fully abstracted version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来更像Python了。乍一看，它看起来好像我们完全删除了命令模式，并且紧密连接了`menu_item`和`Window`类。但是如果我们仔细观察，我们会发现根本没有紧密耦合。任何可调用对象都可以设置为`MenuItem`上的命令，就像以前一样。而`Window.exit`方法可以附加到任何调用者上。命令模式的大部分灵活性都得到了保留。我们为可读性牺牲了完全解耦，但在我看来，以及许多Python程序员看来，这段代码比完全抽象的版本更易维护。
- en: 'Of course, since we can add a `__call__` method to any object, we aren''t restricted
    to functions. The previous example is a useful shortcut when the method being
    called doesn''t have to maintain state, but in more advanced usage, we can use
    the following code as well:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们可以向任何对象添加`__call__`方法，我们不限于函数。当被调用的方法不必维护状态时，前面的例子是一个有用的快捷方式，但在更高级的用法中，我们也可以使用以下代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have something that looks like the first command pattern, but a bit
    more idiomatic. As you can see, making the invoker call a callable instead of
    a `command` object with an execute method has not restricted us in any way. In
    fact, it's given us more flexibility. We can link to functions directly when that
    works, yet we can build a complete callable `command` object when the situation
    calls for it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个看起来像第一个命令模式的东西，但更符合习惯。正如你所看到的，让调用者调用一个可调用对象而不是具有执行方法的`command`对象并没有限制我们的任何方式。事实上，这给了我们更多的灵活性。当适用时，我们可以直接链接到函数，但是当情况需要时，我们可以构建一个完整的可调用`command`对象。
- en: The command pattern is often extended to support undoable commands. For example,
    a text program may wrap each insertion in a separate command with not only an
    `execute` method, but also an `undo` method that will delete that insertion. A
    graphics program may wrap each drawing action (rectangle, line, freehand pixels,
    and so on) in a command that has an `undo` method that resets the pixels to their
    original state. In such cases, the decoupling of the command pattern is much more
    obviously useful, because each action has to maintain enough of its state to undo
    that action at a later date.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常扩展为支持可撤销的命令。例如，文本程序可能将每个插入操作包装在一个单独的命令中，不仅有一个`execute`方法，还有一个`undo`方法，用于删除该插入操作。图形程序可能将每个绘图操作（矩形、线条、自由像素等）包装在一个命令中，该命令具有一个`undo`方法，用于将像素重置为其原始状态。在这种情况下，命令模式的解耦显然更有用，因为每个操作都必须保持足够的状态以便在以后的某个日期撤消该操作。
- en: The abstract factory pattern
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The abstract factory pattern is normally used when we have multiple possible
    implementations of a system that depend on some configuration or platform issue.
    The calling code requests an object from the abstract factory, not knowing exactly
    what class of object will be returned. The underlying implementation returned
    may depend on a variety of factors, such as current locale, operating system,
    or local configuration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式通常在我们有多种可能的系统实现取决于某些配置或平台问题时使用。调用代码从抽象工厂请求对象，不知道将返回什么类的对象。返回的底层实现可能取决于各种因素，如当前区域设置、操作系统或本地配置。
- en: Common examples of the abstract factory pattern include code for operating-system-independent
    toolkits, database backends, and country-specific formatters or calculators. An
    operating-system-independent GUI toolkit might use an abstract factory pattern
    that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac,
    GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract
    factory that returns a set of object relational classes for interacting with a
    specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on
    a configuration setting for the current site. If the application needs to be deployed
    in multiple places, each one can use a different database backend by changing
    only one configuration variable. Different countries have different systems for
    calculating taxes, subtotals, and totals on retail merchandise; an abstract factory
    can return a particular tax calculation object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的常见示例包括操作系统无关的工具包、数据库后端和特定国家的格式化程序或计算器的代码。操作系统无关的GUI工具包可能使用抽象工厂模式，在Windows下返回一组WinForm小部件，在Mac下返回一组Cocoa小部件，在Gnome下返回一组GTK小部件，在KDE下返回一组QT小部件。Django提供了一个抽象工厂，根据当前站点的配置设置，返回一组用于与特定数据库后端（MySQL、PostgreSQL、SQLite等）交互的对象关系类。如果应用程序需要部署到多个地方，每个地方可以通过仅更改一个配置变量来使用不同的数据库后端。不同的国家有不同的零售商品税、小计和总计计算系统；抽象工厂可以返回特定的税收计算对象。
- en: 'The UML class diagram for an abstract factory pattern is hard to understand
    without a specific example, so let''s turn things around and create a concrete
    example first. In our example, we''ll create a set of formatters that depend on
    a specific locale and help us format dates and currencies. There will be an abstract
    factory class that picks the specific factory, as well as a couple of example
    concrete factories, one for France and one for the USA. Each of these will create
    formatter objects for dates and times, which can be queried to format a specific
    value. This is depicted in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式的UML类图很难理解，没有具体的示例，因此让我们改变一下，首先创建一个具体的示例。在我们的示例中，我们将创建一组取决于特定区域设置的格式化程序，帮助我们格式化日期和货币。将有一个选择特定工厂的抽象工厂类，以及一些示例具体工厂，一个用于法国，一个用于美国。这些工厂将为日期和时间创建格式化程序对象，可以查询以格式化特定值。如下图所示：
- en: '![](assets/af57b154-5695-4e8b-b27c-b5db318c52cb.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/af57b154-5695-4e8b-b27c-b5db318c52cb.png)'
- en: Comparing that image to the earlier, simpler text shows that a picture is not
    always worth a thousand words, especially considering we haven't even allowed
    for factory selection code here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个图像与之前更简单的文本进行比较，可以看出图片并不总是价值千言万语，尤其是考虑到我们甚至没有在这里允许工厂选择代码。
- en: 'Of course, in Python, we don''t have to implement any interface classes, so
    we can discard `DateFormatter`, `CurrencyFormatter`, and `FormatterFactory`. The
    formatting classes themselves are pretty straightforward, if verbose, shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们不必实现任何接口类，因此我们可以丢弃`DateFormatter`、`CurrencyFormatter`和`FormatterFactory`。这些格式化类本身非常简单，但冗长，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These classes use some basic string manipulation to try to turn a variety of
    possible inputs (integers, strings of different lengths, and others) into the
    following formats:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类使用一些基本的字符串操作来尝试将各种可能的输入（整数、不同长度的字符串等）转换为以下格式：
- en: '|  | **USA** | **France** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  | **美国** | **法国** |'
- en: '| **Date** | mm-dd-yyyy | dd/mm/yyyy |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | mm-dd-yyyy | dd/mm/yyyy |'
- en: '| **Currency** | $14,500.50 | 14 500€50 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **货币** | $14,500.50 | 14 500€50 |'
- en: There could obviously be more validation on the input in this code, but let's
    keep it simple for this example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，输入显然可以进行更多的验证，但是为了这个例子，让我们保持简单。
- en: 'Now that we have the formatters set up, we just need to create the formatter
    factories, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了格式化程序，我们只需要创建格式化程序工厂，如下所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we set up the code that picks the appropriate formatter. Since this is
    the kind of thing that only needs to be set up once, we could make it a singleton–except
    singletons aren''t very useful in Python. Let''s just make the current formatter
    a module-level variable instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置选择适当格式化程序的代码。由于这种事情只需要设置一次，我们可以将其设置为单例模式——但是单例模式在Python中并不是非常有用。让我们将当前格式化程序作为模块级变量：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we hardcode the current country code; in practice, it would
    likely introspect the locale, the operating system, or a configuration file to
    choose the code. This example uses a dictionary to associate the country codes
    with factory classes. Then, we grab the correct class from the dictionary and
    instantiate it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们硬编码了当前的国家代码；在实践中，它可能会内省区域设置、操作系统或配置文件来选择代码。这个例子使用字典将国家代码与工厂类关联起来。然后，我们从字典中获取正确的类并实例化它。
- en: 'It is easy to see what needs to be done when we want to add support for more
    countries: create the new formatter classes and the abstract factory itself. Bear
    in mind that `Formatter` classes might be reused; for example, Canada formats
    its currency the same way as the USA, but its date format is more sensible than
    its Southern neighbor.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为更多的国家添加支持时，很容易看出需要做什么：创建新的格式化类和抽象工厂本身。请记住，`Formatter`类可能会被重用；例如，加拿大的货币格式与美国相同，但其日期格式比其南部邻居更合理。
- en: Abstract factories often return a singleton object, but this is not required.
    In our code, it's returning a new instance of each formatter every time it's called.
    There's no reason the formatters couldn't be stored as instance variables and
    the same instance returned for each factory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂通常返回一个单例对象，但这并非必需。在我们的代码中，每次调用时都返回每个格式化程序的新实例。没有理由不能将格式化程序存储为实例变量，并为每个工厂返回相同的实例。
- en: 'Looking back at these examples, we see that, once again, there appears to be
    a lot of boilerplate code for factories that just doesn''t feel necessary in Python.
    Often, the requirements that might call for an abstract factory can be more easily
    fulfilled by using a separate module for each factory type (for example: the USA
    and France), and then ensuring that the correct module is being accessed in a
    factory module. The package structure for such modules might look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾这些例子，我们再次看到，对于工厂来说，似乎有很多样板代码在Python中并不感到必要。通常，可能需要抽象工厂的要求可以通过为每种工厂类型（例如：美国和法国）使用单独的模块，并确保在工厂模块中访问正确的模块来更轻松地实现。这些模块的包结构可能如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The trick is that `__init__.py` in the `localize` package can contain logic
    that redirects all requests to the correct backend. There are a variety of ways
    this might be done.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧在于`localize`包中的`__init__.py`可以包含将所有请求重定向到正确后端的逻辑。有多种方法可以实现这一点。
- en: 'If we know that the backend is never going to change dynamically (that is,
    without a program restart), we can just put some `if` statements in `__init__.py`
    that check the current country code, and use the (normally unacceptable) `from``.backends.USA``import``*`
    syntax to import all variables from the appropriate backend. Or, we could import
    each of the backends and set a `current_backend` variable to point at a specific
    module, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道后端永远不会动态更改（即在没有程序重新启动的情况下），我们可以在`__init__.py`中放一些`if`语句来检查当前的国家代码，并使用（通常不可接受的）`from``.backends.USA``import``*`语法从适当的后端导入所有变量。或者，我们可以导入每个后端并设置一个`current_backend`变量指向特定的模块，如下所示：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Depending on which solution we choose, our client code would have to call either
    `localize.format_date` or `localize.current_backend.format_date` to get a date
    formatted in the current country's locale. The end result is much more Pythonic
    than the original abstract factory pattern and, in typical usage, is just as flexible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们选择的解决方案，我们的客户端代码将不得不调用`localize.format_date`或`localize.current_backend.format_date`来获取以当前国家区域设置格式化的日期。最终结果比原始的抽象工厂模式更符合Python的风格，并且在典型的使用情况下同样灵活。
- en: The composite pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合模式
- en: The composite pattern allows complex tree-like structures to be built from simple
    components. These components, called composite objects, are able to behave sort
    of like a container and sort of like a variable, depending on whether they have
    child components. Composite objects are container objects, where the content may
    actually be another composite object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式允许从简单组件构建复杂的树状结构。这些组件，称为复合对象，能够表现得像容器，也能像变量一样，具体取决于它们是否有子组件。复合对象是容器对象，其中的内容实际上可能是另一个复合对象。
- en: 'Traditionally, each component in a composite object must be either a leaf node
    (that cannot contain other objects) or a composite node. The key is that both
    composite and leaf nodes can have the same interface. The following UML diagram is
    very simple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，复合对象中的每个组件必须是叶节点（不能包含其他对象）或复合节点。关键在于复合和叶节点都可以具有相同的接口。以下的UML图表非常简单：
- en: '![](assets/72017a6f-b691-4b3d-953d-495fc8c3e88a.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/72017a6f-b691-4b3d-953d-495fc8c3e88a.png)'
- en: 'This simple pattern, however, allows us to create complex arrangements of elements,
    all of which satisfy the interface of the component object. The following diagram
    depicts a concrete instance of such a complicated arrangement:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单的模式使我们能够创建复杂的元素排列，所有这些元素都满足组件对象的接口。以下图表描述了这样一个复杂排列的具体实例：
- en: '![](assets/4de6c458-0348-42f5-998a-1c5451bc5b4b.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4de6c458-0348-42f5-998a-1c5451bc5b4b.png)'
- en: The composite pattern is commonly useful in file/folder-like trees. Regardless
    of whether a node in the tree is a normal file or a folder, it is still subject
    to operations such as moving, copying, or deleting the node. We can create a component
    interface that supports these operations, and then use a composite object to represent
    folders, and leaf nodes to represent normal files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 组合模式通常在文件/文件夹样式的树中非常有用。无论树中的节点是普通文件还是文件夹，它仍然受到移动、复制或删除节点等操作的影响。我们可以创建一个支持这些操作的组件接口，然后使用复合对象来表示文件夹，使用叶节点来表示普通文件。
- en: 'Of course, in Python, once again, we can take advantage of duck typing to implicitly
    provide the interface, so we only need to write two classes. Let''s define these
    interfaces first in the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们可以再次利用鸭子类型来隐式提供接口，因此我们只需要编写两个类。让我们首先在以下代码中定义这些接口：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For each folder (composite) object, we maintain a dictionary of children. For
    many composite implementations, a list is sufficient, but in this case, a dictionary
    will be useful for looking up children by name. Our paths will be specified as
    node names separated by the `/` character, similar to paths in a Unix shell.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件夹（复合）对象，我们维护一个子对象的字典。对于许多复合实现来说，列表就足够了，但在这种情况下，使用字典来按名称查找子对象会很有用。我们的路径将被指定为由“/”字符分隔的节点名称，类似于Unix
    shell中的路径。
- en: Thinking about the methods involved, we can see that moving or deleting a node
    behaves in a similar way, regardless of whether or not it is a file or folder
    node. Copying, however, has to do a recursive copy for folder nodes, while copying
    a file node is a trivial operation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑涉及的方法，我们可以看到移动或删除节点的行为方式相似，无论它是文件节点还是文件夹节点。然而，复制对于文件夹节点来说必须进行递归复制，而对于文件节点来说，复制是一个微不足道的操作。
- en: 'To take advantage of the similar operations, we can extract some of the common
    methods into a parent class. Let''s take that discarded `Component` interface
    and change it to a base class with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用相似的操作，我们可以将一些常见的方法提取到一个父类中。让我们将被丢弃的`Component`接口改为一个基类，使用以下代码：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've created the `move` and `delete` methods on the `Component` class. Both
    of them access a mysterious `parent` variable that we haven't set yet. The `move`
    method uses a module-level `get_path` function that finds a node from a predefined
    root node, given a path. All files will be added to this root node or a child
    of that node. For the `move` method, the target should be an existing folder,
    or we'll get an error. As in many examples in technical books, error handling
    is woefully absent, to help focus on the principles under consideration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Component`类上创建了`move`和`delete`方法。它们都访问一个我们尚未设置的神秘的`parent`变量。`move`方法使用一个模块级别的`get_path`函数，该函数根据给定的路径从预定义的根节点中找到一个节点。所有文件都将被添加到此根节点或该节点的子节点。对于`move`方法，目标应该是一个现有的文件夹，否则我们将会得到一个错误。就像技术书籍中的许多示例一样，错误处理是非常缺乏的，以帮助专注于正在考虑的原则。
- en: 'Let''s set up that mysterious `parent` variable in the folder''s `add_child`
    method, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件夹的`add_child`方法中设置那个神秘的`parent`变量，如下所示：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Well, that was easy enough. Let''s see if our composite file hierarchy is working
    properly with the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这足够简单了。让我们看看我们的复合文件层次结构是否能够正常工作，使用以下代码片段：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Yes, we can create folders, add folders to other folders, add files to folders,
    and move them around! What more could we ask for in a file hierarchy?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以创建文件夹，将文件夹添加到其他文件夹中，将文件添加到文件夹中，并在它们之间移动！在文件层次结构中，我们还能要求什么呢？
- en: Well, we could ask for copying to be implemented, but to conserve trees, let's
    leave that as an exercise.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以要求实现复制，但为了节约树木，让我们把它作为一个练习留下来。
- en: The composite pattern is extremely useful for a variety of tree-like structures,
    including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML
    DOM. It can be a useful pattern in Python when implemented according to the traditional
    implementation, as in the example demonstrated earlier. Sometimes, if only a shallow
    tree is being created, we can get away with a list of lists or a dictionary of
    dictionaries, and do not need to implement custom component, leaf, and composite
    classes. Other times, we can get away with implementing only one composite class,
    and treating leaf and composite objects as a single class. Alternatively, Python's
    duck typing can make it easy to add other objects to a composite hierarchy, as
    long as they have the correct interface.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 复合模式对于各种类似树结构的结构非常有用，包括GUI小部件层次结构，文件层次结构，树集，图形和HTML DOM。当按照传统实现方式在Python中实现时，它可以成为Python中的一个有用模式，就像之前演示的例子一样。有时，如果只创建了一个浅树，我们可以使用列表的列表或字典的字典，并且不需要实现自定义组件、叶子和复合类。其他时候，我们可以只实现一个复合类，并将叶子和复合对象视为一个类。另外，Python的鸭子类型可以很容易地将其他对象添加到复合层次结构中，只要它们具有正确的接口。
- en: Exercises
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Before diving into exercises for each design pattern, take a moment to implement
    the `copy` method for the `File` and `Folder` objects in the previous section.
    The `File` method should be quite trivial; just create a new node with the same
    name and contents, and add it to the new parent folder. The `copy` method on `Folder`
    is quite a bit more complicated, as you first have to duplicate the folder, and
    then recursively copy each of its children to the new location. You can call the
    `copy()` method on the children indiscriminately, regardless of whether each is
    a file or a folder object. This will drive home just how powerful the composite
    pattern can be.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究每个设计模式的练习之前，花点时间为上一节中的`File`和`Folder`对象实现`copy`方法。`File`方法应该非常简单；只需创建一个具有相同名称和内容的新节点，并将其添加到新的父文件夹中。`Folder`上的`copy`方法要复杂得多，因为您首先必须复制文件夹，然后递归地将其每个子对象复制到新位置。您可以不加区分地在子对象上调用`copy()`方法，无论每个子对象是文件还是文件夹。这将彰显出复合模式有多么强大。
- en: Now, as in the previous chapter, look at the patterns we've discussed and consider
    ideal places where you might implement them. You may want to apply the adapter
    pattern to existing code, as it is usually applicable when interfacing with existing
    libraries, rather than new code. How can you use an adapter to force two interfaces
    to interact with each other correctly?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像在上一章中一样，看看我们讨论过的模式，并考虑您可能实现它们的理想位置。您可能希望将适配器模式应用于现有代码，因为它通常适用于与现有库进行接口，而不是新代码。您如何使用适配器来强制两个接口正确地相互交互？
- en: Can you think of a system complex enough to justify using the facade pattern?
    Consider how facades are used in real-life situations, such as the driver-facing
    interface of a car, or the control panel in a factory. It is similar in software,
    except the users of the facade interface are other programmers, rather than people
    trained to use them. Are there complex systems in your latest project that could
    benefit from the facade pattern?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个足够复杂的系统，可以证明使用外观模式是合理的吗？考虑一下外观在现实生活中的使用情况，比如汽车的驾驶员界面，或者工厂的控制面板。在软件中也是类似的，只不过外观接口的用户是其他程序员，而不是受过培训的人。在你最新的项目中，是否有复杂的系统可以从外观模式中受益？
- en: It's possible you don't have any huge, memory-consuming code that would benefit
    from the flyweight pattern, but can you think of situations where it might be
    useful? Anywhere that large amounts of overlapping data need to be processed,
    a flyweight is waiting to be used. Would it be useful in the banking industry?
    In web applications? At what point does adopting the flyweight pattern make sense?
    When is it overkill?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你没有任何巨大的、占用内存的代码会从享元模式中受益，但你能想到哪些情况下它可能会有用吗？任何需要处理大量重叠数据的地方，都可以使用享元模式。在银行业会有用吗？在Web应用程序中呢？采用享元模式何时是明智的？什么时候又是画蛇添足呢？
- en: What about the command pattern? Can you think of any common (or better yet,
    uncommon) examples of places where the decoupling of action from invocation would
    be useful? Look at the programs you use on a daily basis and imagine how they
    are implemented internally. It's likely that many of them use the command pattern
    for one purpose or another.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式呢？你能想到任何常见（或更好的是，不常见）的例子，其中将动作与调用解耦会有用吗？看看你每天使用的程序，想象它们内部是如何实现的。很可能其中许多都会以某种方式使用命令模式。
- en: The abstract factory pattern, or the somewhat more Pythonic derivatives we discussed,
    can be very useful for creating one-touch-configurable systems. Can you think
    of places where such systems are useful?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式，或者我们讨论过的更加Pythonic的衍生模式，对于创建一键配置系统非常有用。你能想到这样的系统有用的地方吗？
- en: Finally, consider the composite pattern. There are tree-like structures all
    around us in programming; some of them, like our file hierarchy example, are blatant;
    others are fairly subtle. What situations might arise where the composite pattern
    would be useful? Can you think of places where you can use it in your own code?
    What if you adapted the pattern slightly; for example, to contain different types
    of leaf or composite nodes for different types of objects?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑一下组合模式。在编程中，我们周围都有类似树状结构的东西；其中一些，比如我们的文件层次结构示例，是明显的；其他一些则相当微妙。可能会出现哪些情况，组合模式会有用呢？你能想到在自己的代码中可以使用它的地方吗？如果你稍微调整一下模式；例如，包含不同类型的叶子或组合节点，用于不同类型的对象，会怎样？
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went into detail on several more design patterns, covering
    their canonical descriptions as well as alternatives for implementing them in
    Python, which is often more flexible and versatile than traditional object-oriented
    languages. The adapter pattern is useful for matching interfaces, while the facade
    pattern is suited to simplifying them. Flyweight is a complicated pattern and
    only useful if memory optimization is required. In Python, the command pattern
    is often more aptly implemented using first class functions as callbacks. Abstract
    factories allow runtime separation of implementations depending on configuration
    or system information. The composite pattern is used universally for tree-like
    structures.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了几种设计模式，包括它们的经典描述以及在Python中实现它们的替代方法，Python通常比传统的面向对象语言更灵活、多才多艺。适配器模式用于匹配接口，而外观模式适用于简化接口。享元模式是一种复杂的模式，只有在需要内存优化时才有用。在Python中，命令模式通常更适合使用一等函数作为回调来实现。抽象工厂允许根据配置或系统信息在运行时分离实现。组合模式通常用于类似树状结构的情况。
- en: In the next chapter, we'll discuss how important it is to test Python programs,
    and how to do it, focusing on object-oriented principles.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论测试Python程序的重要性，以及如何进行测试，重点放在面向对象的原则上。
