- en: Review of TCP/IP Protocol Suite and Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP协议套件和Python的回顾
- en: Welcome to the new age of network engineering. When I first started working
    as a network engineer 18 years ago, at the turn of the millennium, the role was
    distinctly different than other technical roles. Network engineers mainly possessed
    domain-specific knowledge to manage and operate local and wide area networks,
    while occasionally crossing over to systems administration, but there was no expectation
    to write code or understand programming concepts. This is no longer the case.
    Over the years, the DevOps and **Software-Defined Networking** (**SDN**) movement,
    among other factors, have significantly blurred the lines between network engineers,
    systems engineers, and developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到网络工程的新时代。18年前，也就是在千禧年之交，我开始担任网络工程师时，这个角色与其他技术角色有着明显的不同。网络工程师主要具有领域特定的知识，用于管理和操作局域网和广域网，偶尔会涉足系统管理，但没有写代码或理解编程概念的期望。现在情况已经不同了。多年来，DevOps和软件定义网络（SDN）运动等因素显著地模糊了网络工程师、系统工程师和开发人员之间的界限。
- en: 'The fact that you have picked up this book suggests that you might already
    be an adopter of network DevOps, or maybe you are considering going down that
    path. Maybe you have been working as a network engineer for years, just as I was,
    and want to know what the buzz around the Python programming language is about.
    Or you might already be fluent in Python but wonder what its applications are
    in network engineering. If you fall into any of these camps, or are simply just
    curious about Python in the network engineering field, I believe this book is
    for you:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您拿起这本书的事实表明您可能已经是网络DevOps的采用者，或者您正在考虑走这条路。也许您已经作为网络工程师工作了多年，就像我一样，想知道Python编程语言的热度是怎么回事。或者您可能已经精通Python，但想知道它在网络工程中的应用。如果您属于这些人群，或者只是对网络工程领域中的Python感到好奇，我相信这本书适合您：
- en: '![](assets/dce15e34-48e7-47b4-91ef-fb54268aa5f0.png)The intersection between
    Python and network engineering'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dce15e34-48e7-47b4-91ef-fb54268aa5f0.png)Python和网络工程的交集'
- en: Many books that dive into the topics of network engineering and Python have
    already been written. I do not intend to repeat their efforts with this book.
    Instead, this book assumes that you have some hands-on experience of managing
    networks, as well as a basic understanding of network protocols and the Python
    language. You do not need to be an expert in Python or network engineering, but
    should find that the concepts in this chapter form a general review. The rest
    of the chapter should set the level of expectation of the prior knowledge required
    to get the most out of this book. If you want to brush up on the contents of this
    chapter, there are lots of free or low-cost resources to bring you up to speed.
    I would recommend the free Khan Academy ([https://www.khanacademy.org/)](https://www.khanacademy.org/) and
    the Python tutorials at: [https://www.python.org/.](https://www.python.org/)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多深入探讨网络工程和Python主题的书籍。我不打算在本书中重复他们的努力。相反，本书假设您有一些管理网络的实际经验，以及对网络协议和Python语言的基本理解。您不需要成为Python或网络工程的专家，但应该发现本章中的概念构成了一个概括性的回顾。本章的其余部分应该设定了对先前知识的期望水平，以便从本书中获得最大的收获。如果您想复习本章的内容，有很多免费或低成本的资源可以帮助您迅速掌握。我建议使用免费的可汗学院（[https://www.khanacademy.org/)](https://www.khanacademy.org/)和Python教程：[https://www.python.org/.](https://www.python.org/)
- en: This chapter will pay a very quick visit to the relevant networking topics. From
    my experience working in the field, a typical network engineer or developer might
    not remember the exact TCP state machine to accomplish their daily tasks (I know
    I don't), but they would be familiar with the basics of the OSI model, the TCP
    and UDP operations, different IP headers fields, and other fundamental concepts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将快速介绍相关的网络主题。根据我在这个领域工作的经验，一个典型的网络工程师或开发人员可能不记得确切的TCP状态机来完成他们的日常任务（我知道我不记得），但他们会熟悉OSI模型的基础知识、TCP和UDP的操作、不同的IP头字段以及其他基本概念。
- en: We will also look at a high-level review of the Python language; just enough
    for those readers who do not code in Python on a daily basis to have ground to
    walk on for the rest of the book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对Python语言进行高层次的概述；对于那些不是每天都用Python编码的读者来说，这足够让他们在本书的其余部分有所准备。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: An overview of the internet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网概述
- en: The OSI and client-server model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI和客户端-服务器模型
- en: TCP, UDP, and IP protocol suites
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP、UDP和IP协议套件
- en: Python syntax, types, operators, and loops
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python语法、类型、运算符和循环
- en: Extending Python with functions, classes, and packages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数、类和包扩展Python
- en: Of course, the information presented in this chapter is not exhaustive; please
    do check out the references for further information.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本章中提供的信息并不是详尽无遗的；请查看参考资料以获取更多信息。
- en: An overview of the internet
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网概述
- en: What is the internet? This seemingly easy question might receive different answers
    depending on your background. The internet means different things to different
    people; the young, the old, students, teachers, business people, poets, could
    all give different answers to the question.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是互联网？这个看似简单的问题可能会因你的背景而得到不同的答案。互联网对不同的人意味着不同的东西；年轻人、老年人、学生、教师、商人、诗人，都可能对这个问题给出不同的答案。
- en: To a network engineer, the internet is a global computer network consisting
    of a web of inter-networks connecting large and small networks together. In other
    words, it is a network of networks without a centralized owner. Take your home
    network as an example. It might consist of a home Ethernet switch and a wireless
    access point connecting your smartphone, tablet, computers, and TV together for
    the devices to communicate with each other. This is your **Local Area Network**
    (**LAN**). When your home network needs to communicate with the outside world,
    it passes information from your LAN to a larger network, often appropriately named
    the **Internet Service Provider** (**ISP**). Your ISP often consists of edge nodes
    that aggregate the traffic to their core network. The core network's function
    is to interconnect these edge networks via a higher speed network. At special
    edge nodes, your ISP is connected to other ISPs to pass your traffic appropriately
    to your destination. The return path from your destination to your home computer,
    tablet, or smartphone may or may not follow the same path through all of these
    networks back to your device, while the source and destination remain the same.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络工程师来说，互联网是一个全球计算机网络，由一系列互联网络连接大大小小的网络。换句话说，它是一个没有集中所有者的网络。以您的家庭网络为例。它可能由家用以太网交换机和无线接入点组成，将您的智能手机、平板电脑、计算机和电视连接在一起，以便设备之间进行通信。这就是您的**局域网**（**LAN**）。当您的家庭网络需要与外部世界通信时，它会将信息从您的LAN传递到一个更大的网络，通常称为**互联网服务提供商**（**ISP**）。您的ISP通常由边缘节点组成，这些节点将流量聚合到其核心网络中。核心网络的功能是通过更高速的网络连接这些边缘网络。在特定的边缘节点，您的ISP连接到其他ISP，以适当地将您的流量传递到目的地。从目的地返回到您的家用计算机、平板电脑或智能手机的路径可能会或可能不会沿着同样的路径穿过所有这些网络返回到您的设备，而源和目的地保持不变。
- en: Let's take a look at the components making up this web of networks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看构成这个网络之网的组件。
- en: Servers, hosts, and network components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器、主机和网络组件
- en: '**Hosts** are end nodes on the network that communicate to other nodes. In
    today''s world, a host can be a traditional computer, or can be your smartphone,
    tablet, or TV. With the rise of the **Internet of Things** (**IoT**), the broad
    definition of a host can be expanded to include an IP camera, TV set-top boxes,
    and the ever-increasing type of sensors that we use in agriculture, farming, automobiles,
    and more. With the explosion of the number of hosts connected to the internet,
    all of them need to be addressed, routed, and managed. The demand for proper networking
    has never been greater.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机**是网络上的终端节点，与其他节点进行通信。在今天的世界中，主机可以是传统计算机，也可以是您的智能手机、平板电脑或电视。随着**物联网**（**IoT**）的兴起，主机的广义定义可以扩展到包括IP摄像机、电视机顶盒以及我们在农业、农场、汽车等领域使用的越来越多类型的传感器。随着连接到互联网的主机数量的激增，所有这些主机都需要被寻址、路由和管理。对适当的网络需求从未如此迫切。'
- en: Most of the time when we are on the internet, we make requests for services.
    This could be viewing a web page, sending or receiving emails, transferring files,
    and so on. These services are provided by **servers**. As the name implies, servers
    provide services to multiple nodes and generally have higher levels of hardware
    specification because of this. In a way, servers are special super-nodes on the
    network that provide additional capabilities to its peers. We will look at servers
    later on in the client-server model section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在互联网上大部分时间都是在请求服务。这可能是查看网页，发送或接收电子邮件，传输文件等。这些服务是由**服务器**提供的。顾名思义，服务器为多个节点提供服务，并且通常具有更高级别的硬件规格。在某种程度上，服务器是网络上提供额外功能的特殊超级节点。我们将在客户端-服务器模型部分稍后讨论服务器。
- en: If you think of servers and hosts as cities and towns, the **network components**
    are the roads and highways that connect them together. In fact, the term information
    superhighway comes to mind when describing the network components that transmit
    the ever increasing bits and bytes across the globe. In the OSI model that we
    will look at in a bit, these network components are layer one to three devices.
    They are layer two and three routers and switches that direct traffic, as well
    as layer one transports such as fiber optic cables, coaxial cables, twisted copper
    pairs, and some DWDM equipment, to name a few.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将服务器和主机视为城市和城镇，**网络组件**就是连接它们的道路和高速公路。事实上，在描述跨越全球传输不断增加的比特和字节的网络组件时，信息高速公路这个术语就会浮现在脑海中。在我们稍后将要看到的OSI模型中，这些网络组件是第一到第三层设备。它们是第二和第三层的路由器和交换机，用于指导流量，以及第一层的传输设备，如光纤电缆、同轴电缆、双绞铜线和一些DWDM设备，等等。
- en: Collectively, hosts, servers, and network components make up the internet as
    we know it today.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，主机、服务器和网络组件构成了我们今天所知的互联网。
- en: The rise of data centers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据中心的崛起
- en: In the last section, we looked at the different roles that servers, hosts, and
    network components play in the inter-network. Because of the higher hardware capacity
    that servers demand, they are often put together in a central location, so they
    can be managed more efficiently. We often refer to these locations as data centers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了服务器、主机和网络组件在互联网中扮演的不同角色。由于服务器需要更高的硬件容量，它们通常被放在一个中央位置，以便更有效地进行管理。我们经常将这些位置称为数据中心。
- en: Enterprise data centers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业数据中心
- en: In a typical enterprise, the company generally has the need for internal tools
    such as emailing, document storage, sales tracking, ordering, HR tools, and a
    knowledge sharing intranet. These services translate into file and mail servers,
    database servers, and web servers. Unlike user computers, these are generally
    high-end computers that require a lot of power, cooling, and network connections.
    A byproduct of the hardware is also the amount of noise they make. They are generally
    placed in a central location, called the **Main Distribution Frame** (**MDF**),
    in the enterprise to provide the necessary power feed, power redundancy, cooling,
    and network connectivity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的企业中，公司通常需要内部工具，如电子邮件、文档存储、销售跟踪、订购、人力资源工具和知识共享内部网。这些服务转化为文件和邮件服务器、数据库服务器和Web服务器。与用户计算机不同，这些通常是需要大量电力、冷却和网络连接的高端计算机。硬件的副产品也是它们产生的噪音量。它们通常被放置在企业的中心位置，称为主配线架（MDF），以提供必要的电力供应、电力冗余、冷却和网络连接。
- en: To connect to the MDF, the user's traffic is generally aggregated at a location
    closer to the user, which is sometimes called the **Intermediate Distribution
    Frame** (**IDF**), before they are bundled up and connected to the MDF. It is
    not unusual for the IDF-MDF spread to follow the physical layout of the enterprise
    building or campus. For example, each building floor can consist of an IDF that
    aggregates to the MDF on another floor. If the enterprise consists of several
    buildings, further aggregation can be done by combining the buildings' traffic
    before connecting them to the enterprise data center.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到MDF，用户的流量通常会在距离用户更近的位置进行聚合，有时被称为中间分配框架（IDF），然后再捆绑并连接到MDF。 IDF-MDF的分布通常遵循企业建筑或校园的物理布局。例如，每个楼层可以包括一个IDF，它会聚合到另一楼层的MDF。如果企业由多栋建筑组成，可以通过将建筑的流量组合起来，然后连接到企业数据中心来进一步进行聚合。
- en: Enterprise data centers generally follow the network design of three layers.
    These layers are access, distribution, and a core. The access layer is analogous
    to the ports each user connects to, the IDF can be thought of as the distribution
    layer, while the core layer consists of the connection to the MDF and the enterprise
    data centers. This is, of course, a generalization of enterprise networks, as
    some of them will not follow the same model.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 企业数据中心通常遵循三层网络设计。这些层是接入层、分发层和核心层。接入层类似于每个用户连接的端口，IDF可以被视为分发层，而核心层包括与MDF和企业数据中心的连接。当然，这是企业网络的概括，因为其中一些网络将不会遵循相同的模型。
- en: Cloud data centers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云数据中心
- en: 'With the rise of cloud computing and software, or infrastructure as a service,
    the data centers cloud providers build are at a hyper-scale. Because of the number
    of servers they house, they generally demand a much, much higher capacity for
    power, cooling, network speed, and feed than any enterprise data center. Even
    after working on cloud provider data centers for many years, every time I visit
    a cloud provider data center, I am still amazed at the scale of them. In fact,
    cloud data centers are so big and power-hungry that they are typically built close
    to power plants where they can get the cheapest power rate, without losing too
    much efficiency during the transportation of the power. Their cooling needs are
    so great, some are forced to be creative about where the data center is built,
    building in a generally cold climate just so they can just open the doors and
    windows to keep the server running at a safe temperature when needed. Any search
    engine can give you some of the astounding numbers when it comes to the science
    of building and managing cloud data centers for the likes of Amazon, Microsoft,
    Google, and Facebook:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算和软件或基础设施即服务的兴起，云提供商建立的数据中心规模庞大。由于它们所容纳的服务器数量，它们通常对电力、冷却、网络速度和供电需求远远高于任何企业数据中心。即使在云提供商数据中心工作多年后，每次我访问云提供商数据中心时，我仍然对它们的规模感到惊讶。事实上，云数据中心如此庞大且耗电量巨大，它们通常建在靠近发电厂的地方，以获得最便宜的电力费率，而在输电过程中不会损失太多效率。它们的冷却需求如此之大，有些被迫在建造数据中心时寻求创意，选择建在通常气候寒冷的地方，这样他们就可以在需要时打开门窗，保持服务器以安全温度运行。任何搜索引擎都可以给出一些惊人的数字，涉及为亚马逊、微软、谷歌和Facebook等公司建造和管理云数据中心的科学：
- en: '![](assets/e1e5db92-0a09-4928-a28e-44a3ce26d566.png)Utah data center (source:
    https://en.wikipedia.org/wiki/Utah_Data_Center)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: 犹他数据中心（来源：https://en.wikipedia.org/wiki/Utah_Data_Center）
- en: 'At the cloud provider scale, the services that they need to provide are generally
    not cost efficient or able to feasibly be housed in a single server. They are
    spread between a fleet of servers, sometimes across many different racks, to provide
    redundancy and flexibility for service owners. The latency and redundancy requirements
    put a tremendous amount of pressure on the network. The number of interconnections
    equates to an explosive growth of network equipment; this translates into the
    number of times this network equipment needs to be racked, provisioned, and managed.
    A typical network design would be a multi-staged, CLOS network:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在云提供商的规模下，它们需要提供的服务通常不具备成本效益，或者无法合理地容纳在单个服务器中。它们分布在一群服务器之间，有时跨越许多不同的机架，以提供冗余和灵活性给服务所有者。延迟和冗余要求对网络施加了巨大的压力。互连的数量相当于网络设备的爆炸性增长；这意味着这些网络设备需要被装架、配置和管理的次数。典型的网络设计是多级CLOS网络：
- en: '![](assets/7dc245bf-5a7c-4c3c-880a-80a9e3eeb9b7.png)CLOS network'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CLOS网络
- en: In a way, cloud data centers are where network automation becomes a necessity
    for speed and reliability. If we follow the traditional way of managing network
    devices via a Terminal and command-line interface, the number of engineering hours
    required would not allow the service to be available in a reasonable amount of
    time. This is not to mention that human repetition is error-prone, inefficient,
    and a terrible waste of engineering talent.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，云数据中心是网络自动化成为速度和可靠性的必要性的地方。如果我们按照传统的方式通过终端和命令行界面管理网络设备，所需的工程小时数将不允许服务在合理的时间内可用。更不用说人类的重复是容易出错、低效和工程人才的可怕浪费。
- en: Cloud data centers are where I started my path of network automation with Python
    a number of years ago, and I've never looked back since.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 云数据中心是我多年前开始使用Python进行网络自动化的地方，自那以后我就再也没有回头过。
- en: Edge data centers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘数据中心
- en: 'If we have sufficient computing power at the data center level, why keep anything
    anywhere else but at these data centers? All the connections from clients around
    the world can be routed back to the data center servers providing the service,
    and we can call it a day, right? The answer, of course, depends on the use case.
    The biggest limitation in routing the request and session all the way back from
    the client to a large data center is the latency introduced in the transport.
    In other words, large latency is where the network becomes a bottleneck. The latency
    number would never be zero: even as fast as light can travel in a vacuum, it still
    takes time for physical transportation. In the real world, latency would be much
    higher than light in a vacuum when the packet is traversing through multiple networks,
    and sometimes through an undersea cable, slow satellite links, 3G or 4G cellular
    links, or Wi-Fi connections.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在数据中心级别有足够的计算能力，为什么还要将任何东西放在数据中心之外呢？来自世界各地的客户的所有连接都可以路由回提供服务的数据中心服务器，我们就可以结束一天了，对吗？当然，答案取决于用例。将请求和会话从客户端一直路由到大型数据中心的最大限制是传输中引入的延迟。换句话说，大延迟是网络成为瓶颈的地方。延迟数字永远不会为零：即使光在真空中传播得很快，物理传输也需要时间。在现实世界中，当数据包穿过多个网络时，有时还穿过海底电缆、慢速卫星链路、3G或4G蜂窝链路或Wi-Fi连接时，延迟会比真空中的光要高得多。
- en: The solution? Reduce the number of networks the end user traverses through.
    Be as closely connected to the user as possible at the edge where the user enters
    your network and place enough resources at the edge location to serve the request.
    Let's take a minute and imagine that you are building the next generation of video
    streaming service. In order to increase customer satisfaction with smooth streaming,
    you would want to place the video server as close to the customer as possible,
    either inside or very near to the customer's ISP. Also, the upstream of the video
    server farm would not just be connected to one or two ISPs, but all the ISPs that
    I can connect to to reduce the hop count. All the connections would be with as
    much bandwidth as needed to decrease latency during peak hours. This need gave
    rise to the peering exchange's edge data centers of big ISP and content providers.
    Even when the number of network devices is not as high as cloud data centers,
    they too can benefit from network automation in terms of the increased reliability,
    security, and visibility network automation brings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案？减少终端用户穿越的网络数量。尽可能与用户在用户进入您的网络的边缘处紧密连接，并在边缘位置放置足够的资源来提供服务。让我们花一分钟想象一下，您正在构建下一代视频流媒体服务。为了提高顾客对流畅播放的满意度，您会希望将视频服务器尽可能靠近客户，要么在客户的ISP内部，要么非常靠近客户的ISP。此外，视频服务器农场的上游不仅连接到一个或两个ISP，而是连接到我可以连接的所有ISP，以减少跳数。所有连接都将具有所需的带宽，以在高峰时段减少延迟。这种需求催生了大型ISP和内容提供商的对等交换边缘数据中心。即使网络设备的数量不像云数据中心那样多，它们也可以从网络自动化中受益，因为网络自动化带来了增加的可靠性、安全性和可见性。
- en: We will cover security and visibility in later chapters of this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面章节中涵盖安全性和可见性。
- en: The OSI model
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSI模型
- en: 'No network book is complete without first going over the **Open System Interconnection**
    (**OSI**) model. The model is a conceptional model that componentizes the telecommunication
    functions into different layers. The model defines seven layers, and each layer
    sits independently on top of another one, as long as they follow defined structures
    and characteristics. For example, in the network layer, IP, can sit on top of
    the different types of data link layers, such as Ethernet or frame relay. The
    OSI reference model is a good way to normalize different and diverse technologies
    into a set of common language that people can agree on. This greatly reduces the
    scope for parties working on individual layers and allows them to look at specific
    tasks in depth without worrying too much about compatibility:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 没有网络书籍是完整的，没有先讨论**开放系统互连**（**OSI**）模型。该模型是一个概念模型，将电信功能组件化为不同的层。该模型定义了七个层，每个层都独立地位于另一个层的顶部，只要它们遵循定义的结构和特征。例如，在网络层，IP可以位于不同类型的数据链路层的顶部，如以太网或帧中继。OSI参考模型是将不同和多样的技术规范化为一组人们可以达成一致的共同语言的好方法。这大大减少了在各自层上工作的各方的范围，并允许他们深入研究特定任务，而不用太担心兼容性。
- en: '![](assets/762c9bbe-cd1f-4546-a2a7-2725a7caa3e9.png)OSI model'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/762c9bbe-cd1f-4546-a2a7-2725a7caa3e9.png)OSI模型'
- en: The OSI model was initially worked on in the late 1970s and was later published
    jointly by the **International Organization for Standardization** (**ISO**) and
    what's now known as the **Telecommunication Standardization** **Sector** of the
    **International Telecommunication Union** (**ITU-T**). It is widely accepted and
    commonly referred to when introducing a new topic in telecommunication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型最初是在20世纪70年代后期进行研究的，后来由**国际标准化组织**（**ISO**）和现在被称为**国际电信联盟**（**ITU-T**）的**电信标准化部门**联合出版。它被广泛接受，并在引入电信新主题时通常被引用。
- en: 'Around the same time period of the OSI model development, the internet was
    taking shape. The reference model the original designer used is often referred
    to as the TCP/IP model. The **Transmission Control Protocol** (**TCP**) and the **Internet
    Protocol** (**IP**) were the original protocol suites contained in the design.
    This is somewhat similar to the OSI model in the sense that they divide end-to-end
    data communication into abstraction layers. What is different is the model combines
    layers 5 to 7 in the OSI model in the **Application** layer, while the **Physical**
    and **Data link** layers are combined in the **Link** layer:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSI模型开发的同时期，互联网正在形成。原始设计者使用的参考模型通常被称为TCP/IP模型。传输控制协议（TCP）和互联网协议（IP）是最初包含在设计中的协议套件。这在某种程度上类似于OSI模型，因为它们将端到端数据通信分为抽象层。不同的是，该模型将OSI模型中的第5至7层合并为应用层，而物理层和数据链路层合并为链路层。
- en: '![](assets/de93960b-f436-48de-8df4-a620ef2baf4d.png)Internet protocol suite'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议套件
- en: Both the OSI and TCP/IP models are useful for providing standards for end-to-end
    data communication. However, for the most part, we will refer to the TCP/IP model
    more, since that is what the internet was built on. We will specify the OSI model
    when needed, such as when we are discussing the web framework in upcoming chapters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OSI和TCP/IP模型都对提供端到端数据通信的标准很有用。然而，大部分时间我们将更多地参考TCP/IP模型，因为互联网就是建立在这个模型上的。当我们讨论即将到来的章节中的Web框架时，我们将指定OSI模型。
- en: Client-server model
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器模型
- en: The reference models demonstrated a standard way for data to communicate between
    two nodes. Of course, by now, we all know that not all nodes are created equal.
    Even in its DARPA-net days, there were workstation nodes, and there were nodes
    with the purpose of providing content to other nodes. These server nodes typically
    have higher hardware specifications and are managed more closely by engineers.
    Since these nodes provide resources and services to others, they are typically
    referred to as servers. Servers typically sit idle, waiting for clients to initiate
    requests for their resources. This model of distributed resources that are asked
    for by the client is referred to as the client-server model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参考模型展示了数据在两个节点之间进行通信的标准方式。当然，到现在为止，我们都知道，并非所有节点都是平等的。即使在DARPA网络的早期，也有工作站节点，也有目的是向其他节点提供内容的节点。这些服务器节点通常具有更高的硬件规格，并由工程师更密切地管理。由于这些节点向其他节点提供资源和服务，它们通常被称为服务器。服务器通常处于空闲状态，等待客户端发起对其资源的请求。这种由客户端请求的分布式资源模型被称为客户端-服务器模型。
- en: Why is this important? If you think about it for a minute, the importance of
    networking is highlighted by this client-server model. Without it, there is really
    not a lot of need for network interconnections. It is the need to transfer bits
    and bytes from client to server that shines a light on the importance of network
    engineering. Of course, we are all aware of how the biggest network of them all,
    the internet, has been transforming the lives of all of us and continuing to do
    so.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？如果你仔细想一想，客户端-服务器模型凸显了网络的重要性。没有它，网络互连的需求其实并不是很大。正是客户端向服务器传输比特和字节的需求，突显了网络工程的重要性。当然，我们都知道，最大的网络——互联网，一直在改变我们所有人的生活，并持续不断地这样做。
- en: How, you asked, can each node determine the time, speed, source, and destination
    every time they need to talk to each other? This brings us to network protocols.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，每个节点如何确定每次需要相互通信时的时间、速度、源和目的地？这就引出了网络协议。
- en: Network protocol suites
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络协议套件
- en: In the early days of computer networking, protocols were proprietary and closely
    controlled by the company who designed the connection method. If you were using
    **Novell's IPX/SPX** protocol in your hosts, you would not able to communicate
    with Apple's **AppleTalk** hosts and vice versa. These proprietary protocol suites
    generally have analogous layers to the OSI reference model and follow the client-server
    communication method. They generally work great in **Local Area Networks** (**LAN**)
    that are closed, without the need to communicate with the outside world. When
    traffic does need to move beyond the local LAN, typically, an internet working
    device, such as a router, is used to translate from one protocol to another. An
    example would be a router connecting an AppleTalk network to an IP-based network.
    The translation is usually not perfect, but since most of the communication happens
    within the LAN in the early days, it is okay.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机网络的早期，协议是专有的，并由设计连接方法的公司严格控制。如果您在主机中使用Novell的IPX/SPX协议，您将无法与苹果的AppleTalk主机进行通信，反之亦然。这些专有协议套件通常与OSI参考模型具有类似的层，并遵循客户端-服务器通信方法。它们通常在局域网（LAN）中运行良好，这些局域网是封闭的，无需与外部世界通信。当流量需要移动到本地局域网之外时，通常会使用互联网设备，如路由器，来将一个协议转换为另一个协议。例如，路由器连接AppleTalk网络到基于IP的网络。翻译通常不完美，但由于在早期大部分通信发生在局域网内，这是可以接受的。
- en: However, as the need for inter-network communication rises beyond the LAN, the
    need for standardizing the network protocol suites becomes greater. The proprietary
    protocols eventually gave way to the standardized protocol suites of TCP, UDP,
    and IP, which greatly enhanced the ability of one network to talk to another.
    The internet, the greatest network of them all, relies on these protocols to function
    properly. In the next few sections, we will take a look at each of the protocol
    suites.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着对局域网之外的互联网通信需求的增加，标准化网络协议套件的需求变得更加迫切。专有协议最终让位于TCP、UDP和IP的标准化协议套件，这极大地增强了一个网络与另一个网络进行通信的能力。互联网，所有网络中最伟大的网络，依赖这些协议来正常运行。在接下来的几节中，我们将看一下每个协议套件。
- en: The transmission control protocol
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输控制协议
- en: 'The **Transmission Control Protocol** (**TCP**) is one of the main protocols
    used on the internet today. If you have opened a web page or have sent an email,
    you have come across the TCP protocol. The protocol sits at layer 4 of the OSI
    model, and it is responsible for delivering the data segment between two nodes
    in a reliable and error-checked manner. The TCP consists of a 160-bit header consisting
    of, among others, source and destination ports, a sequence number, an acknowledgment
    number, control flags, and a checksum:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）是今天互联网上使用的主要协议之一。如果您打开过网页或发送过电子邮件，您就已经接触过TCP协议。该协议位于OSI模型的第4层，负责以可靠和经过错误检查的方式在两个节点之间传递数据段。TCP由一个包括源端口、目的端口、序列号、确认号、控制标志和校验和在内的160位标头组成：'
- en: '![](assets/c505f800-db13-46d6-b706-c5c3bf1f94e8.png)TCP header'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c505f800-db13-46d6-b706-c5c3bf1f94e8.png)TCP标头'
- en: Functions and characteristics of TCP
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP的功能和特性
- en: TCP uses datagram sockets or ports to establish a host-to-host communication.
    The standard body, called **Internet Assigned Numbers Authority** (**IANA**) designates
    well-known ports to indicate certain services, such as port `80` for HTTP (web)
    and port `25` for SMTP (mail). The server in the client-server model typically
    listens on one of these well-known ports in order to receive communication requests
    from the client. The TCP connection is managed by the operating system by the
    socket that represents the local endpoint for connection.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: TCP使用数据报套接字或端口来建立主机之间的通信。称为**Internet Assigned Numbers Authority**（**IANA**）的标准机构指定了知名端口，以指示特定服务，例如端口`80`用于HTTP（web），端口`25`用于SMTP（邮件）。在客户端-服务器模型中，服务器通常在这些知名端口之一上监听，以便接收来自客户端的通信请求。TCP连接由操作系统通过表示连接的本地端点的套接字来管理。
- en: The protocol operation consists of a state machine, where the machine needs
    to keep track of when it is listening for an incoming connection, during the communication
    session, as well as releasing resources once the connection is closed. Each TCP
    connection goes through a series of states such as `Listen`, `SYN-SENT`, `SYN-RECEIVED`,
    `ESTABLISHED`, `FIN-WAIT`, `CLOSE-WAIT`, `CLOSING`, `LAST-ACK`, `TIME-WAIT`, and
    `CLOSED`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 协议操作由一个状态机组成，其中状态机需要跟踪何时正在监听传入连接，以及在通信会话期间释放资源。每个TCP连接都经历一系列状态，如`Listen`，`SYN-SENT`，`SYN-RECEIVED`，`ESTABLISHED`，`FIN-WAIT`，`CLOSE-WAIT`，`CLOSING`，`LAST-ACK`，`TIME-WAIT`和`CLOSED`。
- en: TCP messages and data transfer
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP消息和数据传输
- en: The biggest difference between TCP and **User Datagram Protocol** (**UDP**),
    which is its close cousin on the same layer, is that it transmits data in an ordered
    and reliable fashion. The fact that the operation guarantees delivery is often
    referred to TCP as a connection-oriented protocol. It does this by first establishing
    a three-way handshake to synchronize the sequence number between the transmitter
    and the receiver, `SYN`, `SYN-ACK`, and `ACK`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和**用户数据报协议**（**UDP**）之间最大的区别是，TCP以有序和可靠的方式传输数据。操作保证传递通常被称为TCP是一种面向连接的协议。它通过首先建立三次握手来同步发送方和接收方之间的序列号`SYN`，`SYN-ACK`和`ACK`来实现这一点。
- en: The acknowledgment is used to keep track of subsequent segments in the conversation.
    Finally, at the end of the conversation, one side will send a `FIN` message, and
    the other side will `ACK` the `FIN` message as well as sending a `FIN` message
    of its own. The `FIN` initiator will then `ACK` the `FIN` message that it received.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确认用于跟踪对话中的后续段。最后，在对话结束时，一方将发送一个`FIN`消息，另一方将`ACK`这个`FIN`消息，并发送自己的`FIN`消息。`FIN`发起方然后将`ACK`收到的`FIN`消息。
- en: As many of us who have troubleshot a TCP connection can tell you, the operation
    can get quite complex. One can certainly appreciate that, most of the time, the
    operation just happens silently in the background.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如许多我们曾经排查过TCP连接的人所能告诉你的那样，这个操作可能会变得非常复杂。大多数情况下，这个操作只是在后台默默地进行。
- en: A whole book could be written about the TCP protocol; in fact, many excellent
    books have been written on the protocol.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TCP协议可以写一整本书；事实上，已经有许多优秀的书籍写就了这个协议。
- en: As this section is a quick overview, if interested, The TCP/IP Guide ([http://www.tcpipguide.com/](http://www.tcpipguide.com/))
    is an excellent free resource that you can use to dig deeper into the subject.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节是一个快速概述，如果感兴趣，可以使用TCP/IP指南（[http://www.tcpipguide.com/](http://www.tcpipguide.com/)）这个优秀的免费资源来深入了解这个主题。
- en: User datagram protocol
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户数据报协议
- en: 'The **User Datagram Protocol** (**UDP**) is also a core member of the internet
    protocol suite. Like TCP, it operates on layer 4 of the OSI model that is responsible
    for delivering data segments between the application and the IP layer. Unlike
    TCP, the header is only 64-bit, which only consists of a source and destination
    port, length, and checksum. The lightweight header makes it ideal for applications
    that prefer faster data delivery without setting up the session between two hosts
    or needing reliable data delivery. Perhaps it is hard to imagine with today''s
    fast internet connections, but the extra header made a big difference to the speed
    of transmission in the early days of X.21 and frame relay links. Although, as
    important as the speed difference is, not having to maintain various states, such
    as TCP, also saves computer resources on the two endpoints:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）也是互联网协议套件的核心成员之一。与TCP一样，它在OSI模型的第4层上运行，负责在应用程序和IP层之间传递数据段。与TCP不同的是，UDP的标头只有64位，其中只包括源端口、目的端口、长度和校验和。轻量级的标头使其非常适合那些更喜欢快速数据传递而不需要在两个主机之间建立会话或需要可靠数据传递的应用程序。也许在今天快速的互联网连接下很难想象，但在X.21和帧中继链路的早期，额外的标头对传输速度产生了很大影响。尽管速度差异同样重要，但与TCP一样，不必维护各种状态也节省了两个端点的计算机资源：'
- en: '![](assets/3ef8b6dc-c13e-4091-b48b-a9f5a882a35a.png)UDP header'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3ef8b6dc-c13e-4091-b48b-a9f5a882a35a.png)UDP标头'
- en: You might now wonder why UDP was ever used at all in the modern age; given the
    lack of reliable transmission, wouldn't we want all the connections to be reliable
    and error-free? If you think about multimedia video streaming or Skype calling,
    those applications benefit from a lighter header when the application just wants
    to deliver the datagram as quickly as possible. You can also consider the fast
    DNS lookup process based on the UDP protocol. When the address you type in on
    the browser is translated into a computer understandable address, the user will
    benefit from a lightweight process, since this has to happen before even the first
    bit of information is delivered to you from your favorite website.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么在现代时代还要使用UDP；考虑到可靠传输的缺乏，我们难道不希望所有连接都是可靠且无错误的吗？如果考虑多媒体视频流或Skype通话，这些应用程序受益于轻量级标头，因为应用程序只是希望尽快传递数据报。您还可以考虑基于UDP协议的快速DNS查找过程。当您在浏览器中输入的地址被转换为计算机可理解的地址时，用户将受益于轻量级过程，因为这必须在您从您喜爱的网站接收到第一个比特之前发生。
- en: Again, this section does not do justice to the topic of UDP, and the reader
    is encouraged to explore the topic through various resources if you are is interested
    in learning more about UDP.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，本节对UDP的主题并不充分，鼓励读者通过各种资源探索该主题，如果您对学习更多关于UDP感兴趣的话。
- en: The internet protocol
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议
- en: 'As network engineers will tell you, they live at the **Internet Protocol**
    (IP) layer, which is layer 3 on the OSI model. **IP** has the job of addressing
    and routing between end nodes, among others. The addressing of an IP is probably
    its most important job. The address space is divided into two parts: the network
    and the host portion. The subnet mask is used to indicate which portion in the
    network address consists of the network and which portion is the host by matching
    the network portion with a 1 and the host portion with a 0\. Both IPv4 and, later,
    IPv6 expresses the address in the dotted notation, for example, `192.168.0.1`.
    The subnet mask can either be in a dotted notation (`255.255.255.0`) or use a
    forward slash to express the number of bits that should be considered in the network
    bit (/24):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如网络工程师所说，他们活在**互联网协议**（IP）层，这是OSI模型的第3层。**IP**的工作是在终端节点之间进行寻址和路由等。IP的寻址可能是它最重要的工作。地址空间分为两部分：网络部分和主机部分。子网掩码用于指示网络地址中的网络部分和主机部分，通过将网络部分与1匹配，主机部分与0匹配。IPv4和后来的IPv6都以点分表示法表示地址，例如`192.168.0.1`。子网掩码可以以点分表示法（`255.255.255.0`）或使用斜杠表示应考虑的网络位数（/24）：
- en: '![](assets/86dd4756-3682-4a2d-89e9-5e8cd3eeae43.png)IPv4 header'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/86dd4756-3682-4a2d-89e9-5e8cd3eeae43.png)IPv4 头部'
- en: 'The IPv6 header, the next generation of the IP header of IPv4, has a fixed
    portion and various extension headers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6头部是IPv4的IP头部的下一代，具有固定部分和各种扩展标头：
- en: '![](assets/04eb0dd0-5fb9-4c7b-8dbf-deac8eb97cdb.png)IPv6 fixed header'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/04eb0dd0-5fb9-4c7b-8dbf-deac8eb97cdb.png)IPv6固定头部'
- en: The **Next Header** field in the fixed header section can indicate an extension
    header to be followed that carries additional information. The extension headers
    can include routing and fragment information. As much as the protocol designer
    would like to move from IPv4 to IPv6, the internet today is still pretty much
    addressed with IPv4, with some of the service provider networks addressed with
    IPv6 internally.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 固定头部中的**下一个标头**字段可以指示后续携带附加信息的扩展标头。扩展标头可以包括路由和分段信息。尽管协议设计者希望从IPv4转移到IPv6，但今天的互联网仍然主要使用IPv4进行寻址，部分服务提供商网络内部使用IPv6进行寻址。
- en: The IP NAT and security
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT和安全
- en: '**Network Address Translation** (**NAT**) is typically used for translating
    a range of private IPv4 addresses into publicly routable IPv4 addresses. But it
    can also mean a translation between IPv4 to IPv6, such as at a carrier edge when
    they use IPv6 inside of the network that needs to be translated to IPv4 when the
    packet leaves the network. Sometimes, NAT6 to 6 is used as well for security reasons.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络地址转换**（**NAT**）通常用于将一系列私有IPv4地址转换为公共可路由的IPv4地址。但它也可以意味着IPv4到IPv6之间的转换，例如在运营商边缘使用IPv6内部网络需要转换为IPv4时。有时也出于安全原因使用NAT6到6。'
- en: Security is a continuous process that integrates all the aspects of networking,
    including automation and Python. This book aims to use Python to help you manage
    the network; security will be addressed as part of the following chapters in the
    book, such as using SSHv2 over telnet. We will also look at how we can use Python
    and other tools to gain visibility in the network.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个持续的过程，整合了网络的所有方面，包括自动化和Python。本书旨在使用Python帮助您管理网络；安全将作为本书后续章节的一部分进行讨论，例如使用SSHv2替代telnet。我们还将探讨如何使用Python和其他工具来获得网络的可见性。
- en: IP routing concepts
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP路由概念
- en: In my opinion, IP routing is about having the intermediate devices between the
    two endpoints transmit the packets between them based on the IP header. For all
    communication via the internet, the packet will traverse through various intermediate
    devices. As mentioned, the intermediate devices consist of routers, switches,
    optical gears, and various other gears that do not examine beyond the network
    and transport layer. In a road trip analogy, you might travel in the United States
    from the city of San Diego in California to the city of Seattle in Washington.
    The IP source address is analogous to San Diego and the destination IP address
    can be thought of as Seattle. On your road trip, you will stop by many different
    intermediate spots, such as Los Angeles, San Francisco, and Portland; these can
    be thought of as the routers and switches between the source and destination.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，IP路由是指让两个端点之间的中间设备根据IP头部传输数据包。对于所有通过互联网进行的通信，数据包将通过各种中间设备传输。如前所述，中间设备包括路由器、交换机、光学设备和其他不会检查网络和传输层以外内容的设备。用一种道路旅行的类比来说，你可能会从加利福尼亚州的圣迭戈市到华盛顿州的西雅图市旅行。IP源地址类似于圣迭戈，目的地IP地址可以被视为西雅图。在你的旅行中，你会经过许多不同的中间地点，比如洛杉矶、旧金山和波特兰；这些可以被视为源地址和目的地之间的路由器和交换机。
- en: Why was this important? In a way, this book is about managing and optimizing
    these intermediate devices. In the age of mega data centers that span the size
    of multiple American football fields, the need for efficient, agile, reliable,
    and cost-effective ways to manage the network becomes a major point of competitive
    advantage for companies. In future chapters, we will dive into how we can use
    Python programming to effectively manage a network.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？在某种程度上，这本书是关于管理和优化这些中间设备。在跨越多个美式橄榄球场大小的超大数据中心时代，高效、灵活、可靠和具有成本效益的网络管理方式成为公司的竞争优势的重要点。在未来的章节中，我们将深入探讨如何使用Python编程有效地管理网络。
- en: Python language overview
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python语言概述
- en: 'In a nutshell, this book is about making our network engineering lives easier
    with Python. But what is Python and why is it the language of choice of many DevOps
    engineers? In the words of the Python Foundation Executive Summary ([https://www.python.org/doc/essays/blurb/](https://www.python.org/doc/essays/blurb/)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这本书是关于如何使用Python使我们的网络工程生活更轻松。但是Python是什么，为什么它是许多DevOps工程师的首选语言呢？用Python基金会执行摘要的话来说：
- en: '"Python is an interpreted, object-oriented, high-level programming language
    with dynamic semantics. Its high-level, built-in data structure, combined with
    dynamic typing and dynamic binding, makes it very attractive for Rapid Application
    Development, as well as for use as a scripting or glue language to connect existing
    components together. Python''s simple, easy-to-learn syntax emphasizes readability
    and therefore reduces the cost of program maintenance."'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: “Python是一种解释型、面向对象的高级编程语言，具有动态语义。它的高级内置数据结构，结合动态类型和动态绑定，使其非常适合快速应用程序开发，以及作为脚本或粘合语言来连接现有组件。Python的简单、易学的语法强调可读性，因此降低了程序维护的成本。”
- en: If you are somewhat new to programming, the object-oriented, dynamic semantics
    mentioned previously probably do not mean much to you. But I think we can all
    agree that for rapid application development, simple, and easy-to-learn syntax
    sounds like a good thing. Python, as an interpreted language, means there is no
    compilation process required, so the time to write, test, and edit Python programs
    is greatly reduced. For simple scripts, if your script fails, a `print` statement
    is usually all you need to debug what was going on. Using the interpreter also
    means that Python is easily ported to different types of operating systems, such
    as Windows and Linux, and a Python program written on one operating system can
    be used on another.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对编程还比较陌生，前面提到的面向对象、动态语义可能对你来说意义不大。但我认为我们都可以同意，对于快速应用程序开发来说，简单易学的语法听起来是一件好事。作为一种解释型语言，Python意味着不需要编译过程，因此编写、测试和编辑Python程序的时间大大缩短。对于简单的脚本，如果你的脚本出错，通常只需要一个`print`语句就可以调试出问题所在。使用解释器还意味着Python很容易移植到不同类型的操作系统，比如Windows和Linux，一个在一个操作系统上编写的Python程序可以在另一个操作系统上使用。
- en: The object-oriented nature encourages code reuse by breaking a large program
    into simple reusable objects, as well as other reusable formats with functions,
    modules, and packages. In fact, all Python files are modules that can be reused
    or imported into another Python program. This makes it easy to share programs
    between engineers and encourages code reuse. Python also has a *batteries included*
    mantra, which means that for common tasks, you need not download any additional
    packages. In order to achieve this without the code being too bloated, a set of
    standard libraries is installed when you install the Python interpreter. For common
    tasks such as regular expression, mathematics functions, and JSON decoding, all
    you need is the `import` statement, and the interpreter will move those functions
    into your program. This is what I would consider one of the killer features of
    the Python language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的特性鼓励通过将大型程序分解为简单可重用的对象来实现代码重用，以及其他可重用的格式，如函数、模块和包。事实上，所有的Python文件都是可以被重用或导入到另一个Python程序中的模块。这使得工程师之间可以轻松共享程序，并鼓励代码重用。Python还有一个“电池包含在内”的口号，这意味着对于常见的任务，你不需要下载任何额外的包。为了在不使代码过于臃肿的情况下实现这一点，当你安装Python解释器时，一组标准库会被安装。对于常见的任务，比如正则表达式、数学函数和JSON解码，你只需要使用`import`语句，解释器就会将这些函数移入你的程序中。这是我认为Python语言的一个杀手功能。
- en: Lastly, the fact that Python code can start in a relatively small-sized script
    with a few lines of code and grow into a full production system is very handy
    for network engineers. As many of us know, the network typically grows organically
    without a master plan. A language that can grow with your network in size is invaluable.
    You might be surprised to see a language that was deemed as a scripting language
    by many is being used for full production systems by many cutting-edge companies
    (organizations using Python, [https://wiki.python.org/moin/OrganizationsUsingPython](https://wiki.python.org/moin/OrganizationsUsingPython)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python代码可以从几行代码的相对小型脚本开始，并逐渐发展成一个完整的生产系统，对于网络工程师来说非常方便。正如我们许多人所知，网络通常是在没有总体规划的情况下有机地发展的。一种可以随着网络规模增长的语言是非常宝贵的。您可能会惊讶地看到，许多前沿公司（使用Python的组织）正在使用被许多人认为是脚本语言的语言来开发完整的生产系统。
- en: If you have ever worked in an environment where you have to switch between working
    on different vendor platforms, such as Cisco IOS and Juniper Junos, you know how
    painful it is to switch between syntaxes and usage when trying to achieve the
    same task. With Python being flexible enough for large and small programs, there
    is no such context switching, because it is just Python.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经在需要在不同的供应商平台上工作时不得不切换，比如Cisco IOS和Juniper Junos，您就知道在尝试完成相同任务时切换语法和用法是多么痛苦。由于Python足够灵活，可以用于大型和小型程序，因此没有这种上下文切换，因为它只是Python。
- en: For the rest of the chapter, we will take a high-level tour of the Python language
    for a bit of a refresher. If you are already familiar with the basics, feel free
    to quickly scan through it or skip the rest of the chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将对Python语言进行高层次的介绍，以便稍作复习。如果您已经熟悉基础知识，可以快速浏览或跳过本章的其余部分。
- en: Python versions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python版本
- en: 'As many readers are already aware, Python has been going through a transition
    from Python 2 to Python 3 for the last few years. Python 3 was released back in
    2008, over 10 years ago, with active development with the most recent release
    of 3.7\. Unfortunately, Python 3 is not backward compatible with Python 2\. At
    the time of writing the second edition of this book, in the middle of 2018, the
    Python community has largely moved over to Python 3\. The latest Python 2.x release,
    2.7, was released over six years ago in mid-2010\. Fortunately, both versions
    can coexist on the same machine. Personally, I use Python 2 as my default interpreter
    when I type in Python at the Command Prompt, and I use Python 3 when I need to
    use Python 3\. More information is given in the next section about invoking Python
    interpreter, but here is an example of invoking Python 2 and Python 3 on an Ubuntu
    Linux machine:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多读者已经意识到，Python在过去几年中一直在从Python 2过渡到Python 3。 Python 3于2008年发布，已经有10多年的历史，最近发布了3.7版本。不幸的是，Python
    3与Python 2不兼容。在撰写本书第二版时，即2018年中期，Python社区基本上已经转向Python 3。最新的Python 2.x版本2.7是在2010年中期发布的，已经有6年多的历史了。幸运的是，两个版本可以在同一台机器上共存。我个人在命令提示符中输入Python时使用Python
    2作为默认解释器，需要使用Python 3时则使用Python 3。关于调用Python解释器的更多信息将在下一节中给出，但这里有一个在Ubuntu Linux机器上调用Python
    2和Python 3的示例：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the 2.7 release being end-of-life, most Python frameworks now support Python
    3\. Python 3 also has lots of good features, such as asynchronous I/O that can
    be taken advantage of when we need to optimize our code. This book will use Python
    3 for its code examples unless otherwise stated. We will also try to point out
    the Python 2 and Python 3 differences when applicable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着2.7版本的终止生命周期，大多数Python框架现在支持Python 3。Python 3还有许多很好的特性，比如异步I/O，在需要优化我们的代码时可以利用这些特性。本书的代码示例将使用Python
    3，除非另有说明。我们还将尽量在适用时指出Python 2和Python 3之间的区别。
- en: If a particular library or framework is better suited for Python 2, such as
    Ansible (see the following information), it will be pointed out and we will use
    Python 2 instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定的库或框架更适合Python 2，比如Ansible（请参阅以下信息），我们将指出并使用Python 2。
- en: At the time of writing, Ansible 2.5 and above have support for Python 3\. Prior
    to 2.5, Python 3 support was considered a tech preview. Given the relatively new
    supportability, many of the community modules are still yet to migrate to Python
    3\. For more information on Ansible and Python 3, please see [https://docs.ansible.com/ansible/2.5/dev_guide/developing_python_3.html](https://docs.ansible.com/ansible/2.5/dev_guide/developing_python_3.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Ansible 2.5及以上版本支持Python 3。在2.5之前，Python 3支持被视为技术预览。鉴于相对较新的支持性，许多社区模块仍然需要迁移到Python
    3。有关Ansible和Python 3的更多信息，请参阅[https://docs.ansible.com/ansible/2.5/dev_guide/developing_python_3.html](https://docs.ansible.com/ansible/2.5/dev_guide/developing_python_3.html)。
- en: Operating system
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统
- en: As mentioned, Python is cross-platform. Python programs can be run on Windows,
    Mac, and Linux. In reality, certain care needs to be taken when you need to ensure
    cross-platform compatibility, such as taking care of the subtle difference between
    backslashes in Windows filenames. Since this book is for DevOps, systems, and
    network engineers, Linux is the preferred platform for the intended audience,
    especially in production. The code in this book will be tested on the Linux Ubuntu
    16.06 LTS machine. I will also try my best to make sure the code runs the same
    on the Windows and the MacOS platform.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python是跨平台的。Python程序可以在Windows、Mac和Linux上运行。实际上，在需要确保跨平台兼容性时需要注意一些细节，比如在Windows文件名中反斜杠的微妙差异。由于本书是为DevOps、系统和网络工程师编写的，Linux是预期受众的首选平台，特别是在生产环境中。本书中的代码将在Linux
    Ubuntu 16.06 LTS机器上进行测试。我也会尽力确保代码在Windows和MacOS平台上运行相同。
- en: 'If you are interested in the OS details, they are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对操作系统的详细信息感兴趣，它们如下：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running a Python program
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Python程序
- en: Python programs are executed by an interpreter, which means the code is fed
    through this interpreter to be executed by the underlying operating system and
    results are displayed. There are several different implementations of the interpreter
    by the Python development community, such as IronPython and Jython. In this book,
    we will use the most common Python interpreter in use today, CPython. Whenever
    we mention Python in this book, we are referring to CPython unless otherwise indicated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序由解释器执行，这意味着代码通过解释器传递给底层操作系统执行，并显示结果。Python开发社区有几种不同的解释器实现，例如IronPython和Jython。在本书中，我们将使用今天最常用的Python解释器，即CPython。在本书中提到Python时，我们指的是CPython，除非另有说明。
- en: 'One way you can use Python is by taking advantage of the interactive prompt.
    This is useful when you want to quickly test a piece of Python code or concept
    without writing a whole program. This is typically done by simply typing in the
    `Python` keyword:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Python的交互式提示符来使用Python的一种方式。当您想要快速测试一段Python代码或概念而不写整个程序时，这是很有用的。通常只需输入`Python`关键字即可：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Python 3, the `print` statement is a function; therefore, it requires parentheses.
    In Python 2, you can omit the parentheses.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，`print`语句是一个函数；因此，它需要括号。在Python 2中，您可以省略括号。
- en: The interactive mode is one of Python's most useful features. In the interactive
    shell, you can type any valid statement or sequence of statements and immediately
    get a result back. I typically use this to explore a feature or library that I
    am not familiar with. Talk about instant gratification!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 交互模式是Python最有用的功能之一。在交互式shell中，您可以输入任何有效的语句或语句序列，并立即得到结果。我通常用它来探索我不熟悉的功能或库。谈论即时满足！
- en: On Windows, if you do not get a Python shell prompt back, you might not have
    the program in your system search path. The latest Windows Python installation
    program provides a checkbox for adding Python to your system path; make sure that
    is checked. Or you can add the program in the path manually by going to Environment
    Settings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，如果没有收到Python shell提示符，则可能没有将程序添加到系统搜索路径中。最新的Windows Python安装程序提供了一个复选框，用于将Python添加到系统路径中；确保已经选中。或者您可以通过转到环境设置手动将程序添加到路径中。
- en: 'A more common way to run the Python program, however, is to save your Python
    file and run it via the interpreter after. This will save you from typing in the
    same statements over and over again like you have to do in the interactive shell.
    Python files are just regular text files that are typically saved with the `.py`
    extension. In the *Nix world, you can also add the **shebang** (`#!`) line on
    top to specify the interpreter that will be used to run the file. The `#` character
    can be used to specify comments that will not be executed by the interpreter.
    The following file, `helloworld.py`, has the following statements:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行Python程序的更常见的方法是保存您的Python文件，并在之后通过解释器运行它。这将使您免于在交互式shell中一遍又一遍地输入相同的语句。Python文件只是通常以`.py`扩展名保存的普通文本文件。在*Nix世界中，您还可以在顶部添加**shebang**（`#!`）行，以指定将用于运行文件的解释器。`#`字符可用于指定不会被解释器执行的注释。以下文件`helloworld.py`包含以下语句：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be executed as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式执行：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Python built-in types
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python内置类型
- en: 'Python has several standard types built in to the interpreter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python在解释器中内置了几种标准类型：
- en: '**None**: The `Null` object'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**None**：`Null`对象'
- en: '**Numerics**: `int`, `long`, `float`, `complex`, and `bool` (the subclass of
    `int` with a `True` or `False` value)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值**：`int`、`long`、`float`、`complex`和`bool`（带有`True`或`False`值的`int`子类）'
- en: '**Sequences**: `str`, list, tuple, and range'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：`str`、list、tuple和range'
- en: '**Mappings**: `dict`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：`dict`'
- en: '**Sets**: `set` and `frozenset`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：`set`和`frozenset`'
- en: The None type
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: None类型
- en: The `None` type denotes an object with no value. The `None` type is returned
    in functions that do not explicitly return anything. The `None` type is also used
    in function arguments to error out if the caller does not pass in an actual value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`类型表示没有值的对象。在不明确返回任何内容的函数中返回`None`类型。`None`类型也用于函数参数，如果调用者没有传入实际值，则会出错。'
- en: Numerics
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值
- en: 'Python numeric objects are basically numbers. With the exception of Booleans,
    the numeric types of `int`, `long`, `float`, and `complex` are all signed, meaning
    they can be positive or negative. A Boolean is a subclass of the integer, which
    can be one of two values: `1` for `True`, and `0` for `False`. The rest of the
    numeric types are differentiated by how precisely they can represent the number;
    for example, `int` are whole numbers with a limited range while `long` are whole
    numbers with unlimited range. Floats are numbers using the double-precision representation
    (64-bit) on the machine.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python数值对象基本上是数字。除了布尔值外，`int`、`long`、`float`和`complex`这些数值类型都是有符号的，这意味着它们可以是正数或负数。布尔值是整数的一个子类，可以是两个值之一：`True`为`1`，`False`为`0`。其余的数值类型是通过它们能够准确表示数字的方式来区分的；例如，`int`是具有有限范围的整数，而`long`是具有无限范围的整数。浮点数是使用机器上的双精度表示（64位）的数字。
- en: Sequences
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: Sequences are ordered sets of objects with an index of non-negative integers.
    In this and the next few sections, we will use the interactive interpreter to
    illustrate the different types. Please feel free to type along on your own computer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是具有非负整数索引的对象的有序集合。在本节和接下来的几节中，我们将使用交互式解释器来说明不同的类型。请随时在您自己的计算机上输入。
- en: 'Sometimes it surprises people that `string` is actually a sequence type. But
    if you look closely, strings are a series of characters put together. Strings
    are enclosed by either single, double, or triple quotes. Note in the following
    examples, the quotes have to match, and triple quotes allow the string to span
    different lines:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们会感到惊讶，`string`实际上是一个序列类型。但是如果你仔细看，字符串是一系列字符组合在一起。字符串可以用单引号、双引号或三引号括起来。请注意，在以下示例中，引号必须匹配，三引号允许字符串跨越不同的行：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The other two commonly used sequence types are lists and tuples. Lists are
    sequences of arbitrary objects. Lists can be created by enclosing objects in square
    brackets. Just like strings, lists are indexed by non-zero integers that start
    at zero. The values of lists are retrieved by referencing the index number:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种常用的序列类型是列表和元组。列表是任意对象的序列。列表可以通过将对象括在方括号中创建。就像字符串一样，列表由从零开始的非零整数索引。通过引用索引号检索列表的值：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Tuples are similar to lists, created by enclosing values in parentheses. Like
    lists, the values in the tuple are retrieved by referencing its index number.
    Unlike lists, the values cannot be modified after creation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类似于列表，通过括号括起的值创建。与列表一样，可以通过引用其索引号来检索元组中的值。与列表不同的是，创建后不能修改值：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Some operations are common to all sequence types, such as returning an element
    by index as well as slicing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有序列类型都有一些共同的操作，例如按索引返回元素以及切片：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that index starts at `0`. Therefore, the index of `1` is actually the
    second element in the sequence.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记住索引从`0`开始。因此，`1`的索引实际上是序列中的第二个元素。
- en: 'There are also common functions that can be applied to sequence types, such
    as checking the number of elements and the minimum and maximum values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些常见的函数可以应用于序列类型，例如检查元素数量和最小值和最大值：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will come as no surprise that there are various methods that apply only
    to strings. It is worth noting that these methods do not modify the underlying
    string data itself and always return a new string. If you want to use the new
    value, you will need to catch the return value and assign it to a different variable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，还有各种方法仅适用于字符串。值得注意的是，这些方法不会修改基础字符串数据本身，并始终返回一个新的字符串。如果您想使用新值，您需要捕获返回值并将其分配给不同的变量：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are some of the common methods for a list. This list is a very useful
    structure in terms of putting multiple items together and iterating through them
    one at a time. For example, we can make a list of data center spine switches and
    apply the same access list to all of them by iterating through them one by one.
    Since a list''s value can be modified after creation (unlike tuples), we can also
    expand and contrast the existing list as we move along the program:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表的一些常用方法。在将多个项目放在一起并逐个迭代它们方面，列表是一种非常有用的结构。例如，我们可以制作一个数据中心脊柱交换机的列表，并通过逐个迭代它们来应用相同的访问列表。由于列表的值可以在创建后修改（与元组不同），因此我们还可以在程序中扩展和对比现有列表：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mapping
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Python provides one mapping type, called the **dictionary**. The dictionary
    is what I think of as a poor man''s database because it contains objects that
    can be indexed by keys. This is often referred to as the associated array or hashing
    table in other languages. If you have used any of the dictionary-like objects
    in other languages, you will know that this is a powerful type, because you can
    refer to the object with a human-readable key. This key will make more sense for
    the poor guy who is trying to maintain and troubleshoot the code. That guy could
    be you only a few months after you wrote the code and troubleshooting at 2 a.m..
    The object in the dictionary value can also be another data type, such as a list.
    You can create a dictionary with curly braces:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种映射类型，称为**字典**。字典是我认为的穷人的数据库，因为它包含可以由键索引的对象。在其他语言中，这通常被称为关联数组或哈希表。如果您在其他语言中使用过类似字典的对象，您将知道这是一种强大的类型，因为您可以使用可读的键引用对象。对于试图维护和排除代码的可怜家伙来说，这个键将更有意义。几个月后，您编写代码并在凌晨2点排除故障时，这个家伙可能就是您。字典值中的对象也可以是另一种数据类型，比如列表。您可以用大括号创建一个字典：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sets
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A **set** is used to contain an unordered collection of objects. Unlike lists
    and tuples, sets are unordered and cannot be indexed by numbers. But there is
    one character that makes sets standout as useful: the elements of a set are never
    duplicated. Imagine you have a list of IPs that you need to put in an access list
    of. The only problem in this list of IPs is that they are full of duplicates.
    Now, think about how many lines of code you would use to loop through the list
    of IPs to sort out unique items, one at a time. However, the built-in set type
    would allow you to eliminate the duplicate entries with just one line of code.
    To be honest, I do not use set that much, but when I need it, I am always very
    thankful it exists. Once the set or sets are created, they can be compared with
    each other using the union, intersection, and differences:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**用于包含无序的对象集合。与列表和元组不同，集合是无序的，不能通过数字索引。但是有一个特点使集合成为有用的：集合的元素永远不会重复。想象一下，您有一个需要放入访问列表中的IP列表。这个IP列表中唯一的问题是它们充满了重复项。现在，想象一下，您需要使用多少行代码来循环遍历IP列表，逐个筛选出唯一的项。然而，内置的集合类型只需要一行代码就可以消除重复的条目。老实说，我并不经常使用集合，但是当我需要它时，我总是非常感激它的存在。一旦创建了集合，它们可以使用并集、交集和差集进行比较：'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Python operators
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python运算符
- en: 'Python has some numeric operators that you would expect; note that the truncating
    division, (`//`, also known as **floor division**) truncates the result to an
    integer and a floating point and returns the integer value. The modulo (`%`) operator
    returns the remainder value in the division:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一些数字运算符，你会期望的；请注意截断除法（`//`，也称为**地板除法**）将结果截断为整数和浮点数，并返回整数值。取模（`%`）运算符返回除法中的余数值：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are also comparison operators. Note the double equals sign for comparison
    and a single equals sign for variable assignment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有比较运算符。请注意，双等号用于比较，单等号用于变量赋值：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also use two of the common membership operators to see whether an object
    is in a sequence type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用两个常见的成员运算符来查看对象是否在序列类型中：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Python control flow tools
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python控制流工具
- en: 'The `if`, `else`, and `elif` statements control conditional code execution.
    As one would expect, the format of the conditional statement is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`、`else`和`elif`语句控制条件代码的执行。正如你所期望的，条件语句的格式如下：'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is a simple example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `while` loop will continue to execute until the condition is `false`, so
    be careful with this one if you don''t want to continue to execute (and crash
    your process):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环将继续执行，直到条件为`false`，所以如果你不想继续执行（并且崩溃你的进程），请小心：'
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `for` loop works with any object that supports iteration; this means all
    the built-in sequence types, such as lists, tuples, and strings, can be used in
    a `for` loop. The letter `i` in the following `for` loop is an iterating variable,
    so you can typically pick something that makes sense within the context of your
    code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环适用于任何支持迭代的对象；这意味着所有内置的序列类型，如列表、元组和字符串，都可以在`for`循环中使用。下面`for`循环中的字母`i`是一个迭代变量，所以你通常可以在代码的上下文中选择一个有意义的东西：'
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can also make your own object that supports the iterator protocol and be
    able to use the `for` loop for this object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建自己的对象，支持迭代器协议，并能够为这个对象使用`for`循环。
- en: Constructing such an object is outside the scope of this chapter, but it is
    useful knowledge to have; you can read more about it at [https://docs.python.org/3/c-api/iter.html](https://docs.python.org/3/c-api/iter.html).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这样一个对象超出了本章的范围，但这是有用的知识；你可以在[https://docs.python.org/3/c-api/iter.html](https://docs.python.org/3/c-api/iter.html)上阅读更多关于它的内容。
- en: Python functions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python函数
- en: 'Most of the time, when you find yourself copy and pasting some pieces of code,
    you should break it up into a self-contained chunk into functions. This practice
    allows for better modularity, is easier to maintain, and allows for code reuse.
    Python functions are defined using the `def` keyword with the function name, followed
    by the function parameters. The body of the function consists of the Python statements
    that are to be executed. At the end of the function, you can choose to return
    a value to the function caller, or by default, it will return the `None` object
    if you do not specify a return value:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当你发现自己在复制和粘贴一些代码片段时，你应该将它们分解成一个自包含的函数块。这种做法可以实现更好的模块化，更容易维护，并允许代码重用。Python函数是使用`def`关键字定义的，后面跟着函数名和函数参数。函数的主体由要执行的Python语句组成。在函数的末尾，你可以选择向函数调用者返回一个值，或者默认情况下，如果你没有指定返回值，它将返回`None`对象：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will see a lot more examples of function in the following chapters, so here
    is a quick example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到更多的函数示例，所以这里是一个快速的例子：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Python classes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python类
- en: Python is an **object-oriented programming** (**OOP**) language. The way Python
    creates objects is with the `class` keyword. A Python object is most commonly
    a collection of functions (methods), variables, and attributes (properties). Once
    a class is defined, you can create instances of such a class. The class serves
    as a blueprint for subsequent instances.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种**面向对象编程**（**OOP**）语言。Python创建对象的方式是使用`class`关键字。Python对象通常是函数（方法）、变量和属性（属性）的集合。一旦类被定义，你就可以创建这样一个类的实例。类作为后续实例的蓝图。
- en: 'The topic of OOP is outside the scope of this chapter, so here is a simple
    example of a `router` object definition:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: OOP的主题超出了本章的范围，所以这里是一个`router`对象定义的简单例子：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once defined, you are able to create as many instances of that class as you''d
    like:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，你就可以创建任意数量的该类的实例：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, there is a lot more to Python objects and OOP. We will look at more
    examples in future chapters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Python对象和OOP还有很多内容。我们将在以后的章节中看到更多的例子。
- en: Python modules and packages
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python模块和包
- en: 'Any Python source file can be used as a module, and any functions and classes
    you define in that source file can be reused. To load the code, the file referencing
    the module needs to use the `import` keyword. Three things happen when the file
    is imported:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Python源文件都可以用作模块，你在该源文件中定义的任何函数和类都可以被重用。要加载代码，引用模块的文件需要使用`import`关键字。当文件被导入时会发生三件事：
- en: The file creates a new namespace for the objects defined in the source file
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件为源文件中定义的对象创建了一个新的命名空间
- en: The caller executes all the code contained in the module
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者执行模块中包含的所有代码
- en: The file creates a name within the caller that refers to the module being imported.
    The name matches the name of the module
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件在调用者内创建一个指向被导入模块的名称。名称与模块的名称匹配
- en: 'Remember the `subtract()` function that you defined using the interactive shell?
    To reuse the function, we can put it into a file named `subtract.py`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得你在交互式shell中定义的`subtract()`函数吗？为了重用这个函数，我们可以把它放到一个名为`subtract.py`的文件中：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In a file within the same directory of `subtract.py`, you can start the Python
    interpreter and import this function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`subtract.py`的同一目录中的文件中，你可以启动Python解释器并导入这个函数：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This works because, by default, Python will first search for the current directory
    for the available modules. If you are in a different directory, you can manually
    add a search path location using the `sys` module with `sys.path`. Remember the
    standard library that we mentioned a while back? You guessed it, those are just
    Python files being used as modules.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认情况下，Python首先会在当前目录中搜索可用的模块。如果你在不同的目录中，你可以使用`sys`模块和`sys.path`手动添加搜索路径位置。还记得我们之前提到的标准库吗？你猜对了，那些只是作为模块使用的Python文件。
- en: 'Packages allow a collection of modules to be grouped together. This further
    organizes Python modules into a more namespace protection to further reusability.
    A package is defined by creating a directory with a name you want to use as the
    namespace, then you can place the module source file under that directory. In
    order for Python to recognize it as a Python-package, just create a `__init__.py`
    file in this directory. In the same example as the `subtract.py` file, if you
    were to create a directory called `math_stuff` and create `a __init__.py` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 包允许将一组模块组合在一起。这进一步将Python模块组织成更具命名空间保护的可重用性。包是通过创建一个希望用作命名空间的名称的目录来定义的，然后可以将模块源文件放在该目录下。为了让Python将其识别为Python包，只需在该目录中创建一个`__init__.py`文件。在与`subtract.py`文件相同的示例中，如果你创建一个名为`math_stuff`的目录并创建一个`__init__.py`文件：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The way you will now refer to the module will need to include the package name:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将引用模块时需要包括包名：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, modules and packages are great ways to organize large code files
    and make sharing Python code a lot easier.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模块和包是组织大型代码文件并使共享Python代码变得更加容易的好方法。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the OSI model and reviewed network protocol suites,
    such as TCP, UDP, and IP. They work as the layers that handle the addressing and
    communication negotiation between any two hosts. The protocols were designed with
    extensibility in mind and have largely been unchanged from their original design.
    Considering the explosive growth of the internet, that is quite an accomplishment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了OSI模型并回顾了网络协议套件，如TCP、UDP和IP。它们作为处理任意两个主机之间的寻址和通信协商的层。这些协议在设计时考虑了可扩展性，并且基本上没有从其原始设计中改变。考虑到互联网的爆炸性增长，这是相当了不起的成就。
- en: We also quickly reviewed the Python language, including built-in types, operators,
    control flows, functions, classes, modules, and packages. Python is a powerful,
    production-ready language that is also easy to read. This makes the language an
    ideal choice when it comes to network automation. Network engineers can leverage
    Python to start with simple scripts and gradually move on to other advanced features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还快速回顾了Python语言，包括内置类型、运算符、控制流、函数、类、模块和包。Python是一种功能强大、适合生产的语言，同时也很容易阅读。这使得Python成为网络自动化的理想选择。网络工程师可以利用Python从简单的脚本开始，逐渐转向其他高级特性。
- en: In [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network
    Device Interactions*, we will start to look at using Python to programmatically
    interact with network equipment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中，*低级网络设备交互*，我们将开始学习如何使用Python与网络设备进行编程交互。
