- en: Data Structures and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和函数
- en: In this chapter, we are going to traverse through the concept of data structures
    and functions, two primary building blocks of Python. Normal variables are a good
    way to store singular units of data of any type, but for arrays of data, we should
    always use data structures. Python has a raft of data structures available that
    you can use to represent and manipulate your datasets, or even to combine them
    in order to make your own data structures. We have already seen built-in data
    types, such as integers, Booleans, floating numbers, strings, and characters.
    They are called built-in because they come as a dovetail with Python. Now, we
    are going to explore built-in data structures, such as lists, dictionaries, tuples,
    and sets. Combinations of these built-in data types result in data structures
    that are implemented independently. For example, if we put different integers
    in one place, they are arrays of numbers. Python call them lists, which are widely
    used data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将穿越数据结构和函数的概念，这是Python的两个主要构建模块。普通变量是存储任何类型的单个数据单元的好方法，但对于数据数组，我们应该始终使用数据结构。Python有大量可用的数据结构，您可以使用它们来表示和操作数据集，甚至将它们组合在一起以制作自己的数据结构。我们已经看到了内置数据类型，如整数，布尔值，浮点数，字符串和字符。它们被称为内置类型，因为它们与Python一起提供。现在，我们将探索内置数据结构，如列表，字典，元组和集合。这些内置数据类型的组合会独立实现数据结构。例如，如果我们将不同的整数放在一个地方，它们就是数字数组。Python称它们为列表，这是广泛使用的数据结构。
- en: In order to become proficient programmers, first we have to learn about core
    programming paradigms, such as variables, numbers, modules, and built-in functions,
    before then diving into the data structures and algorithms. This book is not any
    different. We have already covered the basics of Python; now, it's time to delve
    into the data structures and the method that is used to access and manipulate
    data. In the previous chapter, we modified our game with conditionals and looping.Now,
    let's extend our knowledge of Python to include the broad concept of data structures
    and functions so that we can refine our game decide the most fa
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成为熟练的程序员，我们首先必须了解核心编程范式，如变量，数字，模块和内置函数，然后再深入研究数据结构和算法。这本书也不例外。我们已经介绍了Python的基础知识；现在是时候深入研究数据结构和用于访问和操作数据的方法。在上一章中，我们使用条件和循环修改了我们的游戏。现在，让我们将对Python的知识扩展到包括数据结构和函数的广泛概念，以便我们可以完善我们的游戏决定最快
- en: further.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why do we need data structures?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要数据结构？
- en: The four structural pillars of Python—lists, dictionaries, sets, and tuples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的四个结构支柱-列表，字典，集合和元组
- en: Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Adding AI to a tic-tac-toe game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向井字棋游戏添加人工智能
- en: Game testing and possible modifications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements that you will need to understand this chapter
    properly:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您需要正确理解本章的要求：
- en: The Python IDLE
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python IDLE
- en: The code assets for this chapter can be found at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码资产可以在[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04)找到
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2oNoxOL](http://bit.ly/2oNoxOL)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oNoxOL](http://bit.ly/2oNoxOL)'
- en: Why do we need data structures?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要数据结构？
- en: As a programmer or computer scientist, we always search for ways to optimize
    our code. Optimization is a way of refining code in order to improve code efficiency
    and quality. Data structures are a shrewd way of organizing data in a computer,
    therefore making it easier to retrieve and access data, which results in code
    optimization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员或计算机科学家，我们总是在寻找优化代码的方法。优化是一种改进代码以提高代码效率和质量的方式。数据结构是计算机中组织数据的一种聪明方式，因此更容易检索和访问数据，从而实现代码优化。
- en: 'So far, we have learned how to use conditionals to make conditions, and how
    to make flow controls with normal variables. However, real-world data is not limited
    to one unit. We may collect profuse amounts of data, which would have the highest
    level of intricacies. It may contain thousands of integers, hundreds of Booleans,
    or a combination of these. Thus, storing them into a single, normal variable with
    an assignment statement is not possible. Take a look at the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何使用条件语句来制定条件，以及如何使用普通变量来进行流程控制。然而，现实世界的数据不限于一个单位。我们可能收集大量数据，这些数据可能具有最高级别的复杂性。它可能包含数千个整数，数百个布尔值，或者它们的组合。因此，将它们存储到一个单一的普通变量中是不可能的。请看以下示例：
- en: '![](Images/ceef5509-9abd-4f84-bd5e-7b5f8ae1118b.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ceef5509-9abd-4f84-bd5e-7b5f8ae1118b.png)'
- en: 'In the preceding code, we tried to assign two values to a single variable.
    It produced a syntax error. We even tried to put two string values into a single
    variable, `a`, but instead it performed a concatenation, and assigned it as a
    single value. Thus, storing multiple values in a normal variable is not possible.
    However, we can easily convert this normal variable into a data structure, as
    shown in the following snippet of code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们尝试将两个值分配给一个变量。这产生了语法错误。我们甚至尝试将两个字符串值放入一个变量`a`中，但它执行了连接，并将其分配为单个值。因此，在普通变量中存储多个值是不可能的。但是，我们可以轻松地将这个普通变量转换为数据结构，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have converted the normal `a` variable into a tuple, which is a built-in
    data structure of Python. We will cover this in detail in the upcoming sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将普通变量`a`转换为元组，这是Python的一种内置数据结构。我们将在接下来的部分中详细介绍这一点。
- en: This variable was only able to store a single unit of data, but if we carry
    out multiple assignments, the preceding value would be overwritten. However, if
    you want to preserve all the data in one placeholder, data structures are a way
    of doing this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量只能存储单个数据单元，但如果我们进行多次赋值，前面的值将被覆盖。然而，如果你想在一个占位符中保留所有数据，数据结构是一种方法。
- en: As a programmer, our primary responsibility is to perform some sort of manipulation
    on input datasets. Input can be anything, such as emails or passwords, or maybe
    a request to enter into a system or location for Google Maps, where we can use
    the data to perform some sort of computation using algorithms. In addition, the
    haversine algorithm (refer to the following URL to learn more about this algorithm: [https://rosettacode.org/wiki/Haversine_formula](https://rosettacode.org/wiki/Haversine_formula))
    gives you the exact distance between your location and your destination. Thus,
    input data can have a wide range, but the main task is to manipulate it. Our systems
    and processors are not powerful enough to handle the manipulation of several terabytes
    of data all at once. Thus, choosing a proper data structure is a major optimization
    that can be carried out by the programmer. If we are able to store such inputs
    into faster data structures in any organized form, we can perform even complex
    tasks with ease. Data structures are just places or storage that provide structure
    to such complex data, but processes such as fetch and manipulation are performed
    using algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们的主要责任是对输入数据集进行某种操作。输入可以是任何东西，比如电子邮件或密码，或者可能是进入系统或谷歌地图位置的请求，我们可以使用数据使用算法进行某种计算。此外，haversine算法（请参考以下网址了解更多关于这个算法的信息：[https://rosettacode.org/wiki/Haversine_formula](https://rosettacode.org/wiki/Haversine_formula)）可以给出您的位置和目的地之间的精确距离。因此，输入数据可以有很广泛的范围，但主要任务是对其进行操作。我们的系统和处理器没有足够的能力一次处理数百太字节的数据操作。因此，选择适当的数据结构是程序员可以进行的主要优化。如果我们能够以任何有组织的形式将这些输入存储到更快的数据结构中，我们甚至可以轻松地执行复杂的任务。数据结构只是提供结构给这些复杂数据的地方或存储，但是像获取和操作这样的过程是使用算法来执行的。
- en: Still in doubt? Let's make things clear by taking an example of a library in
    order to understand data structures and algorithms. First of all, imagine a scenario
    where we don't have proper management in a library. Books are not properly placed
    in their relevant sections. Now, searching for a book in a particular section
    is useless, because it won't be there. The best-case scenario is that you may
    find your book within a few minutes, but the worst-case scenario is that you may
    have to search the entire library to find a book about history, for example. However,
    if the library is properly organized and managed, you will be able to go directly
    to the relevant section where history books are stored, and search for your book
    in that section only. Here, the library represents the data structure and the
    book is the data that you are searching for. Whenever you need data, you go to
    the data structure, and if it is properly managed, you will be easily be able
    to retrieve it. The steps that define how you are going to search for the books
    are called algorithms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有疑问吗？让我们通过以图书馆为例来清楚地理解数据结构和算法。首先，想象一个没有适当管理的图书馆的情景。书籍没有被正确放置在相关的部分。现在，在特定部分搜索书籍是没有意义的，因为它不会在那里。最好的情况是你可能会在几分钟内找到你的书，但最坏的情况是你可能不得不搜索整个图书馆来找一本关于历史的书，例如。然而，如果图书馆得到了适当的组织和管理，你将能够直接去到存放历史书籍的相关部分，并且只在那个部分搜索你的书。在这里，图书馆代表了数据结构，书是你正在寻找的数据。每当你需要数据时，你去到数据结构，如果它被适当管理，你将能够轻松地检索到它。定义你将如何搜索书籍的步骤被称为算法。
- en: Enough of the theory—let's get our hands dirty by coding and learning about
    the four pillars of data structures of Python—**lists**, **dictionaries**, **sets**,
    and **tuples.**
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理论够了，让我们动手编码，学习Python的四大数据结构支柱——**列表**、**字典**、**集合**和**元组**。
- en: The four structural pillars of Python – lists, dictionaries, sets, and tuples
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的四大结构支柱——列表、字典、集合和元组
- en: 'In [Chapter 2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning the Fundamentals
    of Python*, we learned about strings, and we called them immutable data types
    because they do not allow assignment operation. This is shown in the following
    code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](06cdc81b-3e57-405e-b721-235214498ac7.xhtml)中，*学习Python的基础知识*，我们学习了字符串，并将它们称为不可变数据类型，因为它们不允许赋值操作。这在以下代码中显示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, data structures must be flexible, which means that we should be able
    to store and extract elements of data from any position. Thus, most of the built-in
    data structures of Python are mutable, which means that they can be changed and
    manipulated with proper indexing. The proper categories for the four data structures
    are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据结构必须是灵活的，这意味着我们应该能够从任何位置存储和提取数据元素。因此，Python的大多数内置数据结构都是可变的，这意味着它们可以通过适当的索引进行更改和操作。四种数据结构的适当类别如下：
- en: '**List and tuple**: Mutable data structures'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表和元组**：可变数据结构'
- en: '**Dictionary**: Mapped data structure'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**：映射数据结构'
- en: '**Set**: Mutable and unordered data structure'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：可变且无序的数据结构'
- en: Each category exists because of its uniqueness, and you will see how easy it
    is to distinguish them as superior or inferior to one another in the upcoming
    sections. However, remember that they are all superior at some point; it's up
    to us to choose a data structure that is appropriate to the situation. For example,
    we say that dictionaries are the king of data structures, but we may come across
    a situation where tuples may be the faster way to store data, which is usually
    the case when we make programs in Python using databases such as SQLite and MySQL.
    Now, let's take a look at each of these built-in data structures of Python, starting
    with a basic mutable data structure, which is known as a list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别都因其独特性而存在，您将看到在接下来的部分中，很容易将它们区分为优越或次优。但是，请记住，它们在某些时候都是优越的；我们可以选择一个适合情况的数据结构。例如，我们说字典是数据结构之王，但我们可能会遇到元组可能是存储数据的更快方式的情况，通常在使用SQLite和MySQL等数据库制作Python程序时会出现这种情况。现在，让我们来看看Python的每个内置数据结构，从基本的可变数据结构开始，即列表。
- en: Lists
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Just like a string is a sequence of characters, a list is a sequence of values.
    Values can be a combination of any type. The values in a list are called items
    of that list. Lists are mutable and ordered data structures, and elements of lists
    can be extracted using indexes. Like strings, we can extract multiple elements
    from a list using the slicing technique. Lists are notorious for storing homogeneous
    data types, but they also support heterogeneous data types. We are not confined
    to creating lists using only a single method; there are multiple ways of doing
    this. Let''s look at some of basic ways of creating lists in Python:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串是字符序列一样，列表是值序列。值可以是任何类型的组合。列表中的值称为该列表的项。列表是可变和有序的数据结构，可以使用索引提取列表的元素。与字符串一样，我们可以使用切片技术从列表中提取多个元素。列表以存储同质数据类型而臭名昭著，但它们也支持异质数据类型。我们不仅限于使用单一方法创建列表；有多种方法可以做到这一点。让我们看一些在Python中创建列表的基本方法：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The simplest way of creating lists is using square brackets—`[]`. You can add
    multiple elements inside these brackets, and there are multiple ways of doing
    this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的最简单方法是使用方括号——`[]`。您可以在这些方括号中添加多个元素，有多种方法可以做到这一点：
- en: 'Firstly, we can add elements to the list at the moment of its declaration,
    as shown in the following example:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以在声明列表的同时向列表中添加元素，如下例所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also add elements to lists using the built-in methods within Python.
    For example, the `append` method can be used to insert elements into the list.
    Elements are added to the last position of the list, as follows:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用Python内置方法向列表中添加元素。例如，`append`方法可用于向列表中插入元素。元素被添加到列表的最后位置，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also make a list containing multiple types of values, as shown in the
    following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个包含多种类型值的列表，如下例所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we made a list containing numbers, strings, and Booleans. Thus, we stored
    heterogeneous data types in a single list. We can also add multiple lists within
    a single list, and these are known as nested lists. As the term suggests, one
    list is nested within another list, as shown in the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个包含数字、字符串和布尔值的列表。因此，我们在一个列表中存储了异构的数据类型。我们还可以在一个列表中添加多个列表，这些被称为嵌套列表。正如术语所示，一个列表嵌套在另一个列表中，如下例所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous example, we created a single list containing six elements. We
    have integers and two whole lists (`[4,5,6]` and `["hey","Python"]`) within that
    primary list. Thus, these types of list are called nested lists.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们创建了一个包含六个元素的单个列表。我们在主列表中有整数和两个整体列表（`[4,5,6]`和`["hey","Python"]`）。因此，这些类型的列表被称为嵌套列表。
- en: Whenever you assign those lists to variables, the variable type eventually becomes
    the list type. Now, the type of variable has been changed from a built-in data
    type such as `int`, `str`, or `bool`, to a built-in data structure, which is the
    list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您将这些列表分配给变量时，变量类型最终变为列表类型。现在，变量的类型已从内置数据类型（如`int`、`str`或`bool`）更改为内置数据结构，即列表。
- en: 'Another way of creating lists is by using the built-in Python method—the `list()`
    method—but it is redundant in the preceding process because we have to pass the
    whole list as an argument of this list method. This is known as the type-casting
    method. If you want to convert any other data structure into a list, we use the
    `list()` method, as shown in the following example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的另一种方法是使用内置的Python方法——`list()`方法——但在前面的过程中是多余的，因为我们必须将整个列表作为这个列表方法的参数。这被称为类型转换方法。如果你想将任何其他数据结构转换为列表，我们使用`list()`方法，如下例所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside the `list()` method, we have to pass an argument in the form of the list
    that contains the elements, which are enclosed using square brackets. You must
    have guessed by this point that every built-in data structure that is available
    in Python must have one built-in method in order to create its data structures.
    We use the `dict()` method to create dictionaries, the `set()` method to create
    sets, and `tuple()` to create tuples in the same way that the `list()` method
    creates lists.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`list()`方法中，我们必须以包含元素的列表形式传递参数，这些元素使用方括号括起来。到这一点，您一定已经猜到了，Python中可用的每个内置数据结构都必须有一个内置方法来创建其数据结构。我们使用`dict()`方法创建字典，使用`set()`方法创建集合，使用`tuple()`创建元组，就像`list()`方法创建列表一样。
- en: Since we have uncovered the different ways of creating a simple, yet powerful,
    data structure that goes by the name of `list` in this section, let's see how
    we can access and manipulate its stored data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本节中揭示了创建一个名为`list`的简单而强大的数据结构的不同方法，让我们看看如何访问和操作其存储的数据。
- en: Accessing list elements
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问列表元素
- en: 'If you recall the way that we access the elements of a string, you can also
    replicate this process in the case of lists. We use square brackets in lists in
    order to indicate the position inside it so that we can extract and interact with
    particular elements. We call this the index, and it is added inside this `[]`
    bracket symbol. It is same when creating new lists. Indexes of lists start from
    0 and increase in unit digits, while also traversing from left to right. Like
    strings, lists also support negative indexing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回忆一下我们访问字符串元素的方式，你也可以在列表的情况下复制这个过程。我们在列表中使用方括号来指示它的位置，这样我们就可以提取和与特定元素交互。我们称之为索引，它被添加在这个`[]`括号符号内。创建新列表时也是一样的。列表的索引从0开始，以单位数字递增，同时从左到右遍历。与字符串一样，列表也支持负索引：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we tried to assign elements to the string, it was not valid. Unlike strings,
    lists provide reassigned items to the list. Thus, we can say that lists are mutable,
    which means that they are changeable and modifiable. This feature makes the list
    the simplest and most flexible data structure of all. We can assign elements using
    the append method, which we saw in the preceding section, but this method only
    allows us to add elements to the end of the list. If you want to add elements
    to any particular position, you can explicitly tell the Python parser to do this
    through indexing and assignment statements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试给字符串赋值时，是无效的。与字符串不同，列表可以重新分配项目给列表。因此，我们可以说列表是可变的，这意味着它们是可改变和可修改的。这个特性使得列表成为所有数据结构中最简单和最灵活的。我们可以使用append方法来分配元素，这是我们在前面部分看到的，但这个方法只允许我们将元素添加到列表的末尾。如果你想要添加元素到任何特定位置，你可以通过索引和赋值语句明确告诉Python解释器来做这件事。
- en: 'For example, if you want to add `loves` in-between two elements of the list,
    you can do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在列表的两个元素之间添加`loves`，你可以这样做：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thus, we can see that the element at position one, `Monica`, has been replaced
    by `loves`, which shows that we can change the order of the elements and reassign
    any other element to the list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到位置一的元素`Monica`已经被`loves`替换，这表明我们可以改变元素的顺序，并重新分配任何其他元素给列表。
- en: 'While dealing with data structures, it''s always good practice to observe them
    hypothetically. We can consider them as a mapping process, where every element
    on the list is mapped to certain indexes. Indexes are positions, and whenever
    we backtrack the list through the indexes, we are able to access elements of these
    indexes. Even if you have a nested list, that is, one or multiple lists inside
    the single list, they will be also mapped to an index, as shown in the following
    example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据结构时，观察它们是一种良好的实践。我们可以将它们视为一种映射过程，列表上的每个元素都映射到某个索引。索引是位置，每当我们通过索引回溯列表时，我们就能访问这些索引的元素。即使你有一个嵌套列表，也就是说，在单个列表内有一个或多个列表，它们也会被映射到一个索引，如下面的例子所示：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We know that square brackets are used to access elements of a list, but if
    we want to access elements of a nested list, we have to add another square bracket
    in order to specify the level of indexes that are needed to access these elements,
    as shown in the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道方括号用于访问列表的元素，但如果我们想要访问嵌套列表的元素，我们必须添加另一个方括号，以指定需要访问这些元素的索引级别，如下面的例子所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can check whether the element is in the list or not by using the `in` keyword.
    The syntax that''s used in the statement''s results give a Boolean value that
    is either `True` or `False`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`in`关键字来检查元素是否在列表中。语句的语法会返回一个布尔值，要么是`True`，要么是`False`：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Accessing the elements of the list is easier, but sometimes if you make mistakes
    when counting proper indexes, it may give an unintended result. Thus, you must
    count the elements of the list from the index, 0\. If you put indexes inside the
    square brackets that do not map to any value, you will run into an error, known
    as `IndexError`, as shown in the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 访问列表的元素更容易，但有时如果在计算正确的索引时出错，可能会得到意外的结果。因此，你必须从索引0开始计算列表的元素。如果你在方括号中放入不映射到任何值的索引，你将遇到一个错误，称为`IndexError`，如下面的例子所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `IndexError` message pretty much explains why we ran into this error. The
    index of the list named odd stops at 4\. However, we passed 20, which is the position
    that has no mapping to the values, or simply, we don't have any elements in this
    position. Thus, while working with lists, we have to track every position of the
    inserted values so that we don't run into any exceptions. However, we have a solution
    to prevent such conditions—just recall the exception handling mate! That's what
    you need to call in order to handle these exceptions so that our code runs properly
    instead of crashing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexError`消息基本上解释了我们为什么会遇到这个错误。名为odd的列表的索引停在4。然而，我们传递了20，这是没有映射到值的位置，或者简单地说，我们在这个位置没有任何元素。因此，在处理列表时，我们必须跟踪插入值的每个位置，以免遇到任何异常。然而，我们有一个解决方案来防止这种情况——只需回想一下异常处理伙伴！这就是你需要调用的，以处理这些异常，使我们的代码能够正常运行而不是崩溃。'
- en: 'Since we have learned how to access these elements using the indexing technique,
    let''s dive into how to traverse the entire list, which is part of accessing the
    entire list. First and foremost, the thing that you must be aware of is looping.
    Since we are dealing with a list that has multiple pieces of data items stored
    in it—which means accessing multiple data, multiple times—we just need to recall
    the method that we would usually use if we want to do things repeatedly. There
    is nothing better than looping that suits this condition perfectly. Thus, the `for`
    loop is the most appropriate method if you want to read the entire elements of
    the list; for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学会了使用索引技术访问这些元素，那么让我们深入了解如何遍历整个列表，这是访问整个列表的一部分。首先，你必须意识到的是循环。因为我们正在处理一个包含多个数据项的列表——这意味着多次访问多个数据——我们只需要回想一下我们通常会使用的重复操作的方法。没有比循环更适合这种情况的了。因此，如果你想读取列表的所有元素，`for`循环是最合适的方法，例如：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also update and refine our list within a `for` loop. The following example
    is among one of the most important examples that we have learned about so far;
    make sure you grasp every teeny-tiny piece of information from it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`for`循环中更新和完善我们的列表。以下示例是我们迄今为止学到的最重要的示例之一；确保你从中掌握每一个细微的信息：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As always, let's break up the preceding code into segments. First of all, we
    declared two empty lists, which will be our output lists of even and odd numbers.
    Then, we used looping to access the elements of the list. The statement range
    (0, 10) will yield a list that contains numbers from 0 to 9\. Here, 10 is the
    exclusion position. Thus, we have looped an entire list of elements one by one.
    If you have any difficulty in understanding the concept of recursion programming,
    recall the *Looping through dictionaries* section. After taking every element
    of the list at each iteration, we enter the body of the loop and check for the
    condition that will determine whether the elements are even or not. If it is even,
    we append it, which means that we insert that element into the `even_num` list,
    and we do a similar thing in the case of odd numbers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们将前面的代码分成几个部分。首先，我们声明了两个空列表，它们将是我们的偶数和奇数列表的输出列表。然后，我们使用循环来访问列表的元素。语句range(0,
    10)将生成一个包含0到9的数字的列表。这里，10是排除位置。因此，我们逐个循环整个元素列表。如果你对递归编程的概念有困难，回想一下*遍历字典*部分。在每次迭代中取出列表的每个元素后，我们进入循环体并检查将确定元素是偶数还是奇数的条件。如果是偶数，我们将其追加，这意味着我们将该元素插入`even_num`列表中，在奇数的情况下我们也是这样做的。
- en: Wow, do you realize what you just did? You have used a simple yet powerful data
    structure and carried out a linear search. Although we have many more topics to
    cover, this is the best thing that we have done so far. Now, gear yourself up
    to learn more about list operations and methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，你意识到你刚刚做了什么吗？你使用了一个简单但强大的数据结构，并进行了线性搜索。虽然我们还有很多其他主题要讨论，但这是迄今为止我们所做的最好的事情。现在，准备好学习更多关于列表操作和方法的知识。
- en: List operations and methods
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表操作和方法
- en: 'Can you recall the type-casting method of Python from  the preceding chapter?
    It is surely the best way to convert one data type into another. We have looked
    at strings, its slicing techniques, and methods. However, we came to realize that
    it was immutable. This restriction is so robust that we can''t change any of the
    elements of that string. However, now we have come to the most flexible data structure,
    which goes by the name of `list`. So, why not convert the string into a list so
    that we can make it mutable too. Let''s use the following example to clarify this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得前一章中Python的类型转换方法吗？这绝对是将一种数据类型转换为另一种的最佳方法。我们已经看过字符串、它的切片技术和方法。不过，我们意识到它是不可变的。这种限制是如此强大，以至于我们无法更改该字符串的任何元素。不过，现在我们已经来到了最灵活的数据结构，它被称为`list`。那么，为什么不将字符串转换为列表，以便我们也可以使其可变呢。让我们使用以下示例来澄清这一点：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we can manipulate the preceding list however we like; maybe using built-in
    methods. However, most of the operation, apart from the assignment, is quite similar
    to that of strings. We learned so much in the string section, such as slicing,
    addition, and multiplication operations, and even some of the string methods.
    Strings and list manipulation are quite similar-they even start with same index,
    0\. That said, the built-in methods that are provided by Python for strings and
    lists are not quite as similar, and why would they be? They are different types
    of data or structures.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以随心所欲地操作前面的列表；也许使用内置方法。不过，除了赋值之外，大多数操作与字符串的操作相似。我们在字符串部分学到了很多东西，比如切片、加法和乘法操作，甚至一些字符串方法。字符串和列表的操作相当相似——它们甚至从相同的索引0开始。也就是说，Python为字符串和列表提供的内置方法并不是那么相似，为什么会呢？它们是不同类型的数据或结构。
- en: 'You can do arithmetic operations with a list, such as addition and multiplication.
    Remember, though, that addition can only be done between two lists, whereas multiplication
    must be done between a list and any integer number, as shown in the following
    examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对列表进行算术运算，比如加法和乘法。不过要记住，加法只能在两个列表之间进行，而乘法必须在列表和任何整数之间进行，如下面的例子所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the first example, we performed concatenation between the lists using the
    addition operator. In the second example, we multiplied the list by three, and
    the effect of the multiplication can be observed within the content of that list.
    In our case, `john` has been multiplied by three to create three `john` values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用加法运算符对列表执行了连接操作。在第二个例子中，我们将列表乘以三，乘法的效果可以在该列表的内容中观察到。在我们的例子中，`john`被乘以三，创建了三个`john`值。
- en: The built-in methods that are provided by Python are used to manipulate the
    values of the list. They act upon the list by creating an object of it. Let's
    not confuse ourselves by talking about objects here; we have a dedicated chapter
    for that.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供的内置方法用于操作列表的值。它们通过创建列表的对象来对列表进行操作。让我们不要在这里谈论对象，我们有一个专门的章节来讨论对象。
- en: There are a lot of built-in methods available that can manipulate list structures,
    but we are going to cover the most important ones here. I find them useful because
    most developers use only a few of these when carrying out big projects. However,
    if you want to discover more, it's always good practice to take a tour of the
    documentation page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的内置方法可以操作列表结构，但我们将在这里介绍最重要的方法。我发现它们很有用，因为大多数开发人员在进行大型项目时只使用其中的一些。但是，如果你想发现更多，浏览文档页面总是一个好的实践。
- en: 'We have already seen how we can use the `append` method to insert elements
    into the list. This method adds elements to the end of the list. But if you want
    to insert more than one element into the list, we can use the `extend` method,
    as shown in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`append`方法将元素插入列表。这个方法将元素添加到列表的末尾。但是，如果你想要插入多个元素到列表中，我们可以使用`extend`方法，如下例所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, the `extend` method takes the list as an argument, and
    appends all the elements of the list that are being called upon. When we print
    `list_2`, we will see that the list will remain unchanged.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`extend`方法将列表作为参数，并附加调用的列表的所有元素。当我们打印`list_2`时，我们会看到列表保持不变。
- en: 'In the same way that there is a method to add elements to the list, we also
    have a method that can delete elements from the list. Actually, there are two
    methods that can be used to delete elements. One works by passing an argument
    as an index, while the other works by passing an argument directly as an element
    that needs to be deleted. When we use the `pop` method, we have to pass the index
    of the element that needs to be deleted from the list; but when we use the `remove`
    method, we have to pass the element to it in order to specify that this particular
    element needs to be deleted. Take a look at the following snippet of code for
    an example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加元素到列表的方法类似，我们也有一个可以从列表中删除元素的方法。实际上，有两种方法可以用来删除元素。一种是通过将索引作为参数传递，而另一种是直接将要删除的元素作为参数传递。当我们使用`pop`方法时，我们必须传递要从列表中删除的元素的索引；但是当我们使用`remove`方法时，我们必须将元素传递给它，以指定需要删除的特定元素。看一下以下代码片段的例子：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is another way of deleting elements in a list, which is by using the
    simple `del` keyword. Warning: if you write `>>> del fruits` , the entire list
    will be deleted. Make sure you explicitly specify the elements that need to be
    deleted. Specific elements can be fetched in a similar way to how we access elements
    using square brackets, as shown in the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种删除列表中元素的方法，就是使用简单的`del`关键字。警告：如果你写`>>> del fruits`，整个列表将被删除。确保你明确指定需要删除的元素。可以以类似于使用方括号访问元素的方式获取特定元素，如下例所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are a bunch of built-in functions that are available in Python that can
    perform arithmetic and logical operations on a list. Using these functions inevitably
    makes code cleaner and readable, and we can perform numerous tasks within a single
    line. Some of the important built-in functions for a Python list are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多可用的内置函数，可以对列表执行算术和逻辑操作。使用这些函数不可避免地使代码更清晰、更可读，我们可以在一行内执行许多任务。Python列表的一些重要内置函数如下：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `sum` function will give us a result of addition between the elements
    of the list. This method works only on the integers and floating values. Next,
    the min and max functions give the minimum and maximum values of the list, respectively.
    Another important function is `len()`, which will give us the length of the list.
    This `len` function works on any of the objects. In addition, we can use it with
    strings in order to find the number of characters in the list.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sum`函数将给我们一个列表元素之间的加法结果。这个方法只适用于整数和浮点值。接下来，min和max函数分别给出列表的最小值和最大值。另一个重要的函数是`len()`，它将给出列表的长度。这个`len`函数适用于任何对象。此外，我们可以将它与字符串一起使用，以找到列表中字符的数量。
- en: Sometimes, you may only want to extract particular portions or slices of the
    list, for example, only the first four items stored in a list that contains 1,000
    items. In such cases, you have to use the slicing technique, which will be covered
    in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只想提取列表的特定部分或切片，例如，只提取包含1000个项目的列表中存储的前四个项目。在这种情况下，你必须使用切片技术，这将在下一节中介绍。
- en: Slicing the list
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片列表
- en: 'Before learning the technique of slicing a list, let''s recall how we sliced
    parts of a string. We used the square brackets operator to specify the start and
    endpoint for the slicing. It is quite similar in the case of lists, as shown in
    the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习切片列表的技巧之前，让我们回顾一下如何切片字符串的部分。我们使用方括号运算符指定切片的起始和结束点。在列表的情况下，情况相当类似，如下例所示：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Slicing a list can be done by adding a start index and a stop index within
    square brackets. In the preceding example, the stop index element is excluded
    from the resulting slices. Let''s make a simple example that can slice parts of
    the element of our list:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在方括号内添加起始索引和停止索引来对列表进行切片。在前面的例子中，停止索引元素被排除在结果切片之外。让我们做一个简单的例子，可以切片我们列表中的元素的部分：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second colon given in the `info[:3:]` statement is optional. The first
    semicolon separates two blocks as the start and end positions, but the second
    colon would be unnecessary if you don''t want to add `step`. To learn more about
    `[start:stop:step]`, check out the *String slicing technique* section in [Chapter
    2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning the Fundamentals of
    Python*. Take the following code as an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`info[:3:]`语句中给出的第二个冒号是可选的。第一个分号将两个块分开，作为起始和结束位置，但如果您不想添加`step`，则第二个冒号是不必要的。要了解更多关于`[start:stop:step]`的信息，请查看[第2章](06cdc81b-3e57-405e-b721-235214498ac7.xhtml)
    *学习Python基础*中的*字符串切片技术*部分。以以下代码为例：'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, `>>> info[:3:]`, we have added a colon (`:`) separator
    within square brackets to specify the indexes of the list. The space before the
    first colon is the starting index for slicing; here, we passed the empty index,
    which means it is the default, and it will start to slice from the beginning of
    that list. We passed index three to the next placeholder after the first colon
    in order to specify the end index for the slicing procedure. Here, the element
    at index three is `Java`, but it is in the exclusion position, which means it
    will slice from the beginning of list until the element at index two. The last
    placeholder after the second colon specifies the steps that need to be included
    in the slicing. Its value is empty, which means it's the default;, thus, we get
    a result without skipping any of the elements in-between those indexes. It works
    in the same way as the string slicing technique.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`>>> info[:3:]`，我们在方括号内添加了一个冒号（`:`）分隔符来指定列表的索引。第一个冒号前的空格是切片的起始索引；这里，我们传递了空索引，这意味着它是默认的，它将从列表的开头开始切片。我们在第一个冒号后的下一个占位符中传递了索引三，以指定切片过程的结束索引。这里，索引三处的元素是`Java`，但它处于排除位置，这意味着它将从列表的开头切片直到索引为二的元素。第二个冒号后的最后一个占位符指定了切片中需要包含的步骤。它的值为空，这意味着它是默认的；因此，我们得到了一个在这些索引之间没有跳过任何元素的结果。它的工作方式与字符串切片技术相同。
- en: Now, let's learn about the needs of lists by examining the pitfalls of string
    objects. We will see how a list is considered superior and more prevalent than
    a string in the next section**.**
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查字符串对象的缺陷来了解列表的需求。我们将在下一节中看到，列表被认为比字符串更优越和更普遍**。**
- en: String and list objects
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和列表对象
- en: 'So far, we have covered multiple topics about lists; we saw how to create one
    for ourselves, and we saw how to add, delete, and manipulate elements of lists
    using built-in methods. Now, let''s talk about another important concept of string
    and list-objects. Whenever we create any string, an object is created and stored
    in a particular memory reference. For any string that''s created in a program,
    the Python parser creates one object for them, as shown in the following example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了关于列表的多个主题；我们看到了如何为自己创建一个列表，并且我们看到了如何使用内置方法添加、删除和操作列表的元素。现在，让我们谈谈关于字符串和列表对象的另一个重要概念。每当我们创建任何字符串时，都会创建一个对象并将其存储在特定的内存引用中。对于程序中创建的任何字符串，Python解析器都会为它们创建一个对象，如下例所示：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding examples, both `name_1` and `name_2` point to same object.
    Thus, we can say that they are equivalent and identical. Two variables were created
    with the same `Python` string. These two assignment operations do not create two
    objects; instead, a single object is created and mapped into a global namespace.
    We can see that both of these variables, which have the same content, create a
    single object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`name_1`和`name_2`都指向同一个对象。因此，我们可以说它们是等价和相同的。使用相同的`Python`字符串创建了两个变量。这两个赋值操作并不会创建两个对象；相反，会创建一个单一的对象并映射到全局命名空间中。我们可以看到，这两个具有相同内容的变量创建了一个单一的对象：
- en: '![](Images/9705e59f-a13d-438b-b959-b0e5818f6eb7.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9705e59f-a13d-438b-b959-b0e5818f6eb7.png)'
- en: 'But in the case of a list, even if the contents is the same, they create two
    distinct objects, as shown in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在列表的情况下，即使内容相同，它们也会创建两个不同的对象，如下例所示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can clearly see that we get a result of `False` in the preceding code, which
    means that these two list are two different objects. They are not similar, although
    their contents are similar. Thus, whenever we create list variables, we term them
    as a list object, and its content is the value of that object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地看到，在前面的代码中，我们得到了`False`的结果，这意味着这两个列表是两个不同的对象。它们并不相似，尽管它们的内容是相似的。因此，每当我们创建列表变量时，我们将它们称为列表对象，其内容是该对象的值。
- en: Finally, we have covered our elemental and powerful `list` data structure in
    this section. Although we have not discovered the power of `list` yet, we have
    been using it from [Chapter 2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning
    the Fundamentals of Python*. Do you remember that we used `list` to represent
    the positions of the tic-tac-toe board game? Thus, we can conclude that, even
    when we have more robust and complex data structures such as dictionaries, trees,
    and queues, lists are considered the **Queen** of data structures because of their
    usefulness in holding complex data types within simple structures. Now, let's
    learn about **dictionaries**, which are considered the **King** of the data structures.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本节中，我们已经介绍了我们的基本和强大的`list`数据结构。虽然我们还没有发现`list`的威力，但我们从[第2章](06cdc81b-3e57-405e-b721-235214498ac7.xhtml)
    *学习Python基础*开始就一直在使用它。你还记得我们用`list`来表示井字棋游戏的位置吗？因此，我们可以得出结论，即使我们有更强大和复杂的数据结构，如字典、树和队列，列表仍被认为是数据结构的**女王**，因为它们在简单的结构中容纳复杂的数据类型时非常有用。现在，让我们学习一下**字典**，它被认为是数据结构的**国王**。
- en: Dictionaries
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Any discovery of a new data structure occurs because of the deficits in the
    preceding ones. Let's recall the demerits of the list. We have stored elements
    in the list structure that follow some order, and we must use indexes to retrieve
    those values. However those indexes are imaginary. Whenever you want to work with
    the list, you will have the overhead of remembering the order of that sequence,
    otherwise you will run into an `IndexError` exception.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对新数据结构的发现是因为先前数据结构的缺陷。让我们回顾一下列表的缺点。我们已经将元素存储在遵循某种顺序的列表结构中，并且我们必须使用索引来检索这些值。但是这些索引是虚构的。每当您想使用列表时，您都必须记住该序列的顺序，否则您将遇到`IndexError`异常。
- en: 'Now, let''s learn about more of the sturdy data structure that is available
    in Python. Dictionary, as the term implies, involves working the data structure
    in a way that is quite similar to our Oxford Dictionary. In our real-world dictionary,
    we have key and value pairs. Key refers to the word that you want to search for
    in the dictionary, while value refers to the meaning of that word. Similar to
    the Oxford Dictionary, we have key and value pairs in our dictionary data structure,
    and we call them elements or items, collectively. In the case of lists, we also
    have key and value pairs. Key was imaginary, which was the index, and the value
    was the element of that list, as shown in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下Python中可用的更坚固的数据结构。字典，顾名思义，涉及以与牛津词典相似的方式处理数据结构。在我们的现实世界字典中，我们有键和值对。键是指您想在字典中搜索的单词，而值是指该单词的含义。与牛津词典类似，我们的字典数据结构中也有键和值对，并且我们将它们称为元素或项目。在列表的情况下，我们也有键和值对。键是虚构的，即索引，值是该列表的元素，如下例所示：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, the `python` string is the value and index zero is its key. In the case
    of lists, keys are only integers. In the case of dictionaries, keys can be of
    any type. We need to explicitly specify keys within the dictionary structure.
    Between each key and value pair, we need to put a single colon (`:`). Let''s create
    one dictionary to make things clear:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`python`字符串是值，索引零是它的键。在列表的情况下，键只能是整数。在字典的情况下，键可以是任何类型。我们需要在字典结构中明确指定键。在每个键和值对之间，我们需要放一个冒号（`:`）。让我们创建一个字典来澄清事情：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We used square brackets, `[]`, to create lists. But now, we will use curly
    braces, `{}`, to create dictionaries. We have to add items to the dictionary using
    the `key:value` pair. Let''s create a simple dictionary, which will contain the
    names of people as keys, and their ages as values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用方括号`[]`来创建列表。但现在，我们将使用花括号`{}`来创建字典。我们必须使用`键:值`对向字典中添加项目。让我们创建一个简单的字典，其中包含人名作为键，年龄作为值：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can imagine a dictionary as a mapper between a set of indexes and a set
    of values. Here, indexes can be of any type, unlike integers for lists. In our
    `info` dictionary, we made keys as sets of strings and values as integers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将字典想象为一组索引和一组值之间的映射器。在这里，索引可以是任何类型，而不像列表那样只能是整数。在我们的`info`字典中，我们将键设置为字符串集合，将值设置为整数。
- en: 'Now, let''s observe the `info` dictionary that was printed in the preceding
    code. We can clearly see that the output sequence is not printed in the same order
    to that of the input. The element positions have been exchanged. In this case,
    where there are fewer elements, this might not be an issue. However, if we create
    a dictionary with 1,000 of items in it, you will clearly observe that the order
    of the output dictionary won''t be the same to that of the input. In our example,
    we add the `Ross` key at the end of the dictionary, but while printing the same
    dictionary, we got `Ross: 55` added in the second position. So, you might be wondering,
    will it make any difference while accessing the elements of that dictionary? Not
    at all! dictionaries are arranged without an order, unlike that of a list. To
    access the elements of the dictionary, we have to use keys as an identifier. Accessing
    elements of the dictionary is quite similar to that of a list, but instead of
    putting indexes inside the square brackets, we put keys into it. For example,
    if you want to fetch the age of `Monica`, we use the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们观察一下在前面的代码中打印出的`info`字典。我们可以清楚地看到输出序列与输入的顺序不同。元素位置已经交换。在这种情况下，如果元素较少，这可能不是问题。但是，如果我们创建一个包含1,000个项目的字典，您将清楚地观察到输出字典的顺序与输入的顺序不同。在我们的示例中，我们将`Ross`键添加到字典的末尾，但在打印相同的字典时，我们得到`Ross:
    55`添加到第二个位置。因此，您可能会想知道，访问该字典的元素会有什么区别吗？一点也没有！字典是无序排列的，不像列表那样。要访问字典的元素，我们必须使用键作为标识符。访问字典的元素与访问列表的元素非常相似，但是我们不是在方括号内放置索引，而是放置键。例如，如果您想获取`Monica`的年龄，我们使用以下代码：'
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Instead of `IndexError`, we will get `KeyError`, which specifies that there
    is no such element inside the dictionary that has a key named `Chandler`. Thus,
    accessing the list can be an overhead because we have to track every possible
    index of that list. It won't be a problem for lists that are smaller in length,
    but imagine a list containing 10,000 or more elements. To overcome this expense,
    it's better to use dictionaries, since they are easier to access and the chances
    of running into exceptions is also meager. That being said, dictionaries are also
    not perfect data structures, and we will see the reason why most people prefer
    lists over dictionaries in the upcoming sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到`KeyError`而不是`IndexError`，这指定字典中没有名为`Chandler`的键的元素。因此，访问列表可能会增加负担，因为我们必须跟踪该列表的每个可能的索引。对于长度较小的列表来说，这不是问题，但想象一下包含10,000个或更多元素的列表。为了克服这种开销，最好使用字典，因为它们更容易访问，而且遇到异常的几率也较小。话虽如此，字典也不是完美的数据结构，我们将在接下来的部分看到为什么大多数人更喜欢列表而不是字典。
- en: 'There is also another way of creating a dictionary, which is using the `dict()`
    method. Let''s see how it is used:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建字典的方法是使用`dict()`方法。让我们看看它是如何使用的：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have created an empty dictionary using the built-in `dict()` method. Now,
    let''s see how we can add elements to that dictionary:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置的`dict()`方法创建了一个空字典。现在，让我们看看如何向该字典添加元素：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since we have seen how to create our own dictionary using two methods, let's
    see how we can fetch every element of that dictionary. Since our data structure
    may contain many values, we must use loops to iterate over it. We'll look at how,
    w can loop through dictionaries in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了如何使用两种方法创建自己的字典，让我们看看如何获取该字典的每个元素。由于我们的数据结构可能包含许多值，我们必须使用循环来迭代它。我们将在下一节中看看如何遍历字典。
- en: Looping through dictionaries
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历字典
- en: 'Since dictionaries contain a finite number of keys and values, we can use a
    `for` loop to iterate over it. A `for` loop will traverse through the keys of
    the dictionary. The value of a particular key can be extracted by using square
    brackets, `[]`, and passing keys inside it. Let''s see how this works:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典包含有限数量的键和值，我们可以使用`for`循环来迭代它。`for`循环将遍历字典的键。可以使用方括号`[]`来提取特定键的值，并将键传递给它。让我们看看这是如何工作的：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, `info[key]` is going to extract the value of that key.
    The `for` loop will traverse through the keys of the dictionary, and iterating
    the `key` variable will store the key of the dictionary in each iteration. However,
    if we want to extract the key and value within the for loop, we will get `ValueError`.
    Let''s see what I mean by this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`info[key]`将提取该键的值。`for`循环将遍历字典的键，并且在每次迭代中，`key`变量将存储字典的键。然而，如果我们想要在`for`循环内提取键和值，我们将会得到`ValueError`。让我们看看我是什么意思：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We get the preceding error because dictionaries are not iterables. However,
    we can convert it into another data structure, such as a tuple or lists so that
    we can fetch keys and values directly within the definition of the `for` loop.
    We will make this dictionary iterable by converting it into a tuple, which will
    be covered in the upcoming section about tuples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了前面的错误，因为字典不是可迭代的。然而，我们可以将其转换为另一个数据结构，例如元组或列表，以便我们可以直接在`for`循环的定义中获取键和值。我们将通过将其转换为元组使这个字典可迭代，这将在即将到来的关于元组的部分中介绍。
- en: Python provides a bunch of built-in methods in order to manipulate dictionaries
    according to your needs. For example, if you want to delete an item or insert
    an item to the dictionary, you don't have to make your custom logic to implement
    it; instead, Python has built-in functions for this. We will cover some of the
    most important dictionary methods in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一堆内置方法，以便根据您的需求操作字典。例如，如果您想要删除一个项目或向字典中插入一个项目，您不必编写自定义逻辑来实现它；相反，Python有内置函数来实现这一点。我们将在下一节中介绍一些最重要的字典方法。
- en: Dictionary methods
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典方法
- en: 'Adding elements to the dictionary is easier, and we have already seen a couple
    of examples of this. Now, let''s see how we can remove an element from the dictionary
    using the `pop()` method. For the argument that''s given as a key to `pop()`,
    this method removes and returns an element from that dictionary. Let''s look at
    a simple example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典添加元素更容易，我们已经看到了一些例子。现在，让我们看看如何使用`pop()`方法从字典中删除一个元素。对于作为`pop()`键的参数，该方法将从字典中删除并返回一个元素。让我们看一个简单的例子：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you want to retrieve a particular value of the key, we can use the `get`
    method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检索键的特定值，可以使用`get`方法：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can call the `values` method into the dictionary, which will return an object
    view that will represent all the values of the dictionary. Similar to `values()`,
    we can use the `keys()` method to print dictionary objects, which will represent
    all the keys of the dictionary:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`values`方法进入字典，它将返回一个对象视图，表示字典的所有值。类似于`values()`，我们可以使用`keys()`方法打印字典对象，它将表示字典的所有键：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also use the `len()` method, which will return the number of items that
    are stored in the dictionary, as shown in the following example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`len()`方法，它将返回存储在字典中的项目数，如下例所示：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you want to print a shallow copy of your dictionary, the `copy()` method
    can be used, as shown in the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想打印字典的浅拷贝，可以使用`copy()`方法，如下例所示：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now,we have looked at some examples that have given us the knowledge to create
    our own dictionary and showed us how to access them using various dictionary methods.
    Now, let's explore tuples—another immutable data structure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了一些例子，这些例子让我们知道如何创建自己的字典，并向我们展示了如何使用各种字典方法访问它们。现在，让我们探索元组——另一个不可变的数据结构。
- en: Tuples
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples are quite similar to lists in terms of processing, but they are immutable,
    unlike lists, which are mutable or changeable. We can store sequence of values
    within the tuple in a fashion that is similar to a list. Like we used `[]` to
    create a list, and `{}` to create a dictionary, we use `use()` to create tuples.
    The values that are stored in the tuple can be of any type, and each of these
    values are mapped by indexes in the same way as a list. The index of the first
    element of a tuple is zero, and it starts to increment with one, while at the
    same time, traversing from left to right. One of the merits of tuples is that
    they are iterables. Thus, we can convert non-iterable data structures, such as
    dictionaries, into tuple, so that we can extract key and value pairs within the
    loop declaration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在处理方面与列表非常相似，但它们是不可变的，而列表是可变的。我们可以以类似于列表的方式在元组中存储值的序列。就像我们使用`[]`来创建列表，使用`{}`来创建字典一样，我们使用`()`来创建元组。存储在元组中的值可以是任何类型，并且这些值都通过索引进行映射，就像列表一样。元组的第一个元素的索引是零，并且从左到右递增，同时从左到右遍历。元组的一个优点是它们是可迭代的。因此，我们可以将非可迭代的数据结构，例如字典，转换为元组，以便我们可以在循环声明中提取键和值对。
- en: 'Let''s create a simple tuple:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的元组：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also use the built-in method in Python to create tuples. We can create
    empty tuples using the `tuple()` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Python中的内置方法来创建元组。我们可以使用`tuple()`方法创建空元组：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you want to create a tuple with a single element in it, you have to add
    a comma after adding this element, otherwise Python treats it as a built-in data
    type, such as an integer or a string, as shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个只有一个元素的元组，您必须在添加这个元素后加上逗号，否则Python会将其视为内置数据类型，比如整数或字符串，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another way to create tuples is to add a comma between each item:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组的另一种方法是在每个项目之间添加逗号：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Most of the operations that we perform for lists also work in the case of tuples.
    In order to access the elements of a tuple, we use the square bracket operator
    and pass the index to it, as shown in the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对列表执行的大多数操作在元组的情况下也适用。为了访问元组的元素，我们使用方括号运算符并将索引传递给它，如下例所示：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Slice operations can be also performed for tuples in the same way as for lists.
    This operation will result in a range of values that can be extracted from the
    tuple. Have a look at the following example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作也可以像列表一样用于元组。这个操作将导致从元组中提取的一系列值。看下面的例子：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Tuples do not support item assignment, which makes it an immutable data structure,
    as shown in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 元组不支持项目赋值，这使得它成为一个不可变的数据结构，如下例所示：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that you have learned about dictionaries and tuples, let's see how we can
    convert them from one to another. Because all the available data structures are
    not perfect, they have some pitfalls; therefore, the following section will be
    one of the most important sections that we have covered so far. This is where
    we will perform conversions between dictionaries and tuples.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了字典和元组，让我们看看如何将它们从一个转换为另一个。因为所有可用的数据结构都不是完美的，它们都有一些缺陷；因此，接下来的部分将是迄今为止我们所涵盖的最重要的部分之一。这是我们将在字典和元组之间执行转换的地方。
- en: Tuples and dictionaries
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组和字典
- en: 'Dictionaries are not perfect iterables, which means we cannot use a `for` loop
    to extract keys and values directly from them. We can only extract keys from a
    dictionary, but if you want to extract the `key:value` pair, we have to convert
    it into another iterable data structure. Let''s look at an example and observe
    the result, which shows the conversion from a dictionary into a list:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 字典不是完美的可迭代对象，这意味着我们不能使用`for`循环直接从中提取键和值。我们只能从字典中提取键，但如果要提取`键:值`对，我们必须将其转换为另一个可迭代的数据结构。让我们看一个例子并观察结果，显示了从字典到列表的转换：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The direct conversion of a dictionary into a list does not preserve the values
    of the dictionary. It gives an object that contains only the keys of the dictionary.
    This information is useless due to a lack of values. Let''s try to convert it
    into the tuple and see the result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典直接转换为列表不会保留字典的值。它会返回一个只包含字典键的对象。由于缺少值，这些信息是无用的。让我们尝试将其转换为元组并查看结果：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Instead of using the `tuple()` method to convert a dictionary into a tuple,
    there is another effective way. We can perform the same task using the `items()`
    method. This is used to return the dictionary object that contains the list of
    where the keys and values are stored in the nested tuples, as shown in the following
    example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`tuple()`方法将字典转换为元组，还有另一种有效的方法。我们可以使用`items()`方法执行相同的任务。它用于返回包含键和值存储在嵌套元组中的列表的字典对象，如下例所示：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can iterate in this object using a `for` loop and fetch the keys and
    values in the same step of its declaration, as shown in the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`for`循环在这个对象中进行迭代，并在声明的同时获取键和值，如下例所示：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have covered three powerful data structures up until now—lists, dictionaries,
    and tuples. Next is **s****ets**; an unordered structure that is considered iterable
    and mutable, but does not store duplicate elements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了三种强大的数据结构——列表、字典和元组。接下来是**集**；一种无序的结构，被认为是可迭代和可变的，但不存储重复元素。
- en: Sets
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集
- en: Let's make things simple by comparing this data structure with the well-known
    concept of mathematics, which is a set. In mathematics, sets are considered a
    collection of distinct entities, which are normally considered objects. The numbers
    1, 2, and 3 are objects independently, but when they are combined, they form a
    single set, which has a size of 3\. They are no different in Python. A set in
    Python is a collection of objects, which are neither ordered nor indexed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这种数据结构与数学中的著名概念集进行简化。在数学中，集被认为是不同实体的集合，通常被认为是对象。数字1、2和3分别是对象，但当它们组合在一起时，它们形成一个大小为3的单一集合。它们在Python中也是一样的。Python中的集是一组既不排序也不索引的对象。
- en: 'Python sets can be created using two different methods:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种不同的方法创建Python集：
- en: 'The first one is similar to the way in which dictionaries are created; instead
    of key and value pairs, we will pass objects in their own right, as shown in the
    following example:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法类似于创建字典的方式；我们将传递对象本身，而不是键和值对，如下例所示：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Another way is by using a Python built-in method, that is, `set()`, where you
    have to pass your sequence of objects in the form of list, as shown in the following
    example:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是使用Python的内置方法`set()`，您需要以列表形式传递对象序列，如下例所示：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we can see that the elements inside the curly braces
    are unordered. The order of objects, which we passed while creating the sets,
    is not preserved. They also do not support duplicate items in the sets. If there
    is repetition of the same elements multiple times within the set, only one element
    will be kept, and all the others will be removed from the structure, as shown
    in the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到花括号中的元素是无序的。我们在创建集合时传递的对象顺序不会被保留。它们也不支持集合中的重复项。如果集合中同一元素多次重复，只会保留一个元素，其他所有元素都将从结构中删除，如下例所示：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Sets are also non-indexed, unlike lists and tuples. If you want to access the
    elements of sets, you cannot use the indexing technique, as it will throw a `TypeError`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表和元组不同，集合也是非索引的。如果要访问集合的元素，不能使用索引技术，因为这会引发`TypeError`：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since sets are iterables, we can only access them through loops. The appropriate
    loop will be the for loop because we do not have to worry about the terminating
    point while using it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是可迭代的，我们只能通过循环来访问它们。适当的循环将是for循环，因为在使用它时我们不必担心终止点：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we have seen how to create and access sets of our own, let's delve
    into the basic methods of sets that are available so that we can manipulate their
    structure.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建和访问自己的集合，让我们深入了解可用的集合基本方法，以便我们可以操纵它们的结构。
- en: Set methods
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合方法
- en: 'Sets are mutable, but once they have been created, you cannot change their
    items; rather, you can add or delete items from that set. It is quite similar
    to a list, but it is ordered. Now, let''s start this topic with the most commonly
    used methods of Python sets:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是可变的，但一旦它们被创建，就不能更改它们的项；相反，你可以向该集合添加或删除项。它与列表非常相似，但是有序的。现在，让我们从Python集合的最常用方法开始这个主题：
- en: 'We can add single and multiple items to the list, and there are two ways of
    doing this. The `add()` method will insert only a single item into the set at
    any time. On the other hand, the `update()` method will add multiple items to
    the set at the same time. The addition of the elements will be unordered, and
    they may be inserted at any position:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以向集合中添加单个和多个项，有两种方法可以做到这一点。`add()`方法每次只会向集合中插入一个单个项。另一方面，`update()`方法将同时向集合中添加多个项。元素的添加是无序的，它们可能被插入到任何位置：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There are many ways of removing elements of sets. Methods such as `remove()`,
    `discard()`, and `pop()` can be used. If the item that you want to remove from
    the set does not exist, `remove()` will throw an exception, which goes by the
    name of `KeyError`, but in the case of the `discard()` method, our code won''t
    run into any errors, as shown in the following example:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多方法可以删除集合的元素。可以使用`remove()`、`discard()`和`pop()`等方法。如果要从集合中删除的项不存在，`remove()`将抛出一个名为`KeyError`的异常，但在`discard()`方法的情况下，我们的代码不会遇到任何错误，如下例所示：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can also use the `pop()` method to remove elements from a set. `pop()` will
    remove only the last element from the set. However, we don''t know which element
    will be the last in the set, since it is unordered and non-indexed. Thus, using
    `pop()` will be dangerous, as we won''t know about the removal of specific items.
    `pop()` will return an item that is removed from the set, as shown in the following
    example:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`pop()`方法从集合中删除元素。`pop()`只会从集合中删除最后一个元素。然而，由于集合是无序的且没有索引，我们不知道哪个元素将成为集合中的最后一个元素。因此，使用`pop()`会很危险，因为我们无法知道特定项的移除。`pop()`将返回从集合中移除的项，如下例所示：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you want to delete each and every element from the set, two methods can
    be used, but the results of these operations are slightly different. The `del`
    keyword can be used, along with the name of the set, in order to remove an entire
    element of a set along with the set, structure. On the other hand, the `clear()`
    method is used to empty the set, but its structure won''t be completely removed:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想从集合中删除每个元素，可以使用两种方法，但这些操作的结果略有不同。可以使用`del`关键字加上集合的名称来删除整个集合元素以及集合结构。另一方面，`clear()`方法用于清空集合，但其结构不会被完全删除：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can also perform operations such as union, an intersection between sets,
    just like we do in mathematics. The union operation returns a set that contains
    all the elements from the original set, and all the items from the specified set.
    The set removes duplicate items. If any item is present in more than one set,
    it will be added only once in the resulting set. You can perform union between
    multiple sets by separating each of them with a comma:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以执行并集、交集等操作，就像在数学中一样。并集操作返回一个包含原始集合中所有元素和指定集合中所有元素的集合。集合会删除重复项。如果任何项存在于多个集合中，它将只在结果集中添加一次。你可以用逗号分隔每个集合来执行多个集合之间的并集：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We have the `intersection()` method, which will result in a set of items that
    is common between multiple sets, as shown in the following example:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有`intersection()`方法，它将导致多个集合之间共同的项目集合，如下例所示：
- en: '[PRE62]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the previous sections, we covered the fundamentals of Python. We have established
    a strong foundation of core programming up to this point, but we are not capable
    of building an advanced game yet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们已经介绍了Python的基础知识。到目前为止，我们已经建立了核心编程的坚实基础，但我们还不能构建一个高级游戏。
- en: In the upcoming sections, we will delve into the most important concept, not
    only for Python, but for programming in general, that is, **functions**. After
    that section, you will possess procedural programming power, which will be helpful
    when we cover every advanced game that we will build from that point onward.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨最重要的概念，不仅适用于Python，而且适用于编程一般，那就是**函数**。在那一部分之后，你将拥有过程式编程的能力，这将在我们从那时起构建的每个高级游戏中非常有帮助。
- en: Functions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'First of all, let''s recall all the topics that we have learned so far and
    observe procedural programming functions and why they are needed in the first
    place. We learned how to create multiple lines of statements using variables,
    numbers, modules, conditionals, and looping. However, we didn''t stop there; we
    covered all the fundamental data structures of Python, such as lists, dictionaries,
    tuples, and sets. This programming paradigm will result in an abundance in lines
    of code, and sometimes we may need to call the same code again and again. Have
    a look at the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下到目前为止我们学到的所有主题，并观察过程式编程函数以及它们为什么首先是需要的。我们学会了如何使用变量、数字、模块、条件和循环创建多行语句。然而，我们并没有止步于此；我们涵盖了Python的所有基本数据结构，如列表、字典、元组和集合。这种编程范式将导致代码行数的丰富，有时我们可能需要一遍又一遍地调用相同的代码。看看下面的例子：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the preceding code, we are adding two digits. Every time we perform an addition,
    we need to write two digits, followed by addition operators. Instead of doing
    the same task for many addition operations, why not make a single statement, which
    can perform addition, and put that statement into the scope where we can call
    it multiple times? This scope represents functions. We can invoke the execution
    of this statement multiple times by calling these functions. Let''s make a function
    that can add any two numbers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在添加两个数字。每次进行加法运算时，我们需要写两个数字，然后是加法运算符。与其为许多加法操作做同样的任务，为什么不制作一个可以执行加法的单个语句，并将该语句放入我们可以多次调用它的范围内呢？这个范围代表函数。我们可以通过调用这些函数多次来调用这个语句的执行。让我们制作一个可以添加任意两个数字的函数：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding code, we defined the function with `add`. The `def` keyword,
    along with a name, is used to specify the Python parser in order to create functions.
    Inside the scope of the function, we can add multiple statements. Now, instead
    of manually adding two digits every time, we can call this `add` function to perform
    addition between any digits. So, this part of code is usable for operations that
    can add any two digits. The first task is to declare the function, which is what
    we just did; the next task is to call that function. You won''t execute any operation
    that is inside that function until you call that function. You have to use the
    same function name in order to invoke that function. Now, if you want to perform
    an `add` operation, you need to call it with same the signature, `add`, and pass
    two values as an argument to it. If you pass a number, it will be passed as an
    argument to that function call:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们用`add`定义了函数。`def`关键字和一个名称一起用于指定Python解析器以创建函数。在函数的范围内，我们可以添加多个语句。现在，我们不需要每次手动添加两个数字，我们可以调用这个`add`函数来执行任意两个数字之间的加法。因此，这部分代码可用于可以添加任意两个数字的操作。第一个任务是声明函数，这就是我们刚刚做的；下一个任务是调用该函数。在调用该函数之前，不会执行该函数内的任何操作。您必须使用相同的函数名称来调用该函数。现在，如果您想执行`add`操作，您需要以相同的签名`add`调用它，并将两个值作为参数传递给它。如果您传递一个数字，它将作为参数传递给该函数调用：
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the preceding result, each digit that is inside parentheses is passed to
    the function argument: a and b. At the first operation, `add(4,5)`, 4 is passed
    as a value to variable a, and 5 is passed as a value to variable b.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结果中，括号内的每个数字都被传递给函数参数：a和b。在第一个操作中，`add(4,5)`，4被作为值传递给变量a，5被作为值传递给变量b。
- en: 'Let''s compare these functions with the following coffee machine. We feed raw
    materials such as coffee beans, sugar, and water to the coffee machine, which
    will process those materials, and provide us with a coffee. In the same way as
    a coffee machine, functions also take raw arguments containing values as input.
    These arguments will be used for processing, which is done inside the function,
    and gives us meaningful results. Sometimes, functions do not return anything;
    we call these `void`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些函数与以下咖啡机进行比较。我们将原材料，如咖啡豆、糖和水，投放到咖啡机中，咖啡机将加工这些原材料，并为我们提供一杯咖啡。与咖啡机一样，函数也接受包含值的原始参数作为输入。这些参数将用于处理，在函数内部完成，并给我们有意义的结果。有时，函数不返回任何东西；我们称这些为`void`：
- en: '![](Images/e7096471-8dcd-4b00-bf32-b201532c734e.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e7096471-8dcd-4b00-bf32-b201532c734e.png)'
- en: 'We have look at couple of examples where we called the functions by name, but
    their declaration was carried out internally by Python. For instance, take the
    example of the `print()` method. We used this function to print any messages to
    the user on the Terminal, but we didn''t define it using the `def` keyword; we
    simply called it because it''s a built-in function. Thus, if you are using any
    functions such as `print()`, `input()`, or `type()`, you are calling that function
    by passing an argument inside its parentheses. You can see the implementation
    of `print()`, or any other built-in method of Python, by taking a tour of the
    official Python documentation. While calling `input()` or `print()`, we pass a
    string as an argument inside its parenthesis. Let''s look at an example of a function
    call:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了几个例子，我们通过名称调用了函数，但它们的声明是由Python在内部进行的。例如，以`print()`方法为例。我们使用这个函数在终端上向用户打印任何消息，但我们没有使用`def`关键字来定义它；我们只是调用它，因为它是一个内置函数。因此，如果您使用任何函数，如`print()`、`input()`或`type()`，您都是通过在其括号内传递参数来调用该函数。您可以通过参观官方Python文档来查看`print()`或Python的任何其他内置方法的实现。在调用`input()`或`print()`时，我们将一个字符串作为参数传递给它的括号内。让我们看一个函数调用的例子：
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the preceding code, we made a call to the function with `type`. The arguments
    are passed inside the parenthesis of the function. We can pass as many arguments
    as we like as an expression inside the parenthesis, but we have to make sure that
    we pass only the required positional arguments. In the function declaration, if
    we made a function with two parameters, while calling, we should pass the same
    amount of arguments. Otherwise, it will throw us an error, as shown in the following
    example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`type`调用函数。参数传递在函数的括号内。我们可以传递尽可能多的参数作为括号内的表达式，但是我们必须确保只传递所需的位置参数。在函数声明中，如果我们使用了两个参数来定义函数，那么在调用时，我们应该传递相同数量的参数。否则，它会抛出一个错误，就像下面的例子所示：
- en: '[PRE67]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Thus, we can conclude that functions take an argument, execute some statements
    based on that argument, and return a result. In our `add(a,b)` function, we printed
    the result inside the function, but instead of printing it inside the scope of
    the function, we used the `return` keyword in order to return a `result` from
    the function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，函数接受一个参数，根据该参数执行一些语句，并返回一个结果。在我们的`add(a,b)`函数中，我们在函数内部打印了结果，但是我们使用了`return`关键字来从函数中返回一个`result`，而不是在函数的范围内打印它：
- en: '[PRE68]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Thus, we have two types of functions. One prints the results inside the scope
    of a function, rather than returning results from it which are normally void.
    Although Python has nothing nomenclature for void functions, other programming
    languages call these void functions, which means they return nothing. Another
    type will yield a return value of the function. Those return values should be
    captured when a function is called, just like in the code: `result = add(3,5)`.
    The value of `result` is the return value of the function.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种类型的函数。一种在函数的范围内打印结果，而不是从中返回结果，通常为空。虽然Python没有空函数的命名约定，其他编程语言称这些为空函数，这意味着它们不返回任何东西。另一种类型将产生函数的返回值。当调用函数时，应该捕获这些返回值，就像在代码中：`result
    = add(3,5)`。`result`的值是函数的返回值。
- en: 'You may encounter a situation where a function has to return multiple value.
    We can use the tuple structure to return multiple values from the function. Let''s
    take a look at the following simple example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到一个函数必须返回多个值的情况。我们可以使用元组结构从函数中返回多个值。让我们看一个简单的例子：
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We'll learn about the concept of *default arguments* in the next section. Learning
    about this will help us build more flexible functions and so this is an important
    topic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习*默认参数*的概念。学习这个概念将帮助我们构建更灵活的函数，因此这是一个重要的主题。
- en: Default arguments
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'During the function call, we usually pass a value as a positional argument
    to the respective parameters. However, if we make a mistake by passing one less
    or one more than is required, our program will run into an exception. Thus, it
    is always good practice to specify some arguments as default:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用期间，我们通常将一个值作为位置参数传递给相应的参数。但是，如果我们犯了一个错误，传递的参数比所需的少一个或多一个，我们的程序将遇到异常。因此，总是将一些参数指定为默认值是一个很好的做法：
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s look at the power of default arguments. Before using them, you
    should remember that default arguments must be placed at the end of the argument
    order. The syntax for creating a default argument is `argument_name = value`.
    In the preceding example, if you want to make `str1` the default argument, it
    should be placed after `str2`, otherwise you will get a syntax error from the
    Python interpreter, as shown in the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下默认参数的威力。在使用它们之前，您应该记住默认参数必须放在参数顺序的末尾。创建默认参数的语法是`argument_name = value`。在前面的例子中，如果您想将`str1`作为默认参数，它应该放在`str2`之后，否则您将从Python解释器那里得到一个语法错误，就像下面的例子所示：
- en: '[PRE71]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As the error message clarifies, we cannot specify a default argument to the
    left positional one. They should be followed by non-default arguments, as shown
    in the following example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如错误消息所澄清的那样，我们不能将默认参数指定为左侧的位置参数。它们应该跟随非默认参数，就像下面的例子所示：
- en: '[PRE72]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the preceding example, have a look at the part where we called the function
    with only one argument in it. Now, that argument is a positional argument. As
    it is in position one, it will be passed to the first parameter of the function.
    Thus, the `Python` value will be passed to the `str1` parameter. After the `Python`
    value, we passed nothing. Instead of running into `TypeError`, we were able to
    get a proper result. This is the power of default arguments. However, if you pass
    another value to that default argument at the time of the function call, the default
    argument value will be overwritten with a new one:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，看一下我们在其中只使用一个参数调用函数的部分。现在，该参数是一个位置参数。因为它在位置一，所以它将被传递给函数的第一个参数。因此，`Python`值将被传递给`str1`参数。在`Python`值之后，我们什么也没传递。而不是遇到`TypeError`，我们能够得到一个正确的结果。这就是默认参数的威力。但是，如果在函数调用时向该默认参数传递另一个值，那么默认参数值将被覆盖为新值：
- en: '[PRE73]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Up until now, we were able to call the function with a few positional arguments,
    such as a and b. But what if we have to make a function that can add 200 numbers?
    Calling a function such as `add(a,b,c,d,..)`, in which each variable represents
    one number, is not possible. We will have a shortage of variables, too, because
    for 200 numbers, we have to maintain 200 variables. So, the most efficient way
    would be to pack all of those arguments into one, and pass it as a single argument
    to the function. Then, the function will unpack that variable and perform the
    relevant operations. We can use the list data structure as a variable to store
    those multiple values. We'll look at how to pack and unpack normal and keyword
    arguments in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够使用一些位置参数来调用函数，比如a和b。但是如果我们必须创建一个能够添加200个数字的函数呢？调用这样的函数`add(a,b,c,d,..)`，其中每个变量代表一个数字，是不可能的。我们也会缺少变量，因为对于200个数字，我们必须维护200个变量。因此，最有效的方法是将所有这些参数打包到一个变量中，并将其作为单个参数传递给函数。然后，函数将解包该变量并执行相关操作。我们可以使用列表数据结构作为变量来存储这些多个值。我们将在下一节中看一下如何打包和解包普通和关键字参数。
- en: Packing and unpacking arguments
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和解包参数
- en: 'Let''s take a simple example that will help us understand why we need this
    method of packing and unpacking in the first place. In this example, we are going
    to add numbers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子，这将帮助我们理解为什么我们首先需要这种打包和解包方法。在这个例子中，我们将添加数字：
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our code works fine for fewer numbers, maybe up to 10 values. Little modification
    should be done with a small increase in numbers, but that''s fine. However, what
    if we have 100 numbers? Tracking each of these numbers into variables is not possible
    and not effective. Our code would also look unprofessional. Now, here comes the
    crazy feature of Python that goes by the name of packing the arguments. Here,
    we are taking about arguments, that is, normal arguments such as list and tuple.
    We can make a list that contains multiple numbers. Let''s see how we can make
    a function that can add multiple numbers using the case of packing the arguments:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码对于较少的数字可以正常工作，也许最多可以达到10个值。随着数字的小幅增加，需要做一些小的修改，但这没关系。但是，如果我们有100个数字呢？跟踪这些数字到变量中是不可能的，也不是有效的。我们的代码看起来也不专业。现在，Python有一个名为打包参数的疯狂功能。在这里，我们谈论的是参数，即普通参数，比如列表和元组。我们可以制作一个包含多个数字的列表。让我们看看如何制作一个可以添加多个数字的函数，使用打包参数的情况：
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Let's observe the code that we have written here. The `*arg` convention is used
    for packing the arguments. Here, `args` refers to arguments, which is the default
    naming convention for arguments in Python, but you can name it anything as long
    as you follow the rules and conventions of the variable naming pattern. A single
    asterisk (`*`) is essential, which shows that we are packing into a single argument.
    We are packing every item into `args`; therefore, `args` will be built as a list.
    We know that the lists are iterable, which allows us to loop within it using for
    loop. Now, while calling the function, we do not have to worry about any positional
    arguments or even parameters that contain values. Every piece of data that is
    passed during the function call will be packed into the list using this method.
    Now, we are not restricted to using parameters that assign values to specified
    positional arguments. We can perform these packing argument techniques for every
    data type, or even for structures.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们观察我们在这里编写的代码。`*arg`约定用于打包参数。在这里，`args`指的是参数，这是Python中参数的默认命名约定，但只要遵循变量命名模式的规则和约定，你可以给它取任何名字。一个单独的星号(`*`)是必不可少的，它表示我们正在打包成一个单一的参数。我们正在将每个项目打包到`args`中；因此，`args`将被构建为一个列表。我们知道列表是可迭代的，这允许我们使用for循环在其中循环。现在，在调用函数时，我们不必担心任何位置参数，甚至包含值的参数。在函数调用期间传递的每个数据片段都将使用这种方法打包到列表中。现在，我们不再受限于使用分配值给指定位置参数的参数。我们可以对每种数据类型，甚至结构执行这些打包参数技术。
- en: 'Unpacking arguments also works in a similar way to that of packing. We use
    a single asterisk abreast of the argument to specify that we are using the unpacking
    technique. Here, the argument must be a list, a string, or another structure that
    represents collections of items. Have a look at the following example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解包参数的工作方式与打包类似。我们使用单个星号紧挨着参数，指定我们正在使用解包技术。在这里，参数必须是一个列表、字符串或另一个表示项目集合的结构。看一下以下示例：
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Since the argument is passed as a string (`Python`), we unpacked it so that
    every element is printed separately, with some spaces. You can also unpack elements
    of a list structure as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数作为字符串(`Python`)传递，我们解包它，以便每个元素都单独打印出来，中间带有一些空格。你也可以按照以下方式解包列表结构的元素：
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: So, we can pack and unpack normal arguments using a single asterisk, but in
    order to pack and unpack keyword arguments, we have to use a double asterisk.
    The syntax that is used for packing and unpacking a keyword argument is `**kwargs`.
    Just remember to use a single asterisk for normal arguments, and a double asterisk
    for keyword arguments. `args` represent arguments and `kwargs` is the naming convention
    for keyword arguments. We'll see some examples of packing and unpacking keyword
    arguments in the next section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用单个星号打包和解包普通参数，但是为了打包和解包关键字参数，我们必须使用双星号。用于打包和解包关键字参数的语法是`**kwargs`。只需记住对于普通参数使用单个星号，对于关键字参数使用双星号。`args`代表参数，`kwargs`是关键字参数的命名约定。我们将在下一节中看一些打包和解包关键字参数的示例。
- en: Packing and unpacking keyword arguments
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和解包关键字参数
- en: 'Keyword arguments refer to dictionaries. Dictionaries cannot be packed and
    unpacked in a similar way to normal arguments such as lists or tuples. Dictionaries
    contain key and value pairs; thus, they cannot be packed and unpacked in the normal
    way. To distinguish them from normal arguments, we use a double asterisk. `**kwargs`
    is used to pack all the elements of a dictionary into a single argument. However,
    we know that dictionaries are not iterable, or in other words, we cannot loop
    inside dictionaries and fetch key and value pairs directly. In order to retrieve
    key and value pairs, we need to convert `kwargs` into a tuple using the `items()`
    method. We have seen its implementation in the preceding section. Let''s look
    at a simple example of how to implement packing keyword-arguments:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数指的是字典。字典不能像列表或元组那样打包和解包。字典包含键和值对；因此，它们不能以正常的方式打包和解包。为了将它们与正常参数区分开，我们使用双星号。`**kwargs`用于将字典的所有元素打包成单个参数。然而，我们知道字典不可迭代，换句话说，我们不能在字典内部循环并直接获取键和值对。为了检索键和值对，我们需要使用`items()`方法将`kwargs`转换为元组。我们已经在前面的部分看到了它的实现。让我们看一个简单的例子，说明如何实现打包关键字参数：
- en: '[PRE78]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the preceding example, we did two things: we made a dictionary that will
    be packed into a single argument using `**dictionary`, and passed each value to
    the positional arguments of function. In the dictionary definition, the keys of
    the dictionary must be the same as the parameters that are used while making the
    function, that is, `name`, `age`, and `like`. Even single typos will result in
    `TypeError`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们做了两件事：我们制作了一个字典，将使用`**dictionary`打包成单个参数，并将每个值传递给函数的位置参数。在字典定义中，字典的键必须与制作函数时使用的参数相同，即`name`、`age`和`like`。即使是单个拼写错误也会导致`TypeError`。
- en: 'Now, it''s time to cover unpacking keyword arguments. The syntax will be similar,
    which contains a double asterisk and is followed by the dictionary name, or `kwargs`.
    Since we are unpacking, we have to add `**kwargs` as a parameter of function,
    because unpacking has to be done inside the function. Let''s look at the a simple
    example to clarify this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候来介绍解包关键字参数了。语法将是相似的，包含双星号，后面跟着字典名称，或`kwargs`。由于我们正在解包，所以必须将`**kwargs`作为函数的参数添加进去，因为解包必须在函数内部完成。让我们看一个简单的例子来澄清这一点：
- en: '[PRE79]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'While calling the `about` function, we passed a value to the argument, like
    we normally pass in the case of a normal function. For example, `Python` is the
    argument and it has a value of string. Now, this value is passed to the parameter
    of the `about` function. However, there is no parameter with the name of `Python`
    or `Java` within the function parenthesis. Instead, there is `**kwargs`, which
    is going to convert these `argument_name = value` formats into the dictionary.
    This is a form of packing the argument. Now, while inside the function, we have
    to unpack it. At this time, we know that `kwargs` is a dictionary, which is not
    iterable. We cannot fetch its `key:value` pair without converting it into a tuple
    or a list. One easy way to convert a dictionary into a tuple is by using the `items()`
    method. Now, after converting a dictionary into a tuple object using the `items()`
    method, `kwargs` looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`about`函数时，我们向参数传递了一个值，就像我们在普通函数的情况下通常传递的那样。例如，`Python`是参数，它的值是字符串。现在，这个值被传递给`about`函数的参数。然而，在函数括号内没有名为`Python`或`Java`的参数。相反，有`**kwargs`，它将这些`argument_name
    = value`格式转换为字典。这是一种打包参数的形式。现在，在函数内部，我们必须解包它。此时，我们知道`kwargs`是一个不可迭代的字典。我们不能在不将其转换为元组或列表的情况下获取其`key:value`对。将字典转换为元组的一种简单方法是使用`items()`方法。现在，在使用`items()`方法将字典转换为元组对象后，`kwargs`看起来是这样的：
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now, we are looping around these items of the tuple object, and each object
    contains a key and a value separated by a comma. Thus, for each iteration, we
    get key and value pairs, and we print it by formatting it properly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在循环遍历元组对象的这些项，每个对象都包含由逗号分隔的键和值。因此，对于每次迭代，我们都会得到键和值对，并通过适当格式化打印出来。
- en: 'Now, we possess the knowledge that will not only help us create our own functions,
    but also modify them according to our needs. If you want to make your program
    more reusable and sturdy, methods such as packing and unpacking arguments must
    be used. After this broad concept of functional programming, it''s time to explore
    three important functions in Python: the anonymous, recursive, and built-in functions.
    Let''s take a look at each of them one by one. We will begin with the *Anonymous
    function*.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们掌握了不仅可以帮助我们创建自己的函数，还可以根据我们的需求修改它们的知识。如果你想使你的程序更具重用性和稳健性，必须使用打包和解包参数等方法。在这个广泛的函数式编程概念之后，现在是时候探索Python中的三个重要函数：匿名函数、递归函数和内置函数。让我们逐个来看看它们。我们将从*匿名函数*开始。
- en: Anonymous function
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'As the name suggests, these functions do not have any name or signature. In
    the same way that we used the name of the `add(a,b)` function to carry out an
    addition operation between two numbers, this `add` signature is invalid in the
    case of the anonymous function. If you recall the way we created a normal function
    using the `def` keyword, in the case of an anonymous function, we use the `lambda`
    keyword. Thus, anonymous functions are also called lambda functions. We need to
    remember two things while creating any function: arguments and expressions. Arguments
    are the independent and specific input to the function, whereas expressions are
    embedded inside the body of the function. In the case of the `lambda` function,
    we can pass any number of arguments, but only one expression. This implies that
    only one operation can be done with the `lambda` function.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这些函数没有任何名称或签名。就像我们使用`add(a,b)`函数的名称来执行两个数字之间的加法操作一样，在匿名函数的情况下，这个`add`签名是无效的。如果您回忆一下我们使用`def`关键字创建普通函数的方式，在匿名函数的情况下，我们使用`lambda`关键字。因此，匿名函数也被称为lambda函数。在创建任何函数时，我们需要记住两件事：参数和表达式。参数是函数的独立和特定的输入，而表达式嵌入在函数体内。在`lambda`函数的情况下，我们可以传递任意数量的参数，但只能有一个表达式。这意味着`lambda`函数只能执行一个操作。
- en: 'Let''s make a simple `lambda` function in order to grasp this information easily:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`lambda`函数，以便更容易地理解这些信息：
- en: '[PRE81]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In this example, `square` is the container for the result. Since the `lambda`
    function does not contain a unique signature or name, we should pass an argument
    as a value using this container, that is, `square`. Here, the syntax to use for
    the `lambda` function is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`square`是结果的容器。由于`lambda`函数没有独特的签名或名称，我们应该使用这个容器作为值传递参数，也就是`square`。在这里，使用`lambda`函数的语法如下：
- en: '[PRE82]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Notice the `arguments` and `expression` names; we cannot add multiple statements
    inside the `lambda` function. If we try to execute multiple statements inside
    the `lambda` function, we will run into the following error:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`arguments`和`expression`的名称；我们不能在`lambda`函数内添加多个语句。如果我们尝试在`lambda`函数内执行多个语句，就会遇到以下错误：
- en: '[PRE83]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We passed `x,y`, that is, multiple arguments, which is completely valid, but
    two expressions, `x//y` and `x%y`, are not executed by `lambda`. We will use these
    `lambda` functions for creating games in the upcoming chapters. Since we have
    many things to cover in this chapter, and we are running out of space, I would
    like to end this topic right here; however, I highly urge you to practice these
    types of functions a little more. You can always use the Python documentation
    to help.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了`x,y`，也就是多个参数，这是完全有效的，但两个表达式`x//y`和`x%y`不会被`lambda`执行。我们将在接下来的章节中使用这些`lambda`函数来创建游戏。由于本章有许多内容要涵盖，而且空间不够了，我想在这里结束这个话题；但是，我强烈建议您多练习这些类型的函数。您可以随时使用Python文档进行帮助。
- en: 'Let''s look at another type of function: **recursion**—a computer programming
    technique involving the use of a procedure, subroutine, function, or algorithm
    that calls itself in a step, has a termination condition, and when the terminating
    condition is met, the program also terminates.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一种类型的函数：**递归**——一种涉及使用过程、子程序、函数或算法调用自身的计算机编程技术，在一步中具有终止条件，当满足终止条件时，程序也终止。
- en: Recursive functions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: In this section, we are going to uncover another programming paradigm, known
    as recursive programming. Recursion is a way of programming where a function will
    call itself multiple times until a particular condition is met. Inside the body
    of the function, we will call the same function itself, which makes it a recursion.
    It is somewhat similar to nested conditionals, where we have another scope of
    `if..else` inside single `if` conditionals.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将揭示另一种编程范式，称为递归编程。递归是一种编程方式，其中一个函数会多次调用自身，直到满足特定条件为止。在函数体内，我们将调用相同的函数本身，这使它成为递归。这与嵌套条件类似，其中在单个`if`条件中有另一个`if..else`的范围。
- en: 'Recursion should have a base or a terminating condition in order to specify
    the stopping criterion for the program. Without a base condition, our recursive
    program is not going to operate viably. If the base condition is not met at the
    point of program execution, the recursive program will result in an infinite loop.
    Let''s jump to a simple programming example to observe the working principle of
    recursion:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 递归应该有一个基本或终止条件，以指定程序的停止标准。没有基本条件，我们的递归程序将无法正常运行。如果在程序执行时未满足基本条件，递归程序将导致无限循环。让我们来看一个简单的编程示例，观察递归的工作原理：
- en: '[PRE84]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s explore the preceding example to uncover interesting facts about recursive
    programming. Printing a factorial of any number is a simple example that we can
    refer to while learning about recursive programming. In the preceding program,
    we have a base or terminating condition: when the number is one, we return one.
    This is not a random statement; rather, it is a mathematical pattern for finding
    a factorial number. Have a look at the following example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索前面的例子，以揭示关于递归编程的有趣事实。打印任何数字的阶乘是一个简单的例子，我们可以在学习递归编程时参考。在前面的程序中，我们有一个基本或终止条件：当数字为一时，我们返回一。这不是一个随机的陈述；相反，这是找到阶乘数的数学模式。看看下面的例子：
- en: '[PRE85]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For any number, the process of finding a factorial ends after we encounter
    one. Thus, it is a base condition, and whenever our program triggers it, we can
    terminate our program. Inside the scope of the `else` part of the program, we
    are calling the factorial function again, but with a different argument. You can
    observe the example where we found a factorial of five; each time we go to the
    next step, we are decreasing that number by one and multiplying it with the current
    number, which represents this statement:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何数字，找到阶乘的过程在遇到1之后结束。因此，这是一个基本条件，每当我们的程序触发它时，我们可以终止程序。在程序的`else`部分的范围内，我们再次调用阶乘函数，但使用不同的参数。您可以观察到我们找到5的阶乘的例子；每次我们进入下一步时，我们都会将该数字减一，并将其与当前数字相乘，这代表了这个语句：
- en: '`>>> number*factorial(number-1)`. This condition is called a recursive case,
    which leads to recursion.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> number*factorial(number-1)`。这个条件被称为递归情况，导致了递归。'
- en: 'So, there are two ways of making logic with Python: with fundamental logic
    using loops and conditionals, or with recursion. Sometimes, it will be hard to
    get a solution using brand new logic, and in such situations we give recursion
    a try. Although recursion code looks simpler and cleaner, it is an expensive call
    in comparison to other code, because it takes a lot of time and space during computation.
    Now, let''s talk about a faster and cheaper way to execute an operation using
    built-in functions. We have covered so many built-in functions already, such as
    `max()`, `min()`, and `len()`. Thus, this section will be rather easier to follow.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有两种使用Python进行逻辑推理的方法：使用循环和条件语句进行基本逻辑，或者使用递归。有时，使用全新的逻辑来解决问题会很困难，在这种情况下，我们会尝试使用递归。尽管递归代码看起来更简单、更清晰，但与其他代码相比，它是一个昂贵的调用，因为在计算过程中需要大量的时间和空间。现在，让我们谈谈使用内置函数来执行操作的更快、更便宜的方法。我们已经介绍了许多内置函数，比如`max()`、`min()`和`len()`。因此，这一部分将更容易理解。
- en: Built-in functions
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: 'Python comes with multiple built-in functions that are available for us to
    use directly in our programs. We shouldn''t have to import them, or make any extra
    effort to execute them. For example, we have `print()`. We have unknowingly used
    so many built-in functions before, but they are also a type of function. The only
    difference is that they are made by Python creators. They are fast, and more importantly,
    using them makes our code simpler and cleaner. Just think like this: adding two
    numbers using our own custom method may take a minimum of three lines of code,
    but using a built-in function, we can do it in a single line, using the `sum()`
    function.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Python带有多个内置函数，可以直接在我们的程序中使用。我们不需要导入它们，也不需要额外的努力来执行它们。例如，我们有`print()`。我们之前可能不知不觉地使用了许多内置函数，但它们也是一种函数。唯一的区别是它们是由Python创建者制作的。它们快速，更重要的是，使用它们可以使我们的代码更简单、更清晰。只需这样想：使用我们自己的自定义方法来添加两个数字可能需要至少三行代码，但使用内置函数，我们可以在一行代码中使用`sum()`函数来完成。
- en: You can check each and every built-in function by taking a tour of the Python
    official documentation. Secondly, we can also get information containing a list
    of built-in functions within our Python shell. You can type the following `>>>
    dir(__builtins__)` command in order to get a list containing 68 built-in functions.
    We have already seen a few of the most important among them., for example, the
    `type()` method and the type-casting techniques. They all are achieved using built-in
    functions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过浏览Python官方文档来查看每一个内置函数。其次，我们还可以在Python shell中获取包含内置函数列表的信息。您可以输入以下命令`>>>
    dir(__builtins__)`来获取包含68个内置函数的列表。我们已经看到了其中一些最重要的函数，例如`type()`方法和类型转换技术。它们都是使用内置函数实现的。
- en: I won't be covering every built-in function in this section, as that is not
    the actual motive of this book; instead, we will be going directly to the next
    topic, which will be an interesting one since we are going to modify our tic-tac-toe
    game using the functions and data structures that we have learned about so far.
    However, I highly encourage you to take a prudent step forward by learning about
    a few built-in functions on your own. They may not be important just yet, but
    they will surely come in handy at some point during your career.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在本节中涵盖每一个内置函数，因为这不是本书的实际目的；相反，我们将直接进入下一个主题，这将是一个有趣的主题，因为我们将使用到目前为止学到的函数和数据结构来修改我们的井字棋游戏。然而，我强烈鼓励您通过自己学习一些内置函数来谨慎前进。它们现在可能还不重要，但在您的职业生涯中某个时候肯定会派上用场。
- en: Now that we have learned about data structures and functions, we will use them
    to modify the previously built tic-tac-toe game by adding intelligence to it.
    We will cover this in the next section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了数据结构和函数，我们将使用它们来修改之前构建的井字棋游戏，为其增加智能。我们将在下一节中介绍这个内容。
- en: Adding intelligence into our game
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的游戏增加智能
- en: We have made multiple modifications throughout this chapter, such as adding
    conditionals and looping to enhance code structure and processing. However, this
    not isn't perfect yet. In this section, we are going to modify our tic-tac-toe
    game using the functions and data structures that we have learned about in this
    chapter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进行了多次修改，例如添加条件语句和循环以增强代码结构和处理。然而，这还不够完美。在本节中，我们将使用本章学到的函数和数据结构来修改我们的井字棋游戏。
- en: Since the function is going to make our code smaller in length by eliminating
    the repetition of code, and also debugging it, it will be also easier to make
    changes in the code at a later stage; you can simply redirect to a specific function
    instead of traversing the entire program. So, these two features will be helpful
    for us while printing the game board into the terminal. If you recall the code
    that we wrote in the previous chapter, code for printing board layouts was used
    repeatedly. Now, we can create a function that will have all the code we need
    inside it so that we can print the layout of the board, and we can call it any
    time and anywhere within the code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数将通过消除代码的重复而使我们的代码长度变短，并且调试它，以后在代码中进行更改也会更容易；你可以简单地重定向到特定的函数，而不是遍历整个程序。因此，这两个特性在将游戏板打印到终端时对我们有帮助。如果你回忆一下我们在上一章中编写的代码，用于打印游戏板布局的代码被重复使用。现在，我们可以创建一个函数，将所有我们需要的代码放在里面，这样我们就可以打印出游戏板的布局，并且可以在代码中的任何时间和任何地方调用它。
- en: The next implementation on our code will be subsuming intelligence for our tic-tac-toe
    game. Until this moment, if you run your tic-tac-toe game, you will find that
    it can be played by two players. However, both players should be using the same
    computer, and they should play it by toggling their turn. Now, we are going to
    add computer intelligence that can play our game as one player. We are literally
    making a game where the player can play against the computer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的下一个实现将是为我们的井字游戏添加智能。到目前为止，如果你运行你的井字游戏，你会发现它可以由两个玩家玩。然而，两个玩家都应该使用同一台计算机，并且他们应该通过轮流来玩。现在，我们将添加计算机智能，可以作为一个玩家来玩我们的游戏。我们实际上正在制作一个玩家可以与计算机对战的游戏。
- en: As usual, we will start by brainstorming the essentials of the game, and we
    will gather critical information about the game layout and models.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将从头脑风暴游戏的基本要素开始，收集关于游戏布局和模型的关键信息。
- en: Brainstorming and information gathering
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头脑风暴和信息收集
- en: The term *artificial intelligence* is very notorious in the tech world, but
    if you inspect the depth of it, it is a bunch of modules and conditionals that
    determine the flow of agents. Here, agents can be anything that make decisions,
    such as machines, humans, and robots. All these agents perform actions that can
    produce the most desirable results. In our game of tic-tac-toe, the agent is a
    computer player, and it should take actions that can beat our player in the game.
    We have a dedicated chapter to learning about AI and its rational agents, which
    will be covered after we finish learning basic game programming. However, in this
    section, we are going to create a simple AI that can decide on the most favorable
    move in order to beat a human player, or even end the game in a tie most of the
    time.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“人工智能”在技术世界中非常臭名昭著，但如果你深入研究，它其实是一堆模块和条件，决定了代理的流程。在这里，代理可以是任何做决定的东西，比如机器、人类和机器人。所有这些代理执行的动作都可以产生最理想的结果。在我们的井字游戏中，代理是一个计算机玩家，它应该采取行动，可以在比赛中击败我们的玩家。我们有一个专门的章节来学习人工智能及其理性代理，这将在我们完成基本游戏编程的学习后进行介绍。然而，在本节中，我们将创建一个简单的人工智能，可以决定最有利的移动，以击败人类玩家，或者大部分时间结束游戏为平局。
- en: We are going to take on the approach of procedural programming in order to add
    intelligence to the system. Don't get overwhelmed with the term procedural programming—it
    is just a way of making and using functions to achieve a goal. One thing you must
    remember is that every function should perform only one task. For example, we
    can make the `print_board()` function, which will just print the layout of the
    game every time we call it. This `print_board()` function is not going to take
    input from a user, or make any player a winner. Thus, the existence of functions
    should be preserved by performing only one modular task. We can also make the
    `is_winner()` function, which will check whether any player is the winner.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用过程式编程的方法来为系统添加智能。不要被过程式编程这个术语所压倒，它只是一种使用函数来实现目标的方法。你必须记住的一件事是，每个函数都应该只执行一个任务。例如，我们可以制作`print_board()`函数，每次调用它时，它只会打印游戏的布局。这个`print_board()`函数不会从用户那里获取输入，也不会让任何玩家成为赢家。因此，函数的存在应该通过执行一个模块化的任务来保留。我们还可以制作`is_winner()`函数，它将检查是否有任何玩家是赢家。
- en: 'The following diagram shows  how a simple algorithm can be made for our game.
    Here, we can see how we can check for the positions on the tic-tac-toe board so
    that the computer''s next move will produce the best result; something closer
    to winning the game, or in the worst case, making the game be a draw instead of
    the  computer losing:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了我们的游戏如何制作一个简单的算法。在这里，我们可以看到如何检查井字游戏板上的位置，以便计算机的下一步能够产生最佳结果；接近赢得比赛，或者在最坏的情况下，使比赛成为平局，而不是计算机输掉比赛：
- en: '![](Images/cb90d27c-adf9-415e-a234-7607649af642.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cb90d27c-adf9-415e-a234-7607649af642.png)'
- en: 'The following diagram show the procedures that we need to complete in order
    to implement the second part of the algorithm, where we will track every occupied
    position of the human player and check whether they could win with their next
    move. If they can win, we will block those positions. We will also occupy the
    center and side positions so that no human player can win the game easily:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们需要完成的程序，以实现算法的第二部分，我们将跟踪人类玩家的每个占据位置，并检查他们是否可以在下一步赢得比赛。如果他们能赢，我们将阻止这些位置。我们还将占据中心和侧面位置，以便没有人类玩家可以轻松赢得比赛：
- en: '![](Images/79f3c230-ef01-42dc-aac8-4fe51d2e45d6.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/79f3c230-ef01-42dc-aac8-4fe51d2e45d6.png)'
- en: Now, we have formed the basic algorithm so that we can start writing the code
    that can implement basic intelligence in our game. We will use this knowledge
    in the next section, *Implementation of models for intelligence,* in order to
    address the model for intelligence.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经形成了基本算法，这样我们就可以开始编写代码，实现我们游戏中的基本智能。我们将在下一节“智能模型的实现”中使用这些知识，以解决智能模型的问题。
- en: Implementation of models for intelligence
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能模型的实现
- en: 'First of all, let''s refine our code using functions; let''s create a function
    named `printBoard()`.This function will contain lines of code that will print
    the board layout of our tic-tac-toe game:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用函数来完善我们的代码；让我们创建一个名为`printBoard()`的函数。这个函数将包含一些代码行，用来打印我们井字游戏的棋盘布局：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The previous code will print board''s layout; if you want to execute the statements
    that are inside the function you have to call it. Here, we have to call it using
    the `board` argument, which is the list containing all the positions of the board,
    that is, ten empty places, `[''  ''] *10`. Let''s call this function and observe
    the result:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将打印出棋盘的布局；如果你想执行函数内部的语句，你必须调用它。在这里，我们必须使用`board`参数来调用它，这个参数是包含了棋盘所有位置的列表，也就是十个空位置，`['
    '] *10`。让我们调用这个函数并观察结果：
- en: '[PRE87]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, it''s time to make a function that can check whether any player is the
    winner or not. We are not making any brand new logic here; instead, we are putting
    all the statements that we made in the preceding chapters inside the scope of
    the function. Now, each time any user makes a move in the board, we can call this
    function to check whether that particular player is the winner or not. Thus, functions
    can remove repetition or duplication of code. Let''s use the `isWinner()` method
    to check whether any user satisfies the condition to become the winner:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候制作一个函数，来检查任何玩家是否是赢家了。我们在这里并没有制作全新的逻辑；相反，我们将在函数的范围内放置我们在前面章节中制作的所有语句。现在，每当任何用户在棋盘上做出动作时，我们可以调用这个函数来检查那个特定玩家是否是赢家。因此，函数可以消除代码的重复或重复。让我们使用`isWinner()`方法来检查是否有任何用户满足成为赢家的条件：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the preceding code, the parameter to the `isWinner` function is `board`,
    which contains the positions of the board layout and the player's letter; either
    `X` or `O`. We are reusing the same code that we wrote in the previous chapter,
    with small modifications. This method is going to return a Bool type of either
    `True` or `False`, and we will call it every time the player makes a new move
    in the game. We are checking entire rows, columns, and diagonal positions of the
    board layout using this method, and if any user occupies it, this will return
    `True` or `False`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`isWinner`函数的参数是`board`，其中包含了棋盘布局的位置和玩家的棋子，可以是`X`或者`O`。我们正在重用在上一章中编写的相同代码，只是做了一些小修改。这个方法将返回一个`True`或者`False`的布尔类型，并且我们将在玩家在游戏中做出新动作时调用它。我们使用这个方法来检查整行、整列和对角线的棋盘布局，如果有任何用户占据了它，就会返回`True`或者`False`。
- en: 'In the game of tic-tac-toe, we get to move the player in the form of the position
    and we assign the player''s character''s either `X` or `O`, to it. We have seen
    its implementation in the previous chapter. Here, we are going to make a separate
    function that will assign a value to the position. In the following code, the
    board represents the layout of the game containing the positions; `current_player`
    is either `X` or `O` and `move` is the input from the user:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在井字游戏中，我们以位置的形式移动玩家，并将玩家的字符分配给它，可以是`X`或者`O`。我们在前一章中已经看到了它的实现。在这里，我们将制作一个单独的函数，用来给位置分配一个值。在下面的代码中，`board`代表了包含位置的游戏布局；`current_player`要么是`X`，要么是`O`，而`move`是用户的输入：
- en: '[PRE89]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, it''s time to make the computer play our game. Let''s recall the algorithm
    that we made in the preceding section. We are going to perform multiple checks:
    whether the computer can win in the next move or not, and whether a human player
    could win in the next move. If so, we will block the winning position. We cannot
    perform these operations in the real board layout game, because we don''t want
    our board layout to be populated. Thus, we are going to make a copy of the board
    layout so that we can perform these checking operations in the new clone board
    layout. Let''s make a function to copy the original board layout:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候让计算机玩我们的游戏了。让我们回顾一下我们在前一节中制作的算法。我们将进行多次检查：计算机是否能在下一步赢得比赛，以及人类玩家是否能在下一步赢得比赛。如果是这样，我们将阻止获胜的位置。我们不能在真正的棋盘布局游戏中执行这些操作，因为我们不希望我们的棋盘布局被填充。因此，我们将复制一份棋盘布局，以便我们可以在新的克隆棋盘布局中执行这些检查操作。让我们制作一个函数来复制原始的棋盘布局：
- en: '[PRE90]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'After we clone the original board, we have to check whether there are free
    spaces available for the computer to make a move. Let''s make a function to check
    the available free spaces inside the board layout:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们克隆了原始棋盘之后，我们必须检查计算机是否有空位可以移动。让我们制作一个函数来检查棋盘布局中的可用空位：
- en: '[PRE91]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`isSpaceAvailable` returns a Bool type: either `True` or `False`. It will return
    `True` if the move is available on the passed board layout. If the position is
    already occupied by any player, it will return `False`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`isSpaceAvailable`返回一个布尔类型：要么是`True`，要么是`False`。如果在传递的棋盘布局上可以移动，它将返回`True`。如果位置已经被任何玩家占据，它将返回`False`。'
- en: 'Now, it''s time to get into the main part of our topic: making the computer
    play our game. Let''s create a function named `makeComputerMove()` and pass the
    board argument and a `computerPlayer` character to it. Here, the board represents
    our board layout containing all the positions, and `computerPlayer` is a character,
    either `X` or `O`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进入我们话题的主要部分了：让计算机玩我们的游戏。让我们创建一个名为`makeComputerMove()`的函数，并将`board`参数和`computerPlayer`字符传递给它。这里，`board`代表了包含所有位置的棋盘布局，而`computerPlayer`是一个字符，可以是`X`或者`O`：
- en: '[PRE92]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In the preceding code, `#part1`, we checked if the computer can win in the next
    move or not. At first, we looped into the entire position of the board layout
    and made a clone of the board using the `boardCopy` function. After that, we passed
    every position from 1 to 10 to check for space availability. We checked if that
    move was going to make the computer player the winner or not by using the `isWinner`
    function, and returned that specific move as the position if that was the case.
    This part of the code makes our computer player intelligent enough to decide the
    next move, based on its favorable prediction.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码`#part1`中，我们检查了计算机是否能在下一步获胜。首先，我们循环遍历了整个棋盘布局的位置，并使用`boardCopy`函数克隆了棋盘。然后，我们将1到10的每个位置传递给`isWinner`函数，检查空间是否可用。我们通过使用`isWinner`函数检查该移动是否会使计算机玩家成为赢家，并在这种情况下返回特定的移动位置。这部分代码使我们的计算机玩家足够智能，可以根据其有利的预测决定下一步移动。
- en: 'In the process of adding intelligence to our computer player, the next step
    is to keep track of the human player''s movements. On doing so, we can make a
    smart move on the board so that the player won''t win the game easily. In addition,
    if the human player has occupied two positions on the row of the board, we can
    make our move to block the third position. Let''s write `#part2` of our `makeComputerMove()`
    function. In order to check whether the human player is going to win, we have
    to play the game as a human, but virtually. We can do this without affecting the
    original board because we can play as a human within the copy of the board. Now,
    to check whether the human player is going to win, we have to get a player letter,
    that is, either `X` or `O`. We can make a condition to check whether the human
    player is `X` or `O`. After getting that letter, we can play as a human virtually
    on the copy of board game, but remember that we are coding for the computer player:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的计算机玩家增加智能的过程中，下一步是跟踪人类玩家的移动。这样做可以在棋盘上做出聪明的移动，使玩家不会轻易获胜。此外，如果人类玩家在棋盘的一行上占据了两个位置，我们可以移动来阻止第三个位置。让我们编写`makeComputerMove()`函数的`#part2`。为了检查人类玩家是否会获胜，我们必须以虚拟的方式扮演人类玩家来玩游戏。我们可以在不影响原始棋盘的情况下做到这一点，因为我们可以在棋盘的副本中扮演人类。现在，为了检查人类玩家是否会获胜，我们必须获得一个玩家字母，即`X`或`O`。我们可以设置条件来检查人类玩家是`X`还是`O`。获得该字母后，我们可以在棋盘游戏的副本上以虚拟的方式扮演人类，但请记住我们是为计算机玩家编写代码。
- en: '[PRE93]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The code that we have just written is going to add a smart move for the computer
    player. We are making the computer play the tic-tac-toe game as a human, but virtually.
    We are checking if the human will win on the next move or not. If it they are,
    we will return that move so that the computer will place its letter in that position
    to block the human from winning the game.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的代码将为计算机玩家增加一个智能移动。我们让计算机以虚拟的方式扮演井字棋游戏的人类玩家。我们正在检查下一步人类玩家是否会获胜。如果他们会，我们将返回该移动，以便计算机将其字母放在该位置，阻止人类获胜。
- en: 'During the brainstorming and information gathering processes, we made a flowchart
    to track the activities that will embed intelligence into our computer player.
    We executed two of them: checking the best move to win, and blocking the next
    best move of the human player. We can also make the computer player smarter by
    making an initial move, which the human player would normally do. For example,
    when we play tic-tac-toe, we start by taking the center position, because we think
    it is the best position to start with. So, why not make the computer to do that
    too? Let''s write some code where the computer will check the availability of
    the center position on the board and reserve that position accordingly:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在头脑风暴和信息收集过程中，我们制作了一个流程图，以跟踪将智能嵌入我们的计算机玩家的活动。我们执行了其中的两个活动：检查获胜的最佳移动，以及阻止人类玩家的下一个最佳移动。我们还可以通过进行初始移动使计算机玩家变得更加智能，这是人类玩家通常会做的。例如，当我们玩井字棋时，我们会从中心位置开始，因为我们认为这是最好的起始位置。那么，为什么不让计算机也这样做呢？让我们编写一些代码，让计算机检查棋盘上中心位置的可用性，并相应地保留该位置。
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can make this computer player even smarter by checking the availability
    of the corner positions, too. The corner positions on the board are `[1,3,7,9]`.
    Since there are four corners on our board, we maintained the list to track them.
    Now, let''s create a new `getRandomMove()` function, which will take the board
    and moves as arguments. The moves argument will be in the form of a list, such
    as the corner positions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查角落位置的可用性使这个计算机玩家变得更加智能。棋盘上的角落位置是`[1,3,7,9]`。由于我们的棋盘上有四个角落，我们维护了一个列表来跟踪它们。现在，让我们创建一个新的`getRandomMove()`函数，它将接受棋盘和移动作为参数。移动参数将以列表的形式提供，例如角落位置。
- en: '[PRE95]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: A lot of things are going on in the preceding code, so let's break things down
    to make it simpler. First of all, this method is going to take moves which will
    be in the form of a list, that is, `[1,2,3,4,5]`; among them, we have to choose
    only one element using this function. However, the elements of this list are not
    only numbers; they are moves or positions of the board layout. Thus, we have to
    check for the availability of spaces for each move of that list. If there are
    available spaces, we append that move to a new list called `availableMoves`. After
    the filtering is done, we perform conditionals to check whether there are any
    available moves or not.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中发生了很多事情，所以让我们把事情分解成更简单的部分。首先，这个方法将接受以列表形式提供的移动，即`[1,2,3,4,5]`；我们必须使用这个函数选择其中一个元素。然而，这个列表的元素不仅仅是数字；它们是棋盘布局的移动或位置。因此，我们必须检查每个移动的空间是否可用。如果有可用空间，我们将该移动添加到一个名为`availableMoves`的新列表中。筛选完成后，我们进行条件检查，以确定是否有任何可用移动。
- en: 'The `>>> availableMoves.__len__() != 0` expression is the same as `len(availableMoves)`,
    which is going to return the length of the list. We call these implementations
    (`__len__()`) data models, and we have an upcoming dedicated chapter that will
    cover them. If the length of `availableMoves` is zero, we are going to return
    `None`. But if it is not zero, we will execute an expression. Let''s break this
    expression down into fragments:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> availableMoves.__len__() != 0`表达式与`len(availableMoves)`相同，它将返回列表的长度。我们称这些实现(`__len__()`)为数据模型，我们将在即将到来的专门章节中进行介绍。如果`availableMoves`的长度为零，我们将返回`None`。但如果不为零，我们将执行一个表达式。让我们将这个表达式分解成片段：'
- en: '`import random`: If you recall the topics of [Chapter 2](06cdc81b-3e57-405e-b721-235214498ac7.xhtml), *Learning
    the Fundamentals of Python,* where we imported the math modules to perform mathematical
    computations such as square root and factorials, we imported math modules using
    the `import math` command. Now, we are importing a random module, which means
    that we can use methods that are defined inside it using this module. The syntax
    for calling a method from a random module is `random.method_name()`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import random`: 如果你回忆一下[第2章](06cdc81b-3e57-405e-b721-235214498ac7.xhtml)的主题，*学习Python基础*，我们导入了math模块来执行数学计算，比如平方根和阶乘，我们使用`import
    math`命令导入math模块。现在，我们正在导入一个random模块，这意味着我们可以使用该模块中定义的方法。从random模块调用方法的语法是`random.method_name()`。'
- en: '`random.choice()`: The choice method is going to pick up one random element
    from the list of elements that it has been called upon with. For example, the
    execution of the following command will give one random value from the range of
    values that''s been passed into it:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random.choice()`: choice方法将从被调用的元素列表中随机选择一个元素。例如，执行以下命令将从传递给它的值范围中随机选择一个值：'
- en: '[PRE96]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We passed `availableMoves` into it so that the `choice` method would pick any
    one of the moves randomly. This is essential for our gameplay because sometimes
    the computer must make decisions randomly.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`availableMoves`传递给它，以便`choice`方法可以随机选择任意一个移动。这对我们的游戏至关重要，因为有时计算机必须随机做出决定。
- en: 'Now, let''s call this `getRandomMove` function within the `makeComputerMove`
    function. If you take a look through the code of the `makeComputerMove` function,
    we have added a statement that will help the computer occupy the center position.
    What about corner positions? They are also an important position of the tic-tac-toe
    game. If we occupy the center and corner positions of the board, our computer
    will have a high chance of winning the game. Thus, we have to enhance our code,
    which will make the computer player capture the corner positions. Since the corner
    positions are `[1, 3, 7, 9]` we have to pass this as a list argument to the `getRandomMove`
    function, which we have just created:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`makeComputerMove`函数中调用`getRandomMove`函数。如果你浏览一下`makeComputerMove`函数的代码，我们已经添加了一个语句，将帮助计算机占据中心位置。角落位置呢？它们也是井字棋游戏的重要位置。如果我们占据了棋盘的中心和角落位置，我们的计算机将有很高的获胜几率。因此，我们必须增强我们的代码，使计算机玩家占据角落位置。由于角落位置是`[1,
    3, 7, 9]`，我们必须将其作为列表参数传递给我们刚刚创建的`getRandomMove`函数：
- en: '[PRE97]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In the preceding code, we added code that will get random moves on any of the
    corner positions. We have covered the player moves for the center `position [5]`,
    and for corner positions `[1,3,7,9]`; now, we are left with the side positions,
    `[2,4,6,8]`. We made a call to the `getRandomMove` function, which will choose
    any one random move from the passed list.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了代码，将在任何角落位置上获取随机移动。我们已经涵盖了中心位置`[5]`和角落位置`[1,3,7,9]`的玩家移动；现在，我们还剩下边缘位置`[2,4,6,8]`。我们调用了`getRandomMove`函数，它将从传递的列表中选择任意一个随机移动。
- en: We have learned so many things in the preceding sections such as loops, conditionals,
    and many more. In the next section, we are going to write some code that will
    use them to control program flow. We will call it, the **main function**.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学到了许多东西，比如循环、条件语句等等。在下一节中，我们将编写一些代码来使用它们来控制程序流程。我们将称之为**主函数**。
- en: Controlling program flow with main function
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主函数控制程序流程
- en: 'We have written a bunch of functions such as `makeComputerMove`, `isWinner`,
    and many more, but they have not been called anywhere. We know that the function
    is not going to execute code inside it until we call it. Thus, we will make new
    function, that will take care of the flow of the program. We normally name it
    the main function, but you can literally name it anything you like. The code that
    we have wrote in the previous chapters, such as for the main game loop or toggling
    player turn, will be embedded inside this main function. The only function that
    needs to be called explicitly is this main function. Let''s create one now:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了许多函数，比如`makeComputerMove`、`isWinner`等等，但它们还没有被调用。我们知道在调用函数之前，函数不会执行其中的代码。因此，我们将创建一个新的函数，来处理程序的流程。通常我们称之为主函数，但你可以随意命名。我们在之前的章节中编写的代码，比如主游戏循环或切换玩家回合，将嵌入到这个主函数中。唯一需要显式调用的函数就是这个主函数。让我们现在创建一个：
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We have written the preceding code multiple times before, such as when printing
    the board, toggling the players, and creating a winner. The difference is, here,
    we are using functions. We have one task related to one function, such as `isWinner`,
    which checks if a player is the winner or not, and instead of writing an entire
    piece of code to check the winner, we write it once and use it in our main function.
    You can see that we have written some code take input from a user as a move value
    to the board game. We can make a function to take an input from a user. Let''s
    make it now, and make the main function cleaner and more readable:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前多次编写了前面的代码，比如在打印棋盘、切换玩家和创建获胜者时。不同之处在于，这里我们使用了函数。我们有一个与一个函数相关的任务，比如`isWinner`，它检查玩家是否获胜，而不是编写整个代码来检查获胜者，我们只需编写一次并在主函数中使用它。您可以看到我们已经编写了一些代码来从用户那里获取输入作为棋盘游戏的移动值。我们可以制作一个函数来从用户那里获取输入。现在让我们来做，使主函数更清晰、更易读：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, let''s add this newly created function to the main function. We will also
    complete the `else` part of the code, which will make the computer play our game:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个新创建的函数添加到主函数中。我们还将完成代码的`else`部分，让计算机玩我们的游戏：
- en: '[PRE100]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, let''s run our game and play against our custom-made AI agent. The following
    illustration show the output of our game, and shows the new tic-tac-toe board
    layout. This is made with the function call to `printBoard`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行游戏，并与我们定制的AI代理对战。以下插图显示了我们游戏的输出，并显示了新的井字棋棋盘布局。这是通过对`printBoard`进行函数调用实现的：
- en: '![](Images/ad344339-a730-428a-a43a-c7779866475a.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ad344339-a730-428a-a43a-c7779866475a.png)'
- en: 'The following illustration depicts the gameplay where the human player is playing
    against the computer AI. You can see that the human is defeated by the computer
    player:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图描述了人类玩家与计算机AI对战的游戏过程。您可以看到人类被计算机玩家击败了：
- en: '![](Images/e6f59fb7-52ca-4a01-ab9b-bdc8a287e482.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e6f59fb7-52ca-4a01-ab9b-bdc8a287e482.png)'
- en: Now, we have made a layout that is appealing enough to entice any player to
    play the game. However, there are a few modifications that can be done, which
    will be covered in the next section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经制作了一个足够吸引任何玩家玩游戏的布局。但是，还有一些修改可以进行，这将在下一节中介绍。
- en: Game testing and possible modifications
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: The game that we have made in this chapter is playable enough against a computer.
    Using AI in the game is all about addressing all the probable situations that
    a game can face while interacting with the environment. In our tic-tac-toe game,
    we don't have many moves compared to Chess or Go, and so making an AI agent is
    easier. We were able to compete with the human by making an AI that was able to
    make two smart moves, such as checking for the next best move to win or blocking
    the human from winning through simulation. If you are wondering what simulation
    is, you will have to recall the algorithm that we have just implemented in order
    to check whether the human player is going to win in the next move. In addition,
    the computer player was acting as a human player on the clone board and played
    virtually, like a human. This is called simulation, where we made the computer
    imitate the real-world process or behavior of the system.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中制作的游戏已经足够可以与计算机对战。在游戏中使用AI主要是解决游戏在与环境交互时可能面临的所有可能情况。在我们的井字棋游戏中，与国际象棋或围棋相比，我们的走法并不多，因此制作AI代理更容易。通过制作一个能够做出两个聪明的举动的AI，我们能够与人类竞争，比如检查下一个最佳走法以获胜或通过模拟阻止人类获胜。如果您想知道模拟是什么，您将不得不回想一下我们刚刚实现的算法，以检查人类玩家是否会在下一步获胜。此外，计算机玩家在克隆棋盘上扮演人类玩家，并像人类一样进行虚拟游戏。这就是模拟，我们让计算机模仿系统的真实过程或行为。
- en: After predicting the best move to make through simulation, our program was returning
    the best possible next move for our computer player. Let's extrapolate this technique
    further. What we just did in our game was make an AI that can make a simulated
    environment to predict the next best move. The same technique is applied to a
    whole range of AI applications, for instance, a self-driving car; we make a simulated
    environment within the computer where the car is an agent, and will make decisions
    either to turn left or right based on obstacles. Tic-tac-toe is simple while interacting
    with the environment because of its lesser number of moves or situations, but
    programming a self-driving a car simulation requires us to acknowledge a whole
    range of situations that may arise while driving car on the road. Thus, we can
    conclude that AI is all about creating a program where the agent must consider
    all the situations it may face while interacting with the environment and respond
    to each of those situations.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟预测最佳走法后，我们的程序会为计算机玩家返回最佳的下一个可能走法。让我们进一步推广这种技术。我们在游戏中所做的是制作一个能够制作模拟环境以预测下一个最佳走法的AI。相同的技术应用于整个范围的AI应用，例如自动驾驶汽车；我们在计算机内部制作了一个模拟环境，汽车是一个代理，将根据障碍物做出左转或右转的决定。井字棋在与环境交互时比较简单，因为它的走法或情况较少，但是编写自动驾驶汽车模拟需要我们认识到在道路上驾驶汽车时可能出现的一整套情况。因此，我们可以得出结论，AI主要是关于创建一个程序，其中代理必须考虑与环境交互时可能面临的所有情况，并对每种情况做出响应。
- en: 'Our competitor is smart enough to make this game harder for the player to win,
    but humans also possess the ultimate power to make the computer player hamstrung.
    Human players won''t let a computer have an easy win. Thus, most of the time,
    our game will end in a tie. However, if you run the game, you''ll see we haven''t
    addressed those cases. Now, whenever our game is a tie, instead of stopping the
    game, our game will incessantly ask for input from the user. Instead, we have
    to give the user a message saying, try again, and facilitate the user to play
    our game again. In order to check for a tie condition, we have to check whether
    the board is full. When the board positions are fully occupied and nobody is the
    winner, we have a tie condition. We can make another function to check whether
    the board is full:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的竞争对手足够聪明，使游戏对玩家来说更加困难，但人类也拥有让电脑玩家受限的终极力量。人类玩家不会让电脑轻易获胜。因此，大部分时间我们的游戏会以平局结束。然而，如果你运行游戏，你会发现我们还没有处理这些情况。现在，每当我们的游戏是平局时，而不是停止游戏，我们的游戏将不断要求用户输入。相反，我们必须给用户一个消息，告诉他们再试一次，并帮助用户再次玩我们的游戏。为了检查平局条件，我们必须检查棋盘是否已满。当棋盘位置全部被占满且没有人获胜时，我们就有了平局条件。我们可以制作另一个函数来检查棋盘是否已满：
- en: '[PRE101]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The preceding `isBoardOccupied()` function is going to return a Bool type,
    either `True` or `False`, based on the check, which will determine if the board
    is full or not. If the board is full, it will return `True` and if it is not,
    it will return `False`. We are using the `isSpaceAvailable()` function that we
    created in the preceding section, which will check whether there are any empty
    spaces on the board. Now, let''s refine our code with this new function:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`isBoardOccupied()`函数将根据检查返回一个布尔类型，要么是`True`，要么是`False`，这将确定棋盘是否已满。如果棋盘已满，它将返回`True`，如果没有，它将返回`False`。我们正在使用我们在前一节中创建的`isSpaceAvailable()`函数，它将检查棋盘上是否有空位。现在，让我们用这个新函数来完善我们的代码：
- en: '[PRE102]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was concise and terse, containing an abundance of information,
    ranging from data structures to functions. These topics are the building blocks
    of any complex program, and so on, we will use them in every game that we will
    cover from the next chapter onward. We started this chapter by learning the necessity
    of data structures, and we delved into the fundamental data structures of Python
    such as lists, dictionaries, tuples, and sets. We covered the ways in which we
    can create those data structures and manipulate them.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容简洁而扼要，包含了丰富的信息，从数据结构到函数。这些主题是任何复杂程序的基石，因此，我们将在接下来的每个游戏中使用它们。我们从学习数据结构的必要性开始，深入探讨了Python的基本数据结构，如列表、字典、元组和集合。我们讲解了如何创建这些数据结构并对其进行操作。
- en: We learned about ways to create user-defined functions, call them, and document
    them. We also saw that functions are like machines, where you can feed raw data
    in, and get output back as meaningful information. We saw the ways of inputting
    data to the functions using positional and default arguments. Then, we looked
    at saw the ways of modifying our functions by packing and unpacking of normal
    and keyword arguments in order to achieve the best performance from them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了创建用户定义函数、调用它们和记录它们的方法。我们还看到函数就像机器，你可以输入原始数据，然后得到有意义的输出。我们看到了使用位置参数和默认参数输入数据到函数的方法。然后，我们看到了通过打包和解包普通和关键字参数来修改我们的函数，以便从中获得最佳性能。
- en: We also modified our game further using functions and data structures, and we
    made simple algorithms that can address different possible situations of gameplay.
    We made our computer player smart enough to beat our human player. Then, we also
    made a simulation environment where an agent can test and train itself in order
    to predict the next best possible move. Although our game was simple to make,
    it has given us a broad range of ideas about the processes that need to be undertaken,
    such as brainstorming, designing, coding essentials, and analysis, before we actually
    start writing modular code.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用函数和数据结构进一步修改了我们的游戏，并制定了可以应对不同游戏情况的简单算法。我们让我们的电脑玩家足够聪明，可以击败我们的人类玩家。然后，我们还制作了一个模拟环境，其中一个代理可以测试和训练自己，以预测下一个最佳移动。虽然我们的游戏制作起来很简单，但它给了我们许多关于需要进行的流程的想法，例如头脑风暴、设计、编码基础和分析，然后我们才真正开始编写模块化代码。
- en: Finally, we covered procedural programming, which refers to using functions
    to build programs. In the next chapter, we will cover procedural programming in
    terms of curses. We will create programs using terminal-independent, screen painter,
    and text-based terminals. We will make a snake game using a curses event and a
    screen painter and then use curses properties in order to make logic for playing
    the snake game.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讲解了过程式编程，指的是使用函数来构建程序。在下一章中，我们将讲解基于curses的过程式编程。我们将使用与终端无关的屏幕绘图和基于文本的终端来创建程序。我们将使用curses事件和屏幕绘图来制作一个贪吃蛇游戏，然后利用curses属性来制定玩贪吃蛇游戏的逻辑。
- en: Are you excited to hop into the next chapter? It will take you through an adventurous
    tour of game programming with the curses module, and we will learn how to handle
    user events and game consoles with it. Before that, I highly suggest that you
    refer to the official Python documentation and take a tour of the Python built-in
    data structures and modules; and practice with them without any additional help.
    The knowledge that we have gained so far will be used throughout the chapters
    of this book, so it's high time that revise the topics that we have learned about
    so far.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否对进入下一章感到兴奋？它将带你进行一次冒险之旅，学习使用curses模块进行游戏编程，以及如何处理用户事件和游戏控制台。在那之前，我强烈建议你参考官方Python文档，并浏览Python内置的数据结构和模块；并且在没有额外帮助的情况下进行练习。到目前为止我们所学到的知识将在本书的各章中使用，所以现在是时候复习我们迄今为止学到的主题了。
