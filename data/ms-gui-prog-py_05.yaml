- en: Building Applications with QMainWindow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QMainWindow构建应用程序
- en: Basic Qt widgets can take us a long way when building simple forms, but full
    applications include features such as menus, toolbars, dialog boxes, and other
    functionality that can be tedious and tricky to build from scratch. Fortunately,
    PyQt provides us with ready-made classes for these standard components to make
    building applications relatively painless.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Qt小部件可以在构建简单表单时带我们走很远，但完整的应用程序包括诸如菜单、工具栏、对话框等功能，这些功能可能很繁琐和棘手，从头开始构建。幸运的是，PyQt为这些标准组件提供了现成的类，使构建应用程序相对轻松。
- en: 'In this chapter, we''ll explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The `QMainWindow` class
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMainWindow`类'
- en: Standard dialog boxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准对话框
- en: Saving settings with `QSettings`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QSettings`保存设置
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will require the same setup as shown in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*. You may also wish to reference the code found in
    our GitHub repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter04).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将需要与[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)的设置相同。您可能还希望参考我们在GitHub存储库中找到的代码，网址为[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter04)。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5OGnq](http://bit.ly/2M5OGnq)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2M5OGnq](http://bit.ly/2M5OGnq)
- en: The QMainWindow class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMainWindow类
- en: Up until now, we've been using the humble `QWidget` as the base class for our
    top-level window. This works well for simple forms, but it lacks many of the features
    that we might expect from an application's main window, such as menu bars or toolbars.
    Qt provides the `QMainWindow` class to address this need.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`QWidget`作为顶级窗口的基类。这对于简单的表单效果很好，但它缺少许多我们可能期望从应用程序的主窗口中得到的功能，比如菜单栏或工具栏。Qt提供了`QMainWindow`类来满足这种需求。
- en: 'Make a copy of the application template from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and let''s make a small but crucial change:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)的应用程序模板中复制一份，并进行一个小但至关重要的更改：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Instead of inheriting from `QWidget`, we'll inherit from `QMainWindow`. As you'll
    see, this will change the way we have to code our GUI, but it will also add a
    number of nice features to our main window.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再继承自`QWidget`，而是继承自`QMainWindow`。正如您将看到的，这将改变我们编写GUI的方式，但也会为我们的主窗口添加许多很好的功能。
- en: 'To explore these new features, let''s build a simple plain text editor. The
    following screenshot shows what our completed editor will look like, along with
    labels showing the main components of the `QMainWindow` class:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这些新功能，让我们构建一个简单的纯文本编辑器。以下屏幕截图显示了我们完成的编辑器的外观，以及显示`QMainWindow`类的主要组件的标签：
- en: '![](assets/67b30b0a-e7d2-42cf-8b9d-3d2f92ee0828.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67b30b0a-e7d2-42cf-8b9d-3d2f92ee0828.png)'
- en: Save your updated template, copy it to a new file called `text_editor.py`, and
    open the new file in your code editor. Let's begin!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您更新的模板，将其复制到一个名为`text_editor.py`的新文件中，并在您的代码编辑器中打开新文件。让我们开始吧！
- en: Setting a central widget
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置中央小部件
- en: '`QMainWindow` is divided into several sections, the most important of which
    is the **central widget**. This is a single widget that represents the main business
    part of the interface.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMainWindow`分为几个部分，其中最重要的是**中央小部件**。这是一个代表界面主要业务部分的单个小部件。'
- en: 'We set this by passing a reference to any widget to the `QMainWindow.setCentralWidget()`
    method, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将任何小部件的引用传递给`QMainWindow.setCentralWidget（）`方法来设置这一点，就像这样：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There can be only one central widget, so in a more complex application (such
    as a data entry app, for instance) it will more likely be a `QWidget` object on
    which you've arranged a more complex GUI; for our simple text editor, a single
    `QTextEdit` widget will suffice. Notice that we do not set a layout on the `QMainWindow`;
    doing so would break the preset arrangement of components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '只能有一个中央小部件，因此在更复杂的应用程序（例如数据输入应用程序）中，它更可能是一个`QWidget`对象，您在其中安排了一个更复杂的GUI；对于我们的简单文本编辑器，一个单独的`QTextEdit`小部件就足够了。请注意，我们没有在`QMainWindow`上设置布局；这样做会破坏组件的预设排列。 '
- en: Adding a status bar
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加状态栏
- en: A **status bar** is a strip across the bottom of the application window designed
    for displaying short text messages and informational widgets. In Qt, a status
    bar is a `QStatusBar` object that we can assign to the main window's `statusBar`
    property.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态栏**是应用程序窗口底部的一条条纹，用于显示短文本消息和信息小部件。在Qt中，状态栏是一个`QStatusBar`对象，我们可以将其分配给主窗口的`statusBar`属性。'
- en: 'We could create one like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样创建一个：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, there's no need to go to so much trouble; the `QMainWindow` object's
    `statusBar()` method automatically creates a new status bar if there isn't one,
    or returns the existing one if there is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有必要费这么大的劲；如果没有状态栏，`QMainWindow`对象的`statusBar（）`方法会自动创建一个新的状态栏，如果有状态栏，则返回现有的状态栏。
- en: 'So, we can reduce all that code to this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将所有的代码简化为这样：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `showMessage()` method does exactly what it says, displaying the given string
    in the status bar. This is by far the most common use of the status bar; however,
    `QStatusBar` objects can also contain other widgets.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`showMessage（）`方法确切地做了它所说的，显示状态栏中给定的字符串。这是状态栏最常见的用法；但是，`QStatusBar`对象也可以包含其他小部件。'
- en: 'For example, we can add a widget that keeps track of our character count:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以添加一个小部件来跟踪我们的字符计数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `QLabel` is updated with the number of characters entered whenever our
    text changes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们的文本更改时，这个`QLabel`就会更新输入的字符数。
- en: 'Note that we''ve added it directly to the status bar, without referencing a
    layout object; `QStatusBar` has its own methods for adding or inserting widgets
    that come in two flavors: **regular** and **permanent**. In regular mode, widgets
    can be covered up if the status bar is sent a long message to display. In permanent
    mode, they will remain visible. In this case, we used the `addPermanentWidget()`
    method to add `charcount_label` in permanent mode so it won''t be covered up by
    a long text message.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们直接将其添加到状态栏，而不引用布局对象；`QStatusBar`具有自己的方法来添加或插入小部件，有两种模式：**常规**和**永久**。在常规模式下，如果状态栏发送了一个长消息来显示，小部件可能会被覆盖。在永久模式下，它们将保持可见。在这种情况下，我们使用`addPermanentWidget()`方法以永久模式添加`charcount_label`，这样它就不会被长文本消息覆盖。
- en: The methods for adding a widget in regular mode are `addWidget()` and `insertWidget()`;
    for permanent mode, use `addPermanentWidget()` and `insertPermanentWidget()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规模式下添加小部件的方法是`addWidget()`和`insertWidget()`；对于永久模式，请使用`addPermanentWidget()`和`insertPermanentWidget()`。
- en: Creating an application menu
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序菜单
- en: The **application menu** is a crucial feature for most applications, offering
    access to all the application's functionality in hierarchically organized drop-down
    menus.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序菜单**对于大多数应用程序来说是一个关键功能，它提供了对应用程序所有功能的访问，以分层组织的下拉菜单形式。'
- en: 'We can create on easily using the `QMainWindow.menuBar()` method:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`QMainWindow.menuBar()`方法轻松创建一个。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `menuBar()` method returns a `QMenuBar` object, and as with `statusBar()`,
    this method will give us the window's existing menu if it exists, or simply create
    a new one if it doesn't.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`menuBar()`方法返回一个`QMenuBar`对象，与`statusBar()`一样，如果存在窗口的现有菜单，此方法将返回该菜单，如果不存在，则会创建一个新的菜单。'
- en: 'By default, the menu is blank, but we can add submenus using the menu bar''s
    `addMenu()` method, like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，菜单是空白的，但是我们可以使用菜单栏的`addMenu()`方法添加子菜单，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`addMenu()` returns a `QMenu` object, which represents a drop-down submenu.
    The string passed into the method will be used to label the menu in the main menu
    bar.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`addMenu()`返回一个`QMenu`对象，表示下拉子菜单。传递给该方法的字符串将用于标记主菜单栏中的菜单。'
- en: Certain platforms, such as macOS, will not display empty submenus. See the *Menus
    on macOS* section for more information on building menus in macOS.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 某些平台，如macOS，不会显示空的子菜单。有关在macOS中构建菜单的更多信息，请参阅*macOS上的菜单*部分。
- en: To populate these menus with items, we need to create some **actions**. Actions
    are simply objects of the `QAction` class that represent things our program can
    do. To be useful, a `QAction` object needs at least a name and a callback; they
    can optionally define a keyboard shortcut and icon for the action.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要向这些菜单填充项目，我们需要创建一些**操作**。操作只是`QAction`类的对象，表示我们的程序可以执行的操作。要有用，`QAction`对象至少需要一个名称和一个回调；它们还可以为操作定义键盘快捷键和图标。
- en: 'One way to create actions is to call a `QMenu` object''s `addAction()` method,
    like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建操作的一种方法是调用`QMenu`对象的`addAction()`方法，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've created two actions called `Open` and `Save`. Neither of them actually
    does anything, because we haven't assigned callback methods, but if you run your
    application script, you'll see that the file menu does indeed have two items listed,
    `Open` and `Save`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个名为`Open`和`Save`的操作。它们实际上什么都没做，因为我们还没有分配回调方法，但是如果运行应用程序脚本，您会看到文件菜单确实列出了两个项目，`Open`和`Save`。
- en: 'To create items that actually do something, we can pass in a second argument
    containing a Python callable or Qt slot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实际执行操作的项目，我们可以传入第二个参数，其中包含一个Python可调用对象或Qt槽：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For cases where we want more control, it''s possible to create a `QAction` object
    explicitly and add it to the menu, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要更多控制的情况，可以显式创建`QAction`对象并将其添加到菜单中，如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`QAction` objects have a `triggered` signal that must be connected to a callable
    or slot for the action to have any effect. This is handled automatically when
    we use the `addAction()` method of creating actions, but it must be done manually
    when creating `QAction` objects explicitly.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`QAction`对象具有`triggered`信号，必须将其连接到可调用对象或槽，以使操作产生任何效果。当我们使用`addAction()`方法创建操作时，这将自动处理，但在显式创建`QAction`对象时，必须手动执行。'
- en: Although not technically required, it's very important to pass in a parent widget
    when creating a `QAction` object explicitly. Failing to do so will result in the
    item not showing up, even when you add it to the menu.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上不是必需的，但在显式创建`QAction`对象时传入父窗口小部件非常重要。如果未这样做，即使将其添加到菜单中，该项目也不会显示。
- en: Menus on macOS
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS上的菜单
- en: '`QMenuBar` wraps the OS''s native menu system by default. On macOS, the native
    menu system has a few peculiarities that you need to be aware of:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMenuBar`默认包装操作系统的本机菜单系统。在macOS上，本机菜单系统有一些需要注意的特殊之处：'
- en: macOS uses a **global menu**, meaning the menu bar is not part of the application
    window but is attached to the bar at the top of the desktop. By default, your
    main window's menu bar will be used as the global menu. If you have an application
    with multiple main windows and you want them all to use the same menu bar, do
    not use `QMainWindow.menuBar()` to create the menu bar. Instead, create a `QMenuBar`
    object explicitly and assign it to the main window objects you create using the
    `setMenuBar()` method.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS使用**全局菜单**，这意味着菜单栏不是应用程序窗口的一部分，而是附加到桌面顶部的栏上。默认情况下，您的主窗口的菜单栏将用作全局菜单。如果您有一个具有多个主窗口的应用程序，并且希望它们都使用相同的菜单栏，请不要使用`QMainWindow.menuBar()`来创建菜单栏。而是显式创建一个`QMenuBar`对象，并使用`setMenuBar()`方法将其分配给您使用的主窗口对象。
- en: macOS also has a number of default submenus and menu items. To access these
    items, simply use the same when adding a submenu. When adding a submenu see the
    *Further reading* section for more details on macOS menus.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS还有许多默认的子菜单和菜单项。要访问这些项目，只需在添加子菜单时使用相同的方法。有关添加子菜单的更多详细信息，请参阅*进一步阅读*部分中有关macOS菜单的更多详细信息。
- en: As mentioned previously, macOS will not display an empty submenu on the global
    menu.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，macOS不会在全局菜单上显示空子菜单。
- en: 'If you find these issues too problematic for your application, you can always
    instruct Qt not to use the native menu system, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现这些问题对您的应用程序太具有问题，您可以始终指示 Qt 不使用本机菜单系统，就像这样：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will place the menu bar in the application window as it is on other platforms
    and remove the platform-specific issues. However, be aware that this approach
    breaks the workflow typical to macOS software and users may find it jarring.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用程序窗口中放置菜单栏，并消除特定于平台的问题。但是，请注意，这种方法会破坏 macOS 软件的典型工作流程，用户可能会感到不适。
- en: More information about Qt menus on macOS can be found at [https://doc.qt.io/qt-5/macos-issues.html#menu-bar](https://doc.qt.io/qt-5/macos-issues.html#menu-bar).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 macOS 上的 Qt 菜单的更多信息，请访问[https://doc.qt.io/qt-5/macos-issues.html#menu-bar](https://doc.qt.io/qt-5/macos-issues.html#menu-bar)。
- en: Adding toolbars
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具栏
- en: A **toolbar** is a long row of buttons often used for editing commands or similar
    actions. Unlike main menus, toolbars are not hierarchical and the buttons are
    typically only labeled with an icon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具栏**是一排长按钮，通常用于编辑命令或类似操作。与主菜单不同，工具栏不是分层的，按钮通常只用图标标记。'
- en: '`QMainWindow` allows us to add multiple toolbars to our application using the
    `addToolBar()` method, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMainWindow`允许我们使用`addToolBar()`方法向应用程序添加多个工具栏，就像这样：'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `addToolBar()` method creates and returns a `QToolBar` object. The string
    passed into the method becomes the toolbar's title.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToolBar()`方法创建并返回一个`QToolBar`对象。传递给该方法的字符串成为工具栏的标题。'
- en: 'We can add `QAction` objects much like we can to a `QMenu` object:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像向`QMenu`对象添加`QAction`对象一样添加到`QToolBar`对象中：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just as with a menu, we can add `QAction` objects or just the information to
    build an action (title, callback, and other).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与菜单一样，我们可以添加`QAction`对象，也可以只添加构建操作所需的信息（标题、回调等）。
- en: 'Run the application; it should look something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序；它应该看起来像这样：
- en: '![](assets/f019127f-1cea-4671-84cd-3379db227da6.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f019127f-1cea-4671-84cd-3379db227da6.png)'
- en: Note that the title of the toolbar is not displayed on it. However, if you right-click
    the toolbar area, you'll see a pop-up menu containing all the toolbar titles with
    checkboxes that allow you to show or hide any of the application's toolbars.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，工具栏的标题不会显示在工具栏上。但是，如果右键单击工具栏区域，您将看到一个弹出菜单，其中包含所有工具栏标题，带有复选框，允许您显示或隐藏应用程序的任何工具栏。
- en: 'By default, toolbars can be torn from the application and left floating or
    docked to any of the four edges of the application. This can be disabled by setting
    the `movable` and `floatable` properties to `False`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工具栏可以从应用程序中拆下并悬浮，或者停靠到应用程序的四个边缘中的任何一个。可以通过将`movable`和`floatable`属性设置为`False`来禁用此功能：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can also restrict the sides of the window to which the bar can be docked
    by setting its `allowedAreas` property to a combination of flags from the `QtCore.Qt.QToolBarAreas`
    enum.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将其`allowedAreas`属性设置为来自`QtCore.Qt.QToolBarAreas`枚举的标志组合，限制窗口的哪些边可以停靠该工具栏。
- en: 'For example, let''s restrict our toolbar to the top and bottom areas only:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将工具栏限制为仅限于顶部和底部区域：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our toolbar currently has text-labeled buttons, but normally a toolbar would
    have icon-labeled buttons. To show how that works, we'll need some icons.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具栏当前具有带文本标签的按钮，但通常工具栏会有带图标标签的按钮。为了演示它的工作原理，我们需要一些图标。
- en: 'We can extract some icons from the built-in style, like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从内置样式中提取一些图标，就像这样：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Don't worry about how this code works right now; a complete discussion of styles
    and icons will come along in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*. For now, just understand that `open_icon` and `save_icon`
    are `QIcon` objects, which is how Qt handles icons.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心这段代码的工作原理；有关样式和图标的完整讨论将在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)
    *Qt 应用程序的样式* 中进行。现在只需了解`open_icon`和`save_icon`是`QIcon`对象，这是 Qt 处理图标的方式。
- en: 'These can be attached to our `QAction` objects, which can be then attached
    to the toolbar, like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以附加到我们的`QAction`对象，然后可以将它们附加到工具栏，就像这样：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, that looks a bit better:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这看起来好多了：
- en: '![](assets/7b1be327-2b73-4735-a461-fc53946a9f16.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7b1be327-2b73-4735-a461-fc53946a9f16.png)'
- en: Notice when you run this that the File | Open option in the menu also now has
    an icon. Because both use the `open_action` object, any changes we make to that
    action object will carry to all uses of the object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当您运行此代码时，菜单中的文件 | 打开选项现在也有图标。因为两者都使用`open_action`对象，我们对该操作对象所做的任何更改都将传递到对象的所有使用中。
- en: 'Icon objects can be passed into the toolbar''s `addAction` method as the first
    argument, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图标对象可以作为第一个参数传递给工具栏的`addAction`方法，就像这样：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This adds a Save action to the toolbar with an icon and a rather useless callback.
    Notice that this time, the File | Save action in the menu did not get an icon;
    despite the fact that we used the same label text, calling `addAction()` with
    discrete arguments in both places results in two distinct and unrelated `QAction`
    objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在工具栏中添加一个带有图标和一个相当无用的回调的保存操作。请注意，这一次，菜单中的文件 | 保存操作没有图标；尽管我们使用了相同的标签文本，在两个地方分别调用`addAction()`会导致两个不同且不相关的`QAction`对象。
- en: 'Finally, just like with the menu, we can create `QAction` objects explicitly
    and add them to the toolbar, like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像菜单一样，我们可以显式创建`QAction`对象，并将它们添加到工具栏中，就像这样：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To synchronize actions across multiple action containers (toolbars, menus, and
    so on), either explicitly create `QAction` objects or save the references returned
    from `addAction()` to make sure you're adding the same action objects in each
    case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个操作容器（工具栏、菜单等）之间同步操作，可以显式创建`QAction`对象，或者保存从`addAction()`返回的引用，以确保在每种情况下都添加相同的操作对象。
- en: 'We can add as many toolbars as we wish to our application and attach them to
    whichever side of the application we wish. To specify a side, we have to use an
    alternative form of `addToolBar()`, like so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向应用程序添加任意数量的工具栏，并将它们附加到应用程序的任何一侧。要指定一侧，我们必须使用`addToolBar()`的另一种形式，就像这样：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To use this form of `addToolBar()`, we have to create the toolbar first then
    pass it in along with a `QtCore.Qt.ToolBarArea` constant.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种形式的`addToolBar()`，我们必须首先创建工具栏，然后将其与`QtCore.Qt.ToolBarArea`常量一起传递。
- en: Adding dock widgets
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加停靠窗口
- en: '**Dock widgets** are similar to toolbars, but they sit between the toolbar
    areas and the central widget and are able to contain any kind of widget.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**停靠窗口**类似于工具栏，但它们位于工具栏区域和中央窗口之间，并且能够包含任何类型的小部件。'
- en: 'Adding a dock widget is much like explicitly creating a toolbar:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个停靠窗口就像显式创建一个工具栏一样：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like toolbars, dock widgets by default can be closed, floated, or moved to another
    side of the application. To change whether a dock widget can be closed, floated,
    or moved, we have to set its `features` property to a combination of `QDockWidget.DockWidgetFeatures`
    flag values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与工具栏一样，默认情况下，停靠窗口可以关闭，浮动或移动到应用程序的另一侧。要更改停靠窗口是否可以关闭，浮动或移动，我们必须将其`features`属性设置为`QDockWidget.DockWidgetFeatures`标志值的组合。
- en: 'For instance, let''s make it so the user cannot close our dock widget, by adding
    this code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用户无法关闭我们的停靠窗口，通过添加以下代码：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've set `features` to `DockWidgetMovable` and `DockWidgetFloatable`. Since
    `DockWidgetClosable` is missing here, the user won't be able to close the widget.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`features`设置为`DockWidgetMovable`和`DockWidgetFloatable`。由于这里缺少`DockWidgetClosable`，用户将无法关闭小部件。
- en: The dock widget is designed to hold a single widget that is set using the `setWidget()`
    method. As with our main application's `centralWidget`, we typically will set
    this to a `QWidget` containing some kind of form or other GUI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 停靠窗口设计为容纳使用`setWidget()`方法设置的单个小部件。与我们主应用程序的`centralWidget`一样，我们通常会将其设置为包含某种表单或其他GUI的`QWidget`。
- en: 'Let''s build a form to place in the dock widget, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个表单放在停靠窗口中，如下所示：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `addStretch()` method can be called on a layout to add an expanding `QWidget`
    that pushes the other widgets together.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`addStretch()`方法可以在布局上调用，以添加一个扩展的`QWidget`，将其他小部件推在一起。'
- en: 'This is a fairly simple form containing two `QLineEdit` widgets and a button.
    When the button is clicked, it calls the main window''s `search_and_replace()`
    method. Let''s code that quickly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的表单，包含两个`QLineEdit`小部件和一个按钮。当点击按钮时，它调用主窗口的`search_and_replace()`方法。让我们快速编写代码：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method simply retrieves the contents of the two-line edits; then, if there
    is content in the first, it replaces all instances of the first text with the
    second in the text edit's contents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法只是检索两行编辑的内容；然后，如果第一个中有内容，它将在文本编辑的内容中用第二个文本替换所有实例。
- en: 'Run the program at this point and you should see our dock widget on the left
    side of the application, like so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此时运行程序，您应该在应用程序的左侧看到我们的停靠窗口，如下所示：
- en: '![](assets/755c0898-64be-465f-8532-8db0e1916875.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/755c0898-64be-465f-8532-8db0e1916875.png)'
- en: Note the icon in the upper right of the dock widget. This allows the user to
    detach and float the widget outside the application window.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意停靠窗口右上角的图标。这允许用户将小部件分离并浮动到应用程序窗口之外。
- en: Other QMainWindow features
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他`QMainWindow`功能
- en: Although we've covered its main components, the `QMainWindow` offers many other
    features and configuration options that you can explore in its documentation at
    [https://doc.qt.io/qt-5/qmainwindow.html](https://doc.qt.io/qt-5/qmainwindow.html).
    We may touch on some of these in future chapters, as we will make extensive use
    of `QMainWindow` from here onward.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经涵盖了它的主要组件，但`QMainWindow`提供了许多其他功能和配置选项，您可以在其文档中探索这些选项[https://doc.qt.io/qt-5/qmainwindow.html](https://doc.qt.io/qt-5/qmainwindow.html)。我们可能会在未来的章节中涉及其中一些，因为我们将从现在开始广泛使用`QMainWindow`。
- en: Standard dialog boxes
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准对话框
- en: '**Dialog boxes** are commonly required in applications, whether to ask a question,
    present a form or merely alert the user to some information. Qt provides a wide
    variety of ready-made dialog boxes for common situations, as well as the capability
    to define custom dialog boxes of our own. In this section, we''ll look at some
    of the more commonly used dialog box classes and take a stab at designing our
    own.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**对话框**在应用程序中通常是必需的，无论是询问问题，呈现表单还是仅向用户提供一些信息。Qt提供了各种各样的现成对话框，用于常见情况，以及定义自定义对话框的能力。在本节中，我们将看一些常用的对话框类，并尝试设计自己的对话框。'
- en: QMessageBox
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QMessageBox
- en: '`QMessageBox` is a simple dialog box used mainly to display short messages
    or ask yes-or-no questions. The simplest way to use `QMessageBox` is to take advantage
    of its convenient static methods, which create and show a dialog box with minimal
    fuss.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMessageBox`是一个简单的对话框，主要用于显示短消息或询问是或否的问题。使用`QMessageBox`的最简单方法是利用其方便的静态方法，这些方法可以创建并显示一个对话框，而不需要太多麻烦。'
- en: 'The six static methods are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 六个静态方法如下：
- en: '| Function | Type | Dialog |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 类型 | 对话框 |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `about()` | Modeless | Shows an **About** dialog box for your application
    with the given text. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `about()` | 非模态 | 显示应用程序的**关于**对话框，并提供给定的文本。|'
- en: '| `aboutQt()` | Modeless | Shows an **About** dialog box for Qt. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `aboutQt()` | 非模态 | 显示Qt的**关于**对话框。|'
- en: '| `critical()` | Modal | Show a critical error message with the provided text.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `critical()` | 模态 | 显示带有提供的文本的关键错误消息。|'
- en: '| `information()` | Modal | Show an informational message with the provided
    text. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `information()` | 模态 | 显示带有提供的文本的信息消息。|'
- en: '| `warning()` | Modal | Show a warning message with the provided text. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `warning()` | 模态 | 显示带有提供的文本的警告消息。|'
- en: '| `question()` | Modal | Asks the user a question. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `question()` | 模态 | 向用户提问。|'
- en: The main difference between most of these boxes are the default icons, the default
    buttons, and the modality of the dialog.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对话框之间的主要区别在于默认图标，默认按钮和对话框的模态性。
- en: Dialog boxes can be either **modal** or **modeless**. Modal dialog boxes prevent
    the user from interacting with any other part of the program and block program
    execution while displayed, and they can return a value when finished. Modeless
    dialog boxes do not block execution, but they also do not return a value. In the
    case of a modal `QMessageBox`, the return value is an `enum` constant representing
    the button pressed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框可以是**模态**的，也可以是**非模态**的。模态对话框阻止用户与程序的任何其他部分进行交互，并在显示时阻止程序执行，并且在完成时可以返回一个值。非模态对话框不会阻止执行，但它们也不会返回值。在模态`QMessageBox`的情况下，返回值是表示按下的按钮的`enum`常量。
- en: 'Let''s use the `about()` method to add an **About** message to our application.
    First, we''ll create a callback to display the dialog:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`about()`方法向我们的应用程序添加一个**关于**消息。首先，我们将创建一个回调来显示对话框：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The **About** dialog is modeless, so it's really just a way to display information
    passively. The arguments are, in order, the dialog's parent widget, the dialog's
    window title text, and the dialog's main text.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于**对话框是非模态的，因此它实际上只是一种被动显示信息的方式。参数依次是对话框的父窗口小部件，对话框的窗口标题文本和对话框的主要文本。'
- en: 'Back in the constructor, let''s add a menu action to call this method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回到构造函数，让我们添加一个菜单操作来调用这个方法：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Modal dialog boxes can be used to retrieve a response from the user. For instance,
    we could warn the user about the unfinished nature of our editor and see whether
    they are really intent on using it, like so:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 模态对话框可用于从用户那里检索响应。例如，我们可以警告用户我们的编辑器尚未完成，并查看他们是否真的打算使用它，如下所示：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All modal dialog boxes return a Qt constant corresponding to the button the
    user pushed; by default, `question()` creates a dialog box with the `QMessageBox.Yes`
    and `QMessageBox.No` button values so we can test the response and react accordingly.
    The buttons presented can also be overridden by passing in a fourth argument containing
    multiple buttons combined with the pipe operator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模态对话框都返回与用户按下的按钮相对应的Qt常量；默认情况下，`question()`创建一个带有`QMessageBox.Yes`和`QMessageBox.No`按钮值的对话框，因此我们可以测试响应并做出相应的反应。还可以通过传入第四个参数来覆盖呈现的按钮，该参数包含使用管道运算符组合的多个按钮。
- en: 'For example, we can change `No` to `Abort`, like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将`No`更改为`Abort`，如下所示：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the static `QMessageBox` methods do not provide enough flexibility, you
    can also explicitly create a `QMessageBox` object, like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态的`QMessageBox`方法不提供足够的灵活性，还可以显式创建`QMessageBox`对象，如下所示：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, we can set quite a few properties on the message box; these
    are described here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以在消息框上设置相当多的属性；这些在这里描述：
- en: '| Property | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `windowTitle` | The title printed in the taskbar and title bar of the dialog.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `windowTitle` | 对话框任务栏和标题栏中打印的标题。 |'
- en: '| `text` | The text displayed in the dialog. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 对话框中显示的文本。 |'
- en: '| `informativeText` | A longer, explanatory piece of text displayed under the
    `text` string often displayed in a smaller or lighter font face. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `informativeText` | 在`text`字符串下显示的较长的解释性文本，通常以较小或较轻的字体显示。 |'
- en: '| `detailedText` | Text that will be hidden behind a Show details button and
    displayed in a scrolling textbox. Useful for debugging or log output. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `detailedText` | 将隐藏在“显示详细信息”按钮后面并显示在滚动文本框中的文本。用于调试或日志输出。 |'
- en: '| `windowModality` | Used to set whether the message box is modal or modeless.
    Requires a `QtCore.Qt.WindowModality` constant. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `windowModality` | 用于设置消息框是模态还是非模态。需要一个`QtCore.Qt.WindowModality`常量。 |'
- en: We can also add any number of buttons to the dialog box using the `addButton()`
    method and then display the dialog box by calling its `exec()` method. If we configured
    the dialog box to be modal, this method will return the constant matching the
    button that was clicked.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`addButton()`方法向对话框添加任意数量的按钮，然后通过调用其`exec()`方法显示对话框。如果我们配置对话框为模态，此方法将返回与单击的按钮匹配的常量。
- en: QFileDialog
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QFileDialog
- en: Applications commonly need to open or save files, and users need an easy way
    to browse and select those files. Qt provides us with the `QFileDialog` class
    to meet this need.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常需要打开或保存文件，用户需要一种简单的方法来浏览和选择这些文件。 Qt为我们提供了`QFileDialog`类来满足这种需求。
- en: Just as with `QMessageBox`, the `QFileDialog` class contains several static
    methods that display an appropriate modal dialog box and return the value selected
    by the user.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与`QMessageBox`一样，`QFileDialog`类包含几个静态方法，显示适当的模态对话框并返回用户选择的值。
- en: 'This table shows the static methods and their intended use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了静态方法及其预期用途：
- en: '| Method | Returns | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 返回 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `getExistingDirectory` | String | Select an existing directory path. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `getExistingDirectory` | String | 选择现有目录路径。 |'
- en: '| `getExistingDirectoryUrl` | `QUrl` | Select an existing directory URL. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `getExistingDirectoryUrl` | `QUrl` | 选择现有目录URL。 |'
- en: '| `getOpenFileName` | String | Select an existing filename path to open. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `getOpenFileName` | String | 选择要打开的现有文件名路径。 |'
- en: '| `getOpenFileNames` | List | Select multiple existing filename paths to open.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `getOpenFileNames` | List | 选择多个现有文件名路径以打开。 |'
- en: '| `getOpenFileUrl` | `QUrl` | Select an existing filename URL. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `getOpenFileUrl` | `QUrl` | 选择现有文件名URL。 |'
- en: '| `getSaveFileName` | String | Select a new or existing filename path to save
    to. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `getSaveFileName` | String | 选择要保存到的新文件名路径或现有文件名路径。 |'
- en: '| `getSaveFileUrl` | `QUrl` | Select a new or existing URL. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `getSaveFileUrl` | `QUrl` | 选择新的或现有的URL。 |'
- en: On platforms that support it, the URL versions of these methods allow for selecting
    remote files and directories.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的平台上，这些方法的URL版本允许选择远程文件和目录。
- en: 'To see how file dialog boxes work, let''s create the ability to open a file
    in our application:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解文件对话框的工作原理，让我们在应用程序中创建打开文件的能力：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`getOpenFileName()` returns a tuple containing the filename selected and the
    selected file type filter. If the user cancels the dialog, an empty string is
    returned for the filename, and our method will exit. If we receive a filename,
    we attempt to open the file and write into it the contents of our `textedit` widget.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOpenFileName()`返回一个包含所选文件名和所选文件类型过滤器的元组。如果用户取消对话框，将返回一个空字符串作为文件名，并且我们的方法将退出。如果我们收到一个文件名，我们尝试打开文件并将`textedit`小部件的内容写入其中。'
- en: Since we aren't using the second value returned from the method, we're assigning
    it to the `_` (underscore) variable. This is a standard Python convention for
    naming variables you don't intend to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用方法返回的第二个值，我们将其分配给`_`（下划线）变量。这是命名不打算使用的变量的标准Python约定。
- en: '`getOpenFileName()` has a number of arguments for configuring the dialog, all
    of which are optional. In order, they are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOpenFileName()`有许多用于配置对话框的参数，所有这些参数都是可选的。按顺序，它们如下：'
- en: The parent widget
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父窗口小部件
- en: The caption, used in the window title
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题，用于窗口标题
- en: The starting directory, as a path string
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 起始目录，作为路径字符串
- en: The filters available for the file type filter dropdown
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件类型过滤器下拉菜单可用的过滤器
- en: The default selected filter
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认选择的过滤器
- en: Option flags
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选项标志
- en: 'For example, let''s configure our file dialog:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们配置我们的文件对话框：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`QDir.homePath()` is a static method that returns the user''s home directory.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDir.homePath()`是一个返回用户主目录的静态方法。'
- en: 'Notice that the filters are specified as a single string; each filter is a
    description plus a wildcard string in parenthesis, and the filters are separated
    by double semi-colons. This results in a filter dropdown that looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，过滤器被指定为单个字符串；每个过滤器都是一个描述加上括号内的通配符字符串，并且过滤器之间用双分号分隔。这将导致一个看起来像这样的过滤器下拉菜单：
- en: '![](assets/cf80d69c-0bbc-402c-8a6b-ec719c7d9afe.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf80d69c-0bbc-402c-8a6b-ec719c7d9afe.png)'
- en: Last, of all, we can specify a collection of option flags combined using the
    pipe operator. In this case, we're telling Qt not to use the native OS file dialog
    boxes and not to resolve symbolic links (both of which it does by default). See
    the `QFileDialog` documentation at [https://doc.qt.io/qt-5/qfiledialog.html#Option-enum](https://doc.qt.io/qt-5/qfiledialog.html#Option-enum)
    for a complete list of option flags.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用管道运算符组合一系列选项标志。在这种情况下，我们告诉Qt不要使用本机OS文件对话框，也不要解析符号链接（这两者都是默认情况下）。有关选项标志的完整列表，请参阅`QFileDialog`文档[https://doc.qt.io/qt-5/qfiledialog.html#Option-enum](https://doc.qt.io/qt-5/qfiledialog.html#Option-enum)。
- en: 'The save file dialog box works much the same way but provides an interface
    more appropriate for saving a file. We can implement our `saveFile()` method as
    follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件对话框的工作方式基本相同，但提供了更适合保存文件的界面。我们可以实现我们的`saveFile()`方法如下：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Other `QFileDialog` convenience methods work the same way. As with `QMessageBox`,
    it's also possible to explicitly create a `QFileDialog` object, configure its
    properties manually, and then display it with its `exec()` method. However, this
    is rarely necessary as the built-in methods are adequate for most file-selection
    situations.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其他`QFileDialog`便利方法的工作方式相同。与`QMessageBox`一样，也可以显式创建一个`QFileDialog`对象，手动配置其属性，然后使用其`exec()`方法显示它。然而，这很少是必要的，因为内置方法对大多数文件选择情况都是足够的。
- en: 'Before moving on, don''t forget to add actions to call these methods back in
    the `MainWindow` constructor:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，不要忘记在`MainWindow`构造函数中添加调用这些方法的操作：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: QFontDialog
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QFontDialog
- en: Qt provides a number of other convenient selection dialog boxes similar to the
    `QFileDialog`; one such dialog box is the `QFontDialog`, which allows users to
    select and configure various aspects of a text font.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了许多其他方便的选择对话框，类似于`QFileDialog`；其中一个对话框是`QFontDialog`，允许用户选择和配置文本字体的各个方面。
- en: Like the other dialog box classes, this is most easily used by calling a static
    method to display the dialog box and return the user's selection, in this case,
    the `getFont()` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他对话框类一样，最简单的方法是调用静态方法显示对话框并返回用户的选择，这种情况下是`getFont()`方法。
- en: 'Let''s add a callback method to our `MainWindow` class to set the editor font:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`MainWindow`类中添加一个回调方法来设置编辑器字体：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`getFont` takes the current font as an argument, which allows it to set the
    selected font to whatever is current (if you neglect to do this, the dialog box
    will default to the first font listed).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFont`以当前字体作为参数，这使得它将所选字体设置为当前字体（如果您忽略这一点，对话框将默认为列出的第一个字体）。'
- en: It returns a tuple containing the selected font and a Boolean indicating whether
    the user clicked OK. The font is returned as a `QFont` object, which encapsulates
    not only the font family but also the style, size, effects, and writing system
    of the font. Our method can pass this object back to the `QTextEdit` object's
    `setCurrentFont()` slot to set its font.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含所选字体和一个布尔值的元组，指示用户是否点击了确定。字体作为`QFont`对象返回，该对象封装了字体系列、样式、大小、效果和字体的书写系统。我们的方法可以将此对象传回到`QTextEdit`对象的`setCurrentFont()`槽中，以设置其字体。
- en: 'As with `QFileDialog`, Qt tries to use the operating system''s native font
    dialog box if it has one; otherwise, it will use its own widget. You can force
    it to use the Qt version of the dialog box by passing in the `DontUseNativeDialog`
    option to the `options` keyword argument, as we''ve done here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与`QFileDialog`一样，如果操作系统有原生字体对话框，Qt会尝试使用它；否则，它将使用自己的小部件。您可以通过将`DontUseNativeDialog`选项传递给`options`关键字参数来强制使用对话框的Qt版本，就像我们在这里做的那样：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We've also passed in an option here to limit the dialog box to mono-spaced fonts.
    See the Qt documentation on `QFontDialog` at [https://doc.qt.io/qt-5/qfontdialog.html#FontDialogOption-enum](https://doc.qt.io/qt-5/qfontdialog.html#FontDialogOption-enum)
    for more information about the available options.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里传入了一个选项，以限制对话框为等宽字体。有关可用选项的更多信息，请参阅`QFontDialog`的Qt文档[https://doc.qt.io/qt-5/qfontdialog.html#FontDialogOption-enum](https://doc.qt.io/qt-5/qfontdialog.html#FontDialogOption-enum)。
- en: Other dialog boxes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他对话框
- en: Qt contains other dialog box classes for selecting colors, requesting input
    values, and more. All of these work more or less like the file and font dialog
    boxes, and they descend from the `QDialog` class. We can subclass `QDialog` ourselves
    to create a custom dialog box.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Qt包含其他对话框类，用于选择颜色、请求输入值等。所有这些类似于文件和字体对话框，它们都是`QDialog`类的子类。我们可以自己子类化`QDialog`来创建自定义对话框。
- en: 'For example, suppose we want to have a dialog box for entering our settings.
    We could start building it like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要一个对话框来输入我们的设置。我们可以像这样开始构建它：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code isn''t far removed from pop-up boxes we''ve made in past chapters
    using `QWidget`. However, by using `QDialog` we get a few things for free, namely
    these:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在过去章节中使用`QWidget`创建的弹出框并没有太大的区别。然而，通过使用`QDialog`，我们可以免费获得一些东西，特别是这些：
- en: We get `accept` and `reject` slots to which we can connect the appropriate buttons.
    By default, these cause the window to close and emit either an `accepted` or `rejected`
    signal respectively.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获得了`accept`和`reject`插槽，可以将适当的按钮连接到这些插槽。默认情况下，这些会导致窗口关闭并分别发出`accepted`或`rejected`信号。
- en: We also get the `exec()` method that returns a Boolean value indicating whether
    the dialog box was accepted or rejected.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`exec()`方法，该方法返回一个布尔值，指示对话框是被接受还是被拒绝。
- en: We can easily set the dialog box to be modal or modeless, by passing the appropriate
    values to the `super()` constructor.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过向`super()`构造函数传递适当的值来轻松设置对话框为模态或非模态。
- en: '`QDialog` gives us a lot of flexibility on how to make use of the data entered
    by the user. We could use a signal to emit the data or override `exec()` to return
    the data, for instance.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDialog`为我们提供了很多灵活性，可以让我们如何利用用户输入的数据。例如，我们可以使用信号来发射数据，或者重写`exec()`来返回数据。'
- en: 'In this case, since we''re passing in a mutable `dict` object, we''ll override
    `accept()` to alter that `dict` object:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们传入了一个可变的`dict`对象，我们将重写`accept()`来修改那个`dict`对象：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Back in the `MainWindow` class, let''s create a property and method to use
    the new dialog:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow`类，让我们创建一个属性和方法来使用新的对话框：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using a `QDialog` class is as simple as creating an instance of the dialog box
    class and calling `exec()`. Since we're editing our `settings` dict directly,
    in this case, we don't need to worry about connecting the `accepted` signal or
    using the output of `exec()`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QDialog`类就像创建对话框类的实例并调用`exec()`一样简单。在这种情况下，由于我们直接编辑我们的`settings` dict，所以我们不需要担心连接`accepted`信号或使用`exec()`的输出。
- en: Saving settings with QSettings
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QSettings保存设置
- en: Applications of any reasonable size are likely to accumulate settings that need
    to be stored between sessions. Saving these settings usually involves a lot of
    tedious work with file operations and data serialization, and becomes even more
    complex when we want to do it in a way that works well across platforms. Qt rescues
    us from this work with its `QtCore.QSettings` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合理大小的应用程序都可能积累需要在会话之间存储的设置。保存这些设置通常涉及大量繁琐的文件操作和数据序列化工作，当我们希望跨平台良好地工作时，这种工作变得更加复杂。Qt的`QtCore.QSettings`类解救了我们。
- en: The `QSettings` class is a simple key-value data store that is automatically
    persisted in a platform-appropriate way. For example, on Windows, the settings
    are stored in the registry database, while on Linux they are placed in a plain-text
    configuration file under `~/.config`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSettings`类是一个简单的键值数据存储，会以平台适当的方式自动持久化。例如，在Windows上，设置存储在注册表数据库中，而在Linux上，它们被放置在`~/.config`下的纯文本配置文件中。'
- en: Let's replace the settings `dict` object we created in our text editor with
    a `QSettings` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`QSettings`对象替换我们在文本编辑器中创建的设置`dict`对象。
- en: 'To create a `QSettings` object, we need to pass in a company name and application
    name, like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`QSettings`对象，我们需要传入公司名称和应用程序名称，就像这样：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These strings will determine the registry key or file path where the settings
    will be stored. On Linux, for example, this settings file will be saved at `~/.config/Alan
    D Moore/text editor.conf`. On Windows, it will be stored in the registry at `HKEY_CURRENT_USER\Alan
    D Moore\text editor\`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串将确定存储设置的注册表键或文件路径。例如，在Linux上，此设置文件将保存在`~/.config/Alan D Moore/text editor.conf`。在Windows上，它将存储在注册表中的`HKEY_CURRENT_USER\Alan
    D Moore\text editor\`。
- en: 'We can query the value of any setting using the object''s `value()` method;
    for instance, we can make our startup warning dialog boxes conditional on the
    `show _warnings` setting:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用对象的`value()`方法查询任何设置的值；例如，我们可以根据`show_warnings`设置使我们的启动警告对话框成为有条件的：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The arguments to `value()` are the key string, the default value if the key
    is not found, and the `type` keyword argument, which tells `QSettings` how to
    interpret the saved value. The `type` argument is crucial; not all platforms can
    adequately represent all data types in an unambiguous way. Boolean values, for
    instance, are returned as the strings `true` and `false` if the data type is not
    specified, both of which are `True` in Python.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`value()`的参数是键字符串、如果未找到键则是默认值，以及`type`关键字参数，告诉`QSettings`如何解释保存的值。`type`参数至关重要；并非所有平台都能以明确的方式充分表示所有数据类型。例如，如果未指定数据类型，则布尔值将作为字符串`true`和`false`返回，这两者在Python中都是`True`。'
- en: 'Setting the value of a key uses the `setValue()` method, as shown here in the
    `SettingsDialog.accept()` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 设置键的值使用`setValue()`方法，就像在`SettingsDialog.accept()`方法中所示的那样：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we don't have to do anything to store these values to disk; they are
    automatically synced to disk periodically by the Qt event loop. They are also
    read automatically from disk the moment the `QSettings` object is created. Simply
    replacing our original `settings` dict with a `QSettings` object is enough to
    give us persistent settings without writing a single line of file I/O code!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不必做任何事情将这些值存储到磁盘上；它们会被Qt事件循环定期自动同步到磁盘上。它们也会在创建`QSettings`对象的时候自动从磁盘上读取。简单地用`QSettings`对象替换我们原来的`settings`
    dict就足以让我们获得持久的设置，而无需编写一行文件I/O代码！
- en: Limitations of QSettings
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSettings的限制
- en: As powerful as they are, `QSettings` objects can't store just anything. All
    values in the settings object are stored as `QVariant` objects, so only objects
    that can be cast to `QVariant` can be stored. This encompasses a long list of
    types, including nearly any Python built-in type and most of the data classes
    from `QtCore`. Even function references can be stored (though not the function
    definitions).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们很强大，`QSettings`对象不能存储任何东西。设置对象中的所有值都存储为`QVariant`对象，因此只有可以转换为`QVariant`的对象才能存储。这包括了一个长列表的类型，包括几乎任何Python内置类型和`QtCore`中的大多数数据类。甚至函数引用也可以被存储（尽管不是函数定义）。
- en: 'Unfortunately, in the event that you try to store an object that cannot be
    properly stored, `QSettings.setValue()` will neither throw an exception or return
    an error. It will print a warning to the console and store something that will
    likely not be useful, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你尝试存储一个无法正确存储的对象，`QSettings.setValue()`既不会抛出异常也不会返回错误。它会在控制台打印警告并存储一些可能不会有用的东西，例如：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In general, if you're storing objects that clearly represent data, you shouldn't
    have problems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你正在存储清晰表示数据的对象，你不应该遇到问题。
- en: The other major limitation of the `QSettings` object is its inability to automatically
    identify the data type of some stored objects, as we saw with our Boolean value.
    For this reason, it's critical to pass a `type` argument when dealing with anything
    that is not a string value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSettings`对象的另一个主要限制是它无法自动识别一些存储对象的数据类型，就像我们在布尔值中看到的那样。因此，在处理任何不是字符串值的东西时，传递`type`参数是至关重要的。'
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about PyQt classes that help construct complete
    applications. You learned about the `QMainWindow` class, its menus, status bar,
    toolbars, and dock widgets. You also learned about standard dialog boxes and message
    boxes derived from `QDialog`, and how to store application settings with `QSettings`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了有助于构建完整应用程序的PyQt类。你学习了`QMainWindow`类，它的菜单、状态栏、工具栏和停靠窗口。你还学习了从`QDialog`派生的标准对话框和消息框，以及如何使用`QSettings`存储应用程序设置。
- en: In the next chapter, we'll learn about the model-view classes in Qt, which will
    help us separate our concerns and create more robust application designs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Qt中的模型-视图类，这将帮助我们分离关注点并创建更健壮的应用程序设计。
- en: Questions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你从本章中学到的知识：
- en: You want to use `QMainWindow` with the `calendar_app.py` script from [Chapter
    3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling Events with Signals
    and Slots*. How would you go about converting it?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想要使用`QMainWindow`与[第3章](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml)中的`calendar_app.py`脚本，*使用信号和槽处理事件*。你会如何进行转换？
- en: You're working on an app and have added the submenu names to the menu bar but
    not populated any of them with items. Your coworker says that none of the menu
    names are appearing on his desktop when they test it. Your code looks correct;
    what is probably going on here?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在开发一个应用程序，并将子菜单名称添加到菜单栏，但没有填充任何子菜单项。你的同事说在他们测试时，他们的桌面上没有出现任何菜单名称。你的代码看起来是正确的；这里可能出了什么问题？
- en: You're developing a code editor and want to create a sidebar panel for interacting
    with a debugger. Which `QMainWindow` feature would be most appropriate for this
    task?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在开发一个代码编辑器，并希望为与调试器交互创建一个侧边栏面板。哪个`QMainWindow`特性对这个任务最合适？
- en: The following code isn't working correctly; it proceeds no matter what is clicked.
    Why doesn't it work, and how do you fix it?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码不正确；无论点击什么都会继续进行。为什么它不起作用，你该如何修复它？
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You're building a custom dialog box by subclassing `QDialog`. You need to get
    information entered into the dialog box back to the main window object. Which
    of these approaches will not work?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在通过子类化`QDialog`来构建一个自定义对话框。你需要将输入到对话框中的信息传回主窗口对象。以下哪种方法将不起作用？
- en: Pass in a mutable object and use the dialog's `accept()` method to alter its
    values.
  id: totrans-244
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传入一个可变对象，并使用对话框的`accept()`方法来更改其值。
- en: Override the objects `accept()` method and have it `return` a dict of the entered
    values.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写对象的`accept()`方法，并让它返回输入值的字典。
- en: Override the dialog's `accepted` signal with one that passes along a dict of
    the entered values. Connect this signal to a callback in your main window class.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写对话框的`accepted`信号，使其传递输入值的字典。将此信号连接到主窗口类中的回调函数。
- en: 'You''re writing a photo editor called **SuperPhoto** on Linux. You''ve written
    the code and saved the user settings, but looking in `~/.config/` you can''t find
    `SuperPhoto.conf`. Look at the code and determine what went wrong:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在Linux上编写一个名为**SuperPhoto**的照片编辑器。你已经编写了代码并保存了用户设置，但在`~/.config/`中找不到`SuperPhoto.conf`。查看代码并确定出了什么问题：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You're saving preferences from a settings dialog, but for some reason, the settings
    being saved are coming back very strangely. What is wrong here?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在从设置对话框保存偏好设置，但由于某种原因，保存的设置回来的时候非常奇怪。这里有什么问题？
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Further reading
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下内容：
- en: Qt's `QMainWindow` documentation can be found at [https://doc.qt.io/qt-5/qmainwindow.html](https://doc.qt.io/qt-5/qmainwindow.html).
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt的`QMainWindow`文档可以在[https://doc.qt.io/qt-5/qmainwindow.html](https://doc.qt.io/qt-5/qmainwindow.html)找到。
- en: Examples of using `QMainWindow` can be found at [https://github.com/pyqt/examples/tree/master/mainwindows](https://github.com/pyqt/examples/tree/master/mainwindows).
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QMainWindow`的示例可以在[https://github.com/pyqt/examples/tree/master/mainwindows](https://github.com/pyqt/examples/tree/master/mainwindows)找到。
- en: Apple's Human Interface Guidelines for macOS include guidance on how to structure
    the application menus. These can be found at [https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-anatomy/](https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-anatomy/).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果的macOS人机界面指南包括如何构建应用程序菜单的指导。这些可以在[https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-anatomy/](https://developer.apple.com/design/human-interface-guidelines/macos/menus/menu-anatomy/)找到。
- en: Microsoft offers guidance for designing menus for Windows applications at [https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-menus](https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-menus).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软提供了有关为Windows应用程序设计菜单的指南，网址为[https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-menus](https://docs.microsoft.com/en-us/windows/desktop/uxguide/cmd-menus)。
- en: PyQt offers some examples of dialog box usage at [https://github.com/pyqt/examples/tree/master/dialogs](https://github.com/pyqt/examples/tree/master/dialogs).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt提供了一些关于对话框使用的示例，网址为[https://github.com/pyqt/examples/tree/master/dialogs](https://github.com/pyqt/examples/tree/master/dialogs)。
- en: '`QMainWindow` can also be used to create **Multiple Document Interfaces** (**MDIs**).
    For more information on how to build an MDI application, see [https://www.pythonstudio.us/pyqt-programming/multiple-document-interface-mdi.html](https://www.pythonstudio.us/pyqt-programming/multiple-document-interface-mdi.html)
    and the example code at [https://doc.qt.io/qt-5/qtwidgets-mainwindows-mdi-example.html](https://doc.qt.io/qt-5/qtwidgets-mainwindows-mdi-example.html).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMainWindow`也可以用于创建**多文档界面**（**MDIs**）。有关如何构建MDI应用程序的更多信息，请参见[https://www.pythonstudio.us/pyqt-programming/multiple-document-interface-mdi.html](https://www.pythonstudio.us/pyqt-programming/multiple-document-interface-mdi.html)，以及[https://doc.qt.io/qt-5/qtwidgets-mainwindows-mdi-example.html](https://doc.qt.io/qt-5/qtwidgets-mainwindows-mdi-example.html)上的示例代码。'
