- en: Building Network Web Services with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python构建网络Web服务
- en: In the previous chapters, we were a consumer of the APIs provided by various
    tools. In [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs and Intent-Driven
    Networking,* we saw that we can use a `HTTP POST` method to NX-API at the `http://<your
    router ip>/ins` URL with the `CLI` command embedded in the body to execute commands
    remotely on the Cisco Nexus device; the device then returns the command execution
    output in return. In [Chapter 8](5f7e76ef-d93a-4689-8054-8be72d41d69b.xhtml),
    *Network Monitoring with Python – Part 2,* we used the `GET` method for our sFlow-RT
    at `http://<your host ip>:8008/version` with an empty body to retrieve the version
    of the sFlow-RT software. These exchanges are examples of RESTful web services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们是各种工具提供的API的消费者。在[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml)中，*API和意图驱动的网络*，我们看到我们可以使用`HTTP
    POST`方法到`http://<your router ip>/ins` URL上的NX-API，其中`CLI`命令嵌入在主体中，以远程执行Cisco Nexus设备上的命令；然后设备返回命令执行输出。在[第8章](5f7e76ef-d93a-4689-8054-8be72d41d69b.xhtml)中，*使用Python进行网络监控-第2部分*，我们使用`GET`方法来获取我们sFlow-RT的`http://<your
    host ip>:8008/version`上的版本，主体为空。这些交换是RESTful Web服务的例子。
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科（[https://en.wikipedia.org/wiki/Representational_state_transfer](https://en.wikipedia.org/wiki/Representational_state_transfer)）：
- en: '"Representational state transfer (REST) or RESTful web services is one way
    of providing interoperability between computer systems on the internet. REST-compliant
    web services allow requesting systems to access and manipulate the textual representation
    of web resources using a uniform and predefined set of stateless operations."'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “表征状态转移（REST）或RESTful Web服务是提供互操作性的一种方式，用于互联网上的计算机系统。符合REST标准的Web服务允许请求系统使用一组统一和预定义的无状态操作来访问和操作Web资源的文本表示。”
- en: As noted, REST web services using the HTTP protocol is only one of many methods
    of information exchange on the web; other forms of web services also exist. However,
    it is the most commonly used web service today, with the associated `GET`, `POST`,
    `PUT`, and `DELETE` verbs as a predefined way of information exchange.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用HTTP协议的REST Web服务只是网络上信息交换的许多方法之一；还存在其他形式的Web服务。然而，它是今天最常用的Web服务，具有相关的`GET`，`POST`，`PUT`和`DELETE`动词作为信息交换的预定义方式。
- en: One of the advantages of using RESTful services is the ability it provides for
    you to hide your internal operations from the user while still providing them
    with the service. For example, in the case of sFlow-RT, if we were to log in to
    the device where our software is installed, we would need more in-depth knowledge
    of the tool to know where to check for the software version. However, by providing
    the resources in the form of a URL, the software abstracts the version-checking
    operations from the requester, making the operation much simpler. The abstraction
    also provides a layer of security, as it can now open up the endpoints only as
    needed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful服务的优势之一是它可以让您隐藏用户对内部操作的了解，同时仍然为他们提供服务。例如，在sFlow-RT的情况下，如果我们要登录安装了我们软件的设备，我们需要更深入地了解工具，才能知道在哪里检查软件版本。然而，通过以URL的形式提供资源，软件将版本检查操作从请求者中抽象出来，使操作变得更简单。抽象还提供了一层安全性，因为现在可以根据需要仅打开端点。
- en: 'As the master of the network universe, RESTful web services provide many notable
    benefits that we can enjoy, such as the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络宇宙的大师，RESTful Web服务提供了许多显着的好处，我们可以享受，例如以下：
- en: You can abstract the requester from learning about the internals of the network
    operations. For example, we can provide a web service to query the switch version
    without the requester having to know the exact CLI command or API format required.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将请求者与网络操作的内部细节分离。例如，我们可以提供一个Web服务来查询交换机版本，而无需请求者知道所需的确切CLI命令或API格式。
- en: We can consolidate and customize operations that uniquely fit our network needs,
    such as a resource to upgrade all our top-of-rack switches.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以整合和定制符合我们网络需求的操作，例如升级所有顶部交换机的资源。
- en: We can provide better security by only exposing the operations as needed. For
    example, we can provide read-only URLs (`GET`) to core network devices and read-write
    URLs (`GET` / `POST` / `PUT` / `DELETE`) to access-level switches.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过仅在需要时公开操作来提供更好的安全性。例如，我们可以为核心网络设备提供只读URL（`GET`），并为访问级别交换机提供读写URL（`GET`
    / `POST` / `PUT` / `DELETE`）。
- en: 'In this chapter, we will use one of the most popular Python web frameworks, **Flask**,
    to create our own REST web service for our network. In this chapter, we will learn
    about the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用最流行的Python Web框架之一**Flask**来为我们的网络创建自己的REST Web服务。在本章中，我们将学习以下内容：
- en: Comparing Python web frameworks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较Python Web框架
- en: Introduction to Flask
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask简介
- en: Operations involving static network contents
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网络内容的操作
- en: Operations involving dynamic network operations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及动态网络操作的操作
- en: Let's get started by looking at the available Python web frameworks and why
    we chose Flask.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看看可用的Python Web框架以及为什么我们选择了Flask。
- en: Comparing Python web frameworks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Python Web框架
- en: 'Python is known for its great many web frameworks. There is a running joke
    at PyCon, which is that you can never work as a full-time Python developer without
    working with any of the Python web frameworks. There is even an annual conference
    held for Django, one of the most popular Python frameworks, called DjangoCon. It
    attracts hundreds of attendees every year. If you sort the Python web frameworks
    on [https://hotframeworks.com/languages/python](https://hotframeworks.com/languages/python),
    you can see that there is no shortage of choices when it comes to Python and web
    frameworks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python以其众多的web框架而闻名。在PyCon上有一个笑话，即你永远不能成为全职Python开发者而不使用任何Python web框架。甚至为Django举办了一年一度的会议，这是最受欢迎的Python框架之一，叫做DjangoCon。每年都吸引数百名与会者。如果你在[https://hotframeworks.com/languages/python](https://hotframeworks.com/languages/python)上对Python
    web框架进行排序，你会发现在Python和web框架方面选择是不缺乏的。
- en: '![](assets/15528b62-5084-4ef6-936e-5f53f2f6faa0.png)Python web frameworks ranking'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/15528b62-5084-4ef6-936e-5f53f2f6faa0.png)Python web框架排名'
- en: With so many options to choose from, which framework should we pick? Clearly,
    trying all the frameworks out yourself would be really time-consuming. The question
    about which web framework is better is also a passionate topic among web developers.
    If you ask this question on any of the forums, such as Quora, or search on Reddit,
    get ready for some highly opinionated answers and heated debates.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多选择，我们应该选择哪个框架呢？显然，自己尝试所有的框架将非常耗时。关于哪个web框架更好的问题也是网页开发者之间的一个热门话题。如果你在任何论坛上问这个问题，比如Quora，或者在Reddit上搜索，准备好接受一些充满个人意见的答案和激烈的辩论。
- en: 'Speaking of Quora and Reddit, here''s an interesting fact: both Quora and Reddit
    were written in Python. Reddit uses Pylons ([https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F](https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F.)),
    while Quora started with Pylons but replaced a portion of the framework with their
    in-house code ([https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora](https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora)).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 说到Quora和Reddit，这里有一个有趣的事实：Quora和Reddit都是用Python编写的。Reddit使用Pylons（[https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F](https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F.)），而Quora最初使用Pylons，但用他们自己的内部代码替换了部分框架（[https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora](https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora)）。
- en: 'Of course, I have my own bias toward programming languages (Python!) and web
    frameworks (Flask!). In this section, I hope to convey to you my reasoning behind
    choosing one over the other. Let''s pick the top two frameworks from the preceding
    HotFrameworks list and compare them:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我对编程语言（Python！）和web框架（Flask！）有自己的偏见。在这一部分，我希望向你传达我选择一个而不是另一个的理由。让我们选择前面HotFrameworks列表中的前两个框架并进行比较：
- en: '**Django**: The self-proclaimed "web framework for perfectionists with deadlines"
    is a high-level Python web framework that encourages rapid development and a clean,
    pragmatic design ([https://www.djangoproject.com/](https://www.djangoproject.com/)).
    It is a large framework with pre-built code that provides an administrative panel
    and built-in content management.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Django**：这个自称为“完美主义者与截止日期的web框架”是一个高级Python web框架，鼓励快速开发和清晰的实用设计（[https://www.djangoproject.com/](https://www.djangoproject.com/)）。它是一个大型框架，提供了预先构建的代码，提供了管理面板和内置内容管理。'
- en: '**Flask**: This is a microframework for Python and is based on Werkzeug, Jinja2,
    and good intentions ([http://flask.pocoo.org/](http://flask.pocoo.org/)). By being
    a microframework, Flask intends on keeping the core small and being easy to extend
    when needed. The "micro" in microframework does not mean that Flask is lacking
    in functionality, nor does it mean it cannot work in a production environment.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flask**：这是一个基于Werkzeug，Jinja2和良好意图的Python微框架（[http://flask.pocoo.org/](http://flask.pocoo.org/)）。作为一个微框架，Flask的目标是保持核心小，需要时易于扩展。微框架中的“微”并不意味着Flask功能不足，也不意味着它不能在生产环境中工作。'
- en: Personally, I find Django a bit difficult to extend, and most of the time, I
    only use a fraction of the pre-built code. The Django framework also has a strong
    opinion on how things should be done; any deviation from it would sometimes leave
    the user feeling that they are "fighting with the framework". For example, if
    you look at the Django Database documentation, ([https://docs.djangoproject.com/en/2.1/ref/databases/](https://docs.djangoproject.com/en/2.1/ref/databases/)),
    you will notice that the framework supports a number of different SQL databases.
    However, they are all variants of SQL database such as MySQL, PostgreSQL, SQLite,
    and others. What if you want to use a NoSQL database such as MongoDB or CouchDB?
    It might be possible but could be leaving you in your own hands. Being an opinionated
    framework is certainly not a bad thing, it is just a matter of opinion (no pun intended).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我觉得Django有点难以扩展，大部分时间我只使用预先构建的代码的一小部分。Django框架对事物应该如何完成有着强烈的意见；任何偏离这些意见的行为有时会让用户觉得他们在“与框架作斗争”。例如，如果你看一下Django数据库文档，你会注意到这个框架支持多种不同的SQL数据库。然而，它们都是SQL数据库的变体，比如MySQL，PostgreSQL，SQLite等。如果你想使用NoSQL数据库，比如MongoDB或CouchDB呢？这可能是可能的，但可能会让你自己摸索。成为一个有主见的框架当然不是坏事，这只是一个观点问题（无意冒犯）。
- en: The idea of keeping the core code small and extending it when needed is very
    appealing to me. The initial example on the documentation to get Flask up and
    running consists of only eight lines of code and is easy to understand, even if
    you don't have any prior experience. Since Flask is built with extensions in mind,
    writing your own extensions, such as decorator, is pretty easy. Even though it
    is a microframework, the Flask core still includes the necessary components, such
    as a development server, debugger, integration with unit tests, RESTful request
    dispatching, and more, to get you started out of the box. As you can see, besides
    Django, Flask is the second most popular Python framework by some measure. The
    popularity that comes with community contribution, support, and quick development
    helps it further expand its reach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢保持核心代码简洁，并在需要时进行扩展的想法。文档中让Flask运行的初始示例只包含了八行代码，即使你没有任何经验，也很容易理解。由于Flask是以扩展为核心构建的，编写自己的扩展，比如装饰器，非常容易。尽管它是一个微框架，但Flask核心仍然包括必要的组件，比如开发服务器、调试器、与单元测试的集成、RESTful请求分发等等，可以让你立即开始。正如你所看到的，除了Django，Flask是按某些标准来说第二受欢迎的Python框架。社区贡献、支持和快速发展带来的受欢迎程度有助于进一步扩大其影响力。
- en: For the preceding reasons, I feel that Flask is an ideal choice for us when
    it comes to building network web services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 出于上述原因，我觉得Flask是我们在构建网络Web服务时的理想选择。
- en: Flask and lab setup
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask和实验设置
- en: In this chapter, we will use `virtualenv` to isolate the environment we will
    work in. As the name indicates, virtualenv is a tool that creates a virtual environment.
    It can keep the dependencies required by different projects in separate places
    while keeping the global site-packages clean. In other words, when you install
    Flask in the virtual environment, it is only installed in the local `virtualenv`
    project directory, not the global site-packages. This make porting the code to
    other places very easy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`virtualenv`来隔离我们将要工作的环境。顾名思义，virtualenv是一个创建虚拟环境的工具。它可以将不同项目所需的依赖项保存在不同的位置，同时保持全局site-packages的清洁。换句话说，当你在虚拟环境中安装Flask时，它只会安装在本地`virtualenv`项目目录中，而不是全局site-packages。这使得将代码移植到其他地方变得非常容易。
- en: The chances are high that you may have already come across `virtualenv` while
    working with Python before, so we will run through this process quickly. If you
    have not, feel free to pick up one of many excellent tutorials online, such as
    [http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能在之前使用Python时，你已经接触过`virtualenv`，所以我们会快速地浏览一下这个过程。如果你还没有接触过，可以随意选择在线的优秀教程之一，比如[http://docs.python-guide.org/en/latest/dev/virtualenvs/](http://docs.python-guide.org/en/latest/dev/virtualenvs/)。
- en: 'To use , we will first need to install `virtualenv`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用，我们首先需要安装`virtualenv`。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The proceeding command uses the `venv` module (`-m venv`) to get a `venv` folder
    with a full Python interpreter inside it. We can use `source venv/bin/activate`
    and `deactivate` to move in and out of the local Python environment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的命令使用`venv`模块（`-m venv`）来获取一个带有完整Python解释器的`venv`文件夹。我们可以使用`source venv/bin/activate`和`deactivate`来进入和退出本地Python环境：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this chapter, we will install quite a few Python packages. To make life
    easier, I have included a `requirements.txt` file on the book''s GitHub repository;
    we can use it to install all the necessary packages (remember to activate your
    virtualenv). You should see packages being downloaded and successfully installed
    at the end of the process:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装相当多的Python包。为了让生活更轻松，我在书的GitHub存储库中包含了一个`requirements.txt`文件；我们可以使用它来安装所有必要的包（记得激活你的虚拟环境）。在过程结束时，你应该看到包被下载并成功安装：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For our network topology, we will use a simple four-node network, as shown
    here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络拓扑，我们将使用一个简单的四节点网络，如下所示：
- en: '![](assets/1647347c-bb46-4301-82d5-4cd6b61096bc.png) Lab topology'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1647347c-bb46-4301-82d5-4cd6b61096bc.png) 实验拓扑'
- en: Let's take a look at Flask in the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看一下Flask。
- en: Please note that, from here on out, I will assume that you will always execute
    from the virtual environment and that you have installed the necessary packages
    in the `requirements.txt` file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从现在开始，我将假设你总是在虚拟环境中执行，并且已经安装了`requirements.txt`文件中的必要包。
- en: Introduction to Flask
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask简介
- en: Like most popular open source projects, Flask has very good documentation, which
    is available at [http://flask.pocoo.org/docs/0.10/](http://flask.pocoo.org/docs/0.10/).
    If any of the examples are unclear, you can be sure to find the answer on the
    project documentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数流行的开源项目一样，Flask有非常好的文档，可以在[http://flask.pocoo.org/docs/0.10/](http://flask.pocoo.org/docs/0.10/)找到。如果任何示例不清楚，你可以肯定会在项目文档中找到答案。
- en: 'I would also highly recommend Miguel Grinberg''s ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/))
    work related to Flask. His blog, book, and video training have taught me a lot
    about Flask. In fact, Miguel''s class *Building Web APIs with Flask* inspired
    me to write this chapter. You can take a look at his published code on GitHub:
    [https://github.com/miguelgrinberg/oreilly-flask-apis-video](https://github.com/miguelgrinberg/oreilly-flask-apis-video).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我还强烈推荐Miguel Grinberg（[https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/)）关于Flask的工作。他的博客、书籍和视频培训让我对Flask有了很多了解。事实上，Miguel的课程*使用Flask构建Web
    API*启发了我写这一章。你可以在GitHub上查看他发布的代码：[https://github.com/miguelgrinberg/oreilly-flask-apis-video](https://github.com/miguelgrinberg/oreilly-flask-apis-video)。
- en: 'Our first Flask application is contained in one single file, `chapter9_1.py`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个Flask应用程序包含在一个单独的文件`chapter9_1.py`中：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will almost always be your design pattern for Flask initially. We create
    an instance of the Flask class with the first argument as the name of the application''s
    module package. In this case, we used a single module; while doing this yourself,
    type in a name of your choice to indicate whether it is started as an application
    or imported as a module. We then use the route decorator to tell Flask which URL
    should be handled by the `hello_networkers()` function; in this case, we indicated
    the root path. We end the file with the usual name ([https://docs.python.org/3.5/library/__main__.html](https://docs.python.org/3.5/library/__main__.html)).
    We only added the host and debug options, which allow more verbose output and
    also allow us to listen on all the interfaces of the host (by default, it only
    listens on loopback). We can run this application using the development server:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎总是Flask最初的设计模式。我们使用Flask类的实例作为应用程序模块包的第一个参数。在这种情况下，我们使用了一个单一模块；在自己操作时，输入您选择的名称，以指示它是作为应用程序启动还是作为模块导入。然后，我们使用路由装饰器告诉Flask哪个URL应该由`hello_networkers()`函数处理；在这种情况下，我们指定了根路径。我们以通常的名称结束文件（[https://docs.python.org/3.5/library/__main__.html](https://docs.python.org/3.5/library/__main__.html)）。我们只添加了主机和调试选项，允许更详细的输出，并允许我们监听主机的所有接口（默认情况下，它只监听回环）。我们可以使用开发服务器运行此应用程序：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have a server running, let's test the server response with an HTTP
    client.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有一个运行的服务器，让我们用一个HTTP客户端测试服务器的响应。
- en: The HTTPie client
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPie客户端
- en: 'We have already installed HTTPie ([https://httpie.org/](https://httpie.org/))
    as part of the installation from reading the `requirements.txt` file. Although
    this book is printed in black and white text so it does not show up here, in your
    installation, you can see that HTTPie has better syntax highlighting for HTTP
    transactions. It also has a more intuitive command-line interaction with the RESTful
    HTTP server. We can use it to test our first Flask application (more examples
    on HTTPie to follow):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了HTTPie ([https://httpie.org/](https://httpie.org/)) 作为从阅读`requirements.txt`文件安装的一部分。尽管本书是黑白文本打印的，所以这里看不到，但在您的安装中，您可以看到HTTPie对HTTP事务有更好的语法高亮。它还具有更直观的RESTful
    HTTP服务器命令行交互。我们可以用它来测试我们的第一个Flask应用程序（后续将有更多关于HTTPie的例子）：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, you can also use the `-i` switch with curl to see the HTTP headers:
    `curl -i http://172.16.1.173:5000/`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用curl的`-i`开关来查看HTTP头：`curl -i http://172.16.1.173:5000/`。
- en: 'We will use `HTTPie` as our client for this chapter; it is worth taking a minute
    or two to take a look at its usage. We will use the free website HTTP Bin ([https://httpbin.org/](https://httpbin.org/))
    to show the use of `HTTPie`. The usage of `HTTPie` follows this simple pattern:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用`HTTPie`作为我们的客户端；值得花一两分钟来看一下它的用法。我们将使用免费的网站HTTP Bin ([https://httpbin.org/](https://httpbin.org/))
    来展示`HTTPie`的用法。`HTTPie`的用法遵循这种简单的模式：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following the preceding pattern, a `GET` request is very straightforward, as
    we have seen with our Flask development server:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的模式，`GET`请求非常简单，就像我们在Flask开发服务器中看到的那样：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'JSON is the default implicit content type for `HTTPie`. If your HTTP body contains
    just strings, no other operation is needed. If you need to apply non-string JSON
    fields, use `:=` or other documented special characters:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是`HTTPie`的默认隐式内容类型。如果您的HTTP主体只包含字符串，则不需要进行其他操作。如果您需要应用非字符串JSON字段，请使用`:=`或其他文档化的特殊字符：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, `HTTPie` is a big improvement from the traditional curl syntax
    and makes testing the REST API a breeze.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`HTTPie`是传统curl语法的一个重大改进，使得测试REST API变得轻而易举。
- en: More usage examples are available at [https://httpie.org/doc#usage](https://httpie.org/doc#usage.).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的用法示例可在[https://httpie.org/doc#usage](https://httpie.org/doc#usage)找到。
- en: Getting back to our Flask program, a large part of API building is based on
    the flow of URL routing. Let's take a deeper look at the `app.route()` decorator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的Flask程序，API构建的一个重要部分是基于URL路由的流程。让我们更深入地看一下`app.route()`装饰器。
- en: URL routing
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL路由
- en: 'We added two additional functions and paired them up with the appropriate `app.route()`
    route in `chapter9_2.py`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个额外的函数，并将它们与`chapter9_2.py`中的适当的`app.route()`路由配对：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result is that different endpoints are passed to different functions. We
    can verify this with two `http` requests:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是不同的端点传递给不同的函数。我们可以通过两个`http`请求来验证这一点：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, the routing will be pretty limited if we have to keep it static all
    the time. There are ways to pass variables from the URL to Flask; we will look
    at an example of this in the coming section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们一直保持静态，路由将会非常有限。有办法将变量从URL传递给Flask；我们将在接下来的部分看一个例子。
- en: URL variables
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL变量
- en: 'As mentioned previously, we can also pass variables to the URL, as seen in
    the examples discussed in `chapter9_3.py`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以将变量传递给URL，就像在`chapter9_3.py`中讨论的例子中看到的那样：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that, in the `/routers/<hostname>` URL, we pass the `<hostname>` variable
    as a string; `<int:interface_number>` will specify that the variable should only
    be an integer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`/routers/<hostname>` URL中，我们将`<hostname>`变量作为字符串传递；`<int:interface_number>`将指定该变量应该是一个整数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The converter includes integers, float, and path (it accepts slashes).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器包括整数、浮点数和路径（它接受斜杠）。
- en: Besides matching static routes, we can also generate URLs on the fly. This is
    very useful when we do not know the endpoint variable in advance or if the endpoint
    is based on other conditions, such as the values queried from a database. Let's
    take a look at an example of this.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了匹配静态路由之外，我们还可以动态生成URL。当我们事先不知道端点变量，或者端点基于其他条件，比如从数据库查询的值时，这是非常有用的。让我们看一个例子。
- en: URL generation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL生成
- en: 'In `chapter9_4.py`, we wanted to dynamically create a URL in the form of `''/<hostname>/list_interfaces''`
    in code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter9_4.py`中，我们想要在代码中动态创建一个形式为`'/<hostname>/list_interfaces'`的URL：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Upon its execution, you will have a nice and logical URL, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您将得到一个漂亮而合乎逻辑的URL，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For now, you can think of `app.text_request_context()` as a dummy `request`
    object that is necessary for demonstrative purposes. If you are interested in
    the local context, feel free to take a look at [http://werkzeug.pocoo.org/docs/0.14/local/](http://werkzeug.pocoo.org/docs/0.14/local/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您可以将`app.text_request_context()`视为一个虚拟的`request`对象，这对于演示目的是必要的。如果您对本地上下文感兴趣，请随时查看[http://werkzeug.pocoo.org/docs/0.14/local/](http://werkzeug.pocoo.org/docs/0.14/local/)。
- en: The jsonify return
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jsonify返回
- en: 'Another time saver in Flask is the `jsonify()` return, which wraps `json.dumps()`
    and turns the JSON output into a `response` object with `application/json` as
    the content type in the HTTP header. We can tweak the last script a bit, just
    like we will do in `chapter9_5.py`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Flask中的另一个时间节省器是`jsonify()`返回，它包装了`json.dumps()`并将JSON输出转换为具有`application/json`作为HTTP标头中内容类型的`response`对象。我们可以稍微调整最后的脚本，就像我们将在`chapter9_5.py`中做的那样：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will see the result returned as a `JSON` object with the appropriate header:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到返回的结果作为`JSON`对象，并带有适当的标头：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Having looked at URL routing and the `jsonify()` return in Flask, we are now
    ready to build an API for our network.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask中查看了URL路由和`jsonify()`返回后，我们现在准备为我们的网络构建API。
- en: Network resource API
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络资源API
- en: Often, your network consists of network devices that do not change a lot once
    put into production. For example, you would have core devices, distribution devices,
    spine, leaf, top-of-rack switches, and so on. Each of the devices would have certain
    characteristics and features that you would like to keep in a persistent location
    so that you can easily retrieve them later on. This is often done in terms of
    storing data in a database. However, you would not normally want to give other
    users, who might want this information, direct access to the database; nor do
    they want to learn all the complex SQL query language. For this case, we can leverage
    Flask and the **Flask-SQLAlchemy** extension of Flask.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的网络由一旦投入生产就不经常更改的网络设备组成。例如，您将拥有核心设备、分发设备、脊柱、叶子、顶部交换机等。每个设备都有特定的特性和功能，您希望将这些信息存储在一个持久的位置，以便以后可以轻松检索。通常是通过将数据存储在数据库中来实现的。但是，您通常不希望将其他用户直接访问数据库；他们也不想学习所有复杂的SQL查询语言。对于这种情况，我们可以利用Flask和Flask-SQLAlchemy扩展。
- en: You can learn more about Flask-SQLAlchemy at [http://flask-sqlalchemy.pocoo.org/2.1/](http://flask-sqlalchemy.pocoo.org/2.1/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://flask-sqlalchemy.pocoo.org/2.1/](http://flask-sqlalchemy.pocoo.org/2.1/)了解更多关于Flask-SQLAlchemy的信息。
- en: Flask-SQLAlchemy
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy
- en: Of course, SQLAlchemy and the Flask extension are a database abstraction layer
    and object relational mapper, respectively. It's a fancy way of saying to use
    the `Python` object for a database. To make things simple, we will use SQLite
    as the database, which is a flat file that acts as a self-contained SQL database.
    We will look at the content of `chapter9_db_1.py` as an example of using Flask-SQLAlchemy
    to create a network database and insert a table entry into the database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SQLAlchemy和Flask扩展都是数据库抽象层和对象关系映射器。这是一种使用`Python`对象作为数据库的高级方式。为了简化事情，我们将使用SQLite作为数据库，它是一个充当独立SQL数据库的平面文件。我们将查看`chapter9_db_1.py`的内容，作为使用Flask-SQLAlchemy创建网络数据库并将表条目插入数据库的示例。
- en: 'To begin with, we will create a Flask application and load the configuration
    for SQLAlchemy, such as the database path and name, then create the `SQLAlchemy`
    object by passing the application to it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个Flask应用程序，并加载SQLAlchemy的配置，比如数据库路径和名称，然后通过将应用程序传递给它来创建`SQLAlchemy`对象：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then create a `database` object and its associated primary key and various
    columns:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个`database`对象及其关联的主键和各种列：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can invoke the `database` object, create entries, and insert them into the
    database table. Keep in mind that anything we add to the session needs to be committed
    to the database in order to be permanent:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`database`对象，创建条目，并将它们插入数据库表中。请记住，我们添加到会话中的任何内容都需要提交到数据库中才能永久保存：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will run the Python script and check for the existence of the database file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行Python脚本并检查数据库文件是否存在：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use the interactive prompt to check the database table entries:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用交互式提示来检查数据库表条目：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also create new entries in the same manner:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以相同的方式创建新条目：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Network content API
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络内容API
- en: Before we dive into the code, let's take a moment to think about the API that
    we are trying to create. Planning for an API is usually more art than science;
    it really depends on your situation and preference. What I suggest next is, by
    no means, the right way, but for now, stay with me for the purposes of getting
    started.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我们花一点时间考虑我们要创建的API。规划API通常更多是一种艺术而不是科学；这确实取决于您的情况和偏好。我建议的下一步绝不是正确的方式，但是现在，为了开始，跟着我走。
- en: Recall that, in our diagram, we have four Cisco IOSv devices. Let's pretend
    that two of them, `iosv-1` and `iosv-2`, are of the network role of the spine.
    The other two devices, `iosv-3` and `iosv-4`, are in our network service as leafs.
    These are obviously arbitrary choices and can be modified later on, but the point
    is that we want to serve data about our network devices and expose them via an
    API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在我们的图表中，我们有四个Cisco IOSv设备。假设其中两个，`iosv-1`和`iosv-2`，是网络角色的脊柱。另外两个设备，`iosv-3`和`iosv-4`，在我们的网络服务中作为叶子。这显然是任意选择，可以稍后修改，但重点是我们想要提供关于我们的网络设备的数据，并通过API公开它们。
- en: 'To make things simple, we will create two APIs: a devices group API and a single
    device API:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，我们将创建两个API：设备组API和单个设备API：
- en: '![](assets/0cf9e61a-6b19-4746-b968-9ef5830d08ab.png)Network content API'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0cf9e61a-6b19-4746-b968-9ef5830d08ab.png)网络内容API'
- en: 'The first API will be our `http://172.16.1.173/devices/` endpoint that supports
    two methods: `GET` and `POST`. The `GET` request will return the current list
    of devices, while the `POST` request with the proper JSON body will create the
    device. Of course, you can choose to have different endpoints for creation and
    query, but in this design, we choose to differentiate the two by the HTTP methods.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个API将是我们的`http://172.16.1.173/devices/`端点，支持两种方法：`GET`和`POST`。`GET`请求将返回当前设备列表，而带有适当JSON主体的`POST`请求将创建设备。当然，您可以选择为创建和查询设置不同的端点，但在这个设计中，我们选择通过HTTP方法来区分这两种情况。
- en: The second API will be specific to our device in the form of `http://172.16.1.173/devices/<device
    id>`. The API with the `GET` request will show the details of the device that
    we have entered into the database. The `PUT` request will modify the entry with
    the update. Note that we use `PUT` instead of `POST`. This is typical of HTTP
    API usage; when we need to modify an existing entry, we will use `PUT` instead
    of `POST`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个API将特定于我们的设备，形式为`http://172.16.1.173/devices/<device id>`。带有`GET`请求的API将显示我们输入到数据库中的设备的详细信息。`PUT`请求将修改更新条目。请注意，我们使用`PUT`而不是`POST`。这是HTTP
    API使用的典型方式；当我们需要修改现有条目时，我们将使用`PUT`而不是`POST`。
- en: At this point, you should have a good idea about what your API will look like.
    To better visualize the end result, I am going to jump ahead and show the end
    result quickly before we take a look at the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对您的API的外观有一个很好的想法。为了更好地可视化最终结果，我将快速跳转并展示最终结果，然后再看代码。
- en: 'A `POST` request to the `/devices/` API will allow you to create an entry.
    In this case, I would like to create our network device with attributes such as
    hostname, loopback IP, management IP, role, vendor, and the operating system it
    runs on:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对`/devices/`API的`POST`请求将允许您创建一个条目。在这种情况下，我想创建我们的网络设备，其属性包括主机名、回环IP、管理IP、角色、供应商和运行的操作系统：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I can repeat the preceding step for the additional three devices:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以重复前面的步骤来添加另外三个设备：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we can use the same API with the `GET` request, we will be able to see the
    list of network devices that we created:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以使用相同的API和`GET`请求，我们将能够看到我们创建的网络设备列表：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similarly, using the `GET` request for `/devices/<id>` will return specific
    information related to the device:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用`GET`请求对`/devices/<id>`将返回与设备相关的特定信息：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s pretend we have downgraded the `r1` operating system from `15.6` to `14.6`.
    We can use the `PUT` request to update the device record:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`r1`操作系统从`15.6`降级到`14.6`。我们可以使用`PUT`请求来更新设备记录：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's take a look at the code in `chapter9_6.py` that helped create the
    preceding APIs. What's cool, in my opinion, is that all of these APIs were done
    in a single file, including the database interaction. Later on, when we outgrow
    the APIs at hand, we can always separate the components out, such as having a
    separate file for the database class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`chapter9_6.py`中的代码，这些代码帮助创建了前面的API。在我看来，很酷的是，所有这些API都是在单个文件中完成的，包括数据库交互。以后，当我们需要扩展现有的API时，我们总是可以将组件分离出来，比如为数据库类单独创建一个文件。
- en: Devices API
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备API
- en: 'The `chapter9_6.py` file starts with the necessary imports. Note that the following
    request import is the `request` object from the client and not the requests package
    that we were using in the previous chapters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter9_6.py`文件以必要的导入开始。请注意，以下请求导入是来自客户端的`request`对象，而不是我们在之前章节中使用的requests包：'
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We declared a `database` object with its `id` as the primary key and string
    fields for `hostname`, `loopback`, `mgmt_ip`, `role`, `vendor`, and `os`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`database`对象，其`id`为主键，`hostname`、`loopback`、`mgmt_ip`、`role`、`vendor`和`os`为字符串字段：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `get_url()` function returns a URL from the `url_for()` function. Note
    that the `get_device()` function that''s called is not defined just yet under
    the `''/devices/<int:id>''` route:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_url()`函数从`url_for()`函数返回一个URL。请注意，调用的`get_device()`函数尚未在`''/devices/<int:id>''`路由下定义：'
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `export_data()` and `import_data()` functions are mirror images of each
    other. One is used to get the information from the database to the user (`export_data()`) when
    we use the `GET` method. The other is to put information from the user to the
    database (`import_data()`) when we use the `POST` or `PUT` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`export_data()`和`import_data()`函数是彼此的镜像。一个用于从数据库获取信息到用户（`export_data()`），当我们使用`GET`方法时。另一个用于将用户的信息放入数据库（`import_data()`），当我们使用`POST`或`PUT`方法时：'
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the `database` object in place as well as the import and export functions
    created, the URL dispatch is straightforward for device operations. The `GET`
    request will return a list of devices by querying all the entries in the devices
    table and also return the URL of each entry. The `POST` method will use the `import_data()`
    function with the global `request` object as the input. It will then add the device
    and commit the information to the database:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`database`对象以及创建的导入和导出函数，设备操作的URL分发就变得简单了。`GET`请求将通过查询设备表中的所有条目返回设备列表，并返回每个条目的URL。`POST`方法将使用全局`request`对象作为输入，使用`import_data()`函数，然后将设备添加到数据库并提交信息：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you look at the `POST` method, the returned body is an empty JSON body,
    with the status code `201` (created) as well as extra headers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`POST`方法，返回的主体是一个空的JSON主体，状态码为`201`（已创建），以及额外的标头：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's look at the API that queries and returns information pertaining to individual
    devices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下查询和返回有关单个设备的信息的API。
- en: The device ID API
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备ID API
- en: 'The route for individual devices specifies that the ID should be an integer,
    which can act as our first line of defense against a bad request. The two endpoints
    follow the same design pattern as our `/devices/` endpoint, where we use the same
    `import` and `export` functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 单个设备的路由指定ID应该是一个整数，这可以作为我们对错误请求的第一道防线。这两个端点遵循与我们的`/devices/`端点相同的设计模式，我们在这里使用相同的`import`和`export`函数：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the `query_or_404()` method; it provides a convenient way for returning
    `404 (not found)` if the database query returns negative for the ID passed in.
    This is a pretty elegant way of providing a quick check on the database query.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`query_or_404()`方法；如果数据库查询对传入的ID返回负值，它提供了一个方便的方法来返回`404（未找到）`。这是一个相当优雅的方式来快速检查数据库查询。
- en: 'Finally, the last part of the code creates the database table and starts the
    Flask development server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码的最后部分创建数据库表并启动Flask开发服务器：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is one of the longer Python scripts in this book, which is why we took
    more time to explain it in detail. The script provides a way to illustrate how
    we can utilize the database in the backend to keep track of the network devices
    and only expose them to the external world as APIs, using Flask.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中较长的Python脚本之一，这就是为什么我们花了更多的时间详细解释它。该脚本提供了一种说明我们如何利用后端数据库来跟踪网络设备，并将它们仅作为API暴露给外部世界的方法，使用Flask。
- en: In the next section, we will take a look at how to use the API to perform asynchronous
    tasks on either individual devices or a group of devices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何使用API对单个设备或一组设备执行异步任务。
- en: Network dynamic operations
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络动态操作
- en: Our API can now provide static information about the network; anything that
    we can store in the database can be returned to the requester. It would be great
    if we can interact with our network directly, such as a query for the device information
    or to push configuration changes to the device.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API现在可以提供关于网络的静态信息；我们可以将数据库中存储的任何内容返回给请求者。如果我们可以直接与我们的网络交互，比如查询设备信息或向设备推送配置更改，那将是很棒的。
- en: 'We will start this process by leveraging the script we have already seen in
    [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network Device
    Interactions,* for interacting with a device via Pexpect. We will modify the script
    slightly into a function we can repeatedly use in `chapter9_pexpect_1.py`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过利用我们已经在[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中看到的脚本，*低级网络设备交互*，来开始这个过程，通过Pexpect与设备进行交互。我们将稍微修改脚本，将其转换为一个我们可以在`chapter9_pexpect_1.py`中重复使用的函数：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can test the new function via the interactive prompt:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过交互式提示来测试新的函数：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Make sure that your Pexpect script works before you proceed. The following code
    assumes that you have entered the necessary database information from the previous
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Pexpect脚本在继续之前能够正常工作。以下代码假定您已经输入了前一节中的必要数据库信息。
- en: 'We can add a new API for querying the device version in `chapter9_7.py`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`chapter9_7.py`中添加一个新的API来查询设备版本：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result will be returned to the requester:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将返回给请求者：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also add another endpoint that will allow us to perform a bulk action
    on multiple devices, based on their common fields. In the following example, the
    endpoint will take the `device_role` attribute in the URL and match it up with
    the appropriate device(s):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加另一个端点，允许我们根据它们的共同字段对多个设备执行批量操作。在下面的示例中，端点将在URL中获取`device_role`属性，并将其与相应的设备匹配：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Of course, looping through all the devices in `Device.query.all()` is not efficient,
    as in the preceding code. In production, we will use a SQL query that specifically
    targets the role of the device.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像在前面的代码中那样循环遍历所有的设备`Device.query.all()`是不高效的。在生产中，我们将使用一个专门针对设备角色的SQL查询。
- en: 'When we use the REST API, we can see that all the spine, as well as leaf, devices
    can be queried at the same time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用REST API时，可以同时查询所有的骨干和叶子设备：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As illustrated, the new API endpoints query the device(s) in real time and return
    the result to the requester. This works relatively well when you can guarantee
    a response from the operation within the timeout value of the transaction (30
    seconds, by default) or if you are OK with the HTTP session timing out before
    the operation is completed. One way to deal with the timeout issue is to perform
    the tasks asynchronously. We will look at how to do so in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所示，新的API端点实时查询设备，并将结果返回给请求者。当您可以保证在事务的超时值（默认为30秒）内获得操作的响应，或者如果您可以接受HTTP会话在操作完成之前超时，这种方法相对有效。解决超时问题的一种方法是异步执行任务。我们将在下一节中看看如何做到这一点。
- en: Asynchronous operations
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步操作
- en: 'Asynchronous operations are, in my opinion, an advanced topic of Flask. Luckily,
    Miguel Grinberg ([https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/)),
    whose Flask work I am a big fan of, provides many posts and examples on his blog
    and on GitHub. For asynchronous operations, the example code in `chapter9_8.py`
    referenced Miguel''s GitHub code on the `Raspberry Pi` file ([https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py](https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py))
    for the background decorator. We will start by importing a few more modules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，异步操作是Flask的一个高级主题。幸运的是，Miguel Grinberg（[https://blog.miguelgrinberg.com/](https://blog.miguelgrinberg.com/)）是我非常喜欢的Flask工作的作者，他在博客和GitHub上提供了许多帖子和示例。对于异步操作，`chapter9_8.py`中的示例代码引用了Miguel在GitHub上的`Raspberry
    Pi`文件上的代码（[https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py](https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py)）来使用background装饰器。我们将开始导入一些额外的模块：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The background decorator takes in a function and runs it as a background task
    using thread and UUID for the task ID. It returns the status code `202` accepted
    and the location of the new resources for the requester to check. We will make
    a new URL for status checking:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: background装饰器接受一个函数，并使用线程和UUID作为任务ID在后台运行它。它返回状态码`202` accepted和新资源的位置，供请求者检查。我们将创建一个新的URL用于状态检查：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we retrieve the resource, it is deleted. This was done by setting `app.config[''AUTO_DELETE_BG_TASKS'']`
    to `true` at the top of the app. We will add this decorator to our version endpoints
    without changing the other part of the code because all of the complexity is hidden
    in the decorator (how cool is that!):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们检索到资源，它就会被删除。这是通过在应用程序顶部将`app.config['AUTO_DELETE_BG_TASKS']`设置为`true`来完成的。我们将在我们的版本端点中添加这个装饰器，而不改变代码的其他部分，因为所有的复杂性都隐藏在装饰器中（这多酷啊！）：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The end result is a two-part process. We will perform the `GET` request for
    the endpoint and receive the location header:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个两部分的过程。我们将为端点执行`GET`请求，并接收位置头：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then make a second request to the location to retrieve the result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以发出第二个请求以检索结果的位置：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To verify that the status code `202` is returned when the resource is not ready,
    we will use the following script, `chapter9_request_1.py`, to immediately make
    a request to the new resource:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证当资源尚未准备好时是否返回状态码`202`，我们将使用以下脚本`chapter9_request_1.py`立即向新资源发出请求：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see in the result, the status code is returned while the resource
    is still being run in the background as `202`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在结果中所见，当资源仍在后台运行时，状态码以`202`返回：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our APIs are coming along nicely! Because our network resource is valuable to
    us, we should secure API access to only authorized personnel. We will add basic
    security measures to our API in the next section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API正在很好地进行中！因为我们的网络资源对我们很有价值，所以我们应该只允许授权人员访问API。我们将在下一节为我们的API添加基本的安全措施。
- en: Security
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: 'For user authentication security, we will use Flask''s `httpauth` extension,
    written by Miguel Grinberg, as well as the password functions in Werkzeug. The
    `httpauth` extension should have been installed as part of the `requirements.txt`
    installation at the beginning of this chapter. The new file illustrating the security
    feature is named `chapter9_9.py`; we will start with a few more module imports:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户身份验证安全，我们将使用Flask的`httpauth`扩展，由Miguel Grinberg编写，以及Werkzeug中的密码函数。`httpauth`扩展应该已经作为`requirements.txt`安装的一部分。展示安全功能的新文件名为`chapter9_9.py`；我们将从几个模块导入开始：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will create an `HTTPBasicAuth` object as well as the `user database` object.
    Note that, during the user creation process, we will pass the password value;
    however, we are only storing `password_hash` instead of the `password` itself.
    This ensures that we are not storing a clear text password for the user:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`HTTPBasicAuth`对象以及`用户数据库`对象。请注意，在用户创建过程中，我们将传递密码值；但是，我们只存储`password_hash`而不是密码本身。这确保我们不会为用户存储明文密码：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `auth` object has a `verify_password` decorator that we can use, along
    with Flask''s `g` global context object that was created when the request started
    for password verification. Because `g` is global, if we save the user to the `g`
    variable, it will live through the entire transaction:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth`对象有一个`verify_password`装饰器，我们可以使用它，以及Flask的`g`全局上下文对象，该对象在请求开始时创建，用于密码验证。因为`g`是全局的，如果我们将用户保存到`g`变量中，它将在整个事务中存在：'
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There is a handy `before_request` handler that can be used before any API endpoint
    is called. We will combine the `auth.login_required` decorator with the `before_request`
    handler that will be applied to all the API routes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方便的`before_request`处理程序，可以在调用任何API端点之前使用。我们将结合`auth.login_required`装饰器和`before_request`处理程序，将其应用于所有API路由：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lastly, we will use the `unauthorized` error handler to return a `response`
    object for the `401` unauthorized error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`未经授权`错误处理程序返回`401`未经授权错误的`response`对象：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before we can test user authentication, we will need to create users in our
    database:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试用户身份验证之前，我们需要在我们的数据库中创建用户：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once you start your Flask development server, try to make a request, like we
    did previously. You should see that, this time, the server will reject the request
    with a `401` unauthorized error:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动Flask开发服务器，请尝试发出请求，就像我们之前做的那样。您应该看到，这次服务器将以`401`未经授权的错误拒绝请求：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will now need to provide the authentication header for our requests:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为我们的请求提供身份验证头：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We now have a decent RESTful API set up for our network. The user will be able
    to interact with the APIs now instead of the network devices. They can query for
    the static content of the network and perform tasks for individual devices or
    a group of devices. We also added basic security measures to ensure that only
    the users we created are able to retrieve the information from our API. The cool
    part is that this is all done within a single file in less than 250 lines of code
    (less than 200 if you subtract the comments)!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的网络设置了一个不错的RESTful API。用户现在可以与API交互，而不是与网络设备。他们可以查询网络的静态内容，并为单个设备或一组设备执行任务。我们还添加了基本的安全措施，以确保只有我们创建的用户能够从我们的API中检索信息。很酷的是，这一切都在不到250行代码的单个文件中完成了（如果减去注释，不到200行）！
- en: We have now abstracted the underlying vendor API away from our network and replaced
    them with our own RESTful API. We are free to use what is required in the backend,
    such as Pexpect, while still providing a uniform frontend to our requester.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将底层供应商API从我们的网络中抽象出来，并用我们自己的RESTful API替换了它们。我们可以在后端自由使用所需的内容，比如Pexpect，同时为我们的请求者提供统一的前端。
- en: Let's take a look at additional resources for Flask so that we can continue
    to build on our API framework.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Flask的其他资源，这样我们就可以继续构建我们的API框架。
- en: Additional resources
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Flask is no doubt a feature-rich framework that is growing in features and
    in the community. We have covered a lot of topics in this chapter, but we have
    still only scraped the surface of the framework. Besides APIs, you can use Flask
    for web applications as well as your websites. There are a few improvements that
    I think we can still make to our network API framework:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Flask是一个功能丰富的框架，功能和社区都在不断增长。在本章中，我们涵盖了许多主题，但我们仍然只是触及了框架的表面。除了API，你还可以将Flask用于Web应用程序以及你的网站。我认为我们的网络API框架仍然有一些改进的空间：
- en: Separate out the database and each endpoint in its own file so that the code
    is cleaner and easier to troubleshoot.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库和每个端点分开放在自己的文件中，以使代码更清晰，更易于故障排除。
- en: Migrate from SQLite to other production-ready databases.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从SQLite迁移到其他适用于生产的数据库。
- en: Use token-based authentication instead of passing the username and password
    for every transaction. In essence, we will receive a token with finite expiration
    time upon initial authentication and use the token for further transactions until
    the expiration.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于令牌的身份验证，而不是为每个交易传递用户名和密码。实质上，我们将在初始身份验证时收到一个具有有限过期时间的令牌，并在之后的交易中使用该令牌，直到过期。
- en: Deploy your Flask API app behind a production web server, such as Nginx, along
    with the Python WSGI server for production use.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Flask API应用程序部署在生产Web服务器后面，例如Nginx，以及Python WSGI服务器用于生产环境。
- en: Use an automation process control system, such as Supervisor ([http://supervisord.org/](http://supervisord.org/)),
    to control the Nginx and Python scripts.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动化过程控制系统，如Supervisor ([http://supervisord.org/](http://supervisord.org/))，来控制Nginx和Python脚本。
- en: Obviously, the recommended improvement choices will vary greatly from company
    to company. For example, the choice of database and web server may have implications
    for the company's technical preference as well as the other teams' input. The
    use of token-based authentication might not be necessary if the API is only used
    internally and other forms of security have been put into place. For these reasons,
    I would like to provide you with additional links as extra resources should you
    choose to move forward with any of the preceding items.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，推荐的改进选择会因公司而异。例如，数据库和Web服务器的选择可能会对公司的技术偏好以及其他团队的意见产生影响。如果API仅在内部使用，并且已经采取了其他形式的安全措施，那么使用基于令牌的身份验证可能并不必要。因此，出于这些原因，我想为您提供额外的链接作为额外资源，以便您选择继续使用前述任何项目。
- en: 'Here are some of the links I find useful when thinking about design patterns,
    database options, and general Flask features:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些我认为在考虑设计模式、数据库选项和一般Flask功能时有用的链接：
- en: Best practices on Flask design patterns: [http://flask.pocoo.org/docs/0.10/patterns/](http://flask.pocoo.org/docs/0.10/patterns/)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Flask设计模式的最佳实践: [http://flask.pocoo.org/docs/0.10/patterns/](http://flask.pocoo.org/docs/0.10/patterns/)'
- en: 'Flask API: [http://flask.pocoo.org/docs/0.12/api/](http://flask.pocoo.org/docs/0.12/api/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Flask API: [http://flask.pocoo.org/docs/0.12/api/](http://flask.pocoo.org/docs/0.12/api/)'
- en: 'Deployment options: [http://flask.pocoo.org/docs/0.12/deploying/](http://flask.pocoo.org/docs/0.12/deploying/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '部署选项: [http://flask.pocoo.org/docs/0.12/deploying/](http://flask.pocoo.org/docs/0.12/deploying/)'
- en: Due to the nature of Flask and the fact that it relies on the extension outside
    of its small core, sometimes, you might find yourself jumping from one document
    to another. This can be frustrating, but the upside is that you only need to know
    about the extension you are using, which I feel saves time in the long run.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flask的性质以及它依赖于其小核心之外的扩展，有时你可能会发现自己从一个文档跳到另一个文档。这可能令人沮丧，但好处是你只需要了解你正在使用的扩展，我觉得这在长远来看节省了时间。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to move onto the path of building REST APIs for
    our network. We looked at different popular Python web frameworks, namely Django
    and Flask, and compared and contrasted the two. By choosing Flask, we are able
    to start small and expand on features by using Flask extensions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始着手构建网络的REST API。我们研究了不同流行的Python Web框架，即Django和Flask，并对比了两者。选择Flask，我们能够从小处着手，并通过使用Flask扩展来扩展功能。
- en: In our lab, we used the virtual environment to separate the Flask installation
    base from our global site-packages. The lab network consists of four nodes, two
    of which we have designated as spine routers while the other two are designated
    as leaf routers. We took a tour of the basics of Flask and used the simple HTTPie
    client for testing our API setup.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实验室中，我们使用虚拟环境将Flask安装基础与全局site-packages分开。实验室网络由四个节点组成，其中两个被指定为脊柱路由器，另外两个被指定为叶子路由器。我们对Flask的基础知识进行了介绍，并使用简单的HTTPie客户端来测试我们的API设置。
- en: Among the different setups of Flask, we placed special emphasis on URL dispatch
    as well as the URL variables because they are the initial logic between the requesters
    and our API system. We took a look at using Flask-SQLAlchemy and SQLite to store
    and return network elements that are static in nature. For operation tasks, we
    also created API endpoints while calling other programs, such as Pexpect, to accomplish
    configuration tasks. We improved the setup by adding asynchronous handling as
    well as user authentication to our API. Toward the end of this chapter, we looked
    at some of the additional resource links we can follow to add even more security
    and other features.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask的不同设置中，我们特别强调了URL分发以及URL变量，因为它们是请求者和我们的API系统之间的初始逻辑。我们研究了使用Flask-SQLAlchemy和SQLite来存储和返回静态网络元素。对于操作任务，我们还创建了API端点，同时调用其他程序，如Pexpect，来完成配置任务。我们通过添加异步处理和用户身份验证来改进API的设置。在本章的最后，我们还查看了一些额外的资源链接，以便添加更多安全性和其他功能。
- en: In [Chapter 10](1f42ba11-b219-41fa-902c-f85a916429a6.xhtml), *AWS Cloud Networking*,
    we will shift our gear to look at cloud networking using **Amazon Web Services**
    (**AWS**).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](1f42ba11-b219-41fa-902c-f85a916429a6.xhtml)中，*AWS云网络*，我们将转向使用**Amazon
    Web Services**（**AWS**）进行云网络的研究。
