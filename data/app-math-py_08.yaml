- en: Geometric Problems
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 几何问题
- en: This chapter describes solutions to several problems concerning two-dimensional
    geometry. Geometry is a branch of mathematics concerned with the characteristics
    of points, lines, and other figures (shapes), the interaction between such figures,
    and the transformation of such figures. In this chapter, we'll focus on the characteristics
    of two-dimensional figures and the interactions between these objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了关于二维几何的几个问题的解决方案。几何是数学的一个分支，涉及点、线和其他图形（形状）的特征，这些图形之间的相互作用以及这些图形的变换。在本章中，我们将重点关注二维图形的特征以及这些对象之间的相互作用。
- en: There are several problems we must overcome when working with geometric objects
    in Python. The biggest hurdle is the problem of representation. Most geometric
    objects occupy a region in the two-dimensional plane, and as such, it is impossible
    to store every point that lies within the region. Instead, we have to find a more
    compact way to represent the region that can be stored as a relatively small number
    of points. For example, we might store a selection of points along the boundary
    of an object that we can reconstruct the boundary and the object itself from.
    Moreover, we reformulate geometric problems into questions that can be answered
    using the representative data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中处理几何对象时，我们必须克服几个问题。最大的障碍是表示问题。大多数几何对象占据二维平面中的一个区域，因此不可能存储区域内的每个点。相反，我们必须找到一种更紧凑的方式来表示可以存储为相对较少的点的区域。例如，我们可以存储沿对象边界的一些点，从而可以重建边界和对象本身。此外，我们将几何问题重新表述为可以使用代表性数据回答的问题。
- en: The second biggest problem is converting purely geometric questions into a form
    that can be understood and solved using software. This can be relatively simple
    – for example, finding the point at which two straight lines intersect is a matter
    of solving a matrix equation – or it can be extremely complex, depending on the
    type of question being asked. A common technique that's used to solve these problems
    is to represent the figure in question using more simple objects and solve the
    (hopefully) easier problem using each of the simple objects. This should then
    give us an idea of the solution to the original problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个最大的问题是将纯几何问题转化为可以使用软件理解和解决的形式。这可能相对简单-例如，找到两条直线相交的点是解决矩阵方程的问题-或者可能非常复杂，这取决于所提出的问题类型。解决这些问题的常见技术是使用更简单的对象表示所讨论的图形，并使用每个简单对象解决（希望）更容易的问题。然后，这应该给我们一个关于原始问题的解决方案的想法。
- en: We will start by showing you how to visualize two-dimensional shapes, and then
    learn how to determine whether a point is contained within another figure. Then,
    we'll move on and look at edge detection, triangulation, and finding convex hulls.
    We'll conclude this chapter by constructing Bezier curves.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向您展示如何可视化二维形状，然后学习如何确定一个点是否包含在另一个图形中。然后，我们将继续查看边缘检测、三角剖分和寻找凸包。最后，我们将通过构造贝塞尔曲线来结束本章。
- en: 'This chapter covers the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下教程：
- en: Visualizing two-dimensional geometric shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化二维几何形状
- en: Finding interior points
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找内部点
- en: Finding edges in an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中查找边缘
- en: Triangulating planar figures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对平面图形进行三角剖分
- en: Computing convex hulls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算凸包
- en: Constructing Bezier curves
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造贝塞尔曲线
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we will need the `numpy` package and the `matplotlib` package,
    as usual. We will also need the Shapely package and the `scikit-image` package,
    which can be installed using your favorite package manager, such as `pip`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将像往常一样需要`numpy`包和`matplotlib`包。我们还需要Shapely包和`scikit-image`包，可以使用您喜欢的软件包管理器（如`pip`）进行安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found in the `Chapter 08` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的代码可以在GitHub存储库的`Chapter 08`文件夹中找到：[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3hpeKEF](https://bit.ly/3hpeKEF).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：[https://bit.ly/3hpeKEF](https://bit.ly/3hpeKEF)。
- en: Visualizing two-dimensional geometric shapes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化二维几何形状
- en: The focus of this chapter is on two-dimensional geometry, so our first task
    is to learn how to visualize two-dimensional geometric figures. Some of the techniques
    and tools mentioned here might be applicable to three-dimensional geometric figures,
    but generally, this will require more specialized packages and tools.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是二维几何，因此我们的第一个任务是学习如何可视化二维几何图形。这里提到的一些技术和工具可能适用于三维几何图形，但通常需要更专门的软件包和工具。
- en: A *geometric figure*, at least in the context of this book, is any point, line,
    curve, or closed region (including the boundary) whose boundary is a collection
    of lines and curves. Simple examples include points and lines (obviously), rectangles,
    polygons, and circles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*几何图形*，至少在本书的上下文中，是指边界是一组线和曲线的任何点、线、曲线或封闭区域（包括边界）的集合。简单的例子包括点和线（显然）、矩形、多边形和圆。'
- en: In this recipe, we will learn how to visualize geometric figures using Matplotlib.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用Matplotlib可视化几何图形。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need the NumPy package imported as `np`, and the Matplotlib
    `pyplot` module imported as `plt`. We also need to import the `Circle` class from
    the Matplotlib `patches` module and the `PatchCollection` class from the Matplotlib
    `collections` module. This can be done with the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要导入NumPy包作为`np`，导入Matplotlib `pyplot`模块作为`plt`。我们还需要从Matplotlib `patches`模块导入`Circle`类和从Matplotlib
    `collections`模块导入`PatchCollection`类。可以使用以下命令完成这些操作：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will also need the `swisscheese-grid-10411.csv` data file from the code repository
    for this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要本章的代码库中的`swisscheese-grid-10411.csv`数据文件。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you to visualize a two-dimensional geometric figure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示了如何可视化一个二维几何图形：
- en: 'First, we load the data from the `swisscheese-grid-10411.csv` file from this
    book''s code repository:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从本书的代码库中的`swisscheese-grid-10411.csv`文件加载数据：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We create a new patch object that represents a region on a plot. This is going
    to be a circle (disk) with the center at the origin and a radius of `1`. We create
    a new set of axes and add this patch to them:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个代表绘图区域的新补丁对象。这将是一个圆（圆盘），其中心在原点，半径为`1`。我们创建一个新的轴集，并将这个补丁添加到其中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we create a `PatchCollection` object from the data we loaded in *step
    1*, which contains centers and radii for a number of other circles. We then add
    this `PatchCollection` to the axes we created in *step 2*:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从*步骤1*中加载的数据创建一个`PatchCollection`对象，其中包含了一些其他圆的中心和半径。然后我们将这个`PatchCollection`添加到*步骤2*中创建的轴上：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we set the *x-* and *y*-axis ranges so that the whole image is displayed
    and then turns the axes off:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置*x-*和*y-*轴的范围，以便整个图像都能显示出来，然后关闭轴线：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The resulting image is of a *Swiss Cheese*, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像是一个*瑞士奶酪*，如下所示：
- en: '![](assets/6aa2a020-6280-49a0-8606-c12f34d067ce.png)Figure 8.1: Plot of a Swiss
    cheese'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6aa2a020-6280-49a0-8606-c12f34d067ce.png)图8.1：瑞士奶酪的绘图'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The keys to this recipe are the `Circle` and `PatchCollection` objects, which
    represent the regions of the plot area on Matplotlib `Axes`. In this case, we
    are creating one large circular patch, centered at the origin and with a radius
    of `1`, that has a black face color and uses `zorder=0` to place it behind other
    patches. This patch is added to the `Axes` object using the `add_patch` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的关键是`Circle`和`PatchCollection`对象，它们代表了Matplotlib `Axes`上的绘图区域的区域。在这种情况下，我们创建了一个大的圆形补丁，它位于原点，半径为`1`，具有黑色的面颜色，并使用`zorder=0`将其放在其他补丁的后面。这个补丁被添加到`Axes`对象中使用`add_patch`方法。
- en: The next step is to create an object that will render the circles represented
    by the data that we loaded from the CSV file in *step 1*. This data consisted
    of *x*, *y*, and *r* values for the center (*x*, *y*) and the radius, *r*, of
    the individual circles (10,411 in total). The `PatchCollection` object combines
    a sequence of patches into a single object that can be added to an `Axes` object.
    Here, we add one `Circle` for each row in our data, which is then added to the
    `Axes` object using the `add_collection` method. Notice that we have applied the
    face color to the whole collection, rather than to each individual `Circle` constituent.
    We set the face color to white (using the `facecolor="w"` argument), the edge
    color to black (using `ec="k"`), the line width (of the edge lines) to 0.2 (using
    `linewidth=0.2`), and the edge style to a continuous line. All of this, when put
    together, results in our image.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个对象，它将呈现从CSV文件中加载的数据所代表的圆。这些数据包括中心（*x*，*y*）和半径*r*的值，用于表示个别圆的中心和半径（总共10,411个）。`PatchCollection`对象将一系列补丁组合成一个单一的对象，可以添加到`Axes`对象中。在这里，我们为我们的数据中的每一行添加了一个`Circle`，然后使用`add_collection`方法将其添加到`Axes`对象中。请注意，我们已经将面颜色应用到整个集合，而不是每个单独的`Circle`成员。我们将面颜色设置为白色（使用`facecolor="w"`参数），边缘颜色设置为黑色（使用`ec="k"`），边缘线宽设置为0.2（使用`linewidth=0.2`），边缘样式设置为连续线。所有这些放在一起，就得到了我们的图像。
- en: The image that we have created here is called a "Swiss Cheese". These were first
    used in rational approximation theory in 1938 by Alice Roth; they were subsequently
    rediscovered, and similar constructions have been used many times since. We used
    this example because it consists of one large individual part, plus a large collection
    of smaller individual parts. Roth's Swiss Cheese is an example of a set in the
    plane that has a positive area but no topological interior. (It is fairly amazing
    that such a set can even exist!) More importantly, there are continuous functions
    defined on this Swiss Cheese that cannot be approximated by rational functions.
    This property has made similar constructions useful in the theory of *uniform*
    *algebra*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的图像被称为“瑞士奶酪”。这些最初是由爱丽丝·罗斯在1938年在有理逼近理论中使用的；随后它们被重新发现，并且类似的构造自那时以来已经被多次使用。我们使用这个例子是因为它由一个大的个体部分和一个大量的较小的个体部分组成。罗斯的瑞士奶酪是平面上具有正面积但没有拓扑内部的一个集合的例子。（这样一个集合甚至能存在是相当惊人的！）更重要的是，有一些连续函数在这个瑞士奶酪上是不能被有理函数逼近的。这个特性使得类似的构造在*均匀*
    *代数*理论中非常有用。
- en: The `Circle` class is a subclass of the more general `Patch` class. There are
    numerous other `Patch` classes that represent different planar figures, such as
    `Polygon` and `PathPatch`, which represent the region bounded by a path (curve
    or collection of curves). These can be used to generate complex patches that can
    be rendered in a Matplotlib figure. Collections can be used to apply settings
    to a number of patch objects simultaneously, which can be especially useful if,
    as in this recipe, you have a large number of objects that will all be rendered
    in the same style.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类是更一般的`Patch`类的子类。还有许多其他`Patch`类，代表不同的平面图形，比如`Polygon`和`PathPatch`，它们代表了由路径（曲线或曲线集合）所界定的区域。这些可以用来生成可以在Matplotlib图中呈现的复杂补丁。集合可以用来同时应用设置到多个补丁对象上，这在本例中特别有用，因为你有大量的对象都将以相同的样式呈现。'
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many different patch types available in Matplotlib. In this recipe,
    we used the `Circle` patch class, which represents a circular region on the axes.
    There is also the `Polygon` patch class, which represents a polygon (regular or
    otherwise). There are also `PatchPath` objects, which are regions that are surrounded
    by a curve that does not necessarily consist of straight-line segments. This is
    similar to the way a shaded region can be constructed in many vector graphics
    software packages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib中有许多不同的补丁类型。在本教程中，我们使用了`Circle`补丁类，它表示坐标轴上的圆形区域。还有`Polygon`补丁类，它表示多边形（规则或其他）。还有`PatchPath`对象，它们是由不一定由直线段组成的曲线包围的区域。这类似于许多矢量图形软件包中可以构造阴影区域的方式。
- en: In addition to the single patch types in Matplotlib, there are a number of collection
    types that gather a number of patches together to be used as a single object.
    In this recipe, we used the `PatchCollection` class to gather a large number of
    `Circle` patches. There are more specialized patch collections that can be used
    to generate these internal patches automatically, rather than us generating them
    ourselves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Matplotlib中的单个补丁类型外，还有许多集合类型，它们将许多补丁聚集在一起，以便作为单个对象使用。在本教程中，我们使用了`PatchCollection`类来收集大量的`Circle`补丁。还有更多专门的补丁集合，可以用来自动生成这些内部补丁，而不是我们自己生成它们。
- en: See also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'A more detailed history of Swiss Cheeses in mathematics can be found in the
    following biographical article: *Daepp,U., Gauthier, P., Gorkin, P. and Schmieder,
    G., 2005\. Alice in Switzerland: The life and mathematics of Alice Roth. The Mathematical
    Intelligencer, 27(1), pp.41-54*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '在数学中，可以在以下传记文章中找到关于瑞士奶酪的更详细的历史：*Daepp,U., Gauthier, P., Gorkin, P. and Schmieder,
    G., 2005\. Alice in Switzerland: The life and mathematics of Alice Roth. The Mathematical
    Intelligencer, 27(1), pp.41-54*。'
- en: Finding interior points
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找内部点
- en: One problem with working with two-dimensional figures in a programming environment
    is that you can't possibly store all the points that lie within the figure. Instead,
    we usually store far fewer points that represent the figure in some way. In most
    cases, this will be a number of points (connected by lines) that describe the
    boundary of the figure. This is efficient in terms of memory and makes it easy
    to visualize them on screen using Matplotlib `Patches`, for example. However,
    this approach makes it more difficult to determine whether a point, or another
    figure, lies within a given figure. This is a crucial question in many geometric
    problems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程环境中处理二维图形的一个问题是，您不可能存储所有位于图形内的点。相反，我们通常存储表示图形的远少于的点。在大多数情况下，这将是一些点（通过线连接）来描述图形的边界。这在内存方面是有效的，并且可以使用Matplotlib`Patches`轻松在屏幕上可视化它们。但是，这种方法使确定点或其他图形是否位于给定图形内变得更加困难。这是许多几何问题中的一个关键问题。
- en: In this recipe, we will learn how to represent geometric figures and determine
    whether a point lies within a figure or not.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何表示几何图形并确定点是否位于图形内。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'For this recipe, we will need to import the `matplotlib` package (as a whole)
    as `mpl` and the `pyplot` module as `plt`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要将`matplotlib`包（整体）导入为`mpl`，将`pyplot`模块导入为`plt`：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also need to import the `Point` and `Polygon` objects from the `geometry`
    module of the Shapely package. The Shapely package contains many routines and
    objects for representing, manipulating, and analyzing two-dimensional geometric
    figures:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从Shapely包的`geometry`模块中导入`Point`和`Polygon`对象。Shapely包包含许多用于表示、操作和分析二维几何图形的例程和对象：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps show you how to create a Shapely representation of a polygon
    and then test whether a point lies within this polygon:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示如何创建多边形的Shapely表示，然后测试点是否位于此多边形内：
- en: 'Create a sample polygon to test:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个样本多边形进行测试：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we plot the polygon on a new figure. First, we need to convert the polygon
    into a Matplotlib `Polygon` patch that can be added to the figure:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在新图上绘制多边形。首先，我们需要将多边形转换为可以添加到图中的Matplotlib`Polygon`补丁：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to create two test points, one of which will be inside the polygon
    and one of which will be outside the polygon:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建两个测试点，其中一个将位于多边形内，另一个将位于多边形外：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We plot and annotate these two points on top of the polygon to show their positions:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在多边形上方绘制并注释这两个点，以显示它们的位置：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we test where each point lies within the polygon using the `contains`
    method, and then print the result to the Terminal:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`contains`方法测试每个点是否位于多边形内，然后将结果打印到终端：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results show that the first point, `p1`, is contained in the polygon, while
    the second point, `p2`, is not. This can also be seen in the following figure,
    which clearly shows that one point is contained within the shaded polygon, while
    the other point is not:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，第一个点`p1`包含在多边形内，而第二个点`p2`不包含。这也可以在下图中看到，清楚地显示了一个点包含在阴影多边形内，而另一个点不包含：
- en: '![](assets/986dab1f-d3fe-4f7f-bd62-c1f3be844745.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/986dab1f-d3fe-4f7f-bd62-c1f3be844745.png)'
- en: 'Figure 8.2: Points inside and outside a polygonal region'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：多边形区域内外的点
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '工作原理... '
- en: The Shapely `Polygon` class is a representation of a polygon that stores its
    vertices as points. The region enclosed by the outer boundary – the five straight
    lines between the stored vertices – is obvious to us and easily identified by
    the eye, but the notion of being "inside" the boundary is difficult to define
    in a way that can be easily understood by a computer. It is not even straightforward
    to give a formal mathematical definition of what it means to lie "within" a given
    curve.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely`Polygon`类是多边形的表示，它将其顶点存储为点。外边界包围的区域-存储顶点之间的五条直线-对我们来说是明显的，并且很容易被眼睛识别，但是“在”边界内的概念很难以一种计算机容易理解的方式定义。甚至很难给出关于“在”给定曲线内的含义的正式数学定义。
- en: There are two main ways to determine whether a point lies within a simple closed
    curve – that is, a curve that starts and ends at the same place that does not
    contain any self-intersections. The first uses a mathematical concept called the
    *winding number*, which counts the number of times the curve "wraps around" a
    point, and the *ray crossing counting* method, where we count the number of times
    a ray from the point to a point at infinity crosses the curve. Fortunately, we
    don't need to compute these numbers ourselves since we can use the tools from
    the Shapely package to do this computation for us. This is what the `contains`
    method of a polygon does. (Under the hood, Shapely uses the GEOS library to perform
    this calculation.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确定点是否位于简单闭合曲线内有两种主要方法 - 即从同一位置开始并结束且不包含任何自交点的曲线。第一种方法使用数学概念称为*绕数*，它计算曲线“绕”点的次数，以及*射线交叉计数*方法，其中我们计算从点到无穷远处的点的射线穿过曲线的次数。幸运的是，我们不需要自己计算这些数字，因为我们可以使用Shapely包中的工具来为我们执行这些计算。这就是多边形的`contains`方法所做的。（在底层，Shapely使用GEOS库执行此计算。）
- en: The Shapely `Polygon` class can be used to compute many quantities associated
    with these planar figures, including perimeter length and area. The `contains`
    method is used to determine whether a point, or a collection of points, lies within
    the polygon represented by the object. (There are some limitations regarding the
    kinds of polygons that can be represented by this class.) In fact, you can use
    the same method to determine whether one polygon is contained within another since,
    as we have seen in this recipe, a polygon is represented by a simple collection
    of points.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely的`Polygon`类可用于计算与这些平面图形相关的许多数量，包括周长和面积。`contains`方法用于确定点或一组点是否位于对象表示的多边形内（该类有关多边形的表示存在一些限制）。实际上，您可以使用相同的方法来确定一个多边形是否包含在另一个多边形内，因为正如我们在这个示例中看到的，多边形由一组简单的点表示。
- en: Finding edges in an image
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中找到边缘
- en: Finding edges in images is a good way of reducing a complex image that contains
    a lot of noise and distractions to a very simple image containing the most prominent
    outlines. This can be useful as our first step of the analysis process, such as
    in image classification, or as the process of importing line outlines into computer
    graphics software packages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中找到边缘是减少包含大量噪音和干扰的复杂图像为包含最突出轮廓的非常简单图像的好方法。这可以作为我们分析过程的第一步，例如在图像分类中，或者作为将线轮廓导入计算机图形软件包的过程。
- en: In this recipe, we will learn how to use the `scikit-image` package and the
    Canny algorithm to find the edges in a complex image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用`scikit-image`包和Canny算法来找到复杂图像中的边缘。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need to import the Matplotlib `pyplot` module as `plt`,
    the `imread` routine from the `skimage.io` module, and the `canny` routine from
    the `skimage.feature` module:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要将Matplotlib的`pyplot`模块导入为`plt`，从`skimage.io`模块导入`imread`例程，以及从`skimage.feature`模块导入`canny`例程：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to learn how to use the `scikit-image` package to find edges
    in an image:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用`scikit-image`包在图像中找到边缘：
- en: 'Load the image data from the source file. This can be found in the GitHub repository
    for this chapter. Crucially, we pass in `as_gray=True` to load the image in grayscale:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源文件加载图像数据。这可以在本章的GitHub存储库中找到。关键是，我们传入`as_gray=True`以以灰度加载图像：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the original image, for reference. The set itself is shown
    by the white region and, as you can see, the boundary, indicated by the darker
    shades, is very complex:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是原始图像，供参考。集合本身由白色区域显示，如您所见，边界由较暗的阴影表示，非常复杂：
- en: '![](assets/6d107141-bb61-4843-8ca0-d1a230b5eac4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d107141-bb61-4843-8ca0-d1a230b5eac4.png)'
- en: 'Figure 8.3: Plot of the Mandelbrot set generated using Python'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：使用Python生成的Mandelbrot集合的绘图
- en: 'Next, we use the `canny` routine, which needs to be imported from the `features`
    module of the `scikit-image` package. The `sigma` value is set to 0.5 for this
    image:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`canny`例程，需要从`scikit-image`包的`features`模块导入。对于这个图像，`sigma`值设置为0.5：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we add the `edges` image to a new figure with a grayscale (reversed)
    colormap:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`edges`图像添加到一个新的图中，使用灰度（反转）色图：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The edges that have been detected can be seen in the following image. The edge-finding
    algorithm has identified most of the visible details of the boundary of the Mandelbrot
    set, although it is not perfect (this is an estimate, after all):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 已检测到的边缘可以在以下图像中看到。边缘查找算法已经识别出Mandelbrot集合边界的大部分可见细节，尽管并不完美（毕竟这只是一个估计）：
- en: '![](assets/347a3855-99bf-42f3-bcd7-19d0ec8fc398.png)Figure 8.4: The edges of
    the Mandelbrot set found using the scikit-image package''s Canny edge detection
    algorithm'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/347a3855-99bf-42f3-bcd7-19d0ec8fc398.png)图8.4：使用scikit-image包的Canny边缘检测算法找到的Mandelbrot集合的边缘'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `scikit-image` package provides various utilities and types for manipulating
    and analyzing data derived from images. As the name suggests, the `canny` routine
    uses the Canny edge detection algorithm to find edges in an image. This algorithm
    uses the intensity gradients in the image to detect edges, where the gradient
    is larger. It also performs some filtering to reduce the noise in the edges it
    finds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`scikit-image`包提供了各种用于操作和分析从图像中导出的数据的实用程序和类型。正如其名称所示，`canny`例程使用Canny边缘检测算法来找到图像中的边缘。该算法使用图像中的强度梯度来检测边缘，其中梯度较大。它还执行一些过滤以减少它找到的边缘中的噪音。'
- en: The `sigma` keyword value we provided is the standard deviation of the Gaussian
    smoothing that's applied to the image prior to calculating the gradients for edge
    detection. This helps us remove some of the noise from the image. The value we
    set (0.5) is smaller than the default (1), but it does give us better resolution
    in this case. A large value would obscure some of the finer details in the boundary
    of the Mandelbrot set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的`sigma`关键字值是应用于图像的高斯平滑的标准偏差，用于计算边缘检测。这有助于我们去除图像中的一些噪音。我们设置的值（0.5）小于默认值（1），但在这种情况下可以提供更好的分辨率。较大的值会遮盖Mandelbrot集边界的一些细节。
- en: Triangulating planar figures
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对平面图形进行三角剖分
- en: As we saw in [Chapter 3](1a62e7c6-06f5-4ee3-8f63-5bb14f6db553.xhtml), *Calculus
    and Differential Equations*, we often need to break down a continuous region into
    smaller, simpler regions. In earlier recipes, we reduced an interval of real numbers
    into a collection of smaller intervals, each with a small length. This process
    is usually called **discretization**. In this chapter, we are working with two-dimensional
    figures, so we need a two-dimensional version of this process. For this, we'll
    break a two-dimensional figure (in this recipe, a polygon) into a collection of
    smaller and simpler polygons. The simplest of all polygons are triangles, so this
    is a good place to start for two-dimensional discretization. The process of finding
    a collection of triangles that "tiles" a geometric figure is called *triangulation*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](1a62e7c6-06f5-4ee3-8f63-5bb14f6db553.xhtml)中看到的，*微积分和微分方程*，我们经常需要将连续区域分解为更小、更简单的区域。在之前的示例中，我们将实数区间缩小为一系列长度较小的小区间。这个过程通常称为**离散化**。在本章中，我们正在处理二维图形，因此我们需要这个过程的二维版本。为此，我们将一个二维图形（在这个示例中是一个多边形）分解为一系列更小和更简单的多边形。所有多边形中最简单的是三角形，因此这是二维离散化的一个很好的起点。找到一组"铺砌"几何图形的三角形的过程称为*三角剖分*。
- en: In this recipe, we will learn how to triangulate a polygon (with a hole) using
    the Shapely package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用Shapely包对多边形（带有孔）进行三角剖分。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要将NumPy包导入为`np`，将Matplotlib包导入为`mpl`，并将`pyplot`模块导入为`plt`。
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also need the following items from the Shapely package:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从Shapely包中获取以下项目：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you how to triangulate a polygon with a hole using
    the Shapely package:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示了如何使用Shapely包对带有孔的多边形进行三角剖分：
- en: 'First, we need to create a `Polygon` object that represents the figure that
    we wish to triangulate:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个代表我们希望进行三角剖分的图形的`Polygon`对象：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we should plot the figure so that we can understand the region that we
    will be working within:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该绘制图形，以便了解我们将在其中工作的区域：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This polygon can be seen in the following image. As we can see, the figure
    has a "hole" in it that must be carefully considered:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在下图中看到这个多边形。正如我们所看到的，这个图形中有一个"孔"，必须仔细考虑：
- en: '![](assets/38ff179a-35af-43ac-bae1-da8027ddc87c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/38ff179a-35af-43ac-bae1-da8027ddc87c.png)'
- en: 'Figure 8.5: Sample polygon but with a hole'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：带有孔的示例多边形
- en: 'We use the `triangulate` routine to generate a triangulation of the polygon.
    This triangulation includes external edges, which is something we don''t want
    in this recipe:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`triangulate`例程生成多边形的三角剖分。这个三角剖分包括外部边缘，这是我们在这个示例中不想要的：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To remove the triangles that lie outside the original polygon, we need to use
    the built-in `filter` routine, along with the `contains` method (seen earlier
    in this chapter):'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了去除位于原始多边形外部的三角形，我们需要使用内置的`filter`例程，以及`contains`方法（在本章前面已经看到）：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To plot the triangles on top of the original polygon, we need to convert the
    Shapely triangles into Matplotlib `Patch` objects, which we store in a `PatchCollection`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三角形绘制在原始多边形上，我们需要将Shapely三角形转换为Matplotlib `Patch`对象，然后将其存储在`PatchCollection`中：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we add the collection of triangular patches to the figure we created
    earlier:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将三角形补丁的集合添加到之前创建的图形中：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The triangulation that''s been plotted on top of the original polygon can be
    seen in the following figure. Here, we can see that every vertex has been connected
    to two others to form a system of triangles that cover the entire original polygon:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始多边形上绘制的三角剖分可以在下图中看到。在这里，我们可以看到每个顶点都连接到另外两个顶点，形成了覆盖整个原始多边形的三角形系统：
- en: '![](assets/b0ca0510-f765-40e0-b147-23a9e82355b2.png)Figure 8.6: Triangulation
    of a sample polygon with a hole'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b0ca0510-f765-40e0-b147-23a9e82355b2.png)图8.6：带有孔的示例多边形的三角剖分'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `triangulate` routine uses a technique called *Delaunay triangulation* to
    connect a collection of points to a system of triangles. In this case, the collection
    of points are the vertices of the polygon. The Delaunay method finds these triangles
    in such a way that none of the points are contained within the circumcircle of
    any of the triangles. This is a technical condition of the method, but it means
    that the triangles are chosen efficiently, in the sense that it avoids very long,
    thin triangles. The resulting triangulation makes use of the edges that are present
    in the original polygon and also connects some of the external edges.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangulate`例程使用一种称为*Delaunay三角剖分*的技术将一组点连接到一组三角形中。在这种情况下，这组点是多边形的顶点。Delaunay方法以这样一种方式找到这些三角形，即没有任何点包含在任何三角形的外接圆内。这是该方法的技术条件，但这意味着三角形被有效地选择，因为它避免了非常长、细的三角形。得到的三角剖分利用了原始多边形中存在的边缘，并连接了一些外部边缘。'
- en: In order to remove the triangles that lie outside of the original polygon, we
    use the built-in `filter` routine, which creates a new iterable by removing the
    items that the criterion function fails under. This is used in conjunction with
    the `contains` method on Shapely `Polygon` objects to determine whether each triangle
    lies within the original figure. As we mentioned previously, we need to convert
    these Shapely items into Matplotlib patches before they can be added to the plot.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了去除原多边形外的三角形，我们使用内置的`filter`例程，它通过移除标准函数失败的项目来创建一个新的可迭代对象。这与Shapely `Polygon`对象上的`contains`方法一起使用，以确定每个三角形是否位于原始图形内。正如我们之前提到的，我们需要将这些Shapely项目转换为Matplotlib补丁，然后才能将它们添加到图中。
- en: There's more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Triangulations are usually used to reduce a complex geometric figure into a
    collection of triangles, which are much simpler, for some kind of computational
    task. However, they do have other uses. One particularly interesting application
    of triangulations is to solve the "art gallery problem". This problem concerns
    finding the maximum number of guards that are necessary to "guard" an art gallery
    of a particular shape. Triangulations are an essential part of Fisk's simple proof
    of the art gallery theorem, which was originally proved by Chvátal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 三角剖分通常用于将复杂的几何图形简化为一组三角形，这些三角形对于某种计算任务来说要简单得多。然而，它们也有其他用途。三角剖分的一个特别有趣的应用是解决“艺术画廊问题”。这个问题涉及找到必要的“守卫”艺术画廊的最大数量。三角剖分是Fisk对艺术画廊定理的简单证明的重要部分，这个定理最初是由Chvátal证明的。
- en: 'Suppose that the polygon from this recipe is the floor plan for an art gallery
    and that some guards need to be placed on the vertices. A small amount of work
    will show that you''ll need three guards to be placed at the polygon''s vertices
    for the whole museum to be covered. In the following image, we have plotted one
    possible arrangement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个食谱中的多边形是一个艺术画廊的平面图，并且一些守卫需要放置在顶点上。一点工作就会表明，你需要在多边形的顶点处放置三个守卫，整个博物馆才能被覆盖。在下面的图像中，我们绘制了一个可能的布局：
- en: '![](assets/267a0779-deb3-449c-b481-3cde9a5ce205.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/267a0779-deb3-449c-b481-3cde9a5ce205.png)'
- en: 'Figure 8.7: One possible solution to the art gallery problem where guards are
    placed on vertices.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：在顶点上放置守卫的艺术画廊问题的一个可能解决方案。
- en: The guards are indicated by the dots, and their corresponding field of vision
    is shaded.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 点由点表示，并且它们相应的视野范围被阴影表示。
- en: One guard is placed at each of the vertices with a circle, and their field is
    vision is denoted by the corresponding shaded area. Here, you can see that the
    whole polygon is covered by at least one color. The solution to the art gallery
    problem – which is actually a variation of the original problem – tells us that
    we need, at most, four guards.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点都放置了一个守卫，并且他们的视野范围由相应的阴影区域表示。在这里，你可以看到整个多边形至少被一种颜色覆盖。艺术画廊问题的解决方案——实际上是原问题的一个变体——告诉我们，最多需要四名守卫。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'More information about the art gallery problem can be found in the classic
    book by O''Rourke: *ORourke, J. (1987). Art gallery theorems and algorithms. New
    York: Oxford University Press.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '关于艺术画廊问题的更多信息可以在O''Rourke的经典著作中找到：*ORourke, J. (1987). Art gallery theorems
    and algorithms. New York: Oxford University Press.*'
- en: Computing convex hulls
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算凸包
- en: A geometric figure is said to be *convex* if every pair of points within the
    figure can be joined using a straight line that is also contained within the figure.
    Simple examples of convex bodies include points, straight lines, squares, circles
    (disks), regular polygons, and so on. The geometric figure shown in *Figure 8.5*
    is not convex since the points on the opposite sides of the hole cannot be connected
    by a straight line that remains inside the figure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图形内的每一对点都可以使用一条直线连接，并且这条直线也包含在图形内，那么几何图形被称为*凸*。凸体的简单例子包括点、直线、正方形、圆（圆盘）、正多边形等。图8.5中显示的几何图形不是凸的，因为孔的对面的点不能通过保持在图形内的直线连接起来。
- en: Convex figures are simple from a certain perspective, which means they are useful
    in a variety of applications. One particular problem involves finding the smallest
    convex set that contains a collection of points. This smallest convex set is called
    the *convex hull* of the set of points.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来看，凸图形是简单的，这意味着它们在各种应用中都很有用。一个特别的问题涉及找到包含一组点的最小凸集。这个最小凸集被称为这组点的*凸包*。
- en: In this recipe, we'll learn how to find the convex hull of a set of points using
    the Shapely package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用Shapely包找到一组点的凸包。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们需要导入NumPy包作为`np`，导入Matplotlib包作为`mpl`，并导入`plt`模块：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will also need a default random number generator from NumPy. We can import
    this as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从NumPy导入默认的随机数生成器。我们可以这样导入：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we will need to import the `MultiPoint` class from Shapely:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要从Shapely导入`MultiPoint`类：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'Follow these steps to find the convex hull of a collection of randomly generated
    points:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤找到一组随机生成点的凸包：
- en: 'First, we generate a two-dimensional array of random numbers:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们生成一个二维数组的随机数：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create a new figure and plot these raw sample points on this figure:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新图形，并在这个图形上绘制这些原始样本点：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These randomly generated points can be seen in the following figure. The points
    are roughly spread over a square region:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些随机生成的点可以在下图中看到。这些点大致分布在一个正方形区域内：
- en: '![](assets/a5d0f401-8381-489e-915c-cb61b0cf5d5f.png)Figure 8.8: A collection
    of points in the plane'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a5d0f401-8381-489e-915c-cb61b0cf5d5f.png)图8.8：平面上的一组点'
- en: 'Next, we construct a `MultiPoint` object that collects all these points and
    put them into a single object:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个`MultiPoint`对象，收集所有这些点并将它们放入一个单一对象中：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we get the convex hull of this `MultiPoint` object using the `convex_hull`
    attribute:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`convex_hull`属性获取这个`MultiPoint`对象的凸包：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we create a Matplotlib `Polygon` patch that can be plotted on our figure
    to show the result of finding the convex hull:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个Matplotlib`Polygon`补丁，可以在我们的图中绘制，以显示找到的凸包的结果：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we add the `Polygon` patch to the figure to show the convex hull:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，我们将`Polygon`补丁添加到图中，以显示凸包： '
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The convex hull of the randomly generated points can be seen in the following
    image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成的点的凸包可以在下图中看到：
- en: '![](assets/1e11e76a-2124-4912-8fbb-b0b5b4ce95a8.png)Figure 8.9: The convex
    hull of a collection of points in the plane'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1e11e76a-2124-4912-8fbb-b0b5b4ce95a8.png)图8.9：平面上一组点的凸包'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Shapely package is a Python wrapper around the GEOS library for geometric
    analysis. The `convex_hull` attribute of Shapely geometric objects calls the convex
    hull computation routine from the GEOS library, resulting in a new Shapely object.
    From this recipe, we can see that the convex hull of the collection of points
    is a polygon with vertices at the points that are farthest away from the "center".
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely包是围绕GEOS库的Python包装器，用于几何分析。Shapely几何对象的`convex_hull`属性调用GEOS库中的凸包计算例程，从而产生一个新的Shapely对象。从这个教程中，我们可以看到一组点的凸包是一个多边形，其顶点是离“中心”最远的点。
- en: Constructing Bezier curves
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造贝塞尔曲线
- en: '*Bezier curves*, or *B-splines*, are a family of curves that are extremely
    useful in vector graphics – for instance, they are commonly used in high-quality
    font packages. This is because they are defined by a small number of points that
    can then be used to inexpensively calculate a large number of points along the
    curve. This allows detail to be scaled according to the needs of the user.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*贝塞尔曲线*，或*B样条*，是一族曲线，在矢量图形中非常有用-例如，它们通常用于高质量的字体包中。这是因为它们由少量点定义，然后可以用来廉价地计算沿曲线的大量点。这允许根据用户的需求来缩放细节。'
- en: In this recipe, we'll learn how to create a simple class representing a Bezier
    curve and compute a number of points along it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何创建一个表示贝塞尔曲线的简单类，并计算沿其路径的若干点。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, and the `comb` routine from the Python Standard
    Library `math` module, imported under the alias `binom`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用导入为`np`的NumPy包，导入为`plt`的Matplotlib `pyplot`模块，以及Python标准库`math`模块中导入为`binom`的`comb`例程：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to define a class that represents a Bezier curve that can
    be used to compute points along the curve:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤定义一个表示贝塞尔曲线的类，该类可用于计算沿曲线的点：
- en: 'The first step is to set up the basic class. We need to provide the control
    points (nodes) and some associated numbers to instance attributes:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置基本类。我们需要为实例属性提供控制点（节点）和一些相关的数字：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Still inside the `__init__` method, we generate the coefficients for the Bezier
    curve and store them in a list on an instance attribute:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`__init__`方法中，我们生成贝塞尔曲线的系数，并将它们存储在实例属性的列表中：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we define a `__call__` method to make the class callable. We load the
    number of nodes from the instance into a local variable for clarity:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`__call__`方法，使类可调用。我们将实例中的节点数加载到本地变量中，以便清晰明了：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we reshape the input array so that it contains a single row:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重新整理输入数组，使其包含单行：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we generate a list of arrays of values using each of the coefficients
    in the `coeffs` attribute for the instance:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用实例的`coeffs`属性中的每个系数生成值数组的列表：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we sum all the arrays that were constructed in *step 5* and return
    the resulting array:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对*步骤5*中构造的所有数组进行求和，并返回结果数组：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we will test our class by means of an example. We''ll define four control
    points for this example:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过一个示例来测试我们的类。我们将为此示例定义四个控制点：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we set up a new figure for plotting and plot the control points with
    a dashed connecting line:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为绘图设置一个新的图形，并用虚线连接线绘制控制点：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we create a new instance of our `Bezier` class using the four points
    we defined in *step 7*:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用*步骤7*中定义的四个点创建我们的`Bezier`类的新实例：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now create an array of equally spaced points between 0 and 1 using `linspace`
    and compute the points along the Bezier curve:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`linspace`创建0到1之间等间距点的数组，并计算沿着贝塞尔曲线的点：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we plot this curve on top of the control points that we plotted earlier:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在之前绘制的控制点上绘制这条曲线：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Bezier curve that we''ve plotted can be seen in the following diagram.
    As you can see, the curve starts at the first point (0, 0) and finishes at the
    final point (1, 3):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制的贝塞尔曲线可以在下图中看到。正如你所看到的，曲线从第一个点（0, 0）开始，结束于最终点（1, 3）：
- en: '![](assets/c99f6f7e-92bd-41b2-ad90-1825adbf5281.png)Figure 8.10: Bezier curve
    of degree 3 constructed using four nodes'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c99f6f7e-92bd-41b2-ad90-1825adbf5281.png)图8.10：使用四个节点构造的三次贝塞尔曲线'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'A Bezier curve is described by a sequence of control points, from which we
    construct the curve in a recursive manner. A Bezier curve with one point is a
    constant curve that stays at that point. A Bezier curve with two control points
    is a line segment between those two points:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线由一系列控制点描述，我们以递归方式构造曲线。一个点的贝塞尔曲线是一个保持在该点的常数曲线。具有两个控制点的贝塞尔曲线是这两个点之间的线段：
- en: '![](assets/7831c8c4-15ee-4b9b-9510-6984e970b044.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7831c8c4-15ee-4b9b-9510-6984e970b044.png)'
- en: 'When we add a third control point, we take the line segment between the corresponding
    points on the Bezier curve of curves that are constructed with one less point.
    This means that we construct the Bezier curve with three control points using
    the following formula:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加第三个控制点时，我们取对应点之间的线段，这些点是由一个较少点构成的贝塞尔曲线的曲线。这意味着我们使用以下公式构造具有三个控制点的贝塞尔曲线：
- en: '![](assets/073ba1c8-7fa9-44af-b3fd-ac9851a2c20f.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/073ba1c8-7fa9-44af-b3fd-ac9851a2c20f.png)'
- en: 'This construction can be seen in the following diagram:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造可以在下图中看到：
- en: '![](assets/5a5c45d4-8528-4e6e-b677-9358fa883cf8.png)Figure 8.11: Construction
    of a quadratic Bezier curve using a recursive definition. The two linear Bezier
    curves are shown by the black dashed lines.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5a5c45d4-8528-4e6e-b677-9358fa883cf8.png)图8.11：使用递归定义构造二次贝塞尔曲线。黑色虚线显示了两条线性贝塞尔曲线。'
- en: 'The construction continues in this manner to define the Bezier curve on any
    number of control points. Fortunately, we don''t need to work with this recursive
    definition in practice because we can flatten the formulae into a single formula
    for the curve, which is given by the following formula:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造方式继续定义了任意数量控制点上的贝塞尔曲线。幸运的是，在实践中我们不需要使用这种递归定义，因为我们可以将公式展开成曲线的单一公式，即以下公式：
- en: '![](assets/9674263f-1838-4821-9319-4120c125c796.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9674263f-1838-4821-9319-4120c125c796.png)'
- en: Here, the **p**[*i*] elements are the control points, *t* is a parameter, and
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**p**[*i*]元素是控制点，*t*是一个参数，而
- en: '![](assets/b65b100a-f769-42f8-bc75-dc5b79d02475.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b65b100a-f769-42f8-bc75-dc5b79d02475.png)'
- en: 'is the binomial coefficient. Remember that the *t* parameter is the quantity
    that is changing to generate the points of the curve. We can isolate the terms
    in the previous sum that involve *t* and those that do not. This defines the coefficients
    that we defined in *step 2*, each of which are given by the following code fragment:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 是二项式系数。请记住，*t*参数是生成曲线点的变化量。我们可以分离前述求和中涉及*t*的项和不涉及*t*的项。这定义了我们在*步骤2*中定义的系数，每个系数由以下代码片段给出：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We reshape each of the points, `p`, in this step to make sure it is arranged
    as a column vector. This means that each of the coefficients is a column vector
    (as a NumPy array) consisting of the control points scaled by the binomial coefficients.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一步中对每个点`p`进行了reshape，以确保它被排列为列向量。这意味着每个系数都是一个列向量（作为NumPy数组），由二项式系数缩放的控制点组成。
- en: 'Now, we need to specify how to evaluate the Bezier curve at various values
    of *t*. This is where we make use of the high-performance array operations from
    the NumPy package. We reshaped our control points as column vectors when forming
    our coefficients. In *step 4*, we reshaped the input, *t*, values to make a row
    vector. This means that we can use the matrix multiplication operator to multiply
    each coefficient by the corresponding (scalar) value, depending on the input,
    *t*. This is what happens in *step 5*, inside the list comprehension. In the following
    line, we multiply the *l × 1* array by the *1 × N* array to obtain an *l × N*
    array:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要指定如何在不同的*t*值上评估贝塞尔曲线。这就是我们利用NumPy包中的高性能数组操作的地方。在形成系数时，我们将控制点reshape为列向量。在*步骤4*中，我们将输入*t*值reshape为行向量。这意味着我们可以使用矩阵乘法运算符将每个系数乘以相应的（标量）值，具体取决于输入的*t*。这就是*步骤5*中列表推导式中发生的情况。在下一行中，我们将*l×1*数组乘以*1×N*数组，得到一个*l×N*数组：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We get one of these for each coefficient. We can then use the `np.sum` routine
    to sum each of these *l × N* arrays to get the values along the Bezier curve.
    In the example provided in this recipe, the top row of the output array contains
    the *x* values of the curve and the bottom row contains the *y* values of the
    curve. We have to be careful when specifying the `axis=0` keyword argument for
    the `sum` routine to make sure the sum takes over the list we created, and not
    the arrays that this list contains.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个系数都得到一个这样的数组。然后，我们可以使用`np.sum`例程来对这些*l×N*数组中的每一个进行求和，以得到贝塞尔曲线上的值。在本示例中，输出数组的顶行包含曲线的*x*值，底行包含曲线的*y*值。在指定`axis=0`关键字参数时，我们必须小心确保`sum`例程对我们创建的列表进行求和，而不是对该列表包含的数组进行求和。
- en: The class we defined is initialized using the control points for the Bezier
    curve, which are then used to generate the coefficients. The actual computation
    of the curve values is done using NumPy, so this implementation should have relatively
    good performance. Once a specific instance of this class has been created, it
    functions very much like a function, as you might expect. However, no type checking
    is done here, so we can only call this "function" with a NumPy array as an argument.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的类是使用贝塞尔曲线的控制点进行初始化的，然后用于生成系数。曲线值的实际计算是使用NumPy完成的，因此这种实现应该具有相对良好的性能。一旦创建了这个类的特定实例，它的功能就非常像一个函数，正如你所期望的那样。但是，这里没有进行类型检查，所以我们只能用NumPy数组作为参数来调用这个“函数”。
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Bezier curves are defined using an iterative construction, where the curve with
    *n* points is defined using the straight line connecting the curves defined by
    the first and last *n-1* points. Keeping track of the coefficient of each of the
    control points using this construction will quickly lead you to the equation we
    used to define the preceding curve. This construction also leads to interesting
    – and useful – geometric properties of Bezier curves.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线是使用迭代构造定义的，其中具有*n*个点的曲线是使用连接由第一个和最后一个*n-1*点定义的曲线来定义的。使用这种构造跟踪每个控制点的系数将很快导致我们用来定义前述曲线的方程。这种构造还导致贝塞尔曲线的有趣和有用的几何特性。
- en: As we mentioned in the introduction to this recipe, Bezier curves appear in
    many applications that involve vector graphics, such as fonts. They also appear
    in many common vector graphics software packages. In these software packages,
    it is common to see *quadratic Bezier curves*, which are defined by a collection
    of three points. However, you can also define a quadratic Bezier curve by supplying
    the two endpoints, along with the gradient lines, at those points. This is more
    common in graphics software packages. The resulting Bezier curve will leave each
    of the endpoints along the gradient lines and connect the curve smoothly between
    these points.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个配方的介绍中提到的，贝塞尔曲线出现在许多涉及矢量图形的应用程序中，比如字体。它们也出现在许多常见的矢量图形软件包中。在这些软件包中，通常会看到*二次贝塞尔曲线*，它们由三个点的集合定义。然而，你也可以通过提供两个端点以及这些点上的梯度线来定义一个二次贝塞尔曲线。这在图形软件包中更常见。生成的贝塞尔曲线将沿着梯度线离开每个端点，并在这些点之间平滑地连接曲线。
- en: The implementation we constructed here will have relatively good performance
    for small applications, but will not be sufficient for applications involving
    rendering curves with a large number of control points at a large number of *t*
    values. For this, it is best to use a low-level package written in a compiled
    language. For example, the `bezier` Python package uses a compiled Fortran backend
    for its computations and provides a much richer interface than the class we defined
    here.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的实现对于小型应用程序来说性能相对较好，但对于涉及在大量*t*值上渲染具有大量控制点的曲线的应用程序来说是不够的。对于这一点，最好使用一个用编译语言编写的低级软件包。例如，`bezier`
    Python软件包使用编译的Fortran后端进行计算，并提供比我们在这里定义的类更丰富的接口。
- en: Bezier curves can, of course, be extended to higher dimensions in a natural
    way. The result is a Bezier surface, which makes them very useful general-purpose
    tools for high-quality, scalable graphics.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，贝塞尔曲线可以自然地扩展到更高的维度。结果是一个贝塞尔曲面，使它们成为非常有用的通用工具，用于高质量、可伸缩的图形。
- en: Further reading
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A description of some common algorithms from computation geometry can be found
    in the following book: *Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery,
    B.P., 2007\. Numerical recipes: the art of scientific computing**. 3rd ed. Cambridge:
    Cambridge University Press*.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '计算几何中一些常见算法的描述可以在以下书籍中找到：*Press, W.H., Teukolsky, S.A., Vetterling, W.T., and
    Flannery, B.P., 2007\. Numerical recipes: the art of scientific computing**. 3rd
    ed. Cambridge: Cambridge University Press*。'
- en: 'For a more detailed account of some problems and techniques from computational
    geometry, check out the following book: *O''Rourke, J., 1994\. Computational geometry
    in C**. Cambridge: Cambridge University Press*.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '有关计算几何中一些问题和技术的更详细描述，请查阅以下书籍：*O''Rourke, J., 1994\. Computational geometry
    in C**. Cambridge: Cambridge University Press*。'
