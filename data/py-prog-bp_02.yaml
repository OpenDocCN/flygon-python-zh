- en: Creating a Remote-Control Application with Spotify
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spotify创建远程控制应用程序
- en: Spotify is a music streaming service that was developed in Stockholm, Sweden.
    The first version was released back in 2008 and today it doesn't only provide
    music, but video and podcasts as well. Growing rapidly from a startup in Sweden
    to the biggest music service in the world, Spotify has apps running on video game
    consoles and mobile phones, and has integration with many social networks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spotify是一家总部位于瑞典斯德哥尔摩的音乐流媒体服务。第一个版本于2008年发布，如今它不仅提供音乐，还提供视频和播客。Spotify从瑞典的初创公司迅速发展成为世界上最大的音乐服务，其应用程序在视频游戏机和手机上运行，并与许多社交网络集成。
- en: The company really has changed how we consume music and has also enabled not
    only well-known artists but small indie artists to share their music with the
    world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 该公司确实改变了我们消费音乐的方式，也使得不仅是知名艺术家，而且小型独立艺术家也能与世界分享他们的音乐。
- en: Luckily, Spotify is also a great platform for developers and provides a really
    nice and well-documented REST API where it's possible to make searches by artists,
    albums, song names, and also create and share playlists.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Spotify也是开发人员的绝佳平台，并提供了一个非常好的和有文档的REST API，可以通过艺术家、专辑、歌曲名称进行搜索，还可以创建和分享播放列表。
- en: 'For the second application in this book, we are going to develop a terminal
    application where we can:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二个应用程序中，我们将开发一个终端应用程序，其中我们可以：
- en: Search artists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索艺术家
- en: Search albums
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索专辑
- en: Search tracks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索曲目
- en: Play music
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音乐
- en: Apart from all these features, we are going to implement functions so we can
    control the Spotify application through the terminal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些功能之外，我们将实现一些函数，以便通过终端控制Spotify应用程序。
- en: First, we are going to go through the process of creating a new application
    on Spotify; then, it will be time to develop a small framework that will wrap
    some parts of Spotify's REST API. We are also going to work on implementing different
    types of authentication supported by Spotify, in order to consume its REST API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将经历在Spotify上创建新应用程序的过程；然后，将是开发一个小框架的时间，该框架将包装Spotify的REST API的某些部分。我们还将致力于实现Spotify支持的不同类型的身份验证，以便消耗其REST
    API。
- en: When all these core functionalities are in place, we are going to develop a
    terminal user interface using the `curses` package that is distributed with Python.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些核心功能都就位后，我们将使用Python附带的`curses`软件包来开发终端用户界面。
- en: 'In this chapter, you will learn:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to create a `Spotify` app
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建`Spotify`应用程序
- en: How to use `OAuth`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`OAuth`
- en: Object-oriented programming concepts
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的编程概念
- en: Using the popular package `Requests` to consume REST APIs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流行的`Requests`软件包来消耗REST API
- en: How to design terminal user interfaces using curses
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curses设计终端用户界面的方法
- en: I don't know about you, but I really feel like writing code and listening to
    some good music, so let's get right into it!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你们，但我真的很想写代码并听一些好听的音乐，所以让我们开始吧！
- en: Setting up the environment
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Let's go ahead and configure our development environment. The first thing we
    need to do is create a new virtual environment, so we can work and install the
    packages that we need without interfering with the global Python installation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续配置我们的开发环境。我们需要做的第一件事是创建一个新的虚拟环境，这样我们就可以工作并安装我们需要的软件包，而不会干扰全局Python安装。
- en: Our application will be called `musicterminal`, so we can create a virtual environment
    with the same name.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将被称为`musicterminal`，因此我们可以创建一个同名的虚拟环境。
- en: 'To create a new virtual environment, run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的虚拟环境，请运行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure that you are using Python 3.6 or later, otherwise the applications
    in this book may not work properly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用的是Python 3.6或更高版本，否则本书中的应用程序可能无法正常工作。
- en: 'And to activate the virtual environment, you can run the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活虚拟环境，可以运行以下命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Perfect! Now that we have our virtual environment set up, we can create the
    project''s directory structure. It should have the following structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经设置好了虚拟环境，我们可以创建项目的目录结构。它应该具有以下结构：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Like the application in the first chapter, we create a project directory (called `musicterminal` here)
    and a sub-directory also named `pytify`, which will contain the framework wrapping
    Spotify's REST API.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一章中的应用程序一样，我们创建一个项目目录（这里称为`musicterminal`）和一个名为`pytify`的子目录，其中将包含包装Spotify的REST
    API的框架。
- en: Inside the framework directory, we split `auth` into two modules which will
    contain implementations for two authentication flows supported by Spotify—authorization
    code and client credentials. Finally, the `core` module will contain all the methods
    to fetch data from the REST API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架目录中，我们将`auth`拆分为两个模块，这两个模块将包含Spotify支持的两种身份验证流程的实现——授权代码和客户端凭据。最后，`core`模块将包含从REST
    API获取数据的所有方法。
- en: The client directory will contain all the scripts related to the client application
    that we are going to build.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端目录将包含与我们将构建的客户端应用程序相关的所有脚本。
- en: Finally, the `templates` directory will contain some HTML files that will be
    used when we build a small Flask application to perform Spotify authentication.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`templates`目录将包含一些HTML文件，这些文件将在我们构建一个小的Flask应用程序来执行Spotify身份验证时使用。
- en: 'Now, let''s create a `requirements.txt` file inside the `musicterminal` directory
    with the following content:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`musicterminal`目录中创建一个`requirements.txt`文件，内容如下：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To install the dependencies, just run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装依赖项，只需运行以下命令：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](assets/c51878ae-cdd2-4c1c-aba5-a1fb2df3386e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c51878ae-cdd2-4c1c-aba5-a1fb2df3386e.png)'
- en: As you can see in the output, other packages have been installed in our virtual
    environment. The reason for this is that the packages that our project requires
    also require other packages, so they will also be installed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中所见，其他软件包已安装在我们的虚拟环境中。这是因为我们项目所需的软件包也需要其他软件包，因此它们也将被安装。
- en: Requests were created by Kenneth Reitz [https://www.kennethreitz.org/](https://www.kennethreitz.org/),
    and it is one of the most used and beloved packages in the Python ecosystem. It
    is used by large companies such as Microsoft, Google, Mozilla, Spotify, Twitter,
    and Sony, just to name a few, and it is Pythonic and really straight-forward to
    use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Requests是由Kenneth Reitz创建的[https://www.kennethreitz.org/](https://www.kennethreitz.org/)，它是Python生态系统中使用最广泛且备受喜爱的软件包之一。它被微软、谷歌、Mozilla、Spotify、Twitter和索尼等大公司使用，它是Pythonic且非常直观易用的。
- en: Check out other projects from Kenneth, especially the `pipenv` project, which
    is an awesome Python packaging tool.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Kenneth的其他项目，尤其是`pipenv`项目，这是一个很棒的Python打包工具。
- en: Another module that we are going to use is curses. The curses module is simply
    a wrapper over the curses C functions and it is relatively simpler to use than
    programming in C. If you worked with the curses C library before, the curses module
    in Python should be familiar and easy to learn.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的另一个模块是curses。curses模块只是curses C函数的包装器，相对于在C中编程，它相对简单。如果您之前使用过curses C库，那么Python中的curses模块应该是熟悉且易于学习的。
- en: One thing to note is that Python includes the curses module on Linux and Mac;
    however, it is not included by default on Windows. If you are running Windows,
    the curses documentation at [https://docs.python.org/3/howto/curses.html](https://docs.python.org/3/howto/curses.html)
    recommends the  UniCurses package developed by Fredrik Lundh.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，Python在Linux和Mac上包含curses模块；但是，在Windows上，默认情况下不包含它。如果您使用Windows，curses文档在[https://docs.python.org/3/howto/curses.html](https://docs.python.org/3/howto/curses.html)上推荐由Fredrik
    Lundh开发的UniCurses包。
- en: Just one more thing before we start coding. You can run into problems when trying
    to import curses; the most common cause is that the `libncurses` are not installed
    in your system. Make sure that you have `libncurses` and `libncurses-dev` installed
    on your system before installing Python.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，还有一件事。在尝试导入curses时，您可能会遇到问题；最常见的原因是您的系统中未安装`libncurses`。在安装Python之前，请确保您的系统上已安装`libncurses`和`libncurses-dev`。
- en: 'If you are using Linux, you will most likely find `libncurses` on the package
    repository of our preferred distribution. In Debian/Ubuntu, you can install it
    with the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Linux，您很可能会在我们首选发行版的软件包存储库中找到`libncurses`。在Debian/Ubuntu中，您可以使用以下命令安装它：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! Now, we are all set to start implementing our application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们已经准备好开始实施我们的应用程序了。
- en: Creating a Spotify app
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spotify应用程序
- en: The first thing we need to do is create a Spotify app; after that, we are going
    to get access keys so we can authenticate and consume the REST API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个Spotify应用程序；之后，我们将获取访问密钥，以便我们可以进行身份验证并使用REST API。
- en: 'Head over to [https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/)
    and further down on the page you can find the Login button, and if you don''t
    have an account, you can create a new one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/)，在页面下方您可以找到登录按钮，如果您没有帐户，可以创建一个新帐户。
- en: '![](assets/1557b618-e930-456a-bf79-f539bf015194.png)At the time of writing,
    Spotify started changing its developer''s site and was currently in beta, so the
    address to log in and some screenshots may be different.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1557b618-e930-456a-bf79-f539bf015194.png)在撰写本文时，Spotify开始更改其开发者网站，并且目前处于测试阶段，因此登录地址和一些截图可能会有所不同。'
- en: If you don't have a Spotify account, you will have to create one first. You
    should be able to create applications if you sign up for the free account, but
    I would recommend signing up for the premium account because it is a great service
    with a great music catalog.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有Spotify帐户，您首先需要创建一个。如果您注册免费帐户，应该能够创建应用程序，但我建议您注册高级帐户，因为它是一个拥有丰富音乐目录的优秀服务。
- en: 'When you log in to the Spotify developer website, you will see a page similar
    to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录Spotify开发者网站时，您将看到类似以下页面：
- en: '![](assets/d051e689-8f73-40a9-b6bf-7e005dc6fd66.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d051e689-8f73-40a9-b6bf-7e005dc6fd66.png)'
- en: 'At the moment, we don''t have any application created (unless you have already
    created one), so go ahead and click on the CREATE AN APP button. A dialog screen
    to create the application will be displayed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们还没有创建任何应用程序（除非您已经创建了一个），所以继续点击“CREATE AN APP”按钮。将显示一个对话框屏幕来创建应用程序：
- en: '![](assets/50e3e47c-e7b5-484f-8617-203af23e550a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50e3e47c-e7b5-484f-8617-203af23e550a.png)'
- en: 'Here, we have three required fields: the application''s name, description,
    and also some checkboxes where you will have to tell Spotify what you''re building.
    The name should be `pytify` and in the description, you can put anything you want,
    but let''s add something like `Application for controlling the Spotify client
    from the terminal`. The type of application we are building will be a website.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个必填字段：应用程序名称、描述，以及一些复选框，您需要告诉Spotify您正在构建什么。名称应该是`pytify`，在描述中，您可以随意填写，但让我们添加类似“用于从终端控制Spotify客户端的应用程序”的内容。我们正在构建的应用程序类型将是网站。
- en: When you are done, click on the NEXT button at the bottom of the dialog screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击对话框屏幕底部的“NEXT”按钮。
- en: The second step in the application's creation process is to inform Spotify whether
    you are creating a commercial integration. For the purposes of this book, we are
    going to select **NO**; however, if you are going to create an application that
    will monetize, you should definitely select **YES**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建过程的第二步是告知Spotify您是否正在创建商业集成。对于本书的目的，我们将选择**NO**；但是，如果您要创建一个将实现货币化的应用程序，您应该选择**YES**。
- en: 'In the next step, the following dialog will be displayed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，将显示以下对话框：
- en: '![](assets/0f932dc3-70ea-4696-91e7-7ddc19dd3cef.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0f932dc3-70ea-4696-91e7-7ddc19dd3cef.png)'
- en: If you agree with all the conditions, just select all the checkboxes and click
    the SUBMIT button.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您同意所有条件，只需选择所有复选框，然后点击“SUBMIT”按钮。
- en: 'If the application has been created successfully, you will be redirected to
    the application''s page, which is shown as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序已成功创建，您将被重定向到应用程序的页面，如下所示：
- en: '![](assets/ed9c9c57-1548-4c53-8414-9a973dc370df.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ed9c9c57-1548-4c53-8414-9a973dc370df.png)'
- en: Click on the SHOW CLIENT SECRET link and copy the values of the Client ID and
    the Client Secret. We are going to need these keys to consume Spotify's REST API.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“显示客户端密钥”链接，并复制客户端ID和客户端密钥的值。我们将需要这些密钥来使用Spotify的REST API。
- en: The application's configuration
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序的配置
- en: To make the application more flexible and easy to configure, we are going to
    create a configuration file. This way, we don't need to hardcode the URL and access
    keys; also, if we need to change these settings, changes in the source code will
    not be required.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序更灵活且易于配置，我们将创建一个配置文件。这样，我们就不需要硬编码URL和访问密钥；而且，如果需要更改这些设置，也不需要更改源代码。
- en: We are going to create a config file in the YAML format to store information
    that will be used by our application to authenticate, make requests to the Spotify
    RESP API endpoints, and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个YAML格式的配置文件，用于存储我们的应用程序用于认证、向Spotify RESP API端点发出请求等的信息。
- en: Creating a configuration file
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: 'Let''s go ahead and create a file called `config.yaml` in the `musicterminal`
    directory with the following contents:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`musicterminal`目录中创建一个名为`config.yaml`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`client_id` and `client_secret` are the keys that were created for us when
    we created the Spotify application. These keys will be used to get an access token
    that we will have to acquire every time we need to send a new request to Spotify''s
    REST API. Just replace the `<your client ID>` and `<your client secret>` with
    your own keys.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`client_id`和`client_secret`是我们创建Spotify应用程序时为我们创建的密钥。这些密钥将用于获取访问令牌，每次我们需要向Spotify的REST
    API发送新请求时都必须获取访问令牌。只需用您自己的密钥替换`<your client ID>`和`<your client secret>`。'
- en: Keep in mind that these keys have to be kept in a safe place. Don't share the
    keys with anyone and if you are having your project on sites like GitHub, make
    sure that you are not committing this configuration file with your secret keys.
    What I usually do is add the config file to my `.gitignore` file so it won't be
    source-controlled; otherwise, you can always commit the file as I did by presenting
    it with placeholders instead of the actual keys. That way, it will be easy to
    remember where you need to add the keys.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些密钥必须保存在安全的地方。不要与任何人分享密钥，如果您在GitHub等网站上有项目，请确保不要提交带有您的秘密密钥的配置文件。我通常会将配置文件添加到我的`.gitignore`文件中，这样它就不会被源代码控制；否则，您可以像我一样提交文件，使用占位符而不是实际密钥。这样，就很容易记住您需要在哪里添加密钥。
- en: After the `client_id` and `client_secret` keys, we have the `access_token_url`.
    This is the URL to the API endpoint that we have to perform requests on in order
    to get the access token.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client_id`和`client_secret`键之后，我们有`access_token_url`。这是我们必须执行请求的API端点的URL，以便获取访问令牌。
- en: '`auth_url` is the endpoint of Spotify''s Account Service; we will use it when
    we need to acquire or refresh an authorization token.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth_url`是Spotify的账户服务的端点；当我们需要获取或刷新授权令牌时，我们将使用它。'
- en: The `api_version`, as the name says, specifies Spotify's REST API version. This
    is appended to the URL when performing requests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`api_version`，顾名思义，指定了Spotify的REST API版本。在执行请求时，这将附加到URL上。'
- en: Lastly, we have the `api_url`, which is the base URL for Spotify's REST API
    endpoints.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`api_url`，这是Spotify的REST API端点的基本URL。
- en: Implementing a configuration file reader
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现配置文件读取器
- en: 'Before implementing the reader, we are going to add an enumeration to represent
    both kinds of authentication flow that Spotify provides us with. Let''s go ahead
    and create a file called `auth_method.py` in the `musicterminal/pytify/auth` directory
    with the following content:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现读取器之前，我们将添加一个枚举，表示Spotify提供给我们的两种认证流程。让我们继续在`musicterminal/pytify/auth`目录中创建一个名为`auth_method.py`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will define an enumeration with the `CLIENT_CREDENTIALS` and `AUTHORIZATION_CODE` properties.
    Now. we can use these values in the configuration file. Another thing we need
    to do is create a file called `__init__.py` in the `musicterminal/pytify/auth` directory
    and import the enumeration that we just created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义一个枚举，具有`CLIENT_CREDENTIALS`和`AUTHORIZATION_CODE`属性。现在，我们可以在配置文件中使用这些值。我们还需要做的另一件事是在`musicterminal/pytify/auth`目录中创建一个名为`__init__.py`的文件，并导入我们刚刚创建的枚举：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can continue and create the functions that will read the configuration
    for us. Create a file called `config.py` in the `musicterminal/pytify/core` directory,
    and let''s start by adding some import statements:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建将为我们读取配置的函数。在`musicterminal/pytify/core`目录中创建一个名为`config.py`的文件，然后让我们开始添加一些导入语句：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we import the `os` module so we can have access to functions that will
    help us in building the path where the YAML configuration file is located. We
    also import the `yaml` package to read the configuration file and, last but not
    least, we are importing `namedtuple` from the collections module. We will go into
    more detail about what `namedtuple` does later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`os`模块，这样我们就可以访问一些函数，这些函数将帮助我们构建YAML配置文件所在的路径。我们还导入`yaml`包来读取配置文件，最后，我们从collections模块导入`namedtuple`。稍后我们将更详细地讨论`namedtuple`的作用。
- en: The last thing we import is the `AuthMethod` enumeration that we just created
    in the `pytify.auth` module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后导入的是我们刚刚在`pytify.auth`模块中创建的`AuthMethod`枚举。
- en: 'Now, we need a model representing the configuration file, so we create a named
    tuple called `Config`, such as:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个表示配置文件的模型，因此我们创建一个名为`Config`的命名元组，如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `namedtuple` is not a new feature in Python and has been around since version
    2.6. `namedtuple`''s are tuple-like objects with a name and with fields accessible
    by attribute lookup. It is possible to create `namedtuple` in two different ways;
    let''s start Python REPL and try it out:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`不是Python中的新功能，自2.6版本以来一直存在。`namedtuple`是类似元组的对象，具有名称，并且可以通过属性查找访问字段。可以以两种不同的方式创建`namedtuple`；让我们开始Python
    REPL并尝试一下：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This construct gets two arguments; the first argument is the name of the `namedtuple`,
    and the second is an array of `str` elements representing every field in the `namedtuple`.
    It is also possible to specify the fields of the `namedtuple` by passing a string
    with every field name separated by a space, such as:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构有两个参数；第一个参数是`namedtuple`的名称，第二个是表示`namedtuple`中每个字段的`str`元素数组。还可以通过传递一个由空格分隔的每个字段名的字符串来指定`namedtuple`的字段，例如：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `namedtuple` constructor also has two keyword-arguments:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`构造函数还有两个关键字参数：'
- en: '`Verbose`, which, when set to `True`, displays the definition of the class
    that defines the `namedtuple` on the terminal. Behind the scenes, `namedtuple`''s are
    classes and the `verbose` keyword argument lets us have a sneak peek at how the
    `namedtuple` class is constructed. Let''s see this in practice on the REPL:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Verbose`，当设置为`True`时，在终端上显示定义`namedtuple`的类。在幕后，`namedtuple`是类，`verbose`关键字参数让我们一睹`namedtuple`类的构造方式。让我们在REPL上实践一下：'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The other keyword argument is `rename`, which will rename every property in
    the `namedtuple` that has an incorrect naming, for example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键字参数是`rename`，它将重命名`namedtuple`中具有不正确命名的每个属性，例如：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the field `23445` has been automatically renamed to `_3`, which
    is the field position.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字段`23445`已自动重命名为`_3`，这是字段位置。
- en: To access the `namedtuple` fields, you can use the same syntax when accessing
    properties in a class, using the `namedtuple` —`User` as shown in the preceding
    example. If we would like to access the `lastname` property, we can just write `u.lastname`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`namedtuple`字段，可以使用与访问类中的属性相同的语法，使用`namedtuple`——`User`，如前面的示例所示。如果我们想要访问`lastname`属性，只需写`u.lastname`。
- en: 'Now that we have the `namedtuple` representing our configuration file, it is
    time to add the function that will perform the work of loading the YAML file and
    returning the `namedtuple`—`Config`. In the same file, let''s implement the `read_config`
    function as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了代表我们配置文件的`namedtuple`，是时候添加执行加载YAML文件并返回`namedtuple`——`Config`的工作的函数了。在同一个文件中，让我们实现`read_config`函数如下：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `read_config` function starts off by using the `os.path.abspath` function
    to get the absolute path of the current directory, and assigns it to the `current_dir`
    variable. Then, we join the path stored on the `current_dir` variable with the
    name of the file, in this case, the YAML configuration file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_config`函数首先使用`os.path.abspath`函数获取当前目录的绝对路径，并将其赋给`current_dir`变量。然后，我们将存储在`current_dir`变量上的路径与文件名结合起来，即YAML配置文件。'
- en: inside the `try` statement, we try to open the file as read-only and set the
    encoding to UTF-8\. In the event this fails, it will print a help message to the
    user saying that it couldn't open the file and will show help describing how the
    YAML configuration file is structured.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`语句中，我们尝试以只读方式打开文件，并将编码设置为UTF-8。如果失败，将向用户打印帮助消息，说明无法打开文件，并显示描述YAML配置文件结构的帮助。
- en: If the configuration file can be read successfully, we call the load function
    in the `yaml` module to load and parse the file, and assign the results to the `config` variable.
    We also include an extra item in the config called `base_url`, which is just a
    helper value that contains the concatenated values of `api_url` and `api_version`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置文件可以成功读取，我们调用`yaml`模块中的load函数来加载和解析文件，并将结果赋给`config`变量。我们还在配置中包含了一个额外的项目`base_url`，它只是一个辅助值，包含了`api_url`和`api_version`的连接值。
- en: 'The value of the `base_url` will look something like this: [https://api.spotify.com/v1.](https://api.spotify.com/v1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`base_url`的值将如下所示：[https://api.spotify.com/v1.](https://api.spotify.com/v1)'
- en: 'Lastly, we create an instance of `Config`. Note how we spread the values in
    the constructor; this is possible because the `namedtuple`—`Config`, has the same
    fields as the object returned by `yaml.load()`. This would be exactly  the same
    as doing this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个`Config`的实例。请注意我们如何在构造函数中展开值；这是可能的，因为`namedtuple`——`Config`具有与`yaml.load()`返回的对象相同的字段。这与执行以下操作完全相同：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The final touch here is to create a `__init__.py` file in the `pytify/core`
    directory and import the `read_config` function that we just created:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`pytify/core`目录中创建一个`__init__.py`文件，并导入我们刚刚创建的`read_config`函数：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Authenticating with Spotify's web API
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spotify的Web API进行身份验证
- en: 'Now that we have the code to load the configuration file for us, we are going
    to start coding the authentication part of our framework. Spotify currently supports
    three kinds of authentication: authorization code, client credentials, and implicitly
    grant. We are going to implement authorization code and client credentials in
    this chapter, and we will start by implementing the client credentials flow, which
    is the easiest to start with.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了加载配置文件的代码，我们将开始编写框架的认证部分。Spotify目前支持三种认证方式：授权码、客户端凭据和隐式授权。在本章中，我们将实现授权码和客户端凭据，首先实现客户端凭据流程，这是最容易开始的。
- en: The client credentials flow has some disadvantages over the authorization code
    flow because the flow does not include authorization and cannot access the user's
    private data as well as control playback. We will implement and use this flow
    for now, but we will change to authorization code when we start implementing the
    terminal player.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭据流程与授权码流程相比有一些缺点，因为该流程不包括授权，也无法访问用户的私人数据以及控制播放。我们现在将实现并使用此流程，但在开始实现终端播放器时，我们将改为授权码。
- en: 'First, we are going to create a file called `authorization.py` in the `musicterminal/pytify/auth`
    directory with the following contents:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`musicterminal/pytify/auth`目录中创建一个名为`authorization.py`的文件，内容如下：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is going to be the authentication model and it will contain the data we
    get after requesting an access token. In the following list, you can see a description
    of every property:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是认证模型，它将包含我们在请求访问令牌后获得的数据。在下面的列表中，您可以看到每个属性的描述：
- en: '`access_token`: The token that has to be sent together with every request to
    the Web API'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token`：必须与每个对Web API的请求一起发送的令牌'
- en: '`token_type`: The type of the token, which is usually `Bearer`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_type`：令牌的类型，通常为`Bearer`'
- en: '`expires_in`: The `access_token` expiration time, which is 3600 seconds (1
    hour)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expires_in`：`access_token`的过期时间，为3600秒（1小时）'
- en: '`scope`: The scope is basically the permissions that Spotify''s user granted
    to our application'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：范围基本上是Spotify用户授予我们应用程序的权限'
- en: '`refresh_token`: The token that can be used to refresh the `access_token` after
    the expiration'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh_token`：在过期后可以用来刷新`access_token`的令牌'
- en: 'The last touch is to create a `__init__.py` file in the `musicterminal/pytify/auth`
    directory and import the `Authorization` , which is a `namedtuple`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`musicterminal/pytify/auth`目录中创建一个`__init__.py`文件，并导入`Authorization`，这是一个`namedtuple`：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing the client credentials flow
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施客户端凭据流
- en: 'The client credential flow is quite simple. Let''s break down all the steps
    until we get the `access_token`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭据流非常简单。让我们分解一下直到获得`access_token`的所有步骤：
- en: Our application will request the access token from the Spotify accounts service;
    remember that in our configuration file, we have the `api_access_token`. That's
    the URL we need to send the request to get hold of an access token. There are
    three things that we will need to send the request, the client id, the client
    secret, and the grant type, which in this case is `client_credentials`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序将从Spotify帐户服务请求访问令牌；请记住，在我们的配置文件中，有`api_access_token`。这是我们需要发送请求以获取访问令牌的URL。我们需要发送请求的三件事是客户端ID、客户端密钥和授权类型，在这种情况下是`client_credentials`。
- en: The Spotify account service will validate that request, check if the keys match
    with the keys of the app that we register to the developer's site, and return an
    access token.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spotify帐户服务将验证该请求，检查密钥是否与我们在开发者网站注册的应用程序的密钥匹配，并返回一个访问令牌。
- en: Now, our application has to use this access token in order to consume data from
    the REST APIs.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序必须使用此访问令牌才能从REST API中获取数据。
- en: The Spotify REST API will return the data we requested.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spotify REST API将返回我们请求的数据。
- en: Before we start implementing the functions that will make the authentication
    and get the access token, we can add a custom exception that we will throw if
    we get a bad request (HTTP `400`) from the Spotify account service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现将进行身份验证并获取访问令牌的函数之前，我们可以添加一个自定义异常，如果从Spotify帐户服务获得了错误请求（HTTP `400`）时，我们将抛出该异常。
- en: 'Let''s create a file named `exceptions.py` in the `musicterminal/pytify/core` directory
    with the following contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`musicterminal/pytify/core`目录中创建一个名为`exceptions.py`的文件，内容如下：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This class doesn't do much; we simply inherit from `Exception`. We could have
    just thrown a generic exception, but it is a good practice to create your own
    custom exceptions with good names and descriptions when developing frameworks
    and libraries that other developers will make use of.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并没有做太多事情；我们只是继承自`Exception`。我们本可以只抛出一个通用异常，但是在开发其他开发人员将使用的框架和库时，最好创建自己的自定义异常，并使用良好的名称和描述。
- en: 'So, instead of throwing an exception like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要像这样抛出异常：
- en: '`raise Exception(''some message'')`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise Exception(''some message'')`'
- en: 'We can be more explicit and throw a `BadRequestError`, like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更明确地抛出`BadRequestError`，如下所示：
- en: '`raise BadRequestError(''some message'')`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise BadRequestError(''some message'')`'
- en: Now, developers using this code can handle this kind of exception properly in
    their code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用此代码的开发人员可以在其代码中正确处理此类异常。
- en: 'Open the `__init__.py` file in the `musicterminal/pytify/core` directory and
    add the following import statement:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`musicterminal/pytify/core`目录中的`__init__.py`文件，并添加以下导入语句：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Perfect! Now, it is time to add a new file called `auth.py` in the `musicterminal/pytify/auth` directory,
    and the first thing we are going to add to this file is a few imports:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在是时候在`musicterminal/pytify/auth`目录中添加一个名为`auth.py`的新文件了，我们要添加到此文件的第一件事是一些导入：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I usually put all the imports from standard library modules first and function
    imports in files from my applications last. It is not a requirement, but it is
    just something I think makes the code cleaner and more organized. This way, I
    can easily see which are standard library items and which aren't.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常首先放置来自标准库模块的所有导入，然后是来自我的应用程序文件的函数导入。这不是必需的，但我认为这样可以使代码更清晰、更有组织。这样，我可以轻松地看出哪些是标准库项目，哪些不是。
- en: 'Now, we can start adding the functions that will send the request the to the `Spotify`
    account service and return the access token. The first function that we are going
    to add is called `get_auth_key`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加将发送请求到`Spotify`帐户服务并返回访问令牌的函数。我们要添加的第一个函数称为`get_auth_key`：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The client credential flow requires us to send the `client_id` and the `client_secret`,
    which has to be base 64-encoded. First, we convert the string with the `client_id:client_secret` format
    to bytes. After that, we encode it using base 64 and then decode it, returning
    the string representation of that encoded data so we can send it with the request
    payload.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端凭据流要求我们发送`client_id`和`client_secret`，它必须是base 64编码的。首先，我们将字符串转换为`client_id:client_secret`格式的字节。然后，我们使用base
    64对其进行编码，然后解码它，返回该编码数据的字符串表示，以便我们可以将其与请求有效负载一起发送。
- en: 'The other function that we are going to implement in the same file is called `_client_credentials`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要在同一文件中实现的另一个函数称为`_client_credentials`：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function gets an argument as the configuration and uses the `get_auth_key` function
    to pass the `client_id` and the `client_secret` to build a base 64-encoded `auth_key`.
    This will be sent to Spotify's accounts service to request an `access_token`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收配置作为参数，并使用`get_auth_key`函数传递`client_id`和`client_secret`来构建一个base 64编码的`auth_key`。这将被发送到Spotify的账户服务以请求`access_token`。
- en: Now, it is time to prepare the request. First, we set the `Authorization` in
    the request header, and the value will be the `Basic` string followed by the `auth_key.`
    The payload for this request will be `grant_type`, which in this case is `client_credentials`,
    and `json` will be set to `True`, which tells the API that we want the response
    in JSON format.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候准备请求了。首先，我们在请求头中设置`Authorization`，值将是`Basic`字符串后跟`auth_key`。这个请求的载荷将是`grant_type`，在这种情况下是`client_credentials`，`json`将设置为`True`，告诉API我们希望以JSON格式获取响应。
- en: We use the requests package to make the request to Spotify's account service,
    passing the headers and the data that we configured.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用requests包向Spotify的账户服务发出请求，传递我们配置的头部和数据。
- en: When we get a response, we first decode and load the JSON data into the variable
    content.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到响应时，我们首先解码并将JSON数据加载到变量content中。
- en: If the HTTP status code is `400 (BAD_REQUEST)` we raise a `BadRequestError`;
    otherwise, we get the values for `access_token`, `token_type`, `expires_in`, and
    `scope`, and finally create an `Authorization` tuple and return it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP状态码是`400 (BAD_REQUEST)`，我们会引发一个`BadRequestError`；否则，我们会获取`access_token`、`token_type`、`expires_in`和`scope`的值，最后创建一个`Authorization`元组并返回它。
- en: Note that we are setting `None` to the last parameter when creating an `Authentication`, `namedtuple`.
    The reason for this is that Spotify's account service doesn't return a `refresh_token`
    when the type of authentication is `CLIENT_CREDENTIALS`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当创建一个`Authentication`的`namedtuple`时，我们将最后一个参数设置为`None`。这样做的原因是，当身份验证类型为`CLIENT_CREDENTIALS`时，Spotify的账户服务不会返回`refresh_token`。
- en: 'All the functions that we have created so far are meant to be private, so the
    last function that we are going to add is the `authenticate` function. This is
    the function that developers will invoke to start the authentication process:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的所有函数都是私有的，所以我们要添加的最后一个函数是`authenticate`函数。这是开发人员将调用以开始身份验证过程的函数：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function is pretty straightforward; the function gets an argument as an
    instance of the `Config`, `namedtuple`, which will contain all the data that has
    been read from the configuration file. We then pass the configuration to the `_client_credentials` function,
    which will obtain the `access_token` using the client credentials flow.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常直接；函数接收一个`Config`的实例作为参数，`namedtuple`，其中包含了从配置文件中读取的所有数据。然后我们将配置传递给`_client_credentials`函数，该函数将使用客户端凭据流获取`access_token`。
- en: 'Let''s open the `__init__.py` file in the `musicterminal/pytify/auth` directory
    and import the `authenticate` and `get_auth_key` functions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`musicterminal/pytify/auth`目录中打开`__init__.py`文件，并导入`authenticate`和`get_auth_key`函数：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Nice! Let''s try this out in the Python REPL:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！让我们在Python REPL中尝试一下：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exactly what we expected! The next step is to start creating the functions that
    will consume Spotify's REST API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正是我们所期望的！下一步是开始创建将消耗Spotify的REST API的函数。
- en: Implementing the authorization code flow
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现授权码流程
- en: In this section, we are going to implement the authorization code flow, which
    we will be using in the client. We need to use this authentication flow because
    we need to acquire special access rights from the user using our application to
    execute certain actions. For instance, our application will have to be able to
    send a request to Spotify's Web API to play a certain track on the user's active
    device. In order to do that, we need to request `user-modify-playback-state`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现授权码流程，这是我们将在客户端中使用的流程。我们需要使用这种身份验证流程，因为我们需要从用户那里获得特殊的访问权限，以便使用我们的应用程序执行某些操作。例如，我们的应用程序将能够向Spotify的Web
    API发送请求，在用户的活动设备上播放某个曲目。为了做到这一点，我们需要请求`user-modify-playback-state`。
- en: 'Here are the steps involved in the authorization code flow:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是授权码流程中涉及的步骤：
- en: Our application will request authorization to access data, redirecting the user
    to a login page on Spotify's web page. There, the user can see all the access
    rights that the application requires.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序将请求授权以访问数据，并将用户重定向到Spotify网页上的登录页面。在那里，用户可以看到应用程序需要的所有访问权限。
- en: If the user approves it, the Spotify account service will send a request to
    the callback URI, sending a code and the state.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户批准，Spotify账户服务将向回调URI发送一个请求，发送一个代码和状态。
- en: When we get hold of the code, we send a new request passing the `client_id`,
    `client_secret`, `grant_type`, and `code` to acquire the `access_token`. This
    time, it will be different from the client credentials flow; we are going to get
    `scope` and a `refresh_token`
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们获得了代码后，我们发送一个新的请求，传递`client_id`、`client_secret`、`grant_type`和`code`来获取`access_token`。这一次，它将与客户端凭据流不同；我们将获得`scope`和`refresh_token`。
- en: Now, we can normally send requests to the Web API and if the access token has
    expired, we can do another request to refresh the access token and continue performing
    requests.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以正常地向Web API发送请求，如果访问令牌已过期，我们可以发送另一个请求来刷新访问令牌并继续执行请求。
- en: 'With that said, open the `auth.py` file in the `musicterminal/pytify/auth`
    directory and let''s add a few more functions. First, we are going to add a function
    called `_refresh_access_token`; you can add this function after the `get_auth_key`
    function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，在`musicterminal/pytify/auth`目录中打开`auth.py`文件，让我们添加一些更多的函数。首先，我们将添加一个名为`_refresh_access_token`的函数；你可以在`get_auth_key`函数之后添加这个函数：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It basically does the same thing as the function handling the client credentials
    flow, but this time we send the `refresh_token` and the `grant_type`. We get the
    data from the response's object and create an `Authorization`, `namedtuple`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上与处理客户端凭据流的函数做同样的事情，但这次我们发送`refresh_token`和`grant_type`。我们从响应对象中获取数据并创建一个`Authorization`，`namedtuple`。
- en: 'The next function that we are going to implement will make use of the `os`
    module of the standard library, so before we start with the implementation, we
    need to add the following import statement at the top of the `auth.py` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要实现的下一个函数将利用标准库的`os`模块，因此在开始实现之前，我们需要在`auth.py`文件的顶部添加以下导入语句：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can go ahead and add a function called `_authorization_code`. You can
    add this function after the `get_auth_key` function with the following contents:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续添加一个名为`_authorization_code`的函数。您可以在`get_auth_key`函数之后添加此函数，并包含以下内容：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we try opening a file called `.pytify` in the `musicterminal` directory.
    This file will contain the `refresh_token` that we are going to use to refresh
    the `access_token` every time we open our application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试在`musicterminal`目录中打开一个名为`.pytify`的文件。这个文件将包含我们将用来刷新`access_token`的`refresh_token`。
- en: After getting the `refresh_token` from the file, we pass it to the `_refresh_access_token` function,
    together with the `auth_key`. If for some reason we are unable to open the file
    or the file does not exist in the `musicterminal` directory, an exception will
    be raised.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中获取`refresh_token`后，我们将其与`auth_key`一起传递给`_refresh_access_token`函数。如果由于某种原因我们无法打开文件或文件不存在于`musicterminal`目录中，将引发异常。
- en: 'The last modification we need to do now is in the `authenticate` function in
    the same file. We are going to add support for both authentication methods; it
    should look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的最后修改是在同一文件中的`authenticate`函数中。我们将为两种身份验证方法添加支持；它应该是这样的：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we will start different authentication methods depending on what we have
    specified in the configuration file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将根据配置文件中的指定开始不同的身份验证方法。
- en: 'Since the authentication function has a reference to `AuthMethod`, we need
    to import it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于身份验证函数引用了`AuthMethod`，我们需要导入它：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Before we try this type of authentication out, we need to create a small web
    app that will authorize our application for us. We are going to work on that in
    the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试这种类型的身份验证之前，我们需要创建一个小型的Web应用程序，它将为我们授权我们的应用程序。我们将在下一节中进行这方面的工作。
- en: Authorizing our application with authorization code flow
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用授权码流授权我们的应用程序
- en: In order to make our Spotify terminal client work properly, we need special
    access rights to manipulate the user's playback. We do that by using the authorization
    code and we need to specifically request for the `user-modify-playback-state`
    access right.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的Spotify终端客户端正常工作，我们需要特殊的访问权限来操作用户的播放。我们通过使用授权码来做到这一点，我们需要专门请求`user-modify-playback-state`访问权限。
- en: There are a few more access rights which would be a good idea to add from the
    beginning if you intend to add more functionalities to this application; for example,
    if you want to be able to manipulate a user's private and public playlists, you
    may want to add the `playlist-modify-private` and `playlist-modify-public` scope.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算为此应用程序添加更多功能，最好从一开始就添加一些其他访问权限；例如，如果您想要能够操作用户的私人和公共播放列表，您可能希望添加`playlist-modify-private`和`playlist-modify-public`范围。
- en: You might also want to display a list of artists that the user follows on the
    client application, so you need to include `user-follow-read` to the scope as
    well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望在客户端应用程序上显示用户关注的艺术家列表，因此您还需要将`user-follow-read`包含在范围内。
- en: It will suffice to request `user-modify-playback-state` access rights for the
    functionalities that we are going to implement in the client application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们将在客户端应用程序中实现的功能，请求`user-modify-playback-state`访问权限将足够。
- en: The idea is to authorize our application using the authorization code flow.
    We are going to create a simple web application using the framework Flask that
    will define two routes. The `/` root will just render a simple page with a link
    that will redirect us to the Spotify authentication page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的想法是使用授权码流授权我们的应用程序。我们将使用Flask框架创建一个简单的Web应用程序，该应用程序将定义两个路由。`/`根将只呈现一个简单的页面，其中包含一个链接，该链接将重定向我们到Spotify认证页面。
- en: The second root will be `/callback`, which is the endpoint that Spotify will
    call after the users of our application give authorization for our application
    to access their Spotify data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个根将是`/callback`，这是Spotify在我们的应用程序用户授权我们的应用程序访问其Spotify数据后将调用的端点。
- en: 'Let''s see how this is implemented, but first, we need to install Flask. Open
    a terminal and type the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何实现的，但首先，我们需要安装Flask。打开终端并输入以下命令：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After you have installed it you can even include it in the `requirements.txt`
    file such as:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您甚至可以将其包含在`requirements.txt`文件中，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The command `pip freeze` will print all the installed packages in the requirements
    format. The output will return more items because it will also contain all the
    dependencies of the packages that we already installed, which is why we grep `Flask`
    and append it to the `requirements.txt` file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`pip freeze`将以requirements格式打印所有已安装的软件包。输出将返回更多项目，因为它还将包含我们已安装的软件包的所有依赖项，这就是为什么我们使用grep
    `Flask`并将其附加到`requirements.txt`文件中。
- en: 'Next time you are going to set up a virtual environment to work on this project
    you can just run:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下次您要设置虚拟环境来处理这个项目时，只需运行：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great! Now, we can start creating the web application. Create a file called
    `spotify_auth.py`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们可以开始创建Web应用程序。创建一个名为`spotify_auth.py`的文件。
- en: 'First, we add all necessary imports:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加所有必要的导入：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are going to use the `urlencode` function in the `urllib.parse` module to
    encode the parameters that are going to be appended to the authorize URL. We are
    also going to use the requests to send a request to get the `access_token` after
    the user authorizes our app and use the `json` package to parse the response.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`urllib.parse`模块中的`urlencode`函数来对要附加到授权URL的参数进行编码。我们还将使用requests来发送请求，以在用户授权我们的应用程序后获取`access_token`，并使用`json`包来解析响应。
- en: Then, we will import Flask-related things, so we can create a Flask application,  `render_template`,
    so we can return a rendered HTML template to the user, and finally the request,
    so we can access the data sent back to us by Spotify's authorization service.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将导入与Flask相关的内容，以便创建一个Flask应用程序，`render_template`，以便将渲染的HTML模板返回给用户，最后是请求，以便我们可以访问Spotify授权服务返回给我们的数据。
- en: 'We will also import some functions that we included in the core and auth submodules
    of the `pytify` module: the `read_config` to load and read the YAML config file
    and the `_authorization_code_request`. The latter will be explained in more detail
    in a short while.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将导入一些我们在`pytify`模块的核心和auth子模块中包含的函数：`read_config`用于加载和读取YAML配置文件，以及`_authorization_code_request`。后者将在稍后详细解释。
- en: 'We will create a Flask app and the root route:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Flask应用程序和根路由：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Great! Starting from the top, we read the configuration file so we can get our
    `client_id` and also the URL for Spotify's authorization service. We build the
    parameters dictionary with the `client_id`; the response type for the authorization
    code flow needs to be set to `code`; the `redirect_uri` is the callback URI which
    Spotify's authorization service will use to send us the authorization code back.
    And finally, since we are going to send instructions to the REST API to play a
    track in the user's active device, the application needs to have `user-modify-playback-state`
    permissions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！从头开始，我们读取配置文件，以便获取我们的`client_id`，还有Spotify授权服务的URL。我们使用`client_id`构建参数字典；授权代码流的响应类型需要设置为`code`；`redirect_uri`是回调URI，Spotify授权服务将用它来将授权代码发送回给我们。最后，由于我们将向REST
    API发送指令来播放用户活动设备中的曲目，应用程序需要具有`user-modify-playback-state`权限。
- en: Now, we encode all the parameters and build the URL.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对所有参数进行编码并构建URL。
- en: The return value will be a rendered HTML. Here, we will use the `render_template`
    function, passing a template as a first argument. By default, Flask will search
    this template in a directory called `templates`. The second argument to this function
    is the model. We are passing a property named `link` and setting the value of
    the variable URL. This way, we can render the link in the HTML template such as: `{{link}}`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值将是一个渲染的HTML。在这里，我们将使用`render_template`函数，将模板作为第一个参数传递。默认情况下，Flask将在一个名为`templates`的目录中搜索这个模板。这个函数的第二个参数是模型。我们传递了一个名为`link`的属性，并设置了变量URL的值。这样，我们可以在HTML模板中渲染链接，比如：`{{link}}`。
- en: 'Next, we are going to add a function to acquire the `access_token` and the
    `refresh_token` for us after we get the authorization code back from Spotify''s
    account service. Create a function called `_authorization_code_request` with the
    following content:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个函数，以在从Spotify的帐户服务获取授权代码后为我们获取`access_token`和`refresh_token`。创建一个名为`_authorization_code_request`的函数，内容如下：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This function is pretty much the same as the `_refresh_access_token` function
    that we previously implemented in the `auth.py` file. The only thing to note here
    is that in the options, we are passing the authorization code, and the `grant_type`
    is set to `authorization_code`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与我们之前在`auth.py`文件中实现的`_refresh_access_token`函数基本相同。这里唯一需要注意的是，在选项中，我们传递了授权代码，`grant_type`设置为`authorization_code`：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we define the route that will be called by Spotify's authorization service
    to send back the authorization code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了将由Spotify授权服务调用以发送授权代码的路由。
- en: We start off by reading the configuration, parsing the code from the request
    data, and calling the `_authorization_code_request`, passing the code we have
    just obtained.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先读取配置，解析请求数据中的代码，并调用`_authorization_code_request`，传递我们刚刚获取的代码。
- en: This function will send another request using this code, and it will acquire
    an access token that we can use to send requests, along with a refresh token that
    will be stored in a file called `.pytify` in the `musicterminal` directory.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将使用这个代码发送另一个请求，并获取一个我们可以用来发送请求的访问令牌，以及一个将存储在`musicterminal`目录中名为`.pytify`的文件中的刷新令牌。
- en: The access token that we obtain to make the requests to the Spotify REST API
    is valid for 3,600 seconds, or 1 hour, which means that within one hour, we can
    use the same access token to make requests. After that, we need to refresh the
    access token. We can do that by using the refresh token that is stored in the
    `.pytify` file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取的用于向Spotify REST API发出请求的访问令牌有效期为3,600秒，或1小时，这意味着在一个小时内，我们可以使用相同的访问令牌发出请求。之后，我们需要刷新访问令牌。我们可以通过使用存储在`.pytify`文件中的刷新令牌来实现。
- en: Lastly, we send a message to the browser with a success message.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向浏览器发送一个成功消息。
- en: 'Now, to finish our Flask application, we need to add the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成我们的Flask应用程序，我们需要添加以下代码：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This tells Flask to run the server on the localhost and use port `3000`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Flask在本地主机上运行服务器，并使用端口`3000`。
- en: 'The `home` function of our Flash application will, as a response, return a
    templated HTML file called index.html. We haven''t created that file yet, so let''s
    go ahead and create a folder called `musicterminal/templates` and inside the newly
    created directory, add a file called `index.html` with the following contents:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Flash应用程序的`home`函数将作为响应返回一个名为index.html的模板化HTML文件。我们还没有创建该文件，所以让我们继续创建一个名为`musicterminal/templates`的文件夹，并在新创建的目录中添加一个名为`index.html`的文件，内容如下：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's not much to explain here, but note that we are referencing the link
    property that we passed to the `render_template` function in the home function
    of the Flask application. We are setting the `href` attribute of that anchor element
    to the value of the link.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多解释的地方，但请注意我们正在引用链接属性，这是我们在Flask应用程序的主页函数中传递给`render_template`函数的。我们将锚元素的`href`属性设置为链接的值。
- en: Great! There is only more thing before we try this out and see if everything
    is working properly. We need to change the settings of our Spotify app; more specifically,
    we need to configure the callback function for the application, so we can receive
    the authorization code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在我们尝试这个并查看一切是否正常工作之前，还有一件事情。我们需要更改Spotify应用程序的设置；更具体地说，我们需要配置应用程序的回调函数，以便我们可以接收授权码。
- en: With that said, head to the [https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/)
    website and log in with your credentials. The dashboard will show the `pytify`
    app that we created at the beginning of this chapter. Click on the app name and
    then click on the EDIT SETTINGS button on the top right of the page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，前往[https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/)网站，并使用你的凭据登录。仪表板将显示我们在本章开头创建的`pytify`应用程序。点击应用程序名称，然后点击页面右上角的`EDIT
    SETTINGS`按钮。
- en: 'Scroll down until you find Redirect URIs, and in the text field, enter http://localhost:3000/callback
    and click on the ADD button. Your configuration should look as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动直到找到重定向URI，在文本框中输入http://localhost:3000/callback，然后点击添加按钮。你的配置应该如下所示：
- en: '![](assets/bc6aecdc-cc8d-41c2-b322-0e5104dee0e5.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc6aecdc-cc8d-41c2-b322-0e5104dee0e5.png)'
- en: Great! Scroll down to the bottom of the dialog and click the SAVE button.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！滚动到对话框底部，点击保存按钮。
- en: 'Now, we need to run the Flask application that we just created. On the terminal,
    in the projects root folder, type the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要运行我们刚刚创建的Flask应用程序。在终端中，进入项目的根目录，输入以下命令：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see an output similar to this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于这样的输出：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Open the browser of your choice and go to `http://localhost:3000`; you will
    see a simple page with the link that we created:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你选择的浏览器，转到`http://localhost:3000`；你将看到一个简单的页面，上面有我们创建的链接：
- en: '![](assets/6bc6cdd8-da51-453f-a117-5ac4fe18ee67.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bc6cdd8-da51-453f-a117-5ac4fe18ee67.png)'
- en: Click on the link and you will be sent to Spotify's authorization service page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 点击链接，你将被发送到Spotify的授权服务页面。
- en: A dialog will be displayed asking to connect the `Pytify` app to our account.
    Once you authorize it, you will be redirected back to `http://localhost:3000/callback`.
    If everything goes well, you should see the All set! You can close the browser
    window and stop the server message on the page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对话框将显示，要求将`Pytify`应用程序连接到我们的账户。一旦你授权了它，你将被重定向回`http://localhost:3000/callback`。如果一切顺利，你应该在页面上看到`All
    set! You can close the browser window and stop the server`的消息。
- en: Now, just close the browser, and you can stop the Flask application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需关闭浏览器，你就可以停止Flask应用程序了。
- en: 'Note that we now have a file named `.pytify` in the `musicterminal` directory.
    If you look at the contents, you will have an encrypted key similar to this one:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在在`musicterminal`目录中有一个名为`.pytify`的文件。如果你查看内容，你会看到一个类似于这样的加密密钥：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, we are ready to start coding the player.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始编写播放器。
- en: Next up, we are going to add some functions that will perform requests to  Spotify's
    Web API to search for artists, get a list of an artist's albums and a list of
    tracks in an album, and play the selected track.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些函数，用于向Spotify的Web API发送请求，搜索艺术家，获取艺术家专辑的列表和专辑中的曲目列表，并播放所选的曲目。
- en: Querying Spotify's web API
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询Spotify的Web API
- en: So far, we have only prepared the terrain and now things start to get a bit
    more interesting. In this section, we are going to create the basic functions
    to send requests to Spotify's Web API; more specifically, we want to be able to
    search for an artist, get an artist's list of albums, get a list of tracks in
    that album, and finally we want to send a request to actually play a given track
    in Spotify's client that is currently active. It can be the browser, a mobile
    phone, Spotify's client, or even video game consoles. So, let's dive right into
    it!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是准备了地形，现在事情开始变得更有趣了。在这一部分，我们将创建基本函数来向Spotify的Web API发送请求；更具体地说，我们想要能够搜索艺术家，获取艺术家专辑的列表，获取该专辑中的曲目列表，最后我们想要发送一个请求来实际播放Spotify客户端中当前活动的曲目。可以是浏览器、手机、Spotify客户端，甚至是视频游戏主机。所以，让我们马上开始吧！
- en: 'To start off, we are going to create a file called `request_type.py` in the
    `musicterminal/pytify/core` directory with the following contents:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`musicterminal/pytify/core`目录中创建一个名为`request_type.py`的文件，内容如下：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have gone through enumerations before, so we won't be going into so much
    detail. It suffices to say that we create an enumeration with `GET` and `PUT`
    properties. This will be used to notify the function that performs the requests
    for us that we want to do a `GET` request or a `PUT` request.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过枚举，所以我们不会详细讨论。可以说我们创建了一个包含`GET`和`PUT`属性的枚举。这将用于通知为我们执行请求的函数，我们想要进行`GET`请求还是`PUT`请求。
- en: 'Then, we can create another file named `request.py` in the same `musicterminal/pytify/core` directory,
    and we start by adding a few import statements and defining a function called
    `execute_request`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在相同的`musicterminal/pytify/core`目录中创建另一个名为`request.py`的文件，并开始添加一些导入语句，并定义一个名为`execute_request`的函数：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This function gets a few arguments:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一些参数：
- en: '`url_template`: This is the template that will be used to build the URL to
    perform the request; it will use another argument called `params` to build the
    URL'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url_template`：这是将用于构建执行请求的URL的模板；它将使用另一个名为`params`的参数来构建URL'
- en: '`auth`: Is the `Authorization` object'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth`：是`Authorization`对象'
- en: '`params`: It is a `dict` containing all the parameters that will be placed
    into the URL that we are going to perform the request on'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：这是一个包含我们将放入我们将要执行请求的URL中的所有参数的`dict`'
- en: '`request`: This is the request type; it can be `GET` or `PUT`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`：这是请求类型；可以是`GET`或`PUT`'
- en: '`payload`: This is the data that may be sent together with the request'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payload`：这是可能与请求一起发送的数据'
- en: 'As we continue to implement the same function, we can add:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续实现相同的功能，我们可以添加：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We read the configuration and add the base URL to the params so it is replaced
    in the `url_template` string. We add `Authorization` in the request headers, together
    with the authentication access token:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取配置并将基本URL添加到参数中，以便在`url_template`字符串中替换它。我们在请求标头中添加`Authorization`，以及认证访问令牌：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we check if the request type is `GET`. If so, we execute the `get` function
    from requests; otherwise, we execute the `put` function. The function calls are
    very similar; the only thing that differs here is the data argument. If the response
    returned is empty, we just return the empty string; otherwise, we parse the JSON
    data into the `result` variable:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查请求类型是否为`GET`。如果是，我们执行来自requests的`get`函数；否则，我们执行`put`函数。函数调用非常相似；这里唯一不同的是数据参数。如果返回的响应为空，我们只返回空字符串；否则，我们将JSON数据解析为`result`变量：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After parsing the JSON result, we test whether the status of the request is
    not `200` (OK); in that case, we raise a `BadRequestError`. If it is a successful
    response, we return the results.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 解析JSON结果后，我们测试请求的状态是否不是`200`（OK）；在这种情况下，我们引发`BadRequestError`。如果是成功的响应，我们返回结果。
- en: 'We also need some functions to help us prepare the parameters that we are going
    to pass to the Web API endpoints. Let''s go ahead and create a file called `parameter.py`
    in the `musicterminal/pytify/core` folder with the following contents:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些函数来帮助我们准备要传递给Web API端点的参数。让我们继续在`musicterminal/pytify/core`文件夹中创建一个名为`parameter.py`的文件，内容如下：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have two functions here, `prepare_params` and `validate_params`. The `validate_params` function
    is used to identify whether there are parameters that are required for a certain
    operation, but they haven't been supplied. The `prepare_params` function first
    calls `validate_params` to make sure that all the parameters have been supplied
    and to also join all the parameters together so they can be easily appended to
    the URL query string.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个函数，`prepare_params`和`validate_params`。`validate_params`函数用于识别是否有参数需要进行某种操作，但它们尚未提供。`prepare_params`函数首先调用`validate_params`，以确保所有参数都已提供，并将所有参数连接在一起，以便它们可以轻松附加到URL查询字符串中。
- en: 'Now, let''s add an enumeration with the types of searches that can be performed.
    Create a file called `search_type.py` in the `musicterminal/pytify/core` directory
    with the following contents:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个枚举，列出可以执行的搜索类型。在`musicterminal/pytify/core`目录中创建一个名为`search_type.py`的文件，内容如下：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is just a simple enumeration with the four search options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的枚举，列出了四个搜索选项。
- en: 'Now, we are ready to create the function to perform the search. Create a file
    called `search.py` in the `musicterminal/pytify/core` directory:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建执行搜索的函数。在`musicterminal/pytify/core`目录中创建一个名为`search.py`的文件：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We start by explaining the `_search` function. This function gets three criteria
    parameters (what we want to search for), the `Authorization` object, and lastly
    the search type, which is a value in the enumeration that we just created.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解释`_search`函数。这个函数获取三个标准参数（我们要搜索的内容），`Authorization`对象，最后是搜索类型，这是我们刚刚创建的枚举中的一个值。
- en: The function is quite simple; we start by validating the parameters, then we
    build the URL to make the request, we set the `Authorization` head using our access
    token, and lastly,  we perform the request and return the parsed response.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单；我们首先验证参数，然后构建URL以进行请求，我们使用我们的访问令牌设置`Authorization`头，最后，我们执行请求并返回解析后的响应。
- en: The other functions `search_artist`, `search_album`, `search_playlist`, and
    `search_track` simply get the same arguments, the criteria and the `Authorization`
    object, and pass it to the `_search` function, but they pass different search
    types.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其他功能`search_artist`，`search_album`，`search_playlist`和`search_track`只是获取相同的参数，标准和`Authorization`对象，并将其传递给`_search`函数，但它们传递不同的搜索类型。
- en: 'Now that we can search for an artist, we have to get a list of albums. Add
    a file called `artist.py` in the `musicterminal/pytify/core` directory with the
    following contents:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以搜索艺术家，我们必须获取专辑列表。在`musicterminal/pytify/core`目录中添加一个名为`artist.py`的文件，内容如下：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, given an `artist_id`, we just define the URL template and parameters that
    we want to make the request and run the `execute_request` function which will
    take care of building the URL, getting and parsing the results for us.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定一个`artist_id`，我们只需定义URL模板和我们要发出请求的参数，并运行`execute_request`函数，它将负责为我们构建URL，获取和解析结果。
- en: 'Now, we want to get a list of the tracks for a given album. Add a file called
    `album.py` in the `musicterminal/pytify/core` directory with the following contents:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要获取给定专辑的曲目列表。在`musicterminal/pytify/core`目录中添加一个名为`album.py`的文件，内容如下：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `get_album_tracks` function is very similar to the `get_artist_albums` function
    that we just implemented.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_album_tracks`函数与我们刚刚实现的`get_artist_albums`函数非常相似。'
- en: 'Finally, we want to be able to send an instruction to Spotify''s Web API, telling
    it to play a track that we selected. Add a file called `player.py` in the `musicterminal/pytify/core`
    directory, and add the following contents:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够向Spotify的Web API发送指令，告诉它播放我们选择的曲目。在`musicterminal/pytify/core`目录中添加一个名为`player.py`的文件，并添加以下内容：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This function is also very similar to the previous ones (`get_artist_albums`
    and `get_album_tracks`), except that it defines a payload. A payload is a dictionary
    containing two items: `uris`, which is a list of tracks that should be added to
    the playback queue, and `offset`, which contains another dictionary with the URIs
    of tracks that should be played first. Since we are interested in only playing
    one song at a time, `uris` and `offset` will contain the same `track_uri`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与之前的函数（`get_artist_albums`和`get_album_tracks`）非常相似，只是它定义了一个有效负载。有效负载是一个包含两个项目的字典：`uris`，是应该添加到播放队列的曲目列表，和`offset`，其中包含另一个包含应该首先播放的曲目的URI的字典。由于我们只对一次播放一首歌感兴趣，`uris`和`offset`将包含相同的`track_uri`。
- en: 'The final touch here is to import the new function that we implemented. In
    the `__init__.py` file at the `musicterminal/pytify/core` directory, add the following
    code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一步是导入我们实现的新函数。在`musicterminal/pytify/core`目录下的`__init__.py`文件中，添加以下代码：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s try the function to search artists in the python REPL to check whether
    everything is working properly:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在python REPL中搜索艺术家的函数，以检查一切是否正常工作：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The rest of the output has been omitted because it was too long, but now we
    can see that everything is working just as expected.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其余输出已被省略，因为太长了，但现在我们可以看到一切都正如预期地工作。
- en: Now, we are ready to start building the terminal player.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始构建终端播放器。
- en: Creating the player
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建播放器
- en: Now that we have everything we need to authenticate and consume the Spotify
    Rest API, we are going to create a small terminal client where we can search for
    an artist, browse his/her albums, and select a track to play in the Spotify client.
    Note that to use the client, we will have to issue an access token from a premium
    account and the authentication flow we need to use here is the `AUTHENTICATION_CODE`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了认证和使用Spotify Rest API所需的一切，我们将创建一个小型终端客户端，可以在其中搜索艺术家，浏览他/她的专辑，并选择要在Spotify客户端中播放的曲目。请注意，要使用客户端，我们将不得不从高级账户中发出访问令牌，并且我们需要在这里使用的认证流程是`AUTHENTICATION_CODE`。
- en: We will also need to require from the user of our application the `user-modify-playback-state` scope,
    which will allow us to control playback. With that said, let's get right into
    it!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从我们应用程序的用户那里要求`user-modify-playback-state`范围，这将允许我们控制播放。说到这里，让我们开始吧！
- en: First, we need to create a new directory to keep all the client's related files
    in it, so go ahead and create a directory named `musicterminal/client`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新目录，将所有客户端相关的文件保存在其中，所以继续创建一个名为`musicterminal/client`的目录。
- en: Our client will only have three views. In the first view, we are going to get
    the user input and search for an artist. When the artist search is complete, we
    are going to switch to the second view, where a list of albums for the selected
    artist will be presented. In this view, the user will be able to select an album
    on the list using the keyboard's *Up* and *Down* arrow keys and select an album
    by hitting the *Enter* key.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端只有三个视图。在第一个视图中，我们将获取用户输入并搜索艺术家。当艺术家搜索完成后，我们将切换到第二个视图，在这个视图中，将呈现所选艺术家的专辑列表。在这个视图中，用户将能够使用键盘的*上*和*下*箭头键选择列表上的专辑，并通过按*Enter*键选择专辑。
- en: Lastly, when an album is selected, we are going to switch to the third and final
    view on our application, where the user will see a list of tracks for the selected
    album. Like the previous view, the user will also be able to select a track using
    the keyboard's *Up* and *Down* arrow key; hitting *Enter *will send a request
    to the Spotify API to play the selected track on the user's available devices.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当选择了一个专辑后，我们将切换到我们应用程序的第三个和最后一个视图，用户将看到所选专辑的曲目列表。与之前的视图一样，用户还可以使用键盘的*上*和*下*箭头键选择曲目；按*Enter*将向Spotify
    API发送请求，在用户可用设备上播放所选曲目。
- en: One approach is to use `curses.panel`. Panels are a kind of window and they
    are very flexible, allowing us to stack, hide and show, and switch panels, go
    back to the top of the stack of panels, and so on, which is perfect for our purposes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用`curses.panel`。面板是一种窗口，非常灵活，允许我们堆叠、隐藏和显示、切换面板，返回到面板堆栈的顶部等等，非常适合我们的目的。
- en: 'So, let''s create a file inside the `musicterminal/client` directory called
    `panel.py` with the following contents:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在`musicterminal/client`目录下创建一个名为`panel.py`的文件，内容如下：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: All we do here is import the modules and functions we need and create a class
    called `Panel`. We are also importing the `uuid` module so we can create a GUID
    for every new panel.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的就是导入我们需要的模块和函数，并创建一个名为`Panel`的类。我们还导入`uuid`模块，以便为每个新面板创建一个GUID。
- en: 'The Panel''s initializer gets two arguments: `title`, which is the title of
    the window, and `dimensions`. The `dimensions` argument is a tuple and follows
    the curses convention. It is composed of `height`, `width`, and the positions `y`
    and `x`, where the panel should start to be drawn.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 面板的初始化器有两个参数：`title`，是窗口的标题，和`dimensions`。`dimensions`参数是一个元组，遵循curses的约定。它由`height`、`width`和面板应该开始绘制的位置`y`和`x`组成。
- en: We unpack the values of the `dimensions` tuple so it is easier to work with
    and then we use the `newwin` function to create a new window; it will have the
    same dimensions that we passed in the class initializer. Next, we call the box
    function to draw lines on the four sides of the terminal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解包`dimensions`元组的值，以便更容易处理，然后我们使用`newwin`函数创建一个新窗口；它将具有我们在类初始化器中传递的相同尺寸。接下来，我们调用box函数在终端的四个边上绘制线条。
- en: Now that we have the window created, it is time to create the panel for the
    window that we just created, calling `curses.panel.new_panel` and passing the
    window. We also set the window title and create a GUID.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了窗口，是时候为我们刚刚创建的窗口创建面板了，调用`curses.panel.new_panel`并传递窗口。我们还设置窗口标题并创建一个GUID。
- en: 'Lastly, we set the state of the panel to hidden. Continuing working on this
    class, let''s add a new method called `hide`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将面板的状态设置为隐藏。继续在这个类上工作，让我们添加一个名为`hide`的新方法：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This method is quite simple; the only thing that it does is call the `hide`
    method in our panel.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单；它所做的唯一的事情就是调用我们面板中的`hide`方法。
- en: 'The other method that we call in the initializer is `_set_title`; let''s create
    it now:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在初始化器中调用的另一个方法是`_set_title`；现在让我们创建它：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In `_set_title`, we format the title by adding some extra padding on both sides
    of the title string, and then we call the `addstr` method of the window to print
    the title in row zero, column two, and we use the constant `A_REVERSE`, which
    will invert the colors of the string, like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_set_title`中，我们通过在标题字符串的两侧添加一些额外的填充来格式化标题，然后我们调用窗口的`addstr`方法在零行、二列打印标题，并使用常量`A_REVERSE`，它将颠倒字符串的颜色，就像这样：
- en: '![](assets/ae53d748-1e23-4730-8538-9be17dde71de.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae53d748-1e23-4730-8538-9be17dde71de.png)'
- en: 'We have a method to hide the panel; now, we need a method to show the panel.
    Let''s add the `show` method:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个隐藏面板的方法；现在，我们需要一个显示面板的方法。让我们添加`show`方法：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `show` method first clears the window and draws the borders around it with
    the `box` method. Then, we set the `title` again. The `cursers.curs_set(0)` call
    will disable the cursor; we do that here because we don't want the cursor visible
    when we are selecting the items in the list. Finally, we call the `show` method
    in the panel.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`方法首先清除窗口并用`box`方法绘制其周围的边框。然后，我们再次设置`title`。`cursers.curs_set(0)`调用将禁用光标；我们在这里这样做是因为当我们在列表中选择项目时，我们不希望光标可见。最后，我们在面板中调用`show`方法。'
- en: 'It would also be nice to have a way to know whether the current panel is visible
    or not. So, let''s add a method called `is_visible`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 也很好有一种方法来知道当前面板是否可见。因此，让我们添加一个名为`is_visible`的方法：
- en: '[PRE62]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we can use the `hidden` method on the panel, which returns `true` if the
    panel is hidden and `false` if the panel is visible.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以在面板上使用`hidden`方法，如果面板隐藏则返回`true`，如果面板可见则返回`false`。
- en: 'The last touch in this class is to add the possibility of comparing panels.
    We can achieve this by overriding some special methods; in this case, we want
    to override the `__eq__` method, which will be invoked every time we use the `==`
    operator. Remember that we created an `id` for every panel? We can use that `id`
    now to test the equality:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中的最后一步是添加比较面板的可能性。我们可以通过覆盖一些特殊方法来实现这一点；在这种情况下，我们想要覆盖`__eq__`方法，每当使用`==`运算符时都会调用它。记住我们为每个面板创建了一个`id`吗？我们现在可以使用那个`id`来测试相等性：
- en: '[PRE63]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Perfect! Now that we have the `Panel` base class, we are ready to create a special
    implementation of the panel that will contain menus to select items.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有了`Panel`基类，我们准备创建一个特殊的面板实现，其中将包含选择项目的菜单。
- en: Adding menus for albums and track selection
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为专辑和曲目选择添加菜单
- en: 'Now, we are going to create a file called `menu_item.py` in the `musicterminal/client/`
    directory and we will start by importing some functions that we will need:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`musicterminal/client/`目录中创建一个名为`menu_item.py`的文件，并且我们将从中导入一些我们需要的函数开始：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We only need to import the `uuid1` function from the `uuid` module because,
    like the panels, we are going to create an `id (GUID)` for every menu item in
    the list.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从`uuid`模块中导入`uuid1`函数，因为和面板一样，我们将为列表中的每个菜单项创建一个`id（GUID）`。
- en: 'Let''s start by adding the class and the constructor:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先添加类和构造函数：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `MenuItem` initializer gets three arguments, the `label` item, the `data`
    which will contain the raw data returned by the Spotify REST API, and a flag stating
    whether the item is currently selected or not.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItem`初始化器有三个参数，`label`项，`data`将包含Spotify REST API返回的原始数据，以及一个指示项目当前是否被选中的标志。'
- en: We start off by creating an id for the item, then we set the values for the
    data and label properties using the argument values that are passed in the class
    initializer.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为项目创建一个id，然后使用传递给类初始化器的参数值设置数据和标签属性的值。
- en: Every item in the list will have an action that will be executed when the item
    is selected on the list, so we create a function called `return_id` that returns
    a tuple with the item id (not the same as the id that we just created). This is
    the id for the item on Spotify, and the URI is the URI for the item on Spotify.
    The latter will be useful when we select and play a song.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个项目都将有一个在选择列表项时执行的操作，因此我们创建一个名为`return_id`的函数，它返回一个包含项目id的元组（不同于我们刚刚创建的id）。这是Spotify上项目的id，URI是Spotify上项目的URI。当我们选择并播放一首歌时，后者将会很有用。
- en: 'Now, we are going to implement some special methods that will be useful for
    us when performing item comparisons and printing items. The first method that
    we are going to implement is `__eq__`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一些特殊方法，这些方法在执行项目比较和打印项目时将对我们很有用。我们要实现的第一个方法是`__eq__`：
- en: '[PRE66]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will allow us to use the index function to find a specific `MenuItem` in
    a list of `MenuItem` objects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用`index`函数在`MenuItem`对象列表中找到特定的`MenuItem`。
- en: 'The other special method that we are going to implement is the `__len__` method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的另一个特殊方法是`__len__`方法：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It returns the length of the `MenuItem` label and it will be used when measuring
    the length of the menu item labels on the list. Later, when we are building the
    menu, we are going to use the `max` function to get the menu item with the longest
    label, and based on that, we'll add extra padding to the other items so that all
    the items in the list look aligned.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回`MenuItem`标签的长度，当测量列表中菜单项标签的长度时将会用到。稍后，当我们构建菜单时，我们将使用`max`函数来获取具有最长标签的菜单项，并基于此，我们将为其他项目添加额外的填充，以便列表中的所有项目看起来对齐。
- en: 'The last method that we are going to implement is the `__str__` method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的最后一个方法是`__str__`方法：
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is just for convenience when printing menu items; instead of doing `print(menuitem.label)`,
    we can just do `print(menuitem)` and it will invoke `__str__`, which will return
    the value of the `MenuItem` label.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在打印菜单项时的便利性；我们可以直接调用`print(menuitem)`而不是`print(menuitem.label)`，它将调用`__str__`，返回`MenuItem`标签的值。
- en: Implementing the menu panel
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现菜单面板
- en: Now, we are going to implement the menu panel, which will be the container class
    that will accommodate all the menu items, handle events, and perform rendering
    on the terminal screen.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现菜单面板，它将是一个容器类，容纳所有菜单项，处理事件，并在终端屏幕上执行呈现。
- en: Before we start with the implementation of the menu panel, let's add an enumeration
    that will represent different item alignment options, so we can have a bit more
    flexibility on how to display the menu items inside the menu.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现菜单面板之前，让我们添加一个枚举，表示不同的项目对齐选项，这样我们就可以更灵活地显示菜单中的菜单项。
- en: 'Create a file called `alignment.py` in the `musicterminal/client` directory
    with the following contents:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在`musicterminal/client`目录中创建一个名为`alignment.py`的文件，内容如下：
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You should be an enumeration expert if you followed the code in the first chapter.
    There's nothing as complicated here; we define a class `Alignment` inheriting
    from Enum and define two attributes, `LEFT` and `RIGHT`, both with their values
    set to `auto()`, which means that the values will be set automatically for us
    and they will be `1` and `2`, respectively.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在第一章中跟随代码，您应该是一个枚举专家。这里没有什么复杂的；我们定义了一个从Enum继承的`Alignment`类，并定义了两个属性，`LEFT`和`RIGHT`，它们的值都设置为`auto()`，这意味着值将自动设置为`1`和`2`。
- en: Now, we are ready to create the menu. Let's go ahead and create a final class
    called `menu.py` in the `musicterminal/client` directory.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建菜单。让我们继续在`musicterminal/client`目录中创建一个名为`menu.py`的最终类。
- en: 'Let''s add some imports and the constructor:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些导入和构造函数：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `Menu` class inherits from the `Panel` base class that we just created,
    and the class initializer gets a few arguments: the `title`, the `dimensions`
    (tuple with `height`, `width`, `y` and `x` values) the `alignment` setting which
    is `LEFT` by default, and the `items`. The items argument is a list of `MenuItems`
    objects. This is optional and it will be set to an empty list if no value is specified.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu`类继承自我们刚刚创建的`Panel`基类，类初始化器接收一些参数：`title`，`dimensions`（包含`height`，`width`，`y`和`x`值的元组），默认为`LEFT`的`alignment`设置，以及`items`。items参数是一个`MenuItems`对象的列表。这是可选的，如果没有指定值，它将设置为空列表。'
- en: The first thing we do in the class initializer is invoke the `__init__` method
    in the base class. We can do that by using the `super` function. If you remember,
    the `__init__` method on the `Panel` class gets two arguments,  `title` and `dimension`,
    so we pass it to the base class initializer.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在类初始化器中的第一件事是调用基类的`__init__`方法。我们可以使用`super`函数来做到这一点。如果您记得，`Panel`类上的`__init__`方法有两个参数，`title`和`dimension`，所以我们将它传递给基类初始化器。
- en: Next, we assign the values for the properties `align` and `items`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为属性`align`和`items`赋值。
- en: 'We also need a method that returns the currently selected item on the list
    of menu items:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个方法，返回菜单项列表中当前选定的项目：
- en: '[PRE71]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This method is very straightforward; the comprehension returns a list of selected
    items, and it will return `None` if no items are selected; otherwise, it returns
    the first item on the list.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单；推导返回一个选定项目的列表，如果没有选定项目，则返回`None`；否则，返回列表中的第一个项目。
- en: 'Now, we can implement the method that will handle item selection. Let''s add
    another method called `_select`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现处理项目选择的方法。让我们添加另一个名为`_select`的方法：
- en: '[PRE72]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we start getting the current item selected, and right after that we get
    the index of the item in the list of menu items using the index method from the
    array. This is possible because we implemented the `__eq__` method in the `Panel`
    class.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始获取当前选定的项目，然后立即使用数组中的索引方法获取菜单项列表中项目的索引。这是因为我们在`Panel`类中实现了`__eq__`方法。
- en: Then, we get to run the function passed as the argument, `expr`, passing the
    value of the currently selected item index.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始运行作为参数传递的函数`expr`，传递当前选定项目索引的值。
- en: '`expr` will determine the next current item index. If the new index is less
    than `0`, it means that we reached the top of the menu item''s list, so we don''t
    take any action.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr`将确定下一个当前项目索引。如果新索引小于`0`，这意味着我们已经到达菜单项列表的顶部，因此我们不采取任何行动。'
- en: If the new index is greater than the current index, and the new index is greater
    than or equal to the number of menu items on the list, then we have reached the
    bottom of the list, so no action is required at this point and we can continue
    selecting the same item.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新索引大于当前索引，并且新索引大于或等于列表中菜单项的数量，则我们已经到达列表底部，因此此时不需要采取任何操作，我们可以继续选择相同的项目。
- en: However, if we haven't reached to top or the bottom of the list, we need to
    swap the selected items. To do this, we set the selected property on the current
    item to `False` and set the selected property of the next item to `True`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们还没有到达列表的顶部或底部，我们需要交换选定的项目。为此，我们将当前项目的selected属性设置为`False`，并将下一个项目的selected属性设置为`True`。
- en: 'The `_select` method is a `private` method, and it is not intended to be called
    externally, so we define two methods—`next` and `previous`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`_select`方法是一个`private`方法，不打算在外部调用，因此我们定义了两个方法——`next`和`previous`：'
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The next method will invoke the `_select` method and pass a lambda expression
    that will receive an index and add one to it, and the previous method will do
    the same thing, but instead of increasing the index by `1`, it will subtract it.
    So, in the `_select` method when we call:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法将调用`_select`方法，并传递一个lambda表达式，该表达式将接收一个索引并将其加一，而上一个方法将执行相同的操作，但是不是增加索引`1`，而是减去。因此，在`_select`方法中，当我们调用：
- en: '[PRE74]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We are calling either `lambda index: index + 1` or `lambda index: index + 1`.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '我们要么调用`lambda index: index + 1`，要么调用`lambda index: index + 1`。'
- en: 'Great! Now, we are going to add a method that will be responsible for formatting
    menu items before we render them on the screen. Create a method called `_initialize_items`,
    which is shown as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们将添加一个负责在屏幕上呈现菜单项之前格式化菜单项的方法。创建一个名为`_initialize_items`的方法，如下所示：
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: First, we get the menu item that has the largest label; we can do that by using
    the built-in function `max` and passing the `items`, and, as the key, another
    built-in function called `len`. This will work because we implemented the special
    method `__len__` in the menu item.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取具有最大标签的菜单项；我们可以通过使用内置函数`max`并传递`items`，以及作为键的另一个内置函数`len`来实现这一点。这将起作用，因为我们在菜单项中实现了特殊方法`__len__`。
- en: After discovering the menu item with the largest label, we loop through the
    items of the list, adding padding on the `LEFT` or `RIGHT`, depending on the alignment
    options. Finally, if there's no menu item in the list with the selected flag set
    to `True`, we select the first item as selected.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现具有最大标签的菜单项之后，我们循环遍历列表的项目，在`LEFT`或`RIGHT`上添加填充，具体取决于对齐选项。最后，如果列表中没有被选中标志设置为`True`的菜单项，我们将选择第一个项目作为选定项目。
- en: 'We also want to provide a method called `init` that will initialize the items
    on the list for us:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想提供一个名为`init`的方法，它将为我们初始化列表上的项目：
- en: '[PRE76]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We also need to handle keyboard events so we can perform a few actions when
    the user specifically presses the *Up* and *Down* arrow keys,  as well as *Enter*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理键盘事件，这样当用户特别按下*上*和*下*箭头键以及*Enter*键时，我们就可以执行一些操作。
- en: 'First, we need to define a few constants at the top of the file. You can add
    these constants between the imports and the class definition:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在文件顶部定义一些常量。您可以在导入和类定义之间添加这些常量：
- en: '[PRE77]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s go ahead and include a method called `handle_events`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续包括一个名为`handle_events`的方法：
- en: '[PRE78]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This method is pretty simple; it gets a `key` argument, and if the key is equal
    to `curses.KEY_UP`, then we call the `previous` method. If the key is equal to
    `curses.KEY_DOWN`, then we call the `next` method. Now, if the key is `ENTER`,
    then we get the selected item and return its action. The action is a function
    that will execute another function; in our case, we might be selecting an artist
    or song on a list or executing a function that will play a music track.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单；它获取一个`key`参数，如果键等于`curses.KEY_UP`，那么我们调用`previous`方法。如果键等于`curses.KEY_DOWN`，那么我们调用`next`方法。现在，如果键是`ENTER`，那么我们获取选定的项目并返回其操作。操作是一个将执行另一个函数的函数；在我们的情况下，我们可能会在列表上选择艺术家或歌曲，或执行一个将播放音乐曲目的函数。
- en: In addition to testing whether the `key` is `curses.KEY_ENTER`, we also need
    to check whether the key is a new line `\n` or a carriage return `\r`. This is
    necessary because the code for the *Enter* key can differ depending on the configuration
    of the terminal the application is running in.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试`key`是否为`curses.KEY_ENTER`之外，我们还需要检查键是否为换行符`\n`或回车符`\r`。这是必要的，因为*Enter*键的代码可能会根据应用程序运行的终端的配置而有所不同。
- en: 'We are going to implement the `__iter__` method, which will make our `Menu`
    class behave like an iterable object:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现`__iter__`方法，这将使我们的`Menu`类表现得像一个可迭代的对象：
- en: '[PRE79]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The last method of this class is the `update` method. This method will do the
    actual work of rendering the menu items and refreshing the window screen:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最后一个方法是`update`方法。这个方法将实际工作渲染菜单项并刷新窗口屏幕：
- en: '[PRE80]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: First, we set the `x` and `y` coordinates to `2`, so the menu on this window
    will start at line `2` and column `2`. We loop through the menu items and call
    the `addstr` method to print the item on the screen.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`x`和`y`坐标设置为`2`，这样窗口上的菜单将从第`2`行和第`2`列开始。我们循环遍历菜单项，并调用`addstr`方法在屏幕上打印项目。
- en: 'The `addstr` method gets a `y` position, the `x` position, the string that
    will be written on the screen, in our case `item.label`, and the last argument
    is the `style`. If the item is selected, we want to show it highlighted; otherwise,
    it will display with normal colors. The following screenshot illustrates what
    the rendered list will look like:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`addstr`方法获取`y`位置，`x`位置，将在屏幕上写入的字符串，在我们的例子中是`item.label`，最后一个参数是`style`。如果项目被选中，我们希望以突出显示的方式显示它；否则，它将以正常颜色显示。以下截图说明了渲染列表的样子：'
- en: '![](assets/270dbea3-ceb9-4922-8216-c30ab85c7688.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/270dbea3-ceb9-4922-8216-c30ab85c7688.png)'
- en: Creating the DataManager class
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建DataManager类
- en: We have implemented the base functionality to authenticate and consume data
    from the Spotify REST API, but now we need to create a class that will make use
    of this functionality so we get the information that we need to be displayed in
    the client.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了身份验证和从Spotify REST API获取数据的基本功能，但现在我们需要创建一个类，利用这些功能，以便获取我们需要在客户端中显示的信息。
- en: 'Our Spotify terminal client will perform the following actions:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Spotify终端客户端将执行以下操作：
- en: Search an artist by name
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按名称搜索艺术家
- en: List the artist's albums
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出艺术家的专辑
- en: List the album's tracks
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出专辑的曲目
- en: Request a track to be played
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求播放一首曲目
- en: 'The first thing we are going to add is a custom exception that we can raise,
    and no result is returned from the Spotify REST API. Create a new file called
    `empty_results_error.py` in the `musicterminal/client` directory with the following
    contents:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的第一件事是一个自定义异常，我们可以引发，而且没有从Spotify REST API返回结果。在`musicterminal/client`目录中创建一个名为`empty_results_error.py`的新文件，内容如下：
- en: '[PRE81]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To make it easier for us, let''s create a `DataManager` class that will encapsulate
    all these functionalities for us. Create a file called `data_manager.py` in the
    `musicterminal/client` directory:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们更容易，让我们创建一个称为`DataManager`的类，它将为我们封装所有这些功能。在`musicterminal/client`目录中创建一个名为`data_manager.py`的文件：
- en: '[PRE82]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: First, we import the `MenuItem,` so we can return `MenuItem` objects with the
    request's results. After that, we import functions from the `pytify` module to
    search artists, get albums, list albums tracks, and play tracks. Also, in the
    `pytify` module, we import the `read_config` function and authenticate it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`MenuItem`，这样我们就可以返回带有请求结果的`MenuItem`对象。之后，我们从`pytify`模块导入函数来搜索艺术家，获取专辑，列出专辑曲目，并播放曲目。此外，在`pytify`模块中，我们导入`read_config`函数并对其进行身份验证。
- en: Lastly, we import the custom exception that we just created, `EmptyResultsError`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入刚刚创建的自定义异常`EmptyResultsError`。
- en: The initializer of the `DataManager` class starts reading the configuration
    and performs the authentication. The authentication information will be stored
    in the `_auth` property.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataManager`类的初始化器开始读取配置并执行身份验证。身份验证信息将存储在`_auth`属性中。'
- en: 'Next up, we are going to add a method to search for artists:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个搜索艺术家的方法：
- en: '[PRE83]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `_search_artist` method will get `criteria` as an argument and call the
    `search_artist` function from the `python.core` module. If no items are returned,
    it will raise an `EmptyResultsError`; otherwise, it will return the first match.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`_search_artist`方法将`criteria`作为参数，并调用`python.core`模块中的`search_artist`函数。如果没有返回项目，它将引发一个`EmptyResultsError`；否则，它将返回第一个匹配项。'
- en: Before we continue creating the methods that will fetch the albums and the tracks,
    we need two utility methods to format the labels of the `MenuItem` objects.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建将获取专辑和音轨的方法之前，我们需要两个实用方法来格式化`MenuItem`对象的标签。
- en: 'The first one will format the artist label:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法将格式化艺术家标签：
- en: '[PRE84]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, the label will be the name of the item and the type, which can be an album,
    single, EP, and so on.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标签将是项目的名称和类型，可以是专辑、单曲、EP等。
- en: 'And the second one formats the name of the tracks:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法格式化音轨的名称：
- en: '[PRE85]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here, we extract the duration of the track in milliseconds, convert is to `minutes:
    seconds`, and format the label with the name of the track and its duration between
    square brackets.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提取音轨的持续时间（以毫秒为单位），将其转换为`分钟：秒`的格式，并使用音轨的名称和持续时间在方括号之间格式化标签。
- en: 'After that, let''s create a method to get the artist''s albums:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们创建一个获取艺术家专辑的方法：
- en: '[PRE86]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `get_artist_albums` method gets two arguments, the `artist_id` and the `max_item`,
    which is the maximum number of albums that will be returned by the method. By
    default, it is set to `20`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_artist_albums`方法接受两个参数，`artist_id`和`max_item`，它是该方法返回的专辑最大数量。默认情况下，它设置为`20`。'
- en: The first thing we do here is use the `get_artist_albums` method from the `pytify.core`
    module, passing the `artist_id` and the `authentication` objects, and we get the
    item's attribute from the results, assigning it to the variable albums. If the
    `albums` variable is empty, it will raise an `EmptyResultsError`; otherwise, it
    will create a list of `MenuItem` objects for every album.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里首先使用`pytify.core`模块中的`get_artist_albums`方法，传递`artist_id`和`authentication`对象，并从结果中获取项目的属性，将其分配给变量专辑。如果`albums`变量为空，它将引发一个`EmptyResultsError`；否则，它将为每个专辑创建一个`MenuItem`对象的列表。
- en: 'And we can add another method for the tracks:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为音轨添加另一个方法：
- en: '[PRE87]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `get_album_tracklist` method gets `album_id` as an argument and the first
    thing we do is get the tracks for that album using the `get_album_tracks` function
    in the `pytify.core` module. If no result is returned, we raise an `EmptyResultsError`;
    otherwise, we build a list of `MenuItem` objects.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_album_tracklist`方法以`album_id`作为参数，我们首先使用`pytify.core`模块中的`get_album_tracks`函数获取该专辑的音轨。如果没有返回结果，我们会引发一个`EmptyResultsError`；否则，我们会构建一个`MenuItem`对象的列表。'
- en: 'The last method is the one that will actually send a command to the Spotify
    REST API to play a track:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法实际上是将命令发送到Spotify REST API播放音轨的方法：
- en: '[PRE88]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Very straightforward. Here, we just get `track_uri` as an argument and pass
    it down the `play` function in the `pytify.core` module, along with the `authentication`
    object. That will make the track start playing on the available device; it can
    be a mobile phone, Spotify's client on your computer, the Spotify web player,
    or even your games console.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 非常直接。在这里，我们只是将`track_uri`作为参数，并将其传递给`pytify.core`模块中的`play`函数，以及`authentication`对象。这将使音轨开始在可用设备上播放；可以是手机、您计算机上的Spotify客户端、Spotify网络播放器，甚至您的游戏机。
- en: Next up, let's put together everything we have built and run the Spotify player
    terminal.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们把我们建立的一切放在一起，并运行Spotify播放器终端。
- en: Time to listen to music!
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候听音乐了！
- en: Now, we have all the pieces we need to start building the terminal player. We
    have the `pytify` module, which provides a wrapper around the Spotify RESP API
    and will allow us to search for artists, albums, tracks, and even control the
    Spotify client running on a mobile phone or a computer.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了开始构建终端播放器所需的所有部件。我们有`pytify`模块，它提供了Spotify RESP API的包装器，并允许我们搜索艺术家、专辑、音轨，甚至控制运行在手机或计算机上的Spotify客户端。
- en: The `pytify` module also provides two different types of authentication—client
    credentials and authorization code—and in the previous sections, we implemented
    all the infrastructures necessary to build an application using curses. So, let's
    glue all the parts together and listen to some good music.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytify`模块还提供了两种不同类型的身份验证——客户端凭据和授权代码——在之前的部分中，我们实现了构建使用curses的应用程序所需的所有基础设施。因此，让我们将所有部分粘合在一起，听一些好音乐。'
- en: 'On the `musicterminal` directory, create a file called `app.py`; this is going
    to be the entry point for our application. We start by adding import statements:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在`musicterminal`目录中，创建一个名为`app.py`的文件；这将是我们应用程序的入口点。我们首先添加导入语句：
- en: '[PRE89]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We need to import `curses` and `curses.panel` of course, and this time, we are
    also importing `wrapper`. This is used for debugging purposes. When developing
    curses applications, they are extremely hard to debug, and when something goes
    wrong and some exception is thrown, the terminal will not go back to its original
    state.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然需要导入`curses`和`curses.panel`，这次我们还导入了`wrapper`。这用于调试目的。在开发curses应用程序时，它们极其难以调试，当出现问题并抛出异常时，终端将无法返回到其原始状态。
- en: The wrapper takes a `callable` and it returns the terminal original state when
    the `callable` function returns.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器接受一个`callable`，当`callable`函数返回时，它将返回终端的原始状态。
- en: The wrapper will run the callable within a try-catch block and it will restore
    the terminal in case something goes wrong. It is great for us while developing
    the application. Let's use the wrapper so we can see any kind of problem that
    may occur.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器将在try-catch块中运行可调用项，并在出现问题时恢复终端。在开发应用程序时非常有用。让我们使用包装器，这样我们就可以看到可能发生的任何问题。
- en: We are going to import two new functions, `Textbox` and `rectangle`. We are
    going to use those to create a search box where the users can search for their
    favorite artist.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入两个新函数，`Textbox`和`rectangle`。我们将使用它们创建一个搜索框，用户可以在其中搜索他们喜欢的艺术家。
- en: Lastly, we import the `Menu` class and the `DataManager` that we implemented
    in the previous sections.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入在前几节中实现的`Menu`类和`DataManager`。
- en: 'Let''s start implementing some helper functions; the first one is `show_search_screen`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现一些辅助函数；第一个是`show_search_screen`：
- en: '[PRE90]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: It gets an instance of the window as an argument, so we can print text and add
    our textbox on the screen.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 它以窗口实例作为参数，这样我们就可以在屏幕上打印文本并添加我们的文本框。
- en: The `curses.curs_set` function turns the cursor on and off; when set to `1`,
    the cursor will be visible on the screen. We want that in the search screen so
    the user knows where he/she can start typing the search criteria. Then, we print
    help text so the user knows that the name of the artist should be entered; then,
    to finish, they can press *Ctrl* + *G* or just *Enter* to perform the search.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`curses.curs_set`函数用于打开和关闭光标；当设置为`1`时，光标将在屏幕上可见。我们希望在搜索屏幕上这样做，以便用户知道可以从哪里开始输入搜索条件。然后，我们打印帮助文本，以便用户知道应输入艺术家的名称；最后，他们可以按*Ctrl*
    + *G*或*Enter*执行搜索。'
- en: To create the textbox, we create a new small window with a height that equals
    `1` and a width that equals `40`, and it starts at line `3`, column `3` of the
    terminal screen. After that, we use the `rectangle` function to draw a rectangle
    around the new window and we refresh the screen so the changes we made take effect.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文本框时，我们创建一个新的小窗口，高度为`1`，宽度为`40`，并且它从终端屏幕的第`3`行，第`3`列开始。之后，我们使用`rectangle`函数在新窗口周围绘制一个矩形，并刷新屏幕以使我们所做的更改生效。
- en: Then, we create the `Textbox` object, passing the window that we just created,
    and call the method `edit`, which will set the box to the textbox and enter edit
    mode. That will `stop` the application and let the user enter some text in the
    textbox; it will exit when the user clicks *Ctrl* + *G* or *Enter*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建`Textbox`对象，传递我们刚刚创建的窗口，并调用`edit`方法，它将设置框为文本框并进入编辑模式。这将`停止`应用程序，并允许用户在文本框中输入一些文本；当用户点击*Ctrl*
    + *G*或*Enter*时，它将退出。
- en: When the user is done editing the text, we call the `gather` method that will
    collect the data entered by the user and assign it to the `criteria` variable,
    and finally, we return `criteria`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成编辑文本后，我们调用`gather`方法，它将收集用户输入的数据并将其分配给`criteria`变量，最后返回`criteria`。
- en: 'We also need a function to clean the screen easily Let''s create another function
    called `clean_screen`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来轻松清理屏幕，让我们创建另一个名为`clean_screen`的函数：
- en: '[PRE91]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Great! Now, we can start with the main entry point of our application, and
    create a function called main with the following contents:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以开始应用程序的主入口，并创建一个名为main的函数，内容如下：
- en: '[PRE92]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let''s break this down into its constituent parts:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解为其组成部分：
- en: '[PRE93]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we do some initialization. Usually, curses don't register the key immediately.
    When it is typed, this is called buffered mode; the user has to type something
    and then hit *Enter.* In our application, we don't want this behavior; we want
    the key to be registered right after the user types it. This is what `cbreak`
    does; it turns off the curses buffered mode.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进行一些初始化。通常，curses不会立即注册按键。当按键被输入时，这称为缓冲模式；用户必须输入一些内容，然后按*Enter*。在我们的应用程序中，我们不希望出现这种行为；我们希望按键在用户输入后立即注册。这就是`cbreak`的作用；它关闭curses的缓冲模式。
- en: We also use the `noecho` function to be able the read the keys and to control
    when we want to show them on the screen.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`noecho`函数来读取按键并控制何时在屏幕上显示它们。
- en: The last curses setup we do is to turn on the keypad so curses will do the job
    of reading and processing the keys accordingly, and returning constant values
    representing the key that has been pressed. This is much cleaner and easy to read
    than trying to handle it yourself and test key code numbers.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一个curses设置是打开键盘，这样curses将负责读取和处理按键，并返回表示已按下的键的常量值。这比尝试自己处理并测试键码数字要干净得多，更易于阅读。
- en: 'We create an instance of the `DataManager` class so we can get the data we
    need to be displayed on the menus and perform authentication:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`DataManager`类的实例，以便获取我们需要在菜单上显示的数据并执行身份验证：
- en: '[PRE94]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we create the search dialog:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建搜索对话框：
- en: '[PRE95]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We call the `show_search_screen` function, passing the instance of the window;
    it will render the search field on the screen and return the results to us. When
    the user is done typing, the user input will be stored in the `criteria` variable.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`show_search_screen`函数，传递窗口的实例；它将在屏幕上呈现搜索字段并将结果返回给我们。当用户输入完成时，用户输入将存储在`criteria`变量中。
- en: After we get the criteria, we call `get_artist_albums`, which will first search
    an artist and then get a list of the artist's albums and return a list of `MenuItem`
    objects.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取条件后，我们调用`get_artist_albums`，它将首先搜索艺术家，然后获取艺术家专辑列表并返回`MenuItem`对象的列表。
- en: 'When the list of albums is returned, we can create the other panels with the
    menus:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当专辑列表返回时，我们可以创建其他带有菜单的面板：
- en: '[PRE96]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here, we get the height and the width of the main window so we can create panels
    with the same dimensions.  `albums_panel` will display the albums and `tracks_panel`
    will display the tracks; as I mentioned before, it will have the same dimensions
    as the main window and both panels will start at row `0`, column `0`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取主窗口的高度和宽度，以便我们可以创建具有相同尺寸的面板。`albums_panel`将显示专辑，`tracks_panel`将显示曲目；如前所述，它将具有与主窗口相同的尺寸，并且两个面板将从第`0`行，第`0`列开始。
- en: 'After that, we call `clear_screen` to prepare the window to render the menu
    window with the albums:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用`clear_screen`准备窗口以渲染带有专辑的菜单窗口：
- en: '[PRE97]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We first set the item's properties with the results of the albums search. We
    also call `init` on the panel, which will internally run `_initialize_items`,
    format the labels and set the currently selected item. We also call the `update`
    method, which will do the actual work of printing the menu items in the window;
    lastly, we show how to set the panel to visible.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用专辑搜索结果设置项目的属性。我们还在面板上调用`init`，这将在内部运行`_initialize_items`，格式化标签并设置当前选定的项目。我们还调用`update`方法，这将实际打印窗口中的菜单项；最后，我们展示如何将面板设置为可见。
- en: We also define the `current_panel` variable, which will hold the instance of
    the panel that is currently being displayed on the terminal.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了`current_panel`变量，它将保存当前在终端上显示的面板的实例。
- en: The `is_running` flag is set to `True` and it will be used in the application's
    main loop. We will set it to `False` when we want to stop the application's execution.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_running`标志设置为`True`，并将在应用程序的主循环中使用。当我们想要停止应用程序的执行时，我们将其设置为`False`。'
- en: 'Now, we enter the main loop of the application:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入应用程序的主循环：
- en: '[PRE98]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To start off, we call `doupdate` and `update_panels`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`doupdate`和`update_panels`：
- en: '`doupdate`: Curses keeps two data structures representing the physical screen
    (the one you see on the terminal screen) and a virtual screen (the one keeping
    the next updated). `doupdate` updates the physical screen so it matches the virtual
    screen.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doupdate`：Curses保留两个表示物理屏幕（在终端屏幕上看到的屏幕）和虚拟屏幕（保持下一个更新的屏幕）的数据结构。`doupdate`更新物理屏幕，使其与虚拟屏幕匹配。'
- en: '`update_panels`: Updates the virtual screen after changes in the panel stack,
    changes like hiding, show panels, and so on.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_panels`：在面板堆栈中的更改后更新虚拟屏幕，例如隐藏、显示面板等。'
- en: After updating the screen, we wait until a key is pressed using the `getch`
    function, and assign the key pressed value to the `key` variable. The `key` variable
    is then passed to the current panel's `handle_events` method.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 更新屏幕后，我们使用`getch`函数等待按键按下，并将按下的键值分配给`key`变量。然后将`key`变量传递给当前面板的`handle_events`方法。
- en: 'If you remember the implementation of `handle_events` in the `Menu` class,
    it looks like this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得`Menu`类中`handle_events`的实现，它看起来像这样：
- en: '[PRE99]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: It handles `KEY_DOWN`, `KEY_UP`, and `KEY_ENTER`. If the key is `KEY_UP` or
    `KEY_DOWN`, it will just update the position in the menu and set a newly selected
    item, and that will be updated on the screen on the next loop interaction. If
    the key is `KEY_ENTER`, we get the selected item and return its action function.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 它处理`KEY_DOWN`，`KEY_UP`和`KEY_ENTER`。如果键是`KEY_UP`或`KEY_DOWN`，它将只更新菜单中的位置并设置新选择的项目，这将在下一个循环交互中更新在屏幕上。如果键是`KEY_ENTER`，我们获取所选项目并返回其操作函数。
- en: Remember that, for both panels, it will return a function that, when executed,
    will return a tuple containing the item id and the item URI.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于两个面板，它将返回一个函数，当执行时，将返回包含项目ID和项目URI的元组。
- en: 'Moving on, we handle if the action is returned:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理返回的操作：
- en: '[PRE100]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: If the `handle_events` method of the current panel returned a callable `action`,
    we execute it and get the result. Then, we check if the active panel is the first
    panel (with the albums). In this case, we need to get a list of tracks for the
    selected album, so we call `get_album_tracklist` in the `DataManager` instance.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前面板的`handle_events`方法返回一个可调用的`action`，我们执行它并获取结果。然后，我们检查活动面板是否是第一个面板（带有专辑）。在这种情况下，我们需要获取所选专辑的曲目列表，因此我们在`DataManager`实例中调用`get_album_tracklist`。
- en: We hide the `current_panel,` switch the current panel to the second panel (the
    tracks panel), set the items property with the list of tracks, call the init method
    so the items are formatted properly and a first item in the list is set as selected,
    and finally we call `show` so the track's panel is visible.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们隐藏`current_panel`，将当前面板切换到第二个面板（曲目面板），使用曲目列表设置项目属性，调用init方法使项目正确格式化并设置列表中的第一个项目为选定项目，最后我们调用`show`以便曲目面板可见。
- en: In the event the current panel is the `tracks_panel`, we get the action results
    and invoke play on the `DataManager`, passing the track URI. It will request the
    selected track to be played on the device you have active on Spotify.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前面板是`tracks_panel`的情况下，我们获取操作结果并在`DataManager`上调用play，传递曲目URI。它将请求在Spotify上活跃的设备上播放所选的曲目。
- en: Now, we want a way of returning to the search screen. We do that when the user
    hits the *F12* function `key`*:*
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望有一种方法返回到搜索屏幕。当用户按下*F12*功能键时，我们这样做：
- en: '[PRE101]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: For the `if` statement above, test if the user pressed the  *F12* function `key`;
    in this case, we want to return to the search screen so that the user can search
    for a new artist. When the *F12* key is pressed, we hide the current panel. Then,
    we call the `show_search_screen` function so the search screen is rendered and
    the textbox will enter in edit mode, waiting for the user's input.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上面的`if`语句，测试用户是否按下了*F12*功能键；在这种情况下，我们希望返回到搜索屏幕，以便用户可以搜索新的艺术家。当按下*F12*键时，我们隐藏当前面板。然后，我们调用`show_search_screen`函数，以便呈现搜索屏幕，并且文本框将进入编辑模式，等待用户的输入。
- en: When the user is done typing and hits *Ctrl*+ *G* or *Enter*, we search the
    artist. Then, we get the artist's albums and we show the panel with a list of
    albums.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入完成并按下*Ctrl*+ *G*或*Enter*时，我们搜索艺术家。然后，我们获取艺术家的专辑，并显示带有专辑列表的面板。
- en: 'The last event that we want to handle is when the user press either the `q`
    or `Q` key, which sets the `is_running` variable to `False` and the application
    closes:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要处理的最后一个事件是用户按下`q`或`Q`键，将`is_running`变量设置为`False`，应用程序关闭：
- en: '[PRE102]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Finally, we call `update` on the current panel, so we redraw the items to reflect
    the changes on the screen:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在当前面板上调用`update`，以便重新绘制项目以反映屏幕上的更改：
- en: '[PRE103]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Outside the main function, we have the code snippet where we actually execute
    the `main` function:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数之外，我们有代码片段，其中我们实际执行`main`函数：
- en: '[PRE104]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We surround it with a `try` catch so if the user presses *Ctrl* + *C,* a `KeyboardInterrupt`
    exception will be raised and we just finish the application gracefully without
    throwing the exception on the screen.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`try` catch包围它，所以如果用户按下*Ctrl* + *C*，将会引发`KeyboardInterrupt`异常，我们只需优雅地完成应用程序，而不会在屏幕上抛出异常。
- en: We are all done! Let's try it out!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都完成了！让我们试试吧！
- en: Open a terminal and type the command—`python app.py`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并输入命令—`python app.py`。
- en: 'The first screen you will see is the search screen:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的第一个屏幕是搜索屏幕：
- en: '![](assets/526e4ad4-49d1-401d-8c0c-d58064a728fd.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/526e4ad4-49d1-401d-8c0c-d58064a728fd.png)'
- en: 'Let me search for one of my favorite artists:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我搜索一下我最喜欢的艺术家：
- en: '![](assets/fdc3a925-18ee-43ea-b8e1-65fe12d2ae54.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fdc3a925-18ee-43ea-b8e1-65fe12d2ae54.png)'
- en: 'After pressing *Enter* or *Ctrl* + *G,* you should see a list of albums:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*或*Ctrl* + *G*后，您应该会看到专辑列表：
- en: '![](assets/131e336d-88eb-4ca7-a629-e2670ede056f.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/131e336d-88eb-4ca7-a629-e2670ede056f.png)'
- en: 'Here, you can use the arrow keys (*Up* and *Down*) to navigate albums, and
    press *Enter* to select an album. Then, you will see the screen showing all the
    tracks of the selected album:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用箭头键（*上*和*下*）来浏览专辑，并按*Enter*来选择一个专辑。然后，您将看到屏幕显示所选专辑的所有曲目：
- en: '![](assets/71f792f1-dc7c-4300-a96e-3983f7576669.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/71f792f1-dc7c-4300-a96e-3983f7576669.png)'
- en: If this screen is the same, you can use the arrow keys (*Up* and *Down*) to
    select the track, and *Enter* will send a request to play the song on the device
    you have Spotify active on.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个屏幕是一样的，您可以使用箭头键（*上*和*下*）来选择曲目，*Enter*将发送请求在您的Spotify活动设备上播放这首歌曲。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have covered a lot of ground in this chapter; we started by creating an
    application on Spotify and learning our way around its developer''s website. Then,
    we learned how to implement the two types of authentication flow that Spotify
    supports: the client credentials flow and the authorization flow.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容；我们首先在Spotify上创建了一个应用程序，并学习了其开发者网站的使用方法。然后，我们学习了如何实现Spotify支持的两种认证流程：客户端凭据流程和授权流程。
- en: In this chapter, we also implemented a whole module wrapper with some of the
    functionality available from Spotify's REST API.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还实现了一个完整的模块包装器，其中包含了一些来自Spotify的REST API的功能。
- en: Then, we implemented a simple terminal client where users can search for artists,
    browse the artist's albums and tracks, and finally play a song in the user's active
    device, which can be a computer, mobile phone, or even a video game console.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了一个简单的终端客户端，用户可以在其中搜索艺术家，浏览艺术家的专辑和曲目，最后在用户的活动设备上播放一首歌曲，这可以是计算机、手机，甚至是视频游戏主机。
- en: In the next chapter, we are going to create a desktop application that shows
    the number of votes given through Twitter hashtags.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个桌面应用程序，显示通过Twitter标签的投票数。
