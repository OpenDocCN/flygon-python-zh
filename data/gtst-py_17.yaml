- en: When Objects Are Alike
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当对象相似时
- en: In the programming world, duplicate code is considered evil. We should not have
    multiple copies of the same, or similar, code in different places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，重复的代码被认为是邪恶的。我们不应该在不同的地方有相同或相似的代码的多个副本。
- en: 'There are many ways to merge pieces of code or objects that have a similar
    functionality. In this chapter, we''ll be covering the most famous object-oriented
    principle: inheritance. As discussed in [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml),
    *Object-Oriented Design*, inheritance allows us to create is a relationships between
    two or more classes, abstracting common logic into superclasses and managing specific
    details in the subclass. In particular, we''ll be covering the Python syntax and
    principles for the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以合并具有类似功能的代码或对象。在本章中，我们将介绍最著名的面向对象原则：继承。正如在[第15章](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml)中讨论的那样，*面向对象设计*，继承允许我们在两个或多个类之间创建is
    a关系，将通用逻辑抽象到超类中，并在子类中管理特定细节。特别是，我们将介绍以下内容的Python语法和原则：
- en: Basic inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本继承
- en: Inheriting from built-in types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内置类型继承
- en: Multiple inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重继承
- en: Polymorphism and duck typing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态和鸭子类型
- en: Basic inheritance
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本继承
- en: Technically, every class we create uses inheritance. All Python classes are
    subclasses of the special built-in class named `object`. This class provides very
    little in terms of data and behaviors (the behaviors it does provide are all double-underscore
    methods intended for internal use only), but it does allow Python to treat all
    objects in the same way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们创建的每个类都使用继承。所有Python类都是名为`object`的特殊内置类的子类。这个类在数据和行为方面提供的很少（它提供的行为都是为了内部使用的双下划线方法），但它确实允许Python以相同的方式对待所有对象。
- en: 'If we don''t explicitly inherit from a different class, our classes will automatically
    inherit from `object`. However, we can openly state that our class derives from
    `object` using the following syntax:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不明确从不同的类继承，我们的类将自动从`object`继承。然而，我们可以明确声明我们的类从`object`派生，使用以下语法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is inheritance! This example is, technically, no different from our very
    first example in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*, since Python 3 automatically inherits from `object` if we don't explicitly
    provide a different **superclass**. A superclass, or parent class, is a class
    that is being inherited from. A subclass is a class that is inheriting from a
    superclass. In this case, the superclass is `object`, and `MySubClass` is the
    subclass. A subclass is also said to be derived from its parent class or that
    the subclass extends the parent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承！从技术上讲，这个例子与我们在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)中的第一个例子没有什么不同，*Python中的对象*，因为如果我们不明确提供不同的**超类**，Python
    3会自动从`object`继承。超类或父类是被继承的类。子类是从超类继承的类。在这种情况下，超类是`object`，而`MySubClass`是子类。子类也被称为从其父类派生，或者说子类扩展了父类。
- en: As you've probably figured out from the example, inheritance requires a minimal
    amount of extra syntax over a basic class definition. Simply include the name
    of the parent class inside parentheses between the class name and the colon that
    follows. This is all we have to do to tell Python that the new class should be
    derived from the given superclass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中你可能已经发现，继承需要比基本类定义多出一点额外的语法。只需在类名和后面的冒号之间的括号内包含父类的名称。这就是我们告诉Python新类应该从给定的超类派生的所有内容。
- en: 'How do we apply inheritance in practice? The simplest and most obvious use
    of inheritance is to add functionality to an existing class. Let''s start with
    a simple contact manager that tracks the name and email address of several people.
    The `Contact` class is responsible for maintaining a list of all contacts in a
    class variable, and for initializing the name and address for an individual contact:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在实践中应用继承？继承最简单和最明显的用途是向现有类添加功能。让我们从一个简单的联系人管理器开始，跟踪几个人的姓名和电子邮件地址。`Contact`类负责在类变量中维护所有联系人的列表，并为单个联系人初始化姓名和地址：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example introduces us to **class variables**. The `all_contacts` list,
    because it is part of the class definition, is shared by all instances of this
    class. This means that there is only one `Contact.all_contacts` list. We can also
    access it as `self.all_contacts` from within any method on an instance of the
    `Contact` class. If a field can't be found on the object (via `self`), then it
    will be found on the class and will thus refer to the same single list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们介绍了**类变量**。`all_contacts`列表，因为它是类定义的一部分，被这个类的所有实例共享。这意味着只有一个`Contact.all_contacts`列表。我们也可以在`Contact`类的任何实例方法中作为`self.all_contacts`访问它。如果在对象（通过`self`）上找不到字段，那么它将在类上找到，并且因此将引用相同的单个列表。
- en: Be careful with this syntax, for if you ever *set* the variable using `self.all_contacts`,
    you will actually be creating a **new** instance variable associated just with
    that object. The class variable will still be unchanged and accessible as `Contact.all_contacts`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个语法要小心，因为如果你使用`self.all_contacts`来*设置*变量，你实际上会创建一个**新的**与该对象关联的实例变量。类变量仍然不变，并且可以作为`Contact.all_contacts`访问。
- en: 'This is a simple class that allows us to track a couple of pieces of data about
    each contact. But what if some of our contacts are also suppliers that we need
    to order supplies from? We could add an `order` method to the `Contact` class,
    but that would allow people to accidentally order things from contacts who are
    customers or family friends. Instead, let''s create a new `Supplier` class that
    acts like our `Contact` class, but has an additional `order` method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，允许我们跟踪每个联系人的一些数据。但是如果我们的一些联系人也是我们需要从中订购物品的供应商呢？我们可以在`Contact`类中添加一个`order`方法，但这将允许人们意外地从客户或家庭朋友的联系人那里订购东西。相反，让我们创建一个新的`Supplier`类，它的行为类似于我们的`Contact`类，但有一个额外的`order`方法：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, if we test this class in our trusty interpreter, we see that all contacts,
    including suppliers, accept a name and email address in their `__init__`, but
    that only suppliers have a functional order method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在我们可靠的解释器中测试这个类，我们会发现所有联系人，包括供应商，在它们的`__init__`中都接受名称和电子邮件地址，但只有供应商有一个功能性的订单方法：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, now our `Supplier` class can do everything a contact can do (including adding
    itself to the list of `all_contacts`) and all the special things it needs to handle
    as a supplier. This is the beauty of inheritance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们的`Supplier`类可以做所有联系人可以做的事情（包括将自己添加到`all_contacts`列表中）以及作为供应商需要处理的所有特殊事情。这就是继承的美妙之处。
- en: Extending built-ins
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展内置类
- en: 'One interesting use of this kind of inheritance is adding functionality to
    built-in classes. In the `Contact` class seen earlier, we are adding contacts
    to a list of all contacts. What if we also wanted to search that list by name?
    Well, we could add a method on the `Contact` class to search it, but it feels
    like this method actually belongs to the list itself. We can do this using inheritance:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种继承的一个有趣用途是向内置类添加功能。在前面看到的`Contact`类中，我们正在将联系人添加到所有联系人的列表中。如果我们还想按名称搜索该列表怎么办？嗯，我们可以在`Contact`类上添加一个搜索方法，但感觉这个方法实际上属于列表本身。我们可以使用继承来实现这一点：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of instantiating a normal list as our class variable, we create a new
    `ContactList` class that extends the built-in `list` data type. Then, we instantiate
    this subclass as our `all_contacts` list. We can test the new search functionality
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是实例化一个普通列表作为我们的类变量，而是创建一个扩展内置`list`数据类型的新`ContactList`类。然后，我们将这个子类实例化为我们的`all_contacts`列表。我们可以测试新的搜索功能如下：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Are you wondering how we changed the built-in syntax `[]` into something we
    can inherit from? Creating an empty list with `[]` is actually a shortcut for
    creating an empty list using `list()`; the two syntaxes behave identically:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道我们如何将内置语法`[]`改变成我们可以继承的东西？使用`[]`创建一个空列表实际上是使用`list()`创建一个空列表的快捷方式；这两种语法的行为是相同的：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In reality, the `[]` syntax is actually so-called **syntactic sugar** that
    calls the `list()` constructor under the hood. The `list` data type is a class
    that we can extend. In fact, the list itself extends the `object` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`[]`语法实际上是所谓的**语法糖**，在幕后调用`list()`构造函数。`list`数据类型是一个我们可以扩展的类。事实上，列表本身扩展了`object`类：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As a second example, we can extend the `dict` class, which is, similar to the
    list, the class that is constructed when using the `{}` syntax shorthand:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们可以扩展`dict`类，它与列表类似，是在使用`{}`语法缩写时构造的类：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is easy to test in the interactive interpreter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这在交互式解释器中很容易测试：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most built-in types can be similarly extended. Commonly extended built-ins are
    `object`, `list`, `set`, `dict`, `file`, and `str`. Numerical types such as `int`
    and `float` are also occasionally inherited from.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数内置类型都可以类似地扩展。常见的扩展内置类包括`object`、`list`、`set`、`dict`、`file`和`str`。数值类型如`int`和`float`有时也会被继承。
- en: Overriding and super
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写和super
- en: So, inheritance is great for *adding* new behavior to existing classes, but
    what about *changing* behavior? Our `Contact` class allows only a name and an
    email address. This may be sufficient for most contacts, but what if we want to
    add a phone number for our close friends?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继承非常适合*向*现有类添加新行为，但是*改变*行为呢？我们的`Contact`类只允许名称和电子邮件地址。这对大多数联系人可能已经足够了，但是如果我们想为我们的亲密朋友添加电话号码呢？
- en: 'As we saw in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*, we can do this easily by just setting a `phone` attribute on the contact
    after it is constructed. But if we want to make this third variable available
    on initialization, we have to override `__init__`. Overriding means altering or
    replacing a method of the superclass with a new method (with the same name) in
    the subclass. No special syntax is needed to do this; the subclass''s newly created
    method is automatically called instead of the superclass''s method. As shown in
    the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)中看到的，*Python中的对象*，我们可以很容易地在构造后在联系人上设置`phone`属性。但是，如果我们想在初始化时使这个第三个变量可用，我们必须重写`__init__`。重写意味着用子类中的新方法（具有相同名称）更改或替换超类的方法。不需要特殊的语法来做到这一点；子类的新创建的方法会自动被调用，而不是超类的方法。如下面的代码所示：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any method can be overridden, not just `__init__`. Before we go on, however,
    we need to address some problems in this example. Our `Contact` and `Friend` classes
    have duplicate code to set up the `name` and `email` properties; this can make
    code maintenance complicated, as we have to update the code in two or more places.
    More alarmingly, our `Friend` class is neglecting to add itself to the `all_contacts`
    list we have created on the `Contact` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法都可以被重写，不仅仅是`__init__`。然而，在继续之前，我们需要解决这个例子中的一些问题。我们的`Contact`和`Friend`类有重复的代码来设置`name`和`email`属性；这可能会使代码维护复杂化，因为我们必须在两个或更多地方更新代码。更令人担忧的是，我们的`Friend`类忽略了将自己添加到我们在`Contact`类上创建的`all_contacts`列表中。
- en: 'What we really need is a way to execute the original `__init__` method on the
    `Contact` class from inside our new class. This is what the `super` function does;
    it returns the object as an instance of the parent class, allowing us to call
    the parent method directly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一种方法，可以从我们的新类内部执行`Contact`类上的原始`__init__`方法。这就是`super`函数的作用；它将对象作为父类的实例返回，允许我们直接调用父类方法：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example first gets the instance of the parent object using `super`, and
    calls `__init__` on that object, passing in the expected arguments. It then does
    its own initialization, namely, setting the `phone` attribute.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先使用`super`获取父对象的实例，并在该对象上调用`__init__`，传入预期的参数。然后进行自己的初始化，即设置`phone`属性。
- en: A `super()` call can be made inside any method. Therefore, all methods can be
    modified via overriding and calls to `super`. The call to `super` can also be
    made at any point in the method; we don't have to make the call as the first line.
    For example, we may need to manipulate or validate incoming parameters before
    forwarding them to the superclass.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()`调用可以在任何方法内部进行。因此，所有方法都可以通过覆盖和调用`super`进行修改。`super`的调用也可以在方法的任何地方进行；我们不必将调用作为第一行。例如，我们可能需要在将传入参数转发给超类之前操纵或验证传入参数。'
- en: Multiple inheritance
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Multiple inheritance is a touchy subject. In principle, it''s simple: a subclass
    that inherits from more than one parent class is able to access functionality
    from both of them. In practice, this is less useful than it sounds and many expert
    programmers recommend against using it.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承是一个敏感的话题。原则上，它很简单：从多个父类继承的子类能够访问它们两者的功能。实际上，这并没有听起来那么有用，许多专家程序员建议不要使用它。
- en: As a humorous rule of thumb, if you think you need multiple inheritance, you're
    probably wrong, but if you know you need it, you might be right.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个幽默的经验法则，如果你认为你需要多重继承，你可能是错的，但如果你知道你需要它，你可能是对的。
- en: 'The simplest and most useful form of multiple inheritance is called a **mixin**.
    A mixin is a superclass that is not intended to exist on its own, but is meant
    to be inherited by some other class to provide extra functionality. For example,
    let''s say we wanted to add functionality to our `Contact` class that allows sending
    an email to `self.email`. Sending email is a common task that we might want to
    use on many other classes. So, we can write a simple mixin class to do the emailing
    for us:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单和最有用的多重继承形式被称为**mixin**。mixin是一个不打算独立存在的超类，而是打算被其他类继承以提供额外的功能。例如，假设我们想要为我们的`Contact`类添加功能，允许向`self.email`发送电子邮件。发送电子邮件是一个常见的任务，我们可能希望在许多其他类上使用它。因此，我们可以编写一个简单的mixin类来为我们发送电子邮件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For brevity, we won't include the actual email logic here; if you're interested
    in studying how it's done, see the `smtplib` module in the Python standard library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会在这里包含实际的电子邮件逻辑；如果你有兴趣学习如何做到这一点，请参阅Python标准库中的`smtplib`模块。
- en: 'This class doesn''t do anything special (in fact, it can barely function as
    a standalone class), but it does allow us to define a new class that describes
    both a `Contact` and a `MailSender`, using multiple inheritance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并没有做任何特别的事情（实际上，它几乎不能作为一个独立的类运行），但它确实允许我们定义一个新的类，描述了`Contact`和`MailSender`，使用多重继承：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The syntax for multiple inheritance looks like a parameter list in the class
    definition. Instead of including one base class inside the parentheses, we include
    two (or more), separated by a comma. We can test this new hybrid to see the mixin
    at work:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承的语法看起来像类定义中的参数列表。在括号内不是包含一个基类，而是包含两个（或更多），用逗号分隔。我们可以测试这个新的混合体，看看mixin的工作情况：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Contact` initializer is still adding the new contact to the `all_contacts`
    list, and the mixin is able to send mail to `self.email`, so we know that everything
    is working.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact`初始化器仍然将新联系人添加到`all_contacts`列表中，mixin能够向`self.email`发送邮件，所以我们知道一切都在运行。'
- en: 'This wasn''t so hard, and you''re probably wondering what the dire warnings
    about multiple inheritance are. We''ll get into the complexities in a minute,
    but let''s consider some other options we had for this example, rather than using
    a mixin:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难，你可能想知道关于多重继承的严重警告是什么。我们将在一分钟内讨论复杂性，但让我们考虑一下我们在这个例子中的其他选择，而不是使用mixin：
- en: We could have used single inheritance and added the `send_mail` function to
    the subclass. The disadvantage here is that the email functionality then has to
    be duplicated for any other classes that need an email.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以使用单一继承，并将`send_mail`函数添加到子类中。这里的缺点是，邮件功能必须为任何其他需要邮件的类重复。
- en: We can create a standalone Python function for sending an email, and just call
    that function with the correct email address supplied as a parameter when the
    email needs to be sent (this would be my choice).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个独立的Python函数来发送电子邮件，并在需要发送电子邮件时以参数的形式调用该函数并提供正确的电子邮件地址（这将是我的选择）。
- en: We could have explored a few ways of using composition instead of inheritance.
    For example, `EmailableContact` could have a `MailSender` object as a property
    instead of inheriting from it.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以探索一些使用组合而不是继承的方法。例如，`EmailableContact`可以将`MailSender`对象作为属性，而不是继承它。
- en: We could monkey patch (we'll briefly cover monkey patching in [Chapter 20](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml),
    *Python Object-Oriented Shortcuts*) the `Contact` class to have a `send_mail`
    method after the class has been created. This is done by defining a function that
    accepts the `self` argument, and setting it as an attribute on an existing class.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在创建类之后对`Contact`类进行monkey patching（我们将在[第20章](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml)中简要介绍monkey
    patching，*Python面向对象的快捷方式*）。这是通过定义一个接受`self`参数的函数，并将其设置为现有类的属性来完成的。
- en: Multiple inheritance works all right when mixing methods from different classes,
    but it gets very messy when we have to call methods on the superclass. There are
    multiple superclasses. How do we know which one to call? How do we know what order
    to call them in?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合来自不同类的方法时，多重继承效果还不错，但当我们必须在超类上调用方法时，情况就变得非常混乱。有多个超类。我们怎么知道该调用哪一个？我们怎么知道以什么顺序调用它们？
- en: Let's explore these questions by adding a home address to our `Friend` class.
    There are a few approaches we might take. An address is a collection of strings
    representing the street, city, country, and other related details of the contact.
    We could pass each of these strings as a parameter into the `Friend` class's `__init__`
    method. We could also store these strings in a tuple, dictionary, or dataclass
    and pass them into `__init__` as a single argument. This is probably the best
    course of action if there are no methods that need to be added to the address.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的`Friend`类添加家庭地址来探讨这些问题。我们可能会采取一些方法。地址是一组表示联系人的街道、城市、国家和其他相关细节的字符串。我们可以将这些字符串中的每一个作为参数传递给`Friend`类的`__init__`方法。我们也可以将这些字符串存储在元组、字典或数据类中，并将它们作为单个参数传递给`__init__`。如果没有需要添加到地址的方法，这可能是最好的做法。
- en: Another option would be to create a new `Address` class to hold those strings
    together, and then pass an instance of this class into the `__init__` method in
    our `Friend` class. The advantage of this solution is that we can add behavior
    (say, a method to give directions or to print a map) to the data instead of just
    storing it statically. This is an example of composition, as we discussed in [Chapter
    15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml), *Object-Oriented Design*. Composition
    is a perfectly viable solution to this problem and allows us to reuse `Address`
    classes in other entities, such as buildings, businesses, or organizations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是创建一个新的`Address`类来保存这些字符串，然后将这个类的实例传递给我们的`Friend`类的`__init__`方法。这种解决方案的优势在于，我们可以为数据添加行为（比如，一个给出方向或打印地图的方法），而不仅仅是静态存储。这是组合的一个例子，正如我们在[第15章](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml)中讨论的那样，*面向对象设计*。组合是这个问题的一个完全可行的解决方案，它允许我们在其他实体中重用`Address`类，比如建筑物、企业或组织。
- en: 'However, inheritance is also a viable solution, and that''s what we want to
    explore. Let''s add a new class that holds an address. We''ll call this new class
    `AddressHolder` instead of `Address` because inheritance defines an is a relationship.
    It is not correct to say a `Friend` class is an `Address` class, but since a friend
    can have an `Address` class, we can argue that a `Friend` class is an `AddressHolder` class.
    Later, we could create other entities (companies, buildings) that also hold addresses.
    Then again, such convoluted naming is a decent indication we should be sticking
    with composition, rather than inheritance. But for pedagogical purposes, we''ll
    stick with inheritance. Here''s our `AddressHolder` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，继承也是一个可行的解决方案，这就是我们想要探讨的。让我们添加一个新的类来保存地址。我们将这个新类称为`AddressHolder`，而不是`Address`，因为继承定义了一种是一个关系。说`Friend`类是`Address`类是不正确的，但由于朋友可以有一个`Address`类，我们可以说`Friend`类是`AddressHolder`类。稍后，我们可以创建其他实体（公司，建筑物）也持有地址。然而，这种复杂的命名是一个很好的指示，我们应该坚持组合，而不是继承。但出于教学目的，我们将坚持使用继承。这是我们的`AddressHolder`类：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We just take all the data and toss it into instance variables upon initialization.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在初始化时将所有数据放入实例变量中。
- en: The diamond problem
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菱形问题
- en: 'We can use multiple inheritance to add this new class as a parent of our existing
    `Friend` class. The tricky part is that we now have two parent `__init__` methods,
    both of which need to be initialized. And they need to be initialized with different
    arguments. How do we do this? Well, we could start with a naive approach:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多重继承将这个新类添加为现有`Friend`类的父类。棘手的部分是现在我们有两个父`__init__`方法，它们都需要被初始化。而且它们需要用不同的参数进行初始化。我们该怎么做呢？嗯，我们可以从一个天真的方法开始：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we directly call the `__init__` function on each of the superclasses
    and explicitly pass the `self` argument. This example technically works; we can
    access the different variables directly on the class. But there are a few problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们直接调用每个超类的`__init__`函数，并显式传递`self`参数。这个例子在技术上是有效的；我们可以直接在类上访问不同的变量。但是有一些问题。
- en: First, it is possible for a superclass to go uninitialized if we neglect to
    explicitly call the initializer. That wouldn't break this example, but it could
    cause hard-to-debug program crashes in common scenarios. Imagine trying to insert
    data into a database that has not been connected to, for example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们忽略显式调用初始化程序，超类可能会未初始化。这不会破坏这个例子，但在常见情况下可能会导致难以调试的程序崩溃。例如，想象一下尝试将数据插入未连接的数据库。
- en: 'A more insidious possibility is a superclass being called multiple times because
    of the organization of the class hierarchy. Look at this inheritance diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更隐匿的可能性是由于类层次结构的组织而多次调用超类。看看这个继承图：
- en: '![](assets/aa756ecd-f4b1-4ece-b1ec-50fc35c748fa.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa756ecd-f4b1-4ece-b1ec-50fc35c748fa.png)'
- en: The `__init__` method from the `Friend` class first calls `__init__` on `Contact`,
    which implicitly initializes the `object` superclass (remember, all classes derive
    from `object`). `Friend` then calls `__init__` on `AddressHolder`, which implicitly
    initializes the `object` superclass *again*. This means the parent class has been
    set up twice. With the `object` class, that's relatively harmless, but in some
    situations, it could spell disaster. Imagine trying to connect to a database twice
    for every request!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Friend`类的`__init__`方法首先调用`Contact`的`__init__`，这隐式地初始化了`object`超类（记住，所有类都派生自`object`）。然后`Friend`调用`AddressHolder`的`__init__`，这又隐式地初始化了`object`超类。这意味着父类已经被设置了两次。对于`object`类来说，这相对无害，但在某些情况下，这可能会带来灾难。想象一下，每次请求都要尝试两次连接到数据库！'
- en: The base class should only be called once. Once, yes, but when? Do we call `Friend`,
    then `Contact`, then `Object`, and then `AddressHolder`? Or `Friend`, then `Contact`,
    then `AddressHolder`, and then `Object`?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基类应该只被调用一次。是的，但是何时呢？我们先调用`Friend`，然后`Contact`，然后`Object`，然后`AddressHolder`？还是`Friend`，然后`Contact`，然后`AddressHolder`，然后`Object`？
- en: The order in which methods can be called can be adapted on the fly by modifying
    the `__mro__` (**Method Resolution Order**) attribute on the class. This is beyond
    the scope of this book. If you think you need to understand it, we recommend *Expert
    Python Programming*, *Tarek Ziadé*, *Packt Publishing*, or read the original documentation
    (beware, it's deep!) on the topic at [http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的调用顺序可以通过修改类的`__mro__`（**方法解析顺序**）属性来动态调整。这超出了本书的范围。如果您认为您需要了解它，我们建议阅读*Expert
    Python Programming*，*Tarek Ziadé*，*Packt Publishing*，或者阅读有关该主题的原始文档（注意，它很深！）[http://www.python.org/download/releases/2.3/mro/](http://www.python.org/download/releases/2.3/mro/)。
- en: 'Let''s look at a second contrived example, which illustrates this problem more
    clearly. Here, we have a base class that has a method named `call_me`. Two subclasses
    override that method, and then another subclass extends both of these using multiple
    inheritance. This is called diamond inheritance because of the diamond shape of
    the class diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更清楚地说明这个问题的第二个刻意的例子。在这里，我们有一个基类，它有一个名为`call_me`的方法。两个子类重写了该方法，然后另一个子类使用多重继承扩展了这两个子类。这被称为菱形继承，因为类图的形状是菱形：
- en: '![](assets/ad8de812-f1cd-43b8-86d2-0c1b13a40b49.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ad8de812-f1cd-43b8-86d2-0c1b13a40b49.png)'
- en: 'Let''s convert this diagram to code; this example shows when the methods are
    called:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个图转换成代码；这个例子展示了方法何时被调用：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This example ensures that each overridden `call_me` method directly calls the
    parent method with the same name. It lets us know each time a method is called
    by printing the information to the screen. It also updates a static variable on
    the class to show how many times it has been called. If we instantiate one `Subclass`
    object and call the method on it once, we get the output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子确保每个重写的`call_me`方法直接调用具有相同名称的父方法。它通过将信息打印到屏幕上来告诉我们每次调用方法。它还更新了类的静态变量，以显示它被调用的次数。如果我们实例化一个`Subclass`对象并调用它的方法一次，我们会得到输出：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus, we can clearly see the base class's `call_me` method being called twice.
    This could lead to some pernicious bugs if that method is doing actual work, such
    as depositing into a bank account, twice.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以清楚地看到基类的`call_me`方法被调用了两次。如果该方法正在执行实际工作，比如两次存入银行账户，这可能会导致一些隐匿的错误。
- en: 'The thing to keep in mind with multiple inheritance is that we only want to
    call the `next` method in the class hierarchy, not the `parent` method. In fact,
    that next method may not be on a parent or ancestor of the current class. The
    `super` keyword comes to our rescue once again. Indeed, `super` was originally
    developed to make complicated forms of multiple inheritance possible. Here is
    the same code written using `super`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承要记住的一件事是，我们只想调用类层次结构中的`next`方法，而不是`parent`方法。实际上，下一个方法可能不在当前类的父类或祖先上。`super`关键字再次拯救了我们。事实上，`super`最初是为了使复杂的多重继承形式成为可能。以下是使用`super`编写的相同代码：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The change is pretty minor; we only replaced the naive direct calls with calls
    to `super()`, although the bottom subclass only calls `super` once rather than
    having to make the calls for both the left and right. The change is easy enough,
    but look at the difference when we execute it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 更改非常小；我们只用`super()`调用替换了天真的直接调用，尽管底部子类只调用了一次`super`，而不是必须为左侧和右侧都进行调用。更改足够简单，但是当我们执行它时，看看差异：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Looks good; our base method is only being called once. But what is `super()`
    actually doing here? Since the `print` statements are executed after the `super`
    calls, the printed output is in the order each method is actually executed. Let's
    look at the output from back to front to see who is calling what.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错；我们的基本方法只被调用了一次。但是`super()`在这里实际上是在做什么呢？由于`print`语句是在`super`调用之后执行的，打印输出的顺序是每个方法实际执行的顺序。让我们从后往前看输出，看看是谁在调用什么。
- en: First, `call_me` of `Subclass` calls `super().call_me()`, which happens to refer
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Subclass`的`call_me`调用了`super().call_me()`，这恰好是在引用
- en: to `LeftSubclass.call_me()`. The `LeftSubclass.call_me()` method then calls
    `super().call_me()`, but in this case, `super()` is referring to `RightSubclass.call_me()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到`LeftSubclass.call_me()`。然后`LeftSubclass.call_me()`方法调用`super().call_me()`，但在这种情况下，`super()`指的是`RightSubclass.call_me()`。
- en: '**Pay particular attention to this**: the `super` call is *not* calling the
    method on the superclass of `LeftSubclass` (which is `BaseClass`). Rather, it
    is calling `RightSubclass`, even though it is not a direct parent of `LeftSubclass`!
    This is the *next* method, not the parent method. `RightSubclass` then calls `BaseClass`
    and the `super` calls have ensured each method in the class hierarchy is executed
    once.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**特别注意**：`super`调用*不*调用`LeftSubclass`的超类（即`BaseClass`）上的方法。相反，它调用`RightSubclass`，即使它不是`LeftSubclass`的直接父类！这是*next*方法，而不是父方法。然后`RightSubclass`调用`BaseClass`，并且`super`调用确保了类层次结构中的每个方法都被执行一次。'
- en: Different sets of arguments
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的参数集
- en: 'This is going to make things complicated as we return to our `Friend` multiple
    inheritance example. In the `__init__` method for `Friend`, we were originally
    calling `__init__` for both parent classes, *with different sets of arguments*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们返回到我们的`Friend`多重继承示例时，这将使事情变得复杂。在`Friend`的`__init__`方法中，我们最初调用了两个父类的`__init__`，*使用不同的参数集*：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How can we manage different sets of arguments when using `super`? We don't necessarily
    know which class `super` is going to try to initialize first. Even if we did,
    we need a way to pass the `extra` arguments so that subsequent calls to `super`,
    on other subclasses, receive the right arguments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`super`时如何管理不同的参数集？我们不一定知道`super`将尝试首先初始化哪个类。即使我们知道，我们也需要一种方法来传递`extra`参数，以便后续对其他子类的`super`调用接收正确的参数。
- en: Specifically, if the first call to `super` passes the `name` and `email` arguments
    to `Contact.__init__`, and `Contact.__init__` then calls `super`, it needs to
    be able to pass the address-related arguments to the `next` method, which is `AddressHolder.__init__`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，如果对`super`的第一个调用将`name`和`email`参数传递给`Contact.__init__`，然后`Contact.__init__`调用`super`，它需要能够将与地址相关的参数传递给`next`方法，即`AddressHolder.__init__`。
- en: This problem manifests itself anytime we want to call superclass methods with
    the same name, but with different sets of arguments. Most often, the only time
    you would want to call a superclass with a completely different set of arguments
    is in `__init__`, as we're doing here. Even with regular methods, though, we may
    want to add optional parameters that only make sense to one subclass or set of
    subclasses.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要调用具有相同名称但不同参数集的超类方法时，就会出现这个问题。通常情况下，您只会在`__init__`中想要使用完全不同的参数集，就像我们在这里做的那样。即使在常规方法中，我们可能也想要添加仅对一个子类或一组子类有意义的可选参数。
- en: Sadly, the only way to solve this problem is to plan for it from the beginning.
    We have to design our base class parameter lists to accept keyword arguments for
    any parameters that are not required by every subclass implementation. Finally,
    we must ensure the method freely accepts unexpected arguments and passes them
    on to its `super` call, in case they are necessary to later methods in the inheritance
    order.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，解决这个问题的唯一方法是从一开始就计划好。我们必须设计基类参数列表，以接受任何不是每个子类实现所需的参数的关键字参数。最后，我们必须确保该方法自由接受意外的参数并将它们传递给其`super`调用，以防它们对继承顺序中的后续方法是必要的。
- en: 'Python''s function parameter syntax provides all the tools we need to do this,
    but it makes the overall code look cumbersome. Have a look at the proper version
    of the `Friend` multiple inheritance code, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python的函数参数语法提供了我们需要做到这一点的所有工具，但它使整体代码看起来笨重。请看下面`Friend`多重继承代码的正确版本：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've changed all arguments to keyword arguments by giving them an empty string
    as a default value. We've also ensured that a `**kwargs` parameter is included
    to capture any additional parameters that our particular method doesn't know what
    to do with. It passes these parameters up to the next class with the `super` call.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过给它们一个空字符串作为默认值，将所有参数都更改为关键字参数。我们还确保包含一个`**kwargs`参数来捕获我们特定方法不知道如何处理的任何额外参数。它将这些参数传递给`super`调用的下一个类。
- en: If you aren't familiar with the `**kwargs` syntax, it basically collects any
    keyword arguments passed into the method that were not explicitly listed in the
    parameter list. These arguments are stored in a dictionary named `kwargs` (we
    can call the variable whatever we like, but convention suggests `kw`, or `kwargs`).
    When we call a different method (for example, `super().__init__`) with a `**kwargs`
    syntax, it unpacks the dictionary and passes the results to the method as normal
    keyword arguments. We'll cover this in detail in [Chapter 20](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml),
    *Python Object-Oriented Shortcuts*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉`**kwargs`语法，它基本上会收集传递给方法的任何未在参数列表中明确列出的关键字参数。这些参数存储在一个名为`kwargs`的字典中（我们可以随意命名变量，但约定建议使用`kw`或`kwargs`）。当我们使用`**kwargs`语法调用不同的方法（例如`super().__init__`）时，它会解包字典并将结果作为普通关键字参数传递给方法。我们将在[第20章](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml)中详细介绍这一点，*Python面向对象的快捷方式*。
- en: The previous example does what it is supposed to do. But it's starting to look
    messy, and it is difficult to answer the question, *What arguments do we need
    to pass into* `Friend.__init__`? This is the foremost question for anyone planning
    to use the class, so a docstring should be added to the method to explain what
    is happening.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子做了它应该做的事情。但是它开始看起来凌乱，很难回答问题，“我们需要传递什么参数到`Friend.__init__`中？”这是任何计划使用该类的人首要考虑的问题，因此应该在方法中添加一个文档字符串来解释发生了什么。
- en: Furthermore, even this implementation is insufficient if we want to *reuse*
    variables in parent classes. When we pass the `**kwargs` variable to `super`,
    the dictionary does not include any of the variables that were included as explicit
    keyword arguments. For example, in `Friend.__init__`, the call to `super` does
    not have `phone` in the `kwargs` dictionary. If any of the other classes need
    the `phone` parameter, we need to ensure it is in the dictionary that is passed.
    Worse, if we forget to do this, it will be extremely frustrating to debug because
    the superclass will not complain, but will simply assign the default value (in
    this case, an empty string) to the variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使使用这种实现方式，如果我们想要在父类中*重用*变量，它仍然是不够的。当我们将`**kwargs`变量传递给`super`时，字典不包括任何作为显式关键字参数包含的变量。例如，在`Friend.__init__`中，对`super`的调用在`kwargs`字典中没有`phone`。如果其他类中需要`phone`参数，我们需要确保它包含在传递的字典中。更糟糕的是，如果我们忘记这样做，调试将变得非常令人沮丧，因为超类不会抱怨，而只会简单地将默认值（在这种情况下为空字符串）分配给变量。
- en: 'There are a few ways to ensure that the variable is passed upward. Assume the
    `Contact` class does, for some reason, need to be initialized with a `phone` parameter,
    and the `Friend` class will also need access to it. We can do any of the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以确保变量向上传递。假设`Contact`类出于某种原因需要使用`phone`参数进行初始化，并且`Friend`类也需要访问它。我们可以采取以下任一方法：
- en: Don't include `phone` as an explicit keyword argument. Instead, leave it in
    the `kwargs` dictionary. `Friend` can look it up using the `kwargs['phone'] ` syntax.
    When it passes `**kwargs` to the `super` call, `phone` will still be in the dictionary.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将`phone`作为显式关键字参数包含在内。相反，将其留在`kwargs`字典中。`Friend`可以使用`kwargs['phone']`语法查找它。当它将`**kwargs`传递给`super`调用时，`phone`仍将存在于字典中。
- en: Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    before passing it to `super`, using the standard dictionary `kwargs['phone'] =
    phone` syntax.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为显式关键字参数，但在将其传递给`super`之前更新`kwargs`字典，使用标准字典`kwargs['phone'] = phone`语法。
- en: 'Make `phone` an explicit keyword argument, but update the `kwargs` dictionary
    using the `kwargs.update` method. This is useful if you have several arguments
    to update. You can create the dictionary passed into `update` using either the
    `dict(phone=phone)` constructor, or the dictionary `{''phone'': phone}` syntax.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`phone`作为一个显式关键字参数，但使用`kwargs.update`方法更新`kwargs`字典。如果有多个参数需要更新，这是很有用的。您可以使用`dict(phone=phone)`构造函数或`{''phone'':
    phone}`语法创建传递给`update`的字典。'
- en: Make `phone` an explicit keyword argument, but pass it to the super call explicitly
    with the `super().__init__(phone=phone, **kwargs)` syntax.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`phone`作为一个显式关键字参数，但使用`super().__init__(phone=phone, **kwargs)`语法将其明确传递给super调用。
- en: We have covered many of the caveats involved with multiple inheritance in Python.
    When we need to account for all possible situations, we have to plan for them
    and our code will get messy. Basic multiple inheritance can be handy but, in many
    cases, we may want to choose a more transparent way of combining two disparate
    classes, usually using composition or one of the design patterns we'll be covering
    in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml), *Design Patterns
    I,* and [Chapter 23](3e7c30d8-a939-4a5e-9eb4-53d9f24a0306.xhtml), *Design Patterns
    II*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Python中多重继承的许多注意事项。当我们需要考虑所有可能的情况时，我们必须为它们做计划，我们的代码会变得混乱。基本的多重继承可能很方便，但在许多情况下，我们可能希望选择一种更透明的方式来组合两个不同的类，通常使用组合或我们将在[第22章](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml)和[第23章](3e7c30d8-a939-4a5e-9eb4-53d9f24a0306.xhtml)中介绍的设计模式之一。
- en: I have wasted entire days of my life trawling through complex multiple inheritance
    hierarchies trying to figure out what arguments I need to pass into one of the
    deeply nested subclasses. The author of the code tended not to document his classes
    and often passed the kwargs—Just in case they might be needed someday. This was
    a particularly bad example of using multiple inheritance when it was not needed.
    Multiple inheritance is a big fancy term that new coders like to show off, but
    I recommend avoiding it, even when you think it's a good choice. Your future self
    and other coders will be glad they understand your code when they have to read
    it later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经浪费了我生命中的整整一天，搜索复杂的多重继承层次结构，试图弄清楚我需要传递到其中一个深度嵌套的子类的参数。代码的作者倾向于不记录他的类，并经常传递kwargs——以防万一将来可能会需要。这是一个特别糟糕的例子，使用了不需要的多重继承。多重继承是一个新编码者喜欢炫耀的大而复杂的术语，但我建议避免使用它，即使你认为它是一个好选择。当他们以后不得不阅读代码时，你未来的自己和其他编码者会很高兴他们理解你的代码。
- en: Polymorphism
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: 'We were introduced to polymorphism in [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml),
    *Object-Oriented Design*. It is a showy name describing a simple concept: different
    behaviors happen depending on which subclass is being used, without having to
    explicitly know what the subclass actually is. As an example, imagine a program
    that plays audio files. A media player might need to load an `AudioFile` object
    and then `play` it. We can put a `play()` method on the object, which is responsible
    for decompressing or extracting the audio and routing it to the sound card and
    speakers. The act of playing an `AudioFile` could feasibly be as simple as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在《面向对象设计》的[第15章](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml)中介绍了多态性。这是一个华丽的名字，描述了一个简单的概念：不同的行为发生取决于使用哪个子类，而不必明确知道子类实际上是什么。举个例子，想象一个播放音频文件的程序。媒体播放器可能需要加载一个`AudioFile`对象，然后`play`它。我们可以在对象上放一个`play()`方法，负责解压或提取音频并将其路由到声卡和扬声器。播放`AudioFile`的行为可能是非常简单的：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, the process of decompressing and extracting an audio file is very different
    for different types of files. While `.wav` files are stored uncompressed, `.mp3`,
    `.wma`, and `.ogg` files all utilize totally different compression algorithms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解压和提取音频文件的过程对不同类型的文件来说是非常不同的。虽然`.wav`文件是未压缩存储的，`.mp3`、`.wma`和`.ogg`文件都使用完全不同的压缩算法。
- en: 'We can use inheritance with polymorphism to simplify the design. Each type
    of file can be represented by a different subclass of `AudioFile`, for example,
    `WavFile` and `MP3File`. Each of these would have a `play()` method that would
    be implemented differently for each file to ensure that the correct extraction
    procedure is followed. The media player object would never need to know which
    subclass of `AudioFile` it is referring to; it just calls `play()` and polymorphically
    lets the object take care of the actual details of playing. Let''s look at a quick
    skeleton showing how this might look:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多态性的继承来简化设计。每种类型的文件可以由`AudioFile`的不同子类表示，例如`WavFile`和`MP3File`。每个子类都会有一个`play()`方法，为了确保正确的提取过程，每个文件的实现方式都会有所不同。媒体播放器对象永远不需要知道它正在引用哪个`AudioFile`的子类；它只是调用`play()`，并以多态的方式让对象处理实际的播放细节。让我们看一个快速的骨架，展示这可能是什么样子：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All audio files check to ensure that a valid extension was given upon initialization.
    But did you notice how the `__init__` method in the parent class is able to access
    the `ext` class variable from different subclasses? That's polymorphism at work.
    If the filename doesn't end with the correct name, it raises an exception (exceptions
    will be covered in detail in the next chapter). The fact that the `AudioFile`
    parent class doesn't actually store a reference to the `ext` variable doesn't
    stop it from being able to access it on the subclass.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有音频文件都会检查初始化时是否给出了有效的扩展名。但你是否注意到父类中的`__init__`方法如何能够从不同的子类访问`ext`类变量？这就是多态性的工作原理。如果文件名不以正确的名称结尾，它会引发异常（异常将在下一章中详细介绍）。`AudioFile`父类实际上并没有存储对`ext`变量的引用，但这并不妨碍它能够在子类上访问它。
- en: 'In addition, each subclass of `AudioFile` implements `play()` in a different
    way (this example doesn''t actually play the music; audio compression algorithms
    really deserve a separate book!). This is also polymorphism in action. The media
    player can use the exact same code to play a file, no matter what type it is;
    it doesn''t care what subclass of `AudioFile` it is looking at. The details of
    decompressing the audio file are *encapsulated*. If we test this example, it works
    as we would hope:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`AudioFile`的每个子类以不同的方式实现`play()`（这个例子实际上并不播放音乐；音频压缩算法确实值得单独一本书！）。这也是多态的实现。媒体播放器可以使用完全相同的代码来播放文件，无论它是什么类型；它不关心它正在查看的`AudioFile`的子类是什么。解压音频文件的细节被*封装*。如果我们测试这个例子，它会按照我们的期望工作。
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how `AudioFile.__init__` is able to check the file type without actually
    knowing which subclass it is referring to?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`AudioFile.__init__`如何能够检查文件类型，而不实际知道它指的是哪个子类？
- en: 'Polymorphism is actually one of the coolest things about object-oriented programming,
    and it makes some programming designs obvious that weren''t possible in earlier
    paradigms. However, Python makes polymorphism seem less awesome because of duck
    typing. Duck typing in Python allows us to use *any* object that provides the
    required behavior without forcing it to be a subclass. The dynamic nature of Python
    makes this trivial. The following example does not extend `AudioFile`, but it
    can be interacted with in Python using the exact same interface:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 多态实际上是面向对象编程中最酷的东西之一，它使一些在早期范式中不可能的编程设计变得显而易见。然而，由于鸭子类型，Python使多态看起来不那么令人敬畏。Python中的鸭子类型允许我们使用*任何*提供所需行为的对象，而无需强制它成为子类。Python的动态性使这变得微不足道。下面的例子不扩展`AudioFile`，但可以使用完全相同的接口在Python中与之交互：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our media player can play this object just as easily as one that extends `AudioFile`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体播放器可以像扩展`AudioFile`的对象一样轻松地播放这个对象。
- en: Polymorphism is one of the most important reasons to use inheritance in many
    object-oriented contexts. Because any objects that supply the correct interface
    can be used interchangeably in Python, it reduces the need for polymorphic common
    superclasses. Inheritance can still be useful for sharing code, but if all that
    is being shared is the public interface, duck typing is all that is required.
    This reduced need for inheritance also reduces the need for multiple inheritance;
    often, when multiple inheritance appears to be a valid solution, we can just use
    duck typing to mimic one of the multiple superclasses.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多面向对象的上下文中，多态是使用继承的最重要原因之一。因为在Python中可以互换使用任何提供正确接口的对象，所以减少了对多态公共超类的需求。继承仍然可以用于共享代码，但如果所有被共享的只是公共接口，那么只需要鸭子类型。这种对继承的需求减少也减少了对多重继承的需求；通常，当多重继承似乎是一个有效的解决方案时，我们可以使用鸭子类型来模仿多个超类中的一个。
- en: Of course, just because an object satisfies a particular interface (by providing
    required methods or attributes) does not mean it will simply work in all situations.
    It has to fulfill that interface in a way that makes sense in the overall system.
    Just because an object provides a `play()` method does not mean it will automatically
    work with a media player. For example, our chess AI object from [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml),
    *Object-Oriented Design*, may have a `play()` method that moves a chess piece.
    Even though it satisfies the interface, this class would likely break in spectacular
    ways if we tried to plug it into a media player!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只因为一个对象满足特定接口（通过提供所需的方法或属性）并不意味着它在所有情况下都能简单地工作。它必须以在整个系统中有意义的方式满足该接口。仅仅因为一个对象提供了`play()`方法并不意味着它会自动与媒体播放器一起工作。例如，我们在[第15章](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml)中的国际象棋AI对象，*面向对象设计*，可能有一个`play()`方法来移动国际象棋棋子。即使它满足了接口，这个类在我们试图将它插入媒体播放器时可能会以惊人的方式崩溃！
- en: Another useful feature of duck typing is that the duck-typed object only needs
    to provide those methods and attributes that are actually being accessed. For
    example, if we needed to create a fake file object to read data from, we can create
    a new object that has a `read()` method; we don't have to override the `write`
    method if the code that is going to interact with the fake object will not be
    calling it. More succinctly, duck typing doesn't need to provide the entire interface
    of an object that is available; it only needs to fulfill the interface that is
    actually accessed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型的另一个有用特性是，鸭子类型的对象只需要提供实际被访问的方法和属性。例如，如果我们需要创建一个假的文件对象来读取数据，我们可以创建一个具有`read()`方法的新对象；如果将与假对象交互的代码不会调用`write`方法，那么我们就不必覆盖`write`方法。简而言之，鸭子类型不需要提供可用对象的整个接口；它只需要满足实际被访问的接口。
- en: Abstract base classes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象基类
- en: While duck typing is useful, it is not always easy to tell in advance if a class
    is going to fulfill the protocol you require. Therefore, Python introduced the
    idea of **abstract base classes** (**ABC**s). Abstract base classes define a set
    of methods and properties that a class must implement in order to be considered
    a duck-type instance of that class. The class can extend the abstract base class
    itself in order to be used as an instance of that class, but it must supply all
    the appropriate methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然鸭子类型很有用，但事先很难判断一个类是否能够满足你所需的协议。因此，Python引入了**抽象基类**（**ABC**）的概念。抽象基类定义了一组类必须实现的方法和属性，以便被视为该类的鸭子类型实例。该类可以扩展抽象基类本身，以便用作该类的实例，但必须提供所有适当的方法。
- en: In practice, it's rarely necessary to create new abstract base classes, but
    we may find occasions to implement instances of existing ABCs. We'll cover implementing
    ABCs first, and then briefly see how to create your own, should you ever need
    to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，很少需要创建新的抽象基类，但我们可能会发现需要实现现有ABC的实例的情况。我们将首先介绍实现ABC，然后简要介绍如何创建自己的ABC，如果你有需要的话。
- en: Using an abstract base class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象基类
- en: 'Most of the abstract base classes that exist in the Python standard library
    live in the `collections` module. One of the simplest ones is the `Container`
    class. Let''s inspect it in the Python interpreter to see what methods this class
    requires:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中存在的大多数抽象基类都位于`collections`模块中。其中最简单的之一是`Container`类。让我们在Python解释器中检查一下这个类需要哪些方法：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, the `Container` class has exactly one abstract method that needs to be
    implemented, `__contains__`. You can issue `help(Container.__contains__)` to see
    what the function signature should look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Container`类确切地有一个需要被实现的抽象方法，`__contains__`。你可以发出`help(Container.__contains__)`来查看这个函数签名应该是什么样子的：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that `__contains__` needs to take a single argument. Unfortunately,
    the help file doesn't tell us much about what that argument should be, but it's
    pretty obvious from the name of the ABC and the single method it implements that
    this argument is the value the user is checking to see whether the container holds.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`__contains__`需要接受一个参数。不幸的是，帮助文件并没有告诉我们这个参数应该是什么，但从ABC的名称和它实现的单个方法来看，很明显这个参数是用户要检查的容器是否包含的值。
- en: 'This method is implemented by `list`, `str`, and `dict` to indicate whether
    or not a given value is *in* that data structure. However, we can also define
    a silly container that tells us whether a given value is in the set of odd integers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法由`list`、`str`和`dict`实现，用于指示给定的值是否*在*该数据结构中。然而，我们也可以定义一个愚蠢的容器，告诉我们给定的值是否在奇数集合中：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s the interesting part: we can instantiate an `OddContainer` object and
    determine that, even though we did not extend `Container`, the class is a `Container`
    object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是：我们可以实例化一个`OddContainer`对象，并确定，即使我们没有扩展`Container`，该类也是一个`Container`对象。
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And that is why duck typing is way more awesome than classical polymorphism.
    We can create is a relationships without the overhead of writing the code to set
    up inheritance (or worse, multiple inheritance).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么鸭子类型比经典多态更棒的原因。我们可以创建关系而不需要编写设置继承（或更糟的是多重继承）的代码的开销。
- en: 'One cool thing about the `Container` ABC is that any class that implements
    it gets to use the `in` keyword for free. In fact, `in` is just syntax sugar that
    delegates to the `__contains__` method. Any class that has a `__contains__` method
    is a `Container` and can therefore be queried by the `in` keyword, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container` ABC的一个很酷的地方是，任何实现它的类都可以免费使用`in`关键字。实际上，`in`只是语法糖，委托给`__contains__`方法。任何具有`__contains__`方法的类都是`Container`，因此可以通过`in`关键字查询，例如：'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating an abstract base class
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个抽象基类
- en: 'As we saw earlier, it''s not necessary to have an abstract base class to enable
    duck typing. However, imagine we were creating a media player with third-party
    plugins. It is advisable to create an abstract base class in this case to document
    what API the third-party plugins should provide (documentation is one of the stronger
    use cases for ABCs). The `abc` module provides the tools you need to do this,
    but I''ll warn you in advance, this utilizes some of Python''s most arcane concepts,
    as demonstrated in the following block of code::'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，要启用鸭子类型并不需要有一个抽象基类。然而，想象一下我们正在创建一个带有第三方插件的媒体播放器。在这种情况下，最好创建一个抽象基类来记录第三方插件应该提供的API（文档是ABC的一个更强大的用例）。`abc`模块提供了你需要做到这一点的工具，但我提前警告你，这利用了Python中一些最深奥的概念，就像下面的代码块中所演示的那样：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a complicated example that includes several Python features that won't
    be explained until later in this book. It is included here for completeness, but
    you do not need to understand all of it to get the gist of how to create your
    own ABC.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的例子，包括了几个Python特性，这些特性在本书的后面才会被解释。它被包含在这里是为了完整性，但你不需要理解所有这些来了解如何创建你自己的ABC。
- en: The first weird thing is the `metaclass` keyword argument that is passed into
    the class where you would normally see the list of parent classes. This is a seldom-used
    construct from the mystic art of metaclass programming. We won't be covering metaclasses
    in this book, so all you need to know is that by assigning the `ABCMeta` metaclass,
    you are giving your class superhero (or at least superclass) abilities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件奇怪的事情是`metaclass`关键字参数被传递到类中，而在通常情况下你会看到父类列表。这是来自元类编程的神秘艺术中很少使用的构造。我们不会在本书中涵盖元类，所以你需要知道的是，通过分配`ABCMeta`元类，你为你的类赋予了超级英雄（或至少是超类）的能力。
- en: Next, we see the `@abc.abstractmethod` and `@abc.abstractproperty` constructs.
    These are Python decorators. We'll discuss those in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml),
    *Python Design Patterns I*. For now, just know that by marking a method or property
    as being abstract, you are stating that any subclass of this class must implement
    that method or supply that property in order to be considered a proper member
    of the class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了`@abc.abstractmethod`和`@abc.abstractproperty`构造。这些是Python装饰器。我们将在[第22章](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml)中讨论这些。现在，只需要知道通过将方法或属性标记为抽象，你声明了这个类的任何子类必须实现该方法或提供该属性，才能被视为该类的合格成员。
- en: 'See what happens if you implement subclasses that do, or don''t, supply those
    properties:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如果你实现了提供或不提供这些属性的子类会发生什么：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since the `Wav` class fails to implement the abstract attributes, it is not
    possible to instantiate that class. The class is still a legal abstract class,
    but you'd have to subclass it to actually do anything. The `Ogg` class supplies
    both attributes, so it instantiates cleanly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Wav`类未实现抽象属性，因此无法实例化该类。该类仍然是一个合法的抽象类，但你必须对其进行子类化才能实际执行任何操作。`Ogg`类提供了这两个属性，因此可以干净地实例化。
- en: Going back to the `MediaLoader` ABC, let's dissect that `__subclasshook__` method.
    It is basically saying that any class that supplies concrete implementations of
    all the abstract attributes of this ABC should be considered a subclass of `MediaLoader`,
    even if it doesn't actually inherit from the `MediaLoader` class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MediaLoader` ABC，让我们解剖一下`__subclasshook__`方法。它基本上是说，任何提供了这个ABC所有抽象属性的具体实现的类都应该被认为是`MediaLoader`的子类，即使它实际上并没有继承自`MediaLoader`类。
- en: More common object-oriented languages have a clear separation between the interface
    and the implementation of a class. For example, some languages provide an explicit
    `interface` keyword that allows us to define the methods that a class must have
    without any implementation. In such an environment, an abstract class is one that
    provides both an interface and a concrete implementation of some, but not all,
    methods. Any class can explicitly state that it implements a given interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的面向对象语言在接口和类的实现之间有明确的分离。例如，一些语言提供了一个明确的`interface`关键字，允许我们定义一个类必须具有的方法，而不需要任何实现。在这样的环境中，抽象类是提供了接口和一些但不是所有方法的具体实现的类。任何类都可以明确声明它实现了给定的接口。
- en: Python's ABCs help to supply the functionality of interfaces without compromising
    on the benefits of duck typing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python的ABCs有助于提供接口的功能，而不会影响鸭子类型的好处。
- en: Demystifying the magic
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密魔术
- en: 'You can copy and paste the subclass code without understanding it if you want
    to make abstract classes that fulfill this particular contract. We''ll cover most
    of the unusual syntaxes in the book, but let''s go over it line by line to get
    an overview:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建满足这个特定契约的抽象类，你可以复制并粘贴子类代码而不必理解它。我们将在本书中涵盖大部分不寻常的语法，但让我们逐行地概述一下：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This decorator marks the method as a class method. It essentially says that
    the method can be called on a class instead of an instantiated object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器标记方法为类方法。它基本上表示该方法可以在类上调用，而不是在实例化的对象上调用：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This defines the `__subclasshook__` class method. This special method is called
    by the Python interpreter to answer the question: Is the class `C` a subclass
    of this class?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`__subclasshook__`类方法。这个特殊的方法是由Python解释器调用来回答这个问题：类`C`是这个类的子类吗？
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We check to see whether the method was called specifically on this class, rather
    than, say, a subclass of this class. This prevents, for example, the `Wav` class
    from being thought of as a parent class of the `Ogg` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查方法是否是在这个类上专门调用的，而不是在这个类的子类上调用。例如，这可以防止`Wav`类被认为是`Ogg`类的父类：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All this line does is get the set of methods and properties that the class
    has, including any parent classes in its class hierarchy:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行所做的只是获取类的方法和属性集，包括其类层次结构中的任何父类：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line uses set notation to see whether the set of abstract methods in this
    class has been supplied in the candidate class. Note that it doesn't check to
    see whether the methods have been implemented; just if they are there. Thus, it's
    possible for a class to be a subclass and yet still be an abstract class itself.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行使用集合符号来查看候选类中是否提供了这个类中的抽象方法。请注意，它不检查方法是否已经被实现；只是检查它们是否存在。因此，一个类可能是一个子类，但仍然是一个抽象类本身。
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If all the abstract methods have been supplied, then the candidate class is
    a subclass of this class and we return `True`. The method can legally return one
    of the three values: `True`, `False`, or `NotImplemented`. `True` and `False`
    indicate that the class is, or isn''t, definitively a subclass of this class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的抽象方法都已经提供，那么候选类是这个类的子类，我们返回`True`。该方法可以合法地返回三个值之一：`True`，`False`或`NotImplemented`。`True`和`False`表示该类是否明确是这个类的子类：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If any of the conditionals have not been met (that is, the class is not `MediaLoader`
    or not all abstract methods have been supplied), then return `NotImplemented`.
    This tells the Python machinery to use the default mechanism (does the candidate
    class explicitly extend this class?) for subclass detection.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何条件都没有被满足（也就是说，这个类不是`MediaLoader`，或者没有提供所有的抽象方法），那么返回`NotImplemented`。这告诉Python机制使用默认机制（候选类是否明确扩展了这个类？）来检测子类。
- en: 'In short, we can now define the `Ogg` class as a subclass of the `MediaLoader`
    class without actually extending the `MediaLoader` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们现在可以将`Ogg`类定义为`MediaLoader`类的子类，而不实际扩展`MediaLoader`类：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Case study
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: Let's try to tie everything we've learned together with a larger example. We'll
    be developing an automated grading system for programming assignments, similar
    to that employed at Dataquest or Coursera. The system will need to provide a simple
    class-based interface for course writers to create their assignments and should
    give a useful error message if it does not fulfill that interface. The writers
    need to be able to supply their lesson content and to write custom answer checking
    code to make sure their students got the answer right. It will also be nice for
    them to have access to the students' names to make the content seem a little friendlier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个更大的例子把我们学到的东西联系起来。我们将为编程作业开发一个自动评分系统，类似于Dataquest或Coursera使用的系统。该系统需要为课程作者提供一个简单的基于类的接口，以便创建他们的作业，并且如果不满足该接口，应该提供有用的错误消息。作者需要能够提供他们的课程内容，并编写自定义答案检查代码，以确保他们的学生得到正确的答案。他们还可以访问学生的姓名，使内容看起来更友好一些。
- en: The grader itself will need to keep track of which assignment the student is
    currently working on. A student might make several attempts at an assignment before
    they get it right. We want to keep track of the number of attempts so the course
    authors can improve the content of the more difficult lessons.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 评分系统本身需要跟踪学生当前正在进行的作业。学生可能在得到正确答案之前尝试几次作业。我们希望跟踪尝试次数，以便课程作者可以改进更难的课程内容。
- en: 'Let''s start by defining the interface that the course authors will need to
    use. Ideally, it will require the course authors to write a minimal amount of
    extra code besides their lesson content and answer checking code. Here is the
    simplest class I could come up with:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义课程作者需要使用的接口。理想情况下，除了课程内容和答案检查代码之外，它将要求课程作者写入最少量的额外代码。以下是我能想到的最简单的类：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Admittedly, that particular course author may be a little naive in how they
    do their answer checking.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，该课程作者可能对他们的答案检查方式有些天真。
- en: 'We can start with an abstract base class that defines this interface, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从定义这个接口的抽象基类开始，如下所示：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This ABC defines the two required abstract methods and provides the magic `__subclasshook__`
    method to allow a class to be perceived as a subclass without having to explicitly
    extend it (I usually just copy and paste this code. It isn't worth memorizing.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ABC定义了两个必需的抽象方法，并提供了魔术`__subclasshook__`方法，允许一个类被视为子类，而无需明确扩展它（我通常只是复制并粘贴这段代码。不值得记忆。）
- en: 'We can confirm that the `IntroToPython` class fulfills this interface using
    `issubclass(IntroToPython, Assignment)`, which should return `True`. Of course,
    we can explicitly extend the `Assignment` class if we prefer, as seen in this
    second assignment:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`issubclass(IntroToPython, Assignment)`来确认`IntroToPython`类是否满足这个接口，这应该返回`True`。当然，如果愿意，我们也可以明确扩展`Assignment`类，就像在第二个作业中所看到的那样：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This course author, unfortunately, is also rather naive. The `exec` call will
    execute the student's code right inside the grading system, giving them access
    to the entire system. Obviously, the first thing they will do is hack the system
    to make their grades 100%. They probably think that's easier than doing the assignments
    correctly!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这位课程作者也相当天真。`exec`调用将在评分系统内部执行学生的代码，使他们可以访问整个系统。显然，他们将首先对系统进行黑客攻击，使他们的成绩达到100%。他们可能认为这比正确完成作业更容易！
- en: 'Next, we''ll create a class that manages how many attempts the student has
    made at a given assignment:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个类，用于管理学生在特定作业上尝试的次数：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This class uses composition instead of inheritance. At first glance, it would
    make sense for these methods to exist on the `Assignment` superclass. That would
    eliminate the annoying `lesson` method, which just proxies through to the same
    method on the assignment object. It would certainly be possible to put all this
    logic directly on the `Assignment` abstract base class, or even to have the ABC
    inherit from this `AssignmentGrader` class. In fact, I would normally recommend
    that, but in this case, it would force all course authors to explicitly extend
    the class, which violates our request that content authoring be as simple as possible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用组合而不是继承。乍一看，这些方法存在于`Assignment`超类似乎是有道理的。这将消除令人讨厌的`lesson`方法，它只是代理到作业对象上的相同方法。当然，可以直接在`Assignment`抽象基类上放置所有这些逻辑，甚至可以让ABC从这个`AssignmentGrader`类继承。事实上，我通常会推荐这样做，但在这种情况下，这将强制所有课程作者明确扩展该类，这违反了我们尽可能简单地请求内容创作的要求。
- en: 'Finally, we can start to put together the `Grader` class, which is responsible
    for managing which assignments are available and which one each student is currently
    working on. The most interesting part is the register method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始组建`Grader`类，该类负责管理哪些作业是可用的，每个学生当前正在进行哪个作业。最有趣的部分是注册方法：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code block includes the initializer, which includes two dictionaries we'll
    discuss in a minute. The `register` method is a bit complex, so we'll dissect
    it thoroughly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块包括初始化器，其中包括我们将在一分钟内讨论的两个字典。`register`方法有点复杂，所以我们将彻底剖析它。
- en: 'The first odd thing is the parameter this method accepts: `assignment_class`.
    This parameter is intended to be an actual class, not an instance of the class.
    Remember, classes are objects, too, and can be passed around like other classes.
    Given the `IntroToPython` class we defined earlier, we might register it without
    instantiating it, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件奇怪的事是这个方法接受的参数：`assignment_class`。这个参数意味着是一个实际的类，而不是类的实例。记住，类也是对象，可以像其他类一样传递。鉴于我们之前定义的`IntroToPython`类，我们可以在不实例化的情况下注册它，如下所示：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The method first checks whether that class is a subclass of the `Assignment`
    class. Of course, we implemented a custom `__subclasshook__` method, so this includes
    classes that do not explicitly subclass `Assignment`. The naming is, perhaps,
    a bit deceitful! If it doesn't have the two required methods, it raises an exception.
    Exceptions are a topic we'll cover in detail in the next chapter; for now, just
    assume that it makes the program get angry and quit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先检查该类是否是`Assignment`类的子类。当然，我们实现了一个自定义的`__subclasshook__`方法，因此这包括了不明确地作为`Assignment`子类的类。命名可能有点欺骗性！如果它没有这两个必需的方法，它会引发一个异常。异常是我们将在下一章详细讨论的一个主题；现在，只需假设它会使程序生气并退出。
- en: Then, we generate a random identifier to represent that specific assignment.
    We store the `assignment_class` in a dictionary indexed by that ID, and return
    the ID so that the calling code can look that assignment up in the future. Presumably,
    another object would then place that ID in a course syllabus of some sort so students
    do the assignments in order, but we won't be doing that for this part of the project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成一个随机标识符来表示特定的作业。我们将`assignment_class`存储在一个由该ID索引的字典中，并返回该ID，以便调用代码将来可以查找该作业。据推测，另一个对象将在某种课程大纲中放置该ID，以便学生按顺序完成作业，但在项目的这一部分我们不会这样做。
- en: The `uuid` function returns a specially formatted string called a universally
    unique identifier, also known as a globally unique identifier. It essentially
    represents an extremely large random number that is almost, but not quite, impossible
    to conflict with another similarly generated identifier. It is a great, quick,
    and clean way to create an arbitrary ID to keep track of items.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid`函数返回一个称为通用唯一标识符的特殊格式字符串，也称为全局唯一标识符。它基本上代表一个几乎不可能与另一个类似生成的标识符冲突的极大随机数。这是创建用于跟踪项目的任意ID的一种很好、快速和干净的方法。'
- en: 'Next up, we have the `start_assignment` function, which allows a student to
    start working on an assignment given the ID of that assignment. All it does is
    construct an instance of the `AssignmentGrader` class we defined earlier and plop
    it in a dictionary stored on the `Grader` class, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`start_assignment`函数，它允许学生开始做一项作业，给定该作业的ID。它所做的就是构造我们之前定义的`AssignmentGrader`类的一个实例，并将其放入存储在`Grader`类上的字典中，如下所示：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, we write a couple of proxy methods that get the lesson or check
    the code for whatever assignment the student is currently working on:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们编写了一些代理方法，用于获取学生当前正在进行的课程或检查作业的代码：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we create a method that gives a summary of a student''s current assignment
    progress. It looks up the assignment object and creates a formatted string with
    all the information we have about that student:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个方法，用于总结学生当前作业的进展情况。它查找作业对象，并创建一个格式化的字符串，其中包含我们对该学生的所有信息：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And that's it. You'll notice that this case study does not use a ton of inheritance,
    which may seem a bit odd given the topic of the chapter, but duck typing is very
    prevalent. It is quite common for Python programs to be designed with inheritance
    that gets simplified into more versatile constructs as it is iterated on. As another
    example, I originally defined the `AssignmentGrader` as an inheritance relationship,
    but realized halfway through that it would be better to use composition, for the
    reasons outlined previously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。您会注意到，这个案例研究并没有使用大量的继承，这可能看起来有点奇怪，因为这一章的主题，但鸭子类型非常普遍。Python程序通常被设计为使用继承，随着迭代的进行，它会简化为更多功能的构造。举个例子，我最初将`AssignmentGrader`定义为继承关系，但中途意识到最好使用组合，原因如前所述。
- en: 'Here''s a bit of test code that shows all these objects connected together:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些测试代码，展示了所有这些对象是如何连接在一起的：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Exercises
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Look around you at some of the physical objects in your workspace and see if
    you can describe them in an inheritance hierarchy. Humans have been dividing the
    world into taxonomies like this for centuries, so it shouldn't be difficult. Are
    there any non-obvious inheritance relationships between classes of objects? If
    you were to model these objects in a computer application, what properties and
    methods would they share? Which ones would have to be polymorphically overridden?
    What properties would be completely different between them?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你的工作空间中的一些物理物体，看看你能否用继承层次结构描述它们。人类几个世纪以来一直在将世界划分为这样的分类法，所以这应该不难。在对象类之间是否存在一些非明显的继承关系？如果你要在计算机应用程序中对这些对象进行建模，它们会共享哪些属性和方法？哪些属性需要多态地重写？它们之间有哪些完全不同的属性？
- en: Now write some code. No, not for the physical hierarchy; that's boring. Physical
    items have more properties than methods. Just think about a pet programming project
    you've wanted to tackle in the past year, but never gotten around to. For whatever
    problem you want to solve, try to think of some basic inheritance relationships
    and then implement them. Make sure that you also pay attention to the sorts of
    relationships that you actually don't need to use inheritance for. Are there any
    places where you might want to use multiple inheritance? Are you sure? Can you
    see any place where you would want to use a mixin? Try to knock together a quick
    prototype. It doesn't have to be useful or even partially working. You've seen
    how you can test code using `python -i` already; just write some code and test
    it in the interactive interpreter. If it works, write some more. If it doesn't,
    fix it!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在写一些代码。不是为了物理层次结构；那很无聊。物理物品比方法更多。只是想想你过去一年想要解决的宠物编程项目。无论你想解决什么问题，都试着想出一些基本的继承关系，然后实现它们。确保你也注意到了实际上不需要使用继承的关系。有哪些地方你可能想要使用多重继承？你确定吗？你能看到任何你想使用混入的地方吗？试着拼凑一个快速的原型。它不必有用，甚至不必部分工作。你已经看到了如何使用`python
    -i`测试代码；只需编写一些代码并在交互式解释器中测试它。如果它有效，再写一些。如果不行，修复它！
- en: Now, take a look at the student grader system in the case study. There is a
    lot missing from it, and not just decent course content! How do students get into
    the system? Is there a curriculum that defines which order they should study lessons
    in? What happens if you change the `AssignmentGrader` to use inheritance, rather
    than composition, on the `Assignment` objects?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看案例研究中的学生评分系统。它缺少很多东西，不仅仅是良好的课程内容！学生如何进入系统？是否有一个课程大纲规定他们应该按照什么顺序学习课程？如果你将`AssignmentGrader`更改为在`Assignment`对象上使用继承而不是组合，会发生什么？
- en: Finally, try to come up with some good use cases for mixins, then experiment
    with them until you realize that there is probably a better design using composition!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试想出一些使用混入的好用例，然后尝试使用混入，直到意识到可能有更好的设计使用组合！
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've gone from simple inheritance, one of the most useful tools in the object-oriented
    programmer's toolbox, all the way through to multiple inheritance—One of the most
    complicated. Inheritance can be used to add functionality to existing classes
    and built-ins using inheritance. Abstracting similar code into a parent class
    can help increase maintainability. Methods on parent classes can be called using
    `super` and argument lists must be formatted safely for these calls to work when
    using multiple inheritance. Abstract base classes allow you to document what methods
    and properties a class must have to fulfill a particular interface, and even allow
    you to change the very definition of *subclass*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从简单的继承，这是面向对象程序员工具箱中最有用的工具之一，一直到多重继承——最复杂的之一。继承可以用来通过继承向现有类和内置类添加功能。将类似的代码抽象成父类可以帮助增加可维护性。父类上的方法可以使用`super`进行调用，并且在使用多重继承时，参数列表必须安全地格式化以使这些调用起作用。抽象基类允许您记录一个类必须具有哪些方法和属性才能满足特定接口，并且甚至允许您更改*子类*的定义。
- en: In the next chapter, we'll cover the subtle art of handling exceptional circumstances.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍处理特殊情况的微妙艺术。
