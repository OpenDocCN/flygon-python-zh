- en: Reading Emails and Taking Names Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读电子邮件和获取名称的配方
- en: 'The following recipes are covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下配方：
- en: Parsing EML files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析EML文件
- en: Viewing MSG files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看MSG文件
- en: Ordering Takeout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订购外卖
- en: What’s in the box?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子里有什么？
- en: Parsing PST and OST mailboxes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析PST和OST邮箱
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The he-said-she-said game is often thrown out the window once computer evidence
    is added to the fray. The email plays a major role in most types of investigations.
    The email evidence extends to both business and personal devices, as it is widely
    used to send files, communicate with peers, and to receive notifications from
    online services. By examining email, we can learn what social media, cloud storage,
    or other sites are used by the custodian. We can also look for data exfiltration
    outside of an organization or investigate the source of a phishing scheme.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算机证据被添加到混乱中，他说她说的游戏通常就被抛到一边。电子邮件在大多数类型的调查中起着重要作用。电子邮件证据涉及到商业和个人设备，因为它被广泛用于发送文件、与同行交流以及从在线服务接收通知。通过检查电子邮件，我们可以了解托管人使用哪些社交媒体、云存储或其他网站。我们还可以寻找组织外的数据外流，或者调查钓鱼计划的来源。
- en: 'This chapter will cover recipes that expose this information for investigations,
    including:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖揭示此信息以进行调查的配方，包括：
- en: Reading the EML format using built-in libraries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置库读取EML格式
- en: Leveraging the `win32com` library to extract information from Outlook MSG files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`win32com`库从Outlook MSG文件中提取信息
- en: Preserving Google Gmail with Takeouts and parsing the preservation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Takeouts保存Google Gmail并解析保存内容
- en: Using built-in libraries to read from MBOX containers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置库从MBOX容器中读取
- en: Reading PST files with `libpff`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`libpff`读取PST文件
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)下载本章的代码包。
- en: Parsing EML files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析EML文件
- en: 'Recipe Difficulty: Easy'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: The EML file format is widely used for storing email messages, as it is a structured
    text file that is compatible across multiple email clients. This text file stores
    email headers, body content, and attachment data as plain text, using `base64`
    to encode binary data and the **Quoted-Printable** (**QP**) encoding to store
    content information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: EML文件格式被广泛用于存储电子邮件消息，因为它是一个结构化的文本文件，兼容多个电子邮件客户端。这个文本文件以纯文本形式存储电子邮件头部、正文内容和附件数据，使用`base64`来编码二进制数据，使用**Quoted-Printable**（**QP**）编码来存储内容信息。
- en: Getting started
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python's standard library.
    We will use the built-in `email` library to read and extract key information from
    the EML files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。我们将使用内置的`email`库来读取和提取EML文件中的关键信息。
- en: To learn more about the `email` library, visit [https://docs.python.org/3/library/email.html](https://docs.python.org/3/library/email.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`email`库的信息，请访问[https://docs.python.org/3/library/email.html](https://docs.python.org/3/library/email.html)。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create an EML parser, we must:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个EML解析器，我们必须：
- en: Accept an argument for an EML file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一个EML文件的参数。
- en: Read values from the headers.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从头部读取值。
- en: Parse information from each of the sections of the EML.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从EML的各个部分中解析信息。
- en: Display this information for ease of review in the console.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中显示此信息以便审查。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by importing libraries for argument handling, EML processing, and
    decoding base64 encoded data. The `email` library provides classes and methods
    necessary to read EML files. We will use the `message_from_file()` function to
    parse data from the provided EML file. `Quopri` is a new library to this book
    which we use to decode the QP encoded values found in the HTML body and attachments.
    The `base64` library, as one might expect, allows us to decode any base64 encoded
    data:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入用于处理参数、EML处理和解码base64编码数据的库。`email`库提供了从EML文件中读取数据所需的类和方法。我们将使用`message_from_file()`函数来解析提供的EML文件中的数据。`Quopri`是本书中的一个新库，我们使用它来解码HTML正文和附件中的QP编码值。`base64`库，正如人们所期望的那样，允许我们解码任何base64编码的数据：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe''s command-line handler accepts one positional argument, `EML_FILE`,
    which represents the path to the EML file we will process. We use the `FileType`
    class to handle the opening of the file for us:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的命令行处理程序接受一个位置参数`EML_FILE`，表示我们将处理的EML文件的路径。我们使用`FileType`类来处理文件的打开：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `main()` function, we read the file-like object into the `email` library
    using the `message_from_file()` function. We can now use the resulting variable,
    `emlfile`, to access the headers, body content, attachments, and other payload
    information. Reading the email headers is simply a matter of iterating through
    a dictionary provided by the library''s `_headers` attribute. To handle the body
    content, we must check if this message contains multiple payloads and, if so,
    pass each to the designated processing function, `process_payload()`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们使用`message_from_file()`函数将类似文件的对象读入`email`库。现在我们可以使用结果变量`emlfile`来访问头部、正文内容、附件和其他有效载荷信息。读取电子邮件头部只是通过迭代库的`_headers`属性提供的字典来处理。要处理正文内容，我们必须检查此消息是否包含多个有效载荷，并且如果是这样，将每个传递给指定的处理函数`process_payload()`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `process_payload()` function begins by extracting extracting the MIME type
    of the message using the `get_content_type()` method. We print this value to the
    console and, on a newline, we print a number of `"="` characters to distinguish
    between this and the remainder of the message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_payload()`函数首先通过使用`get_content_type()`方法提取消息的MIME类型。我们将这个值打印到控制台上，并在新行上打印一些`"="`字符来区分这个值和消息的其余部分。'
- en: 'In one line, we extract the message body content using the `get_payload()`
    method and decoding the QP encoded data with the `quopri.decodestring()` function.
    We then check the there is a character set of the data and, if we do identify
    a character set, use the `decode()` method on the content while specifying the
    character set. If the encoding is unknown, we will try to decode the object with
    UTF8, the default when leaving the `decode()` method empty, and Windows-1252:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行中，我们使用`get_payload()`方法提取消息正文内容，并使用`quopri.decodestring()`函数解码QP编码的数据。然后，我们检查数据是否有字符集，如果我们确定了字符集，则在指定字符集的同时使用`decode()`方法对内容进行解码。如果编码是未知的，我们将尝试使用UTF8对对象进行解码，这是在将`decode()`方法留空时的默认值，以及Windows-1252：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our decoded data, we check the content MIME type to properly handle the
    storage of the email. The first condition for HTML information, specified by the
    `text/html` MIME type, is written to an HTML document in the same directory as
    the input file. In the second condition, we handle binary data under the `Application`
    MIME type. This data is conveyed as `base64` encoded values, which we decode before
    writing to a file in the current directory using the `base64.b64decode()` function.
    The binary data has the `get_filename()` method, which we can use to accurately
    name the attachment. Note that the output file must be opened in `"w"` mode for
    the first type and `"wb"` mode for the second. If the MIME type is other than
    what we have covered here, we print the body to the console:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们解码的数据，我们检查内容的MIME类型，以便正确处理电子邮件的存储。 HTML信息的第一个条件，由`text/html` MIME类型指定，被写入到与输入文件相同目录中的HTML文档中。在第二个条件中，我们处理`Application`
    MIME类型下的二进制数据。这些数据以`base64`编码的值传输，我们在使用`base64.b64decode()`函数写入到当前目录中的文件之前对其进行解码。二进制数据具有`get_filename()`方法，我们可以使用它来准确命名附件。请注意，输出文件必须以`"w"`模式打开第一种类型，以`"wb"`模式打开第二种类型。如果MIME类型不是我们在这里涵盖的类型，我们将在控制台上打印正文：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we execute this code, we see the header information first printed to the
    console, followed by the various payloads. In this case, we have a `text/plain`
    MIME content first, containing a sample message, followed by an `application/vnd.ms-excel`
    attachment that we export, and another `text/plain` block showing the initial
    message:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们首先在控制台上看到头信息，然后是各种有效载荷。在这种情况下，我们首先有一个`text/plain` MIME内容，其中包含一个示例消息，然后是一个`application/vnd.ms-excel`附件，我们将其导出，然后是另一个`text/plain`块显示初始消息：
- en: '![](../images/00064.jpeg)![](../images/00065.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00064.jpeg)![](../images/00065.jpeg)'
- en: Viewing MSG files
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看MSG文件
- en: 'Recipe Difficulty: Easy'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Windows'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Windows
- en: Email messages can come in many different formats. The MSG format is another
    popular container for storing message content and attachments. In this example,
    we will learn to parse MSG files using the Outlook API.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件消息可以以许多不同的格式出现。MSG格式是存储消息内容和附件的另一种流行容器。在这个例子中，我们将学习如何使用Outlook API解析MSG文件。
- en: Getting started
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: This recipe requires the installation of the third-party library `pywin32`.
    This means the script will only be compatible on Windows systems. We will also
    need to install `pywin32,` as we did in [Chapter 1](part0029.html#RL0A0-260f9401d2714cb9ab693c4692308abe),
    *Essential Scripting and File Information Recipes*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要安装第三方库`pywin32`。这意味着该脚本只能在Windows系统上兼容。我们还需要安装`pywin32`，就像我们在[第1章](part0029.html#RL0A0-260f9401d2714cb9ab693c4692308abe)中所做的那样，*基本脚本和文件信息配方*。
- en: To install `pywin32`, we need to access its SourceForge page at [https://sourceforge.net/projects/pywin32/](https://sourceforge.net/projects/pywin32/)
    and download the version that matches your Python installation. To check our Python
    version, we can import the `sys` module and call `sys.version` within an interpreter.
    Both the version and the architecture are important when selecting the correct
    `pywin32` installer. We also want to confirm we have a valid installation of Outlook
    that has been setup on our machine, as the `pywin32` bindings rely on resources
    provided by Outlook. We are ready to create the script after running the `pywin32`
    installer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`pywin32`，我们需要访问其SourceForge页面[https://sourceforge.net/projects/pywin32/](https://sourceforge.net/projects/pywin32/)，并下载与您的Python安装相匹配的版本。要检查我们的Python版本，我们可以导入`sys`模块，并在解释器中调用`sys.version`。在选择正确的`pywin32`安装程序时，版本和架构都很重要。我们还希望确认我们在计算机上安装了有效的Outlook，因为`pywin32`绑定依赖于Outlook提供的资源。在运行`pywin32`安装程序后，我们准备创建脚本。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create an MSG parser, we must:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建MSG解析器，我们必须：
- en: Accept an argument for an MSG file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受一个MSG文件的参数。
- en: Print general metadata about the MSG file to the console.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有关MSG文件的一般元数据打印到控制台。
- en: Print recipient-specific metadata to the console.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将特定于收件人的元数据打印到控制台。
- en: Export the message content to an output file.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息内容导出到输出文件。
- en: Export any attachments embedded within the message to appropriate output files.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将嵌入在消息中的任何附件导出到适当的输出文件。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We begin by importing libraries for argument handling, `argparse` and `os`,
    followed by the `win32com` library from `pywin32`. We also import the `pywintypes`
    library to properly catch and handle `pywin32` errors:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入用于参数处理的库`argparse`和`os`，然后是来自`pywin32`的`win32com`库。我们还导入`pywintypes`库以正确捕获和处理`pywin32`错误：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This recipe''s command-line handler accepts two positional arguments, `MSG_FILE`
    and `OUTPUT_DIR`, which represent the path to the MSG file to process and the
    desired output folder, respectively. We check if the desired output folder exists
    and create it if it does not. Afterwards, we pass the two inputs to the `main()`
    function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受两个位置参数，`MSG_FILE`和`OUTPUT_DIR`，分别表示要处理的MSG文件的路径和所需的输出文件夹。我们检查所需的输出文件夹是否存在，如果不存在，则创建它。之后，我们将这两个输入传递给`main()`函数：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `main()` function we call the `win32com` library to set up the Outlook
    API configuring it in such a way that allows access to the `MAPI` namespace. Using
    this `mapi` variable, we can open an `MSG` file with the `OpenSharedItem()` method
    and create an object we will use for the other functions in this recipe. These
    functions include: `display_msg_attribs()`, `display_msg_recipients()`, `extract_msg_body()`,
    and `extract_attachments()`. Let''s now turn our attention to each of these functions,
    in turn, to see how they work:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们调用 `win32com` 库来设置 Outlook API，以便以允许访问 `MAPI` 命名空间的方式进行配置。使用这个
    `mapi` 变量，我们可以使用 `OpenSharedItem()` 方法打开一个 `MSG` 文件，并创建一个我们将在本示例中使用的对象。这些函数包括：`display_msg_attribs()`、`display_msg_recipients()`、`extract_msg_body()`
    和 `extract_attachments()`。现在让我们依次关注这些函数，看看它们是如何工作的：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `display_msg_attribs()` function allows us to display the various attributes
    of a message (subject, to, BCC, size, and so on). Some of these attributes may
    not be present in the message we are parsing, however, we attempt to export all
    values regardless. The `attribs` list shows, in order, the attributes we try to
    access from the message. As we iterate through each attribute, we use the built-in
    `getattr()` method on the `msg` object and attempt to extract the relevant value,
    if present, and `"N/A"` if not. We then print the attribute and its determined
    value to the console. As a word of caution, some of these values may be present
    but only set to a default value, such as the year `4501` for some dates:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_msg_attribs()` 函数允许我们显示消息的各种属性（主题、收件人、密件抄送、大小等）。其中一些属性可能不存在于我们解析的消息中，但是我们尝试导出所有值。`attribs`
    列表按顺序显示我们尝试从消息中访问的属性。当我们遍历每个属性时，我们在 `msg` 对象上使用内置的 `getattr()` 方法，并尝试提取相关值（如果存在），如果不存在，则为
    `"N/A"`。然后我们将属性及其确定的值打印到控制台。需要注意的是，其中一些值可能存在，但仅设置为默认值，例如某些日期的年份为 `4501`：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `display_msg_recipients()` function iterates through the message and displays
    recipient details. The `msg` object provides a `Recipients()` method, which accepts
    an integer argument to access recipients by index. Using a `while` loop, we try
    to load and display values for available recipients. For each recipient found,
    as in the prior function, we use of `getattr()` method with a list of attributes,
    called `recipient_attrib`, to extract and print the relevant values or, if they
    are not present, assign them the value `"N/A"`. Though most Python iterables use
    zero as the first index, the `Recipients()` method starts at `1`. For this reason,
    the variable `i` will start at `1` and be incremented until no further recipients
    are found. We will continue to try and read these values until we receive a `pywin32`
    error:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_msg_recipients()` 函数遍历消息并显示收件人详细信息。`msg` 对象提供了一个 `Recipients()` 方法，该方法接受一个整数参数以按索引访问收件人。使用
    `while` 循环，我们尝试加载和显示可用收件人的值。对于找到的每个收件人，与之前的函数一样，我们使用 `getattr()` 方法与属性列表 `recipient_attrib`
    提取和打印相关值，或者如果它们不存在，则赋予它们值 `"N/A"`。尽管大多数 Python 可迭代对象使用零作为第一个索引，但 `Recipients()`
    方法从 `1` 开始。因此，变量 `i` 将从 `1` 开始递增，直到找不到更多的收件人为止。我们将继续尝试读取这些值，直到收到 `pywin32` 错误。'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `extract_msg_body()` function is designed to extract the body content from
    the message. The `msg` object exposes the body content in a few different formats;
    in this recipe, we will export the HTML, using the `HTMLBody()` method, and plaintext,
    using the `Body()` method, versions of the body. Since these objects are byte
    strings, we must first decode them, which we do with the `cp1252` code page. With
    the decoded content, we open the output file for writing, in the user-specified
    directory, and create the respective `*.body.html` and `*.body.txt` files:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_msg_body()` 函数旨在从消息中提取正文内容。`msg` 对象以几种不同的格式公开正文内容；在本示例中，我们将导出 HTML（使用
    `HTMLBody()` 方法）和纯文本（使用 `Body()` 方法）版本的正文。由于这些对象是字节字符串，我们必须首先解码它们，这是通过使用 `cp1252`
    代码页来完成的。有了解码后的内容，我们打开用户指定目录中的输出文件，并创建相应的 `*.body.html` 和 `*.body.txt` 文件：'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, the `extract_attachments()` function exports attachment data from the
    MSG file to the desired output directory. Using the `msg` object, we again create
    a list, `attachment_attribs`, representing a series of attributes about an attachment.
    Similar to the recipient function, we use a `while` loop and the `Attachments()`
    method, which accepts an integer as an argument to select an attachment by index,
    to iterate through each attachment. As we saw before with the `Recipients()` method,
    the `Attachments()` method starts its index at `1`. For this reason, the variable
    `i` will start at `1` and be incremented until no further attachments are found:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`extract_attachments()` 函数将附件数据从 MSG 文件导出到所需的输出目录。使用 `msg` 对象，我们再次创建一个列表
    `attachment_attribs`，表示有关附件的一系列属性。与收件人函数类似，我们使用 `while` 循环和 `Attachments()` 方法，该方法接受一个整数作为参数，以选择要迭代的附件。与之前的
    `Recipients()` 方法一样，`Attachments()` 方法从 `1` 开始索引。因此，变量 `i` 将从 `1` 开始递增，直到找不到更多的附件为止：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For each attachment, we print its attributes to the console. The attributes
    we extract and print are defined in the `attachment_attrib` list at the beginning
    of this function. After printing available attachment details, we write its content
    using the `SaveAsFile()` method and supplying it with a string containing the
    output path and desired name of the output attachment (which is obtained using
    the `FileName` attribute). After this, we are ready to move onto the next attachment
    and so we increment variable `i` and try to access the next attachment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个附件，我们将其属性打印到控制台。我们提取和打印的属性在此函数开始时的 `attachment_attrib` 列表中定义。打印可用附件详细信息后，我们使用
    `SaveAsFile()` 方法写入其内容，并提供一个包含输出路径和所需输出附件名称的字符串（使用 `FileName` 属性获取）。之后，我们准备移动到下一个附件，因此我们递增变量
    `i` 并尝试访问下一个附件。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we execute this code, we see the following output, along with several files
    in the output directory. This includes the body as text and HTML, along with any
    discovered attachments. The attributes of the message and its attachments are
    displayed in the console window.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们将看到以下输出，以及输出目录中的几个文件。这包括正文文本和HTML，以及任何发现的附件。消息及其附件的属性将显示在控制台窗口中。
- en: '![](../images/00066.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00066.jpeg)'
- en: There’s more...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们提供了一个或多个建议如下：
- en: Consider adding more fields to the parser by referencing the properties of an
    MSG object on MSDN at [https://msdn.microsoft.com/en-us/library/microsoft.office.interop.outlook.mailitem_properties.aspx](https://msdn.microsoft.com/en-us/library/microsoft.office.interop.outlook.mailitem_properties.aspx)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑通过参考MSDN上MSG对象的属性来向解析器添加更多字段[https://msdn.microsoft.com/en-us/library/microsoft.office.interop.outlook.mailitem_properties.aspx](https://msdn.microsoft.com/en-us/library/microsoft.office.interop.outlook.mailitem_properties.aspx)
- en: See also
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Other libraries for accessing MSG files exist, including the `Redemption` library.
    This library provides handlers to access header information, along with many of
    the same attributes shown in this example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他用于访问MSG文件的库，包括`Redemption`库。该库提供了访问标头信息的处理程序，以及与此示例中显示的许多相同属性。
- en: Ordering Takeout
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订购外卖
- en: 'Recipe Difficulty: Easy'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 教程难度：简单
- en: 'Python Version: N/A'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：N/A
- en: 'Operating System: Any'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Google Mail, popularly known as Gmail, is one of the more widely-used webmail
    services. Gmail accounts not only function as email addresses, but a gateway into
    the slew of other services that Google offers. In addition to providing access
    to mail through the web or **Internet Message Access Protocol** (**IMAP**) and
    **Post Office Protocol** (**POP**) mail protocols, Google has developed a system
    for the archival and acquisition of mail and other associated data stored in a
    Gmail account.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌邮件，通常称为Gmail，是更广泛使用的网络邮件服务之一。Gmail帐户不仅可以作为电子邮件地址，还可以作为通往谷歌提供的众多其他服务的入口。除了通过网络或**Internet
    Message Access Protocol**（**IMAP**）和**Post Office Protocol**（**POP**）邮件协议提供邮件访问外，谷歌还开发了一种用于存档和获取Gmail帐户中存储的邮件和其他相关数据的系统。
- en: Getting started
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: This recipe, believe it or not, actually does not involve any Python and instead
    requires a browser and access to a Google account instead. The purpose of this
    recipe is to acquire the Google account mailbox in the MBOX format which we parse
    in the next recipe.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这个教程实际上不涉及任何Python，而是需要浏览器和对Google帐户的访问。这个教程的目的是以MBOX格式获取Google帐户邮箱，我们将在下一个教程中解析它。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To initiate a Google Takeout, we follow these steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Google Takeout，我们按照以下步骤进行：
- en: Login to the Google account in question.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到相关的谷歌帐户。
- en: Navigate to account settings and the Create Archive feature.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到帐户设置和创建存档功能。
- en: Select desired Google products to archive and begin the process.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要存档的所需谷歌产品并开始该过程。
- en: Download the archived data.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载存档数据。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start the Google Takeout process by logging into the account and selecting
    the My Account option. We can also navigate to [https://myaccount.google.com](https://myaccount.google.com)
    if the My Account option is not present:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过登录帐户并选择“我的帐户”选项来开始Google Takeout过程。如果“我的帐户”选项不存在，我们也可以导航到[https://myaccount.google.com](https://myaccount.google.com)：
- en: '![](../images/00067.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00067.jpeg)'
- en: 'On the My Account dashboard, we select the Control your content link under
    the Personal info & privacy section:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在“我的帐户”仪表板上，我们选择“个人信息和隐私”部分下的“控制您的内容”链接：
- en: '![](../images/00068.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00068.jpeg)'
- en: 'Within the Control your content section, we are presented with an option to
    CREATE ARCHIVE. This is where we start the Google Takeout collection:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在“控制您的内容”部分，我们将看到一个“创建存档”的选项。这是我们开始Google Takeout收集的地方：
- en: '![](../images/00069.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00069.jpeg)'
- en: 'When selecting this option, we are presented with an option to manage existing
    archives or generate a new one. When generating a new one, we are presented with
    check boxes for each Google product we wish to include. Drop-down arrows provide
    sub-menus altering the export format or content. For example, we can choose how
    Google Drive Documents are exported as Microsoft Word, PDF, or plaintext formats.
    In this instance, we will leave the options as defaults, ensuring the Mail option
    is set to collect All mail:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项时，我们将看到管理现有存档或生成新存档的选项。生成新存档时，我们将看到每个我们希望包括的Google产品的复选框。下拉箭头提供子菜单，可更改导出格式或内容。例如，我们可以选择将Google
    Drive文档导出为Microsoft Word、PDF或纯文本格式。在这种情况下，我们将保留选项为默认值，确保邮件选项设置为收集所有邮件：
- en: '![](../images/00070.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00070.jpeg)'
- en: With the desired content selected, we can configure the format of the archive.
    Google Takeout allows us to select both an archive file type and a maximum segment
    size for ease of download and access. We can also select how we would like to
    access the Takeout. This option can be set to send a download link to the account
    being archived (the default option) or upload the archive to the account's Google
    Drive or other third-party cloud services, which may modify more information than
    necessary to preserve this data. We elect to receive the email and then select
    Create archive to start the process!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所需的内容后，我们可以配置存档的格式。Google Takeout允许我们选择存档文件类型和最大段大小，以便轻松下载和访问。我们还可以选择如何访问Takeout。此选项可以设置为将下载链接发送到被存档的帐户（默认选项）或将存档上传到帐户的Google
    Drive或其他第三方云服务，这可能会修改比必要更多的信息以保留这些数据。我们选择接收电子邮件，然后选择“创建存档”以开始该过程！
- en: '![](../images/00071.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00071.jpeg)'
- en: And now we must wait. Depending on the size of the data being preserved this
    can take a considerable amount of time, as Google has to gather, convert, and
    compress all of the data for you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须等待。根据要保存的数据大小，这可能需要相当长的时间，因为Google必须为您收集、转换和压缩所有数据。
- en: When you receive the notification email, select the provided link to download
    the archive. This archive is only available for a limited time, so it is important
    to collect it as soon as you are notified.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您收到通知电子邮件时，请选择提供的链接下载存档。此存档仅在有限的时间内可用，因此在收到通知后尽快收集它是很重要的。
- en: '![](../images/00072.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: After downloading the data, extract the archive's contents and look at the internal
    folder structure and provided data. Each of the products selected is given a folder
    containing the relevant content or folder structure for the product. In this instance,
    we are most interested in mail, provided in the MBOX format. In the next recipe,
    we will show how to parse this MBOX data using Python.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下载数据后，提取存档的内容并查看内部文件夹结构和提供的数据。所选的每个产品都有一个包含相关内容或产品的文件夹结构的文件夹。在这种情况下，我们最感兴趣的是以MBOX格式提供的邮件。在下一个配方中，我们将展示如何使用Python解析这些MBOX数据。
- en: There’s more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you prefer a more direct route for this acquisition, you can navigate to
    [https://takeout.google.com/settings/takeout](https://takeout.google.com/settings/takeout)
    after logging into the account. From here you can choose the products for export.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢更直接的方式来获取这些数据，您可以在登录账户后导航到[https://takeout.google.com/settings/takeout](https://takeout.google.com/settings/takeout)。在这里，您可以选择要导出的产品。
- en: What’s in the box?!
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒子里有什么?!
- en: 'Recipe Difficulty: Medium'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：中等
- en: 'Python Version: 3.5'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：3.5
- en: 'Operating System: Any'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: MBOX files are often found in association with UNIX systems, Thunderbird, and
    Google Takeouts. These MBOX containers are text files with special formatting
    that split messages stored within. Since there are several formats for structuring
    MBOX files, our script will focus on those from Google Takeout, using the output
    from the prior recipe.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MBOX文件通常与UNIX系统、Thunderbird和Google Takeouts相关联。这些MBOX容器是具有特殊格式的文本文件，用于分割存储在其中的消息。由于有几种用于构造MBOX文件的格式，我们的脚本将专注于来自Google
    Takeout的格式，使用前一个配方的输出。
- en: Getting started
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python's standard library.
    We use the built-in `mailbox` library to parse the Google Takeout structured MBOX
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。我们使用内置的`mailbox`库来解析Google Takeout结构化的MBOX文件。
- en: To learn more about the `mailbox` library, visit [https://docs.python.org/3/library/mailbox.html](https://docs.python.org/3/library/mailbox.html).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`mailbox`库的信息，请访问[https://docs.python.org/3/library/mailbox.html](https://docs.python.org/3/library/mailbox.html)。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement this script, we must:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个脚本，我们必须：
- en: Design arguments to accept a file path to the MBOX file and an output the report
    its contents.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计参数以接受MBOX文件的文件路径并输出报告内容。
- en: Develop a custom MBOX reader that handles encoded data.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个处理编码数据的自定义MBOX阅读器。
- en: Extract message metadata including attachment names.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取消息元数据，包括附件名称。
- en: Write attachments to the output directory.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附件写入输出目录。
- en: Create an MBOX metadata report.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个MBOX元数据报告。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by importing libraries for argument handling, followed by the `os`,
    `time`, and `csv` libraries required for creating the script''s output. Next,
    we import the `mailbox` library to parse the MBOX message format and `base64`
    to decode binary data in attachments. Lastly, we bring in the `tqdm` library to
    provide a progress bar related to the message parsing status:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入用于处理参数的库，然后是用于创建脚本输出的`os`、`time`和`csv`库。接下来，我们导入`mailbox`库来解析MBOX消息格式和`base64`来解码附件中的二进制数据。最后，我们引入`tqdm`库来提供与消息解析状态相关的进度条：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This recipe''s command-line handler accepts two positional arguments, `MBOX`
    and `OUTPUT_DIR`, which represent the path to the MBOX file to process and the
    desired output folder, respectively. Both of these arguments are passed to the
    `main()` function to kick off the script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受两个位置参数，`MBOX`和`OUTPUT_DIR`，分别表示要处理的MBOX文件的路径和期望的输出文件夹。这两个参数都传递给`main()`函数来启动脚本：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `main()` function starts with a call to the `mailbox` library’s `mbox`
    class. Using this class, we can parse a MBOX file by providing the path to the
    file and an optional argument for the factory, which in our case, is a custom
    reader function. Using this library, we now have an iterable object containing
    message objects we can interact with. We use the built-in `len()` method to print
    the number of messages contained within the MBOX file. Let''s first look at how
    the `custom_reader()` function works:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数从调用`mailbox`库的`mbox`类开始。使用这个类，我们可以通过提供文件路径和一个可选的工厂参数来解析MBOX文件，这在我们的情况下是一个自定义阅读器函数。使用这个库，我们现在有一个包含我们可以交互的消息对象的可迭代对象。我们使用内置的`len()`方法来打印MBOX文件中包含的消息数量。让我们首先看看`custom_reader()`函数是如何工作的：'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This recipe requires a number of functions to function (see what we did there...),
    but the `custom_reader()` method is a bit different than the others. This function
    is a reader method for the `mailbox` library. We need to create this function
    due to the fact that the default reader does not handle encoding such as `cp1252`.
    We can add other encodings into this reader, though ASCII and `cp1252` are the
    two most common encodings for MBOX files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要一些函数来运行（看到我们做了什么吗...），但`custom_reader()`方法与其他方法有些不同。这个函数是`mailbox`库的一个阅读器方法。我们需要创建这个函数，因为默认的阅读器不能处理诸如`cp1252`之类的编码。我们可以将其他编码添加到这个阅读器中，尽管ASCII和`cp1252`是MBOX文件的两种最常见的编码。
- en: 'After using the `read()` method on the input data stream, it tries to decode
    the data using the ASCII codepage. If this is unsuccessful, it instead relies
    on the `cp1252` codepage to get the job done. Any errors that are encountered
    when decoding with the `cp1252` codepage are replaced by the replacement character
    `U+FFFD` by supplying the `decode()` method with the `errors` keyword setting
    it to `"replace"`. We use the `mailbox.mboxMessage()` function to return the decoded
    content in the appropriate format:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入数据流上使用`read()`方法后，它尝试使用ASCII代码页对数据进行解码。如果不成功，它将依赖`cp1252`代码页来完成任务。使用`cp1252`代码页解码时遇到的任何错误都将被替换为替换字符`U+FFFD`，通过向`decode()`方法提供`errors`关键字并将其设置为`"replace"`来实现。我们使用`mailbox.mboxMessage()`函数以适当的格式返回解码后的内容：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Back in the `main()` function, we prepare a few variables before we begin processing
    the messages. Namely, we set up the `parsed_data` results list, create an output
    directory for attachments, and define the `columns` for the MBOX metadata report.
    These columns will also be used to extract information from the message using
    the `get()` method. Two of these columns will not extract information from the
    message object and, instead, will contain data we assign after processing attachments.
    For consistency, we will keep these values in the `columns` list, as they will
    default to an `"N/A"` value anyways:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main()`函数，在开始处理消息之前，我们准备了一些变量。具体来说，我们设置了`parsed_data`结果列表，为附件创建了一个输出目录，并定义了MBOX元数据报告的`columns`。这些列也将用于使用`get()`方法从消息中提取信息。其中两列不会从消息对象中提取信息，而是在处理附件后包含我们分配的数据。为了保持一致性，我们将这些值保留在`columns`列表中，因为它们将默认为`"N/A"`值：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we begin to iterate through the messages, we implement a `tqdm` progress
    bar to track the iteration process. Since the `mbox` object has a length property,
    we do not need to provide any additional arguments to `tqdm`. Inside of the loop,
    we define the `msg_data` dictionary to store message results and then try to assign
    message properties through a second `for` loop using the `get()` method to query
    for `columns` keys in the `header_data` dictionary:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始迭代消息时，我们实现了一个`tqdm`进度条来跟踪迭代过程。由于`mbox`对象具有长度属性，因此我们不需要为`tqdm`提供任何额外的参数。在循环内部，我们定义了`msg_data`字典来存储消息结果，然后尝试通过第二个`for`循环使用`get()`方法在`header_data`字典中查询`columns`键来分配消息属性：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, in an `if` statement, we check if the `message` has a payload and, if
    it does, we use the `write_payload()` method supplying it the `message` object
    and the output attachments directory as its inputs. If no payloads exist for the
    `message`, the two attachment-related columns will remain with the default `"N/A"`
    values. Otherwise, we count the number of attachments found and join a list of
    their paths together into a comma-separated list:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在一个`if`语句中，我们检查`message`是否具有有效载荷，如果有，我们使用`write_payload()`方法，向其提供`message`对象和输出附件目录作为输入。如果`message`没有有效载荷，那么两个与附件相关的列将保持默认的`"N/A"`值。否则，我们计算找到的附件数量，并将它们的路径列表连接成逗号分隔的列表：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After each message is processed, its data is appended to the `parsed_data`
    list. After every message has been processed, the `create_report()` method is
    called and passed the `parsed_data` list and the desired output CSV name. Let''s
    backtrack a bit and look at the `write_payload()` method first:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每处理完一条消息，其数据都会被附加到`parsed_data`列表中。在处理完所有消息后，将调用`create_report()`方法，并传递`parsed_data`列表和所需的输出CSV名称。让我们回溯一下，首先看一下`write_payload()`方法：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since messages can have a wide variety of payloads, we need to craft a dedicated
    function to handle the various `MIME` types. The `write_payload()` method is such
    a function. This function begins by extracting the payload with the `get_payload()`
    method and performing a quick check to see if the payload content consists of
    multiple parts. If it does, we call this function recursively to handle each subsection,
    by iterating through the payloads and appending the output to the `export_path`
    variable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于消息可能具有各种各样的有效载荷，我们需要编写一个专门的函数来处理各种`MIME`类型。`write_payload()`方法就是这样一个函数。该函数首先通过`get_payload()`方法提取有效载荷，并进行快速检查，看看有效载荷内容是否包含多个部分。如果是，我们会递归调用此函数来处理每个子部分，通过迭代有效载荷并将输出附加到`export_path`变量中：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the payload is not multi-part, we determine its MIME type using the `get_content_type()`
    method and creating logic to handle the data source appropriately by category.
    Data types, including application, image, and video, are generally represented
    as `base64`-encoded data, allowing binary information to be transmitted as ASCII
    characters. For this reason, the majority of the formats, including some within
    the text category, require us to decode the data before providing it for writing.
    In other instances, the data already exists as a string and can be written as-is
    to the file. Regardless, the method is generally the same, the data is decoded
    (if necessary) and its contents are written to the filesystem using the `export_content()`
    method. Lastly, a string representing the path to the exported item is appended
    to the `export_path` list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有效载荷不是多部分的，我们使用`get_content_type()`方法确定其MIME类型，并创建逻辑来根据类别适当地处理数据源。应用程序、图像和视频等数据类型通常表示为`base64`编码数据，允许将二进制信息作为ASCII字符传输。因此，大多数格式（包括文本类别中的一些格式）都要求我们在提供写入之前对数据进行解码。在其他情况下，数据已存在为字符串，并且可以按原样写入文件。无论如何，方法通常是相同的，数据被解码（如果需要），并使用`export_content()`方法将其内容写入文件系统。最后，表示导出项目路径的字符串被附加到`export_path`列表中：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `else` statement adds an additional `if-elif` statement to the payload
    to determine if the export contains a filename. If it does, we treat it as the
    others, however, if it does not, it is likely a message body stored as HTML or
    text. While we could export each message body by modifying this section, it would
    generate a large amount of data for this example and so we choose not to. Once
    we have finished exporting data from the message, we return the list of paths
    for the data exported to the `main()` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 语句在负载中添加了一个额外的 `if-elif` 语句，以确定导出是否包含文件名。如果有，我们将其视为其他文件，但如果没有，它很可能是存储为
    HTML 或文本的消息正文。虽然我们可以通过修改这一部分来导出每个消息正文，但这将为本示例生成大量数据，因此我们选择不这样做。一旦我们完成了从消息中导出数据，我们将导出的数据的路径列表返回给
    `main()` 函数：'
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `export_content()` function starts by calling the `get_filename()` function,
    a method that extracts the filename from the `msg` object. Additional processing
    is performed on the filename to extract an extension, if present, though the generic
    `.FILE` extension is used if none is found:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`export_content()` 函数首先调用 `get_filename()` 函数，这个方法从 `msg` 对象中提取文件名。对文件名进行额外处理以提取扩展名（如果有的话），如果没有找到则使用通用的
    `.FILE` 扩展名：'
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we perform additional formatting to create a unique filename by integrating
    the time, represented as a Unix time integer, followed by the determined file
    extension. This filename is then joined to the output directory to form a full
    path for writing the output. This unique filename ensures that we do not mistakenly
    overwrite already present attachments in the output directory:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行额外的格式化，通过整合时间（表示为 Unix 时间整数）和确定的文件扩展名来创建一个唯一的文件名。然后将此文件名连接到输出目录，形成用于写入输出的完整路径。这个唯一的文件名确保我们不会错误地覆盖输出目录中已经存在的附件：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last segment of code in this function handles the actual export of file
    content. This `if` statement handles the different file modes (`"w"` or `"wb"`),
    based on the source type. After writing the data, we return the file path used
    in the export. This path will be added to our metadata report:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中代码的最后一部分处理文件内容的实际导出。这个 `if` 语句处理不同的文件模式（`"w"` 或 `"wb"`），根据源类型。写入数据后，我们返回用于导出的文件路径。这个路径将被添加到我们的元数据报告中：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next function, `get_filename()`, extracts filenames from the message to
    accurately represent the names of these files. The filenames can be found within
    the `"Content-Disposition"` or `"Content-Type"` properties and are generally found
    prepended with a `"name="` or `"filename="` string. For both properties, the logic
    is largely the same. The function first replaces any newline characters with one
    space and then splits the string on a semicolon and space. This delimiter generally
    separates the values within these properties. Using list comprehension, we identify
    which element contains a `name=` substring and use that as the filename:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数 `get_filename()` 从消息中提取文件名以准确表示这些文件的名称。文件名可以在 `"Content-Disposition"`
    或 `"Content-Type"` 属性中找到，并且通常以 `"name="` 或 `"filename="` 字符串开头。对于这两个属性，逻辑基本相同。该函数首先用一个空格替换任何换行符，然后在分号和空格上拆分字符串。这个分隔符通常分隔这些属性中的值。使用列表推导，我们确定哪个元素包含
    `name=` 子字符串，并将其用作文件名：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the two content properties are empty, we assign a generic `NO_FILENAME`
    and continue preparing the filename. After we extract the potential filename,
    we remove any characters that are not alphanumeric, a space, or a period to prevent
    errors with writing the file to the system. With our filesystem-safe filename
    ready, we return it for use in the previously discussed `export_content()` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个内容属性为空，我们分配一个通用的 `NO_FILENAME` 并继续准备文件名。提取潜在的文件名后，我们删除任何不是字母数字、空格或句号的字符，以防止在系统中写入文件时出错。准备好我们的文件系统安全文件名后，我们将其返回供前面讨论的
    `export_content()` 方法使用：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Lastly, we have reached the point where we are ready to discuss the CSV metadata
    report. The `create_report()` function, is similar to what we have seen variations
    of throughout this book, it creates a CSV report from a list of dictionaries using
    the `DictWriter` class. Ta-da!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了准备讨论 CSV 元数据报告的阶段。`create_report()` 函数类似于本书中我们已经看到的各种变体，它使用 `DictWriter`
    类从字典列表创建 CSV 报告。哒哒！
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This script creates a CSV report and directory full of attachments. The first
    screenshot shows the first few columns and rows of the CSV report and how the
    data is displayed to the user:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本创建了一个 CSV 报告和一个附件目录。第一个截图显示了 CSV 报告的前几列和行以及数据如何显示给用户：
- en: '![](../images/00073.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00073.jpeg)'
- en: 'This second screenshot displays the last few columns of these same rows and
    reflects how attachment information is reported. These file paths can be followed
    to access the corresponding attachments:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二个截图显示了这些相同行的最后几列，并反映了附件信息的报告方式。这些文件路径可以被跟踪以访问相应的附件：
- en: '![](../images/00074.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00074.jpeg)'
- en: Parsing PST and OST mailboxes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 PST 和 OST 邮箱
- en: 'Recipe Difficulty: Hard'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：困难
- en: 'Python Version: 2.7'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本：2.7
- en: 'Operating System: Linux'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Linux
- en: The **Personal Storage Table** (**PST**) file is commonly found on many systems
    and provides access to archived email. These files, generally associated with
    the Outlook application, contain message and attachment data. These files are
    commonly found in the corporate setting, as many business environments continue
    to leverage Outlook for internal and external email management.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**个人存储表**（**PST**）文件通常在许多系统上找到，并提供对归档电子邮件的访问。这些文件通常与 Outlook 应用程序相关联，包含消息和附件数据。这些文件通常在企业环境中找到，因为许多商业环境继续利用
    Outlook 进行内部和外部电子邮件管理。'
- en: Getting started
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: This recipe requires the installation of the `libpff`, and its Python bindings,
    `pypff`, to function. Available on GitHub, this library provides tools, and Python
    bindings, to handle and extract data from PST files. We will set up this library
    in Ubuntu 16.04 with bindings for Python 2 for ease of development. This library
    can be built for Python 3 as well, though we will use the Python 2 bindings for
    this section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方需要安装`libpff`及其Python绑定`pypff`才能正常运行。这个库在GitHub上提供了工具和Python绑定，用于处理和提取PST文件中的数据。我们将在Ubuntu
    16.04上为Python 2设置这个库以便开发。这个库也可以为Python 3构建，不过在本节中我们将使用Python 2的绑定。
- en: 'We must install a number of dependencies before installing the required library.
    Using the Ubuntu `apt` package manager, we will install the following eight packages.
    You may want to keep this Ubuntu environment handy as we will use it extensively
    [Chapter 8](part0241.html#75QNI0-260f9401d2714cb9ab693c4692308abe), *Working with
    Forensic Evidence Container Recipes* and onwards:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装所需的库之前，我们必须安装一些依赖项。使用Ubuntu的`apt`软件包管理器，我们将安装以下八个软件包。您可能希望将这个Ubuntu环境保存好，因为我们将在[第8章](part0241.html#75QNI0-260f9401d2714cb9ab693c4692308abe)以及以后的章节中广泛使用它：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the dependencies installed, navigate to the GitHub repository and download
    the desired release for the library. This recipe was developed using the `libpff-experimental-20161119`
    release of the `pypff` library. Next, once the contents of the release are extracted,
    open a terminal and navigate to the extracted directory and execute the following
    commands for the release:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 安装依赖项后，转到GitHub存储库并下载所需的库版本。这个配方是使用`pypff`库的`libpff-experimental-20161119`版本开发的。接下来，一旦提取了发布的内容，打开终端并导航到提取的目录，并执行以下命令以进行发布：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To learn more about the `pypff` library, visit [https://github.com/libyal/libpff](https://github.com/libyal/libpff).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`pypff`库的更多信息，请访问[https://github.com/libyal/libpff](https://github.com/libyal/libpff)。
- en: Lastly, we can check the library installation by opening a Python interpreter,
    importing `pypff`, and running the `pypff.get_version()` method to ensure we have
    the correct release version.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过打开Python解释器，导入`pypff`并运行`pypff.get_version()`方法来检查库的安装情况，以确保我们有正确的发布版本。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We extract PST message content following these steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下步骤提取PST消息内容：
- en: Create a handle for the PST file using `pypff`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pypff`为PST文件创建一个句柄。
- en: Iterate through all folders and messages within the PST.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历PST中的所有文件夹和消息。
- en: Store relevant metadata for each message.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储每条消息的相关元数据。
- en: Create a metadata report based on the contents of the PST.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据PST的内容创建元数据报告。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This script begins by importing libraries for argument handling, writing spreadsheets,
    performing regular expression searches, and processing PST files:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本首先导入用于处理参数、编写电子表格、执行正则表达式搜索和处理PST文件的库：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This recipe''s command-line handler accepts two positional arguments, `PFF_FILE`
    and `CSV_REPORT`, which represent the path to the PST file to process and the
    desired output CSV path, respectively. We forego a `main()` function in this recipe
    and immediately begin by using the `pypff.file()` object to instantiate the `pff_obj`
    variable. Following that, we use the `open()` method and attempt to access the
    user-supplied PST. We pass this PST to the `process_folders()` method and store
    the returned list of dictionaries in the `parsed_data` variable. After using the
    `close()` method on the `pff_obj` variable, we write the PST metadata report using
    the `write_data()` function by passing it the desired output CSV path and processed
    data dictionary:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的命令行处理程序接受两个位置参数，`PFF_FILE`和`CSV_REPORT`，分别表示要处理的PST文件的路径和所需的输出CSV路径。在这个配方中，我们不使用`main()`函数，而是立即使用`pypff.file()`对象来实例化`pff_obj`变量。随后，我们使用`open()`方法并尝试访问用户提供的PST。我们将此PST传递给`process_folders()`方法，并将返回的字典列表存储在`parsed_data`变量中。在对`pff_obj`变量使用`close()`方法后，我们使用`write_data()`函数写入PST元数据报告，通过传递所需的输出CSV路径和处理后的数据字典：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This recipe consists of several functions that handle different elements of
    the PST file. The `process_folders()` function handles the folder processing and
    iteration. As we process these folders, we print their names, the number of subfolders,
    and the number of messages within that folder to the console. This can be accomplished
    by calling the `number_of_sub_folders` and `number_of_sub_messages` attributes
    on the `pff_folder` object:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方由几个处理PST文件不同元素的函数组成。`process_folders()`函数处理文件夹处理和迭代。在处理这些文件夹时，我们将它们的名称、子文件夹的数量以及该文件夹中的消息数量打印到控制台。这可以通过在`pff_folder`对象上调用`number_of_sub_folders`和`number_of_sub_messages`属性来实现：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Following these print messages, we setup up the `data_list` which is responsible
    for storing processed message data. As we iterate through the messages within
    the folder, we call the `process_message()` method to create the dictionary object
    with the processed message data. Immediately afterward, we add the folder name
    to the dictionary before appending it to the list of results.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印这些消息后，我们设置了`data_list`，它负责存储处理过的消息数据。当我们遍历文件夹中的消息时，我们调用`process_message()`方法来创建带有处理过的消息数据的字典对象。紧接着，我们将文件夹名称添加到字典中，然后将其附加到结果列表中。
- en: 'The second loop iterates through subfolders, recursively calling the `process_folders()`
    function and passing it the subfolder to process and appending the resulting list
    of dictionaries to the `data_list`. This allows us to walk through the PST and
    extract all of the data before we return the `data_list` and write the CSV report:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环通过递归调用`process_folders()`函数并将子文件夹传递给它，然后将结果字典列表附加到`data_list`中。这使我们能够遍历PST并提取所有数据，然后返回`data_list`并编写CSV报告：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `process_message()` function is responsible for accessing the various attributes
    of the message, including the email header information. As seen in previous recipes,
    we use a list of object attributes to build a dictionary of results. We then iterate
    through the `attribs` dictionary and, using the `getattr()` method, append the
    appropriate key-value pairs to the `data_dict` dictionary. Lastly, if email headers
    are present, which we determine by using the `transport_headers` attribute, we
    update the `data_dict` dictionary with additional values extracted from the `process_headers()`
    function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_message()` 函数负责访问消息的各种属性，包括电子邮件头信息。正如在以前的示例中所看到的，我们使用对象属性的列表来构建结果的字典。然后我们遍历`attribs`字典，并使用`getattr()`方法将适当的键值对附加到`data_dict`字典中。最后，如果存在电子邮件头，我们通过使用`transport_headers`属性来确定，我们将从`process_headers()`函数中提取的附加值更新到`data_dict`字典中：'
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `process_headers()` function ultimately returns a dictionary containing
    extracted email header data. This data is displayed as key-value pairs, delimited
    by a colon and space. Since content within a header may be stored on a new line,
    we use regular expression to check that there is a key at the start of the line
    followed by a value. If we do not find a key matching the pattern (any number
    of letters or a dash character followed by a colon), we will append the new value
    to the prior key, as the header displays information in a sequential fashion.
    At the end of this function, we have some specific lines of code, using `isinstance()`,
    to handle the dictionary value assignments. This code checks the key type to ensure
    that values are assigned to keys in a manner that will not overwrite any data
    already associated with a given key:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_headers()` 函数最终返回一个包含提取的电子邮件头数据的字典。这些数据以键值对的形式显示，由冒号和空格分隔。由于头部中的内容可能存储在新的一行上，我们使用正则表达式来检查是否在行首有一个键，后面跟着一个值。如果我们找不到与模式匹配的键（任意数量的字母或破折号字符后跟着一个冒号），我们将把新值附加到先前的键上，因为头部以顺序方式显示信息。在这个函数的结尾，我们有一些特定的代码行，使用`isinstance()`来处理字典值的赋值。这段代码检查键的类型，以确保值被分配给键的方式不会覆盖与给定键关联的任何数据：'
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, the `write_data()` method is responsible for creating the metadata
    report. Since we may have a great number column names from the email header parsing,
    we iterate through the data and extract distinct column names if they are not
    already defined in the list. Using this method, we ensure that dynamic information
    from the PST is not excluded. In the `for` loop, we are also reassigning values
    from `data_list` into `formatted_data_list`, primarily to convert list values
    into a string to more easily write the data to the spreadsheet. The `csv` library
    does a nice job ensuring that commas within a cell are escaped and handled appropriately
    by our spreadsheet application:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`write_data()` 方法负责创建元数据报告。由于我们可能从电子邮件头解析中有大量的列名，我们遍历数据并提取不在列表中已定义的不同列名。使用这种方法，我们确保来自
    PST 的动态信息不会被排除。在`for`循环中，我们还将`data_list`中的值重新分配到`formatted_data_list`中，主要是将列表值转换为字符串，以更容易地将数据写入电子表格。`csv`库很好地确保了单元格内的逗号被转义并由我们的电子表格应用程序适当处理：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using the `csv.DictWriter` class, we open the file, write the header, and each
    of the rows to the output file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`csv.DictWriter`类，我们打开文件，写入头部和每一行到输出文件：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When this script runs, a CSV report is generated which should look similar
    to the one shown as shown in the following screenshot. While scrolling horizontally,
    we can see the columns specified at the top in the header row; especially with
    the email header columns, the majority of these columns only containing a handful
    of values. As you run this code against more email containers in your environment,
    make note of the columns that are most useful and commonly found in the PSTs you
    process to expedite analysis:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个脚本运行时，将生成一个 CSV 报告，其外观应该与以下截图中显示的类似。在水平滚动时，我们可以看到在顶部指定的列名；特别是在电子邮件头列中，大多数这些列只包含少量的值。当您在您的环境中对更多的电子邮件容器运行此代码时，请注意哪些列是最有用的，并且在您处理
    PST 时最常见，以加快分析的速度：
- en: '![](../images/00075.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00075.jpeg)'
- en: There’s more...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This process can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以进一步改进。我们提供了一个或多个以下建议：
- en: This library also handles **Offline Storage Table** (**OST**) files, which are
    generally associated with Outlook’s offline storage of mail content. Find and
    test this script on an OST file and, if necessary, modify it to support this other
    common mail format.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个库还处理**离线存储表**（**OST**）文件，通常与 Outlook 的离线邮件内容存储相关。找到并测试这个脚本在 OST 文件上，并在必要时修改以支持这种常见的邮件格式。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In this instance, we could also leverage the `Redemtion` library for accessing
    information within Outlook.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还可以利用`Redemtion`库来访问 Outlook 中的信息。
