- en: Learning the Fundamentals of Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Python的基础知识
- en: Python doesn't need in-game development, design, and analysis are considered
    the steps that are done before programming. Designing and analysis require that
    we brainstorm for ideas, model the procedures, and format the input. All of these
    procedures have something to do with data. Data can be something as simple as
    a list of numbers or as complex as weather history. This data has its own types
    and structures. Data needs to have its own storage location so that we can reference
    it. Python provides an abstraction of data in the form of objects that facilitate
    us to create a nested data structure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python不需要在游戏开发中，设计和分析被认为是编程之前完成的步骤。设计和分析要求我们集思广益，模拟程序，并格式化输入。所有这些程序都与数据有关。数据可以是简单的数字列表，也可以是复杂的天气历史。这些数据有自己的类型和结构。数据需要有自己的存储位置，以便我们可以引用它。Python提供了数据的抽象形式，以对象的形式，这样我们可以创建嵌套的数据结构。
- en: This chapter will give you a roller-coaster ride of the core programming paradigm
    within Python. We will begin by learning about the different data types that are
    available and ways to capture them in variables or storage units. We will learn
    about different mathematical operations (arithmetic and trigonometric) using the
    `math` module. By the end of this chapter, we will have made our first game, tic-tac-toe,
    by using the knowledge that we have learned in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您体验Python中的核心编程范式的过山车之旅。我们将首先学习可用的不同数据类型以及将它们捕捉到变量或存储单元中的方法。我们将学习使用`math`模块进行不同的数学运算（算术和三角）的方法。在本章结束时，我们将使用在本章学到的知识制作我们的第一个游戏-井字棋。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Handling values and data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理值和数据
- en: Variables and keywords
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和关键字
- en: Operators and operands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符和操作数
- en: Writing comments in the code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中编写注释
- en: Requesting User Inputs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求用户输入
- en: String Operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作
- en: Building your first game – tic-tac-toe
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的第一个游戏-井字棋
- en: Possible errors and warnings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的错误和警告
- en: Game testing and possible modifications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following requirements to get the full benefits of this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要满足以下要求才能充分获得本章的全部好处：
- en: You'll need the Python **IDLE**
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将需要Python **IDLE**
- en: The code assets for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter02](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter02)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码资产可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter02](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter02)
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2o6Kto2](http://bit.ly/2o6Kto2)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2o6Kto2](http://bit.ly/2o6Kto2)'
- en: Handling values and data
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理值和数据
- en: Software is evaluated as good or bad based on its capability to handle data.
    Every program has its own database design and implementation. A database is a
    schema where data is stored in such a way that it can be retrieved fast and securely
    so that it can be manipulated. It is assumed that social networks such as Facebook
    and Twitter collect 1.7 billion people's data each day. Such huge amount of data,
    which is collected on a daily basis, should be addressed properly because we don't
    have enough memory to store and process it. Hence, Python provides flexible built-in
    methods to map, filter, and reduce these datasets so that they can be stored and
    fetched faster for processing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的评价取决于其处理数据的能力。每个程序都有自己的数据库设计和实现。数据库是一个模式，数据以这样的方式存储，以便可以快速和安全地检索和操作。据推测，像Facebook和Twitter这样的社交网络每天收集17亿人的数据。这么庞大的数据量，每天都在收集，应该得到妥善处理，因为我们没有足够的内存来存储和处理它。因此，Python提供了灵活的内置方法，以便对这些数据集进行映射、过滤和减少，以便可以更快地存储和获取以进行处理。
- en: Python is lightning-fast when it comes to storing data as a schema. Its integration
    with big data platforms such as Hadoop, which inherits its compatibility, is the
    main reason we use Python in big datasets. Powerful packages such as NumPy, pandas,
    and scikit-learn provide data support for today's data and analytical needs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python在存储数据方面非常快速。它与Hadoop等大数据平台的集成，继承了其兼容性，是我们在大型数据集中使用Python的主要原因。强大的包，如NumPy、pandas和scikit-learn，为当今的数据和分析需求提供数据支持。
- en: A value is the representation of data for some attributes that are computed
    by programs. Here, attributes are the properties of any object. For example, when
    we talk about a person, we reference them by name, age, and height. These attributes
    have an *r*-value (the content of the attribute) and an *l*-value (memory location)
    attached to them. The *content of the attribute* refers to the value that is stored
    as the content of the variable, while the *memory location* refers to the physical
    place where the value is stored. For example, `name = "Python"` has a `name` variable
    as an attribute; its *r*-value is `Python` and its *l*-value is a unique ID that
    is assigned by the Python parser automatically as a memory location for the name
    attribute.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值是程序计算的一些属性的表示。在这里，属性是任何对象的属性。例如，当我们谈论一个人时，我们通过姓名、年龄和身高来引用他们。这些属性有一个*r*-value（属性的内容）和一个*l*-value（内存位置）与它们相关联。*属性的内容*指的是存储为变量内容的值，而*内存位置*指的是存储值的物理位置。例如，`name
    = "Python"`有一个`name`变量作为属性；它的*r*-value是`Python`，它的*l*-value是Python解析器自动分配的唯一ID，作为名称属性的内存位置。
- en: 'In Python, values are stored in the form of objects. Objects have four particulars:
    ID, namespace, type, and value. Let''s look at a simple example to uncover the
    particulars of an object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，值以对象的形式存储。对象有四个特点：ID、命名空间、类型和值。让我们看一个简单的例子，揭示对象的这些特点。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the `player_age` variable is created, its instance is created, which we
    call an object. Whenever an object is created, it receives a unique memory storage
    location, that is, a unique ID number, and assigns a type dynamically, that is,
    an integer, because we are assigning 90 to it. After that, the player variable
    is added to the namespace so that we can retrieve its value, that is, 90\. The
    following diagram attempts to simplify this explanation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`player_age`变量时，它的实例被创建，我们称之为对象。每当创建一个对象时，它都会接收一个唯一的内存存储位置，即一个唯一的ID号，并动态地分配一个类型，即一个整数，因为我们将90分配给它。之后，将player变量添加到命名空间中，以便我们可以检索其值，即90。以下图尝试简化这个解释：
- en: '![](Images/f8339e73-d20e-4f62-af02-a35b4ae74219.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f8339e73-d20e-4f62-af02-a35b4ae74219.png)'
- en: Whenever any assignment statement is executed, the parser creates an object,
    which gets a unique memory ID from where we can reference the value of the variable.
    Since Python is a dynamically typed language, it assigns a type of variable dynamically
    by analyzing the value that's been assigned to the variable. Eventually, it adds
    that variable to a global namespace so that whenever you want to fetch that variable,
    you can use the variable name. Here, `memory_ID` is the location that points to
    the value of an object. Some programming languages, such as C, call this a pointer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行任何赋值语句时，解析器都会创建一个对象，该对象从中获取唯一的内存ID，我们可以引用变量的值。由于Python是一种动态类型的语言，它通过分析分配给变量的值动态地分配变量的类型。最终，它将该变量添加到全局命名空间，以便在您想要获取该变量时，可以使用变量名。在这里，`memory_ID`是指向对象值的位置。一些编程语言，如C，称之为指针。
- en: 'Each of these values has a type associated with it. `1` is an integer, `a` is
    a character, and `Hello World` is a string. `Hello World` is a collection of characters
    and it is called a string since it defines a string of characters. In the previous chapter,
    we saw an example where we asked a user for input. Whenever a user types something
    as input, it is considered a string. These values define objects in programming.
    Let''s use a parrot as an example. It will have a name as a string, its age as
    an integer, and its sex as male or female, denoted by *M* or *F*, which are characters.
    In Python, a character is also represented as a string. To verify that, we have
    the `type` method. The `type` method is represented as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些值都有与之关联的类型。`1`是一个整数，`a`是一个字符，`Hello World`是一个字符串。`Hello World`是一系列字符，因为它定义了一系列字符，所以它被称为字符串。在前一章中，我们看到了一个示例，我们要求用户输入。每当用户输入一些内容时，它被视为字符串。这些值在编程中定义对象。让我们以鹦鹉为例。它将有一个作为字符串的名称，一个作为整数的年龄，以及一个作为男性或女性的性别，用*M*或*F*表示，这些都是字符。在Python中，字符也被表示为字符串。为了验证这一点，我们有`type`方法。`type`方法表示如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding command will be `<class ''str''>`, which implies
    that the character is also part of a string. To check the type of any value, we
    can use the same `type` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出将是`<class 'str'>`，这意味着字符也是字符串的一部分。要检查任何值的类型，我们可以使用相同的`type`方法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding commands will show class as `int` and `str`, respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将分别显示类别为`int`和`str`。
- en: 'Now, let''s talk about numbers. Numbers are of two types: whole numbers and
    decimal numbers. As we saw, a whole number is an integer, but a decimal number
    is a float. We call decimal numbers floating numbers in Python as they are represented
    in floating-point format, like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈数字。数字有两种类型：整数和小数。正如我们所看到的，整数是整数，但小数是浮点数。我们在Python中称小数为浮点数，因为它们以浮点格式表示，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output of the preceding command is `<class 'float'>`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出是`<class 'float'>`。
- en: 'You can print these values in the Terminal using the `print` method. The `print`
    method takes values within parenthesis and gives the result in the interpreter,
    like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`print`方法在终端中打印这些值。`print`方法在括号内接受值，并在解释器中给出结果，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you put `1` within the `print` statement, it will print `1` as a number.
    However, when you put `1` within double quotes, it will print `1` as a string,
    like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`print`语句中放入`1`，它将打印`1`作为数字。但是，当您在双引号中放入`1`时，它将打印`1`作为字符串，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any number, text, or special symbols, such as @, $, %,  or * you put inside
    a single quote or double quote will eventually be a string. The following is an
    example of a string: `1`, `Hello`, `False`,  `#$(#`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字、文本或特殊符号，如@、$、%或*，您放在单引号或双引号中最终都将成为字符串。以下是字符串的一个示例：`1`、`Hello`、`False`、`#$(#`。
- en: 'When you put a comma between two values in a `print` statement, it puts a space
    between them, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在`print`语句中的两个值之间放置逗号时，它会在它们之间放置一个空格，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code will give you the output of `abc abc`, but they are no longer
    considered strings. This is the first semantic error we''ve seen in Python. We
    passed `abc` as a string, but the result is a non-type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将给出`abc abc`的输出，但它们不再被视为字符串。这是我们在Python中看到的第一个语义错误。我们将`abc`作为字符串传递，但结果是一个非类型：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a perfect example of a semantic error. We got the output without any
    errors, but we didn't get the result we wanted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个语义错误的完美例子。我们得到了输出而没有任何错误，但是我们没有得到我们想要的结果。
- en: 'You can also check integers. It''s not possible to print integers with a comma
    between them. The Python interpreter converts commas into spaces between each
    value that''s passed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查整数。不可能用逗号在它们之间打印整数。Python解释器将逗号转换为传递的每个值之间的空格：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will give us a result of `0 0 0`. Each comma was converted into
    spaces and printed. If you check the type of the value that is returned from the
    function, it will also be `NoneType`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将给我们一个`0 0 0`的结果。每个逗号都被转换为空格并打印出来。如果您检查从函数返回的值的类型，它也将是`NoneType`。
- en: Now that we know about value and types, let's get ourselves familiar with variables
    and keywords.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了值和类型，让我们熟悉一下变量和关键字。
- en: Variables and keywords
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和关键字
- en: Programming is all about accepting and manipulating values that we've learned
    about. We make use of variables while accepting and manipulating those values
    so that we can reference them for future use. Variables are like boxes, where
    you put in different things and fetch them whenever they're required. A variable
    is created with a name and a value assigned to it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编程就是接受和操作我们学到的值。我们在接受和操作这些值时使用变量，以便将来可以引用它们。变量就像盒子，您可以在其中放入不同的东西，并在需要时取出。变量是通过名称创建的，并为其分配一个值。
- en: 'We use the equal to sign (`=`) to make an assignment statement. Variables are
    created with assignment statements; for example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用等号（`=`）来进行赋值语句。变量是通过赋值语句创建的；例如：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we created three variables with assignment statements. In the first command,
    we made the `myAge` variable and assigned an integer to it. You do not have to
    specify types of variables explicitly in Python since Python does it internally.
    This is what makes Python a dynamically typed language. In the second command,
    we made the `info` variable and assigned a string to it. Finally, we made the `isHonest`
    variable and assigned a Boolean to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用赋值语句创建了三个变量。在第一条命令中，我们创建了`myAge`变量并为其分配了一个整数。在Python中，您不必显式指定变量的类型，因为Python会在内部执行此操作。这就是使Python成为动态类型语言的原因。在第二条命令中，我们创建了`info`变量并为其分配了一个字符串。最后，我们创建了`isHonest`变量并为其分配了一个布尔值。
- en: Boolean types are logic types. They are either `True` or `False`. Creating a
    Boolean variable is the same as creating other variables, for example, `is_hungry
    = True`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型是逻辑类型。它们要么是`True`，要么是`False`。创建布尔变量与创建其他变量相同，例如，`is_hungry = True`。
- en: 'Variables are basic pieces of data storage. We can assign one value to a variable at
    a time. Whenever you assign another value to the same variable name, it will overwrite
    the original one. For example, here, we made the `info` variable a string, but
    if I replace it with another value, say, `integer`, this is valid:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是基本的数据存储单元。我们一次可以将一个值分配给一个变量。每当您将另一个值分配给相同的变量名称时，它将覆盖原始值。例如，在这里，我们将`info`变量设置为字符串，但是如果我用另一个值替换它，比如`integer`，这是有效的：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you make variables in Python, it will create separate memory references
    for each variable. So, any time you replace the same variable in another value,
    the value at that particular position will be retrieved and overwritten with the
    new one. Variable names are pointers to the value in the reserved memory location.
    You can''t store multiple values in a variable. You have to use advanced data
    structures to do this. We will cover this in the upcoming chapters (CHAPTER 4:
    Data Structures and Functions: Refine Your Game with Taste of AI).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Python中创建变量，它将为每个变量创建单独的内存引用。因此，每当您用另一个值替换相同的变量时，该特定位置的值将被检索并用新值覆盖。变量名称是保留内存位置中值的指针。您不能在一个变量中存储多个值。您必须使用高级数据结构来实现这一点。我们将在接下来的章节中介绍这一点（第4章：数据结构和函数：用AI的味道完善您的游戏）。
- en: 'Assigning multiple variables to different variables can be done in a single
    line of code. We can assign them with a single assignment statement. The variable''s
    name should be given at the left-hand side and they should have commas between
    them. You can create as many variables with distinct data types in a single line
    as you want with the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个变量分配给不同的变量可以在一行代码中完成。我们可以用单个赋值语句来分配它们。变量的名称应该在左侧给出，它们之间应该用逗号隔开。您可以使用以下命令在一行中创建尽可能多的具有不同数据类型的变量：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see the value of your variable by directly writing the variable''s
    name in the Terminal:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过直接在终端中写入变量的名称来查看变量的值：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you only write the name of a variable in the script, the value won''t be
    printed. Instead, it will terminate. If you want to print something on the screen,
    you have to use the `print()` method. To print the value of any variable, type `print(variable_name)`
    in your shell or script, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只在脚本中写变量的名称，那么不会打印出值。相反，它会终止。如果要在屏幕上打印出东西，您必须使用`print()`方法。要打印任何变量的值，请在shell或脚本中键入`print(variable_name)`，如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want to see the type of the value that''s stored in the variable, you
    can call the `type()` method. To do this, pass the variable''s name inside parentheses:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查看存储在变量中的值的类型，可以调用`type()`方法。为此，请将变量的名称放在括号内：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding command will give us the output of `<class 'int'>`, which implies
    that integer values can be stored in variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将给出`<class 'int'>`的输出，这意味着可以在变量中存储整数值。
- en: 'We can also assign the same value to multiple variables in Python. In the preceding
    command, instead of assigning multiple values, we assigned a single value to it,
    like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在Python中将相同的值分配给多个变量。在上述命令中，我们不是分配多个值，而是将单个值分配给它，如下所示：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding command, we assigned an integer value of 10 to two different
    variables, `even` and `num`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们将整数值10分配给了两个不同的变量`even`和`num`。
- en: Python doesn't need variable instantiation and declaration. Hence, there is
    no need for reserved memory space in Python. Python does this internally when
    we create variables with assignment statements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python不需要变量实例化和声明。因此，在Python中不需要保留内存空间。当我们使用赋值语句创建变量时，Python会在内部执行此操作。
- en: 'Python has reserved 33 words as keywords for specific functionality. We cannot
    use them to name variables. Python checks the name of the variable with these
    keywords internally with its in-built script. Whenever it detects one of those
    words, it will throw a syntax error, as in the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经将33个单词保留为关键字，用于特定功能。我们不能使用它们来命名变量。Python会使用内置脚本检查变量的名称与这些关键字，每当它检测到其中一个单词时，它将抛出语法错误，如下例所示：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding command isn't executed and cannot be used as a variable name because
    it is a keyword. Python uses it to do some logical operations. However, if you
    create a variable called `And` and assign a value to it, Python will create the `And` variable
    for you. For Python, `And` and `and` are not the same. It is a case-sensitive
    language.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令不会被执行，也不能用作变量名，因为它是一个关键字。Python用它来执行一些逻辑操作。但是，如果您创建一个名为`And`的变量并为其赋值，Python将为您创建`And`变量。对于Python来说，`And`和`and`是不同的。它是大小写敏感的语言。
- en: To avoid any issues with your variable names, we can follow a few simple rules.
    We'll go over these rules in the following section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免变量名的任何问题，我们可以遵循一些简单的规则。我们将在下一节中介绍这些规则。
- en: Rules for naming variables
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量命名规则
- en: We normally choose meaningful variable names because, in the long run, there
    may be cases where we completely forget about code sequence and flow, and variables
    that don't have a proper name can create confusion. Although you can create variables
    with any name by following some rules, it is highly suggested to create variable
    names that make sense. Let's say you are making a game where you want to create
    a variable for the player's health; naming that variable `a` is not good practice.
    Instead, you should name it `player_Health` so that it's clear to you and those
    who may look at your code what the code in this variable does.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们选择有意义的变量名，因为从长远来看，可能会出现我们完全忘记代码顺序和流程的情况，而没有适当名称的变量会造成混乱。尽管您可以按照一些规则创建任何名称的变量，但强烈建议创建有意义的变量名。比如，您正在制作一个游戏，想要为玩家的生命值创建一个变量；将该变量命名为`a`不是一个好的做法。相反，您应该将其命名为`player_Health`，这样对您和可能查看您代码的人来说，这个变量中的代码是清晰的。
- en: Usually, from a programming perspective, there are two ways of giving a variable
    a name effectively. Two of them are famously known as `CamelCase` and `PascalCase`.
    Observing the naming convention of the previously defined variable, `playerHealth`,
    the first character of the variable should be lowercase and all of the others
    should be in uppercase. Similarly, in the case of `PascalCase`, every first character
    of the variable should be in uppercase. Hence, using `PascalCase`, the previously
    defined variable can be written as `PlayerHealth`. You can use either of them
    to name your variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常从编程的角度来看，有两种有效地给变量命名的方式。其中两种被广泛称为`驼峰命名法`和`帕斯卡命名法`。观察先前定义的变量的命名约定，`playerHealth`，变量的第一个字符应该是小写的，其他所有字符都应该是大写的。同样，在`帕斯卡命名法`中，变量的每个第一个字符都应该是大写的。因此，使用`帕斯卡命名法`，先前定义的变量可以写成`PlayerHealth`。您可以使用其中任何一种来命名您的变量。
- en: Your variable name can be any length. It can contain a combination of uppercase
    alphabetical letters (A-Z), lowercase letters (a-z), digits (0-9), and an underscore
    (_). An underscore is used in-between two words to distinguish two entities in
    a variable. For example, the `player_Health` variable is made up of two words.
    We use the underscore in-between them. Alternatively, you can also use `camelCase`,
    where you start your first word in lowercase and the first letter of the second
    word in uppercase, for example, `playerHealth`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您的变量名可以是任意长度。它可以包含大写字母（A-Z）、小写字母（a-z）、数字（0-9）和下划线（_）的组合。下划线用于在两个单词之间区分变量中的两个实体。例如，`player_Health`变量由两个单词组成。我们在它们之间使用下划线。或者，您也可以使用`驼峰命名法`，其中您将第一个单词以小写字母开头，第二个单词的第一个字母大写，例如，`playerHealth`。
- en: 'We can also use an underscore at the start of the variable''s name. We use
    them in our code if it''s being used as a library for others. We can use them
    in recursive statements, too, as in the example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在变量名的开头使用下划线。如果它被用作其他库的库，我们会在我们的代码中使用它。我们也可以在递归语句中使用它，就像这个例子：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are some rules we need to follow while naming a variable, otherwise Python
    will declare it illegal and throw a syntax error. The following screenshot shows
    some illegal assignment statements:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名变量时，我们需要遵循一些规则，否则Python会将其声明为非法并抛出语法错误。以下截图显示了一些非法的赋值语句：
- en: '![](Images/32303842-b5f5-4db7-8f21-fb372bff8957.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/32303842-b5f5-4db7-8f21-fb372bff8957.png)'
- en: 'To remove the preceding errors, we have to follow a few rules. Some are mandatory
    while some are just good practices:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除前述错误，我们必须遵循一些规则。有些是强制性的，而有些只是良好的实践：
- en: We give the variable a name that makes sense. Naming the age variable `age` is
    more meaningful than naming it `a`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们给变量取一个有意义的名字。将年龄变量命名为`age`比将其命名为`a`更有意义。
- en: 'We cannot use special symbols (@, #, $, and %) while naming variables. For
    example, n@me is not a valid variable name.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名变量时，我们不能使用特殊符号（@、#、$和%）。例如，n@me不是一个有效的变量名。
- en: A variable name should not start with digits. 45 age is not a proper variable
    name and Python will throw an error.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不应以数字开头。45 age不是一个合适的变量名，Python会报错。
- en: Declare constants with an uppercase name, for example, `>>> PI = 3.14`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大写名称声明常量，例如，`>>> PI = 3.14`。
- en: It's good practice to use `camelCase` to create variables name, for example,
    `>>> myCountry = "USA"`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`驼峰命名法`创建变量名是一个好的做法，例如，`>>> myCountry = "USA"`。
- en: We have now seen what variables and keywords are and some rules to follow when
    naming them. Now, let's move on and see what operators and operands are.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了变量和关键字是什么，以及在命名它们时要遵循的一些规则。现在，让我们继续看看运算符和操作数是什么。
- en: Operators and operands
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和操作数
- en: Math and programming are two distinct fields that are closely related. The former
    deals with theory and provides formulated principles to solve any problem domain,
    while the latter deals with using those principles to solve a business domain.
    Programming is all about accepting data using models and manipulating it with
    the appropriate mathematical operations. Operators are used to perform those operations.
    We have arithmetic and logical operators in Python.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数学和编程是两个密切相关但又不同的领域。前者处理理论并提供制定的原则来解决任何问题领域，而后者处理使用这些原则来解决业务领域。编程就是接受数据并使用模型以及适当的数学运算对其进行操作。运算符用于执行这些操作。Python中有算术和逻辑运算符。
- en: 'Operators are symbols that perform computations such as addition, multiplication,
    division, and so on. Symbols such as `+`, `-`, and `/` are used to perform those
    operations. The values that operators are applied to are called operands. Some
    examples of operators are shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是执行加法、乘法、除法等计算的符号。诸如`+`、`-`和`/`之类的符号用于执行这些操作。运算符应用的值称为操作数。以下是一些运算符的示例：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding examples, the result of the first operation is 7, the result
    of the second operation is 0, and the result of the last operation is 8\. You
    can add or subtract as many numbers as you like within the shell. Here, all of
    the numbers are operands, and symbols such as `+`, `-`, and `*` are operators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一次操作的结果是7，第二次操作的结果是0，最后一次操作的结果是8。您可以在shell中添加或减去任意数量的数字。在这里，所有数字都是操作数，而`+`、`-`和`*`等符号是运算符。
- en: 'Another important operator in Python is division (`/`). In Python 3.x, the
    division operation results in floating-point numbers, as in the example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Python中重要的运算符是除法（`/`）。在Python 3.x中，除法操作的结果是浮点数，例如：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding operation gives you a result of 2.5\. This is the same result
    that we get using a calculator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作给出了一个结果为2.5。这与使用计算器得到的结果相同。
- en: 'In Python 2.x, the interpreter would truncate the decimal part and give us
    a result of 2\. If you want to get the same result in Python 3.x, you should use
    floor division (`//`); for example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.x中，解释器会截断小数部分，并给出一个结果为2。如果您想在Python 3.x中获得相同的结果，应该使用地板除法（`//`）；例如：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding operation will give us a result of 2 instead of 2.5.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作将给我们一个结果为2，而不是2.5。
- en: 'Let''s go over what we''ve learned so far, that is, values, variables, and
    operators. Let''s combine all of these into one statement. This is known as an
    expression:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们迄今为止学到的内容，即值、变量和运算符。让我们将所有这些组合成一个语句。这被称为表达式：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can combine all of these to make any type of expression. The assignment
    operation is the simplest expression to use. We saw the assignment operation while
    creating variables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将所有这些组合在一起，以制作任何类型的表达式。赋值操作是使用最简单的表达式。我们在创建变量时看到了赋值操作。
- en: When there are multiple operators being used in an expression, the order of
    these operations becomes important to solve the expression. We'll go over the
    order of operations in the following section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式中使用多个运算符时，这些运算的顺序变得重要。我们将在下一节中介绍操作的顺序。
- en: Order of operations
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作顺序
- en: 'Let''s recall the basic math that we mostly learned in our school days. You
    may have heard of the BODMAS rule or the PEDMAS rule. Whenever more than one operator
    is used in our expression, an operation is performed with this rule of precedence. Operations
    in brackets/parenthesis, exponentiation, division, multiplication, addition, and
    subtraction are performed in this order:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在学校时学到的基本数学。您可能听说过BODMAS规则或PEDMAS规则。每当我们的表达式中使用多个运算符时，都会按照这个优先级规则执行操作。括号内的操作、指数、除法、乘法、加法和减法按照这个顺序执行：
- en: '**Parentheses/brackets**: This symbol has the highest precedence, which means
    that operations within parentheses are completed first. With the use of parentheses
    in your expression, you are telling the interpreter to explicitly execute a certain
    expression forcefully. For example, in `(10 - 5) + 5 * 6`, the operation within
    the parentheses is done first, that is, *10 - 5*, and then multiplication is done.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号/方括号：这个符号具有最高的优先级，这意味着括号内的操作首先完成。通过在表达式中使用括号，您告诉解释器强制执行某个表达式。例如，在`(10-5)+5*6`中，括号内的操作首先完成，即*10-5*，然后进行乘法。
- en: '**Exponential/of**: Th exponential operation is done after operations within
    parentheses are completed. The output of `9**0+1` is not 9; instead, it is 1\.
    Exponential is done first, and then addition is done.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数/幂：在括号内的操作完成后，指数操作会首先执行。`9**0+1`的输出不是9，而是1。首先执行指数操作，然后执行加法。
- en: '**Division**: Division operations are done after exponential if operations,
    including division if it''s not inside parentheses. For example, `10 / 2 + 3 +
    9 / 3` is 11 but not 5\. If the expression was `10 / (2 +3) + 9 /3`, the output
    would be 5.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法：除法操作在指数操作之后进行，包括除法，如果它不在括号内。例如，`10 / 2 + 3 + 9 / 3`是11而不是5。如果表达式是`10 / (2
    +3) + 9 /3`，输出将是5。
- en: '**Multiplication**: It has also the same precedence as that of division. However,
    if the expression has both division and multiplication, operations are done sequentially
    from left to right. Scanning from left to right, if we get multiplication before
    division, it is done first. For example, the output of `3*4 / 3` is `4` but not
    3.999.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法：它的优先级与除法相同。但是，如果表达式中既有除法又有乘法，操作是从左到右顺序执行的。从左到右扫描，如果我们在除法之前得到乘法，就先执行乘法。例如，`3*4
    / 3`的输出是`4`而不是3.999。
- en: '**Addition and subtraction**: These two operations also have the same level
    of precedence. Thus, we perform these operations according to what comes first
    while scanning from left to right. For example, in terms of `5 - 5 + 6`, we subtract
    first as it comes first and then add, which gives us 6.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法和减法：这两个操作也具有相同的优先级。因此，我们根据从左到右扫描的顺序执行这些操作。例如，在`5-5+6`中，我们首先执行减法，然后执行加法，得到6。
- en: 'If you are still confused about the BODMAS/PEDMAS rule, you can simply use
    parentheses to make sure you get the intended result. In the next section, we
    will learn about two important operators: `//` and `%`. The former is known as
    floor division, while the latter is known as the modulus operator.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然对BODMAS/PEDMAS规则感到困惑，您可以简单地使用括号来确保获得预期的结果。在下一节中，我们将学习两个重要的运算符：`//`和`%`。前者称为地板除法，而后者称为模运算符。
- en: Modulus operator
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模运算符
- en: 'Earlier, we saw how to use floor division (`//`) and how it provides us with
    only the quotient of the division operation. But if you want the remainder of
    your division, use the modulus operator. The modulus operator yields the remainder
    of when the first operand was divided by the second operand. The symbol for the
    modulus operator is the percentage sign (`%`). The following screenshot shows
    two operations: the first one is a floor division, which will result in a quotient,
    while the next one is a modulus operation, which will result in the remainder
    of the division:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何使用地板除法(`//`)以及它如何为我们提供除法运算的商。但是，如果您想要除法的余数，可以使用取模运算符。取模运算符产生第一个操作数除以第二个操作数时的余数。取模运算符的符号是百分号(`%`)。以下屏幕截图显示了两个操作：第一个是地板除法，将得到商，而下一个是取模运算，将得到除法的余数：
- en: '![](Images/150412e6-94be-4faa-9bd0-32e2e6986fc7.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/150412e6-94be-4faa-9bd0-32e2e6986fc7.png)'
- en: 'The modulus operator is very useful when we want to search number patterns
    and make programs that can divide numbers based on that pattern. For example,
    we can check the remainder of division between any number and 2 to find whether
    the number is even or odd:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要搜索数字模式并创建可以根据该模式划分数字的程序时，取模运算符非常有用。例如，我们可以检查任何数字与2之间的除法余数，以确定该数字是偶数还是奇数：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the preceding operation gives the remainder as 1, 5 can be considered
    an odd number.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的操作给出了余数为1，5可以被认为是一个奇数。
- en: All of the preceding operations are pretty basic and don't need any hard work
    to calculate. However, we know that computers are known for processing complex
    tasks. Hence, in the next section, we will learn about the `math` module, which
    is capable of performing intricate mathematical operations such as calculating
    trigonometric and complex equations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有操作都非常基本，不需要任何艰苦的计算。但是，我们知道计算机以处理复杂任务而闻名。因此，在下一节中，我们将学习`math`模块，它能够执行复杂的数学运算，例如计算三角函数和复杂方程。
- en: Using the math module
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数学模块
- en: Math is not only limited to addition and multiplication. So far, we have learned
    about various arithmetic operations. We haven't at logical operators and comparisons
    yet as those will be covered in the next chapter. To incorporate many domains
    of mathematics, Python has given us one powerful library, called the `math` module.
    We call the file that contains the code a module. These libraries are also called
    in-built libraries because they come prepackaged whenever we install Python.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数学不仅仅局限于加法和乘法。到目前为止，我们已经学习了各种算术运算。我们还没有涉及逻辑运算符和比较，因为这些将在下一章中介绍。为了涵盖许多数学领域，Python给了我们一个强大的库，称为`math`模块。我们称包含代码的文件为模块。这些库也被称为内置库，因为它们在安装Python时预先打包。
- en: 'They are made by Python and we can call them whenever we want in our code without
    having to install it manually. If you want to use the code of any in-built library,
    you have to call it first. Calling them means importing them. To import and use
    that in-built library, we use the `import` keyword. As you may recall from the
    previous chapter, it''s a reserved word that has a specific purpose in Python.
    Hence, the `import` keyword imports any library into your code. If you want to
    import the `math` module, for example, just write the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是由Python制作的，我们可以随时在我们的代码中调用它们，而无需手动安装。如果要使用任何内置库的代码，必须首先调用它。调用它们意味着导入它们。要导入并使用内置库，我们使用`import`关键字。正如您可能还记得的，从上一章中，它是Python中具有特定目的的保留字。因此，`import`关键字将任何库导入您的代码中。例如，如果要导入`math`模块，只需编写以下内容：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will instantly see the next line with an empty shell, like this: `>>>`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您将立即看到下一行有一个空的shell，就像这样：`>>>`。
- en: 'That just specifies that you are importing it. Import statements are not the
    same as print or input methods, which give us an instant response. We should call
    something from that module in order to see any response or result. The `math`
    module provides us with numerous operations. These can be accessed by following
    these steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是指定您正在导入它。导入语句与打印或输入方法不同，后者会立即给我们一个响应。我们应该从该模块中调用某些内容，以便看到任何响应或结果。`math`模块为我们提供了许多操作。可以通过以下步骤访问这些操作：
- en: 'Open your IDLE and press *F1* to open the documentation. You will see the following
    window:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的IDLE并按*F1*打开文档。您将看到以下窗口：
- en: '![](Images/379348e2-3ebf-4de9-94df-af2e49cd1add.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/379348e2-3ebf-4de9-94df-af2e49cd1add.png)'
- en: 'Now, click on modules. You will see a new window containing a list of modules:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击模块。您将看到一个包含模块列表的新窗口：
- en: '![](Images/fec0ac60-a9f1-4d65-b02d-f16e3f0f455b.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fec0ac60-a9f1-4d65-b02d-f16e3f0f455b.png)'
- en: 'Search for the math module from that tab or simply press *M* on your keyboard
    if you want to navigate through the list of modules that starts with the letter
    `m`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该选项卡搜索数学模块，或者如果您想浏览以字母`m`开头的模块列表，只需在键盘上按*M*：
- en: '![](Images/801ce731-abb7-479d-8898-ef017a539a56.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/801ce731-abb7-479d-8898-ef017a539a56.png)'
- en: There are so many methods to use! Don't get overwhelmed with the term methods;
    we have dedicated a section to object-oriented programming where we will learn
    how to create our own methods. Right now, just think of a method as operations
    we use to create expressions. The methods that are provided by the `math` module
    are also going to perform simple arithmetic operations and many other complex
    ones. If you want to get a square root, we don't have specific operators to do
    that, nor can we perform complex mathematical operations; instead, you have to
    use a math module. We'll look at square roots in the following example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以使用！不要被术语方法所压倒；我们已经专门介绍了面向对象编程的部分，我们将学习如何创建自己的方法。现在，只需将方法视为我们用来创建表达式的操作。数学模块提供的方法也将执行简单的算术运算和许多其他复杂的运算。如果您想要获得平方根，我们没有特定的运算符来执行，也不能执行复杂的数学运算；相反，您必须使用数学模块。我们将在下面的示例中查看平方根。
- en: 'To get the square root of a number, we can use the `sqrt` method. Check out
    the documentation for the `sqrt` method to find out more about it and learn how
    to call it. It''s super easy! First of all, we write `math`, then a period (`.`),
    which signifies that we want to use something from the math module and use the `sqrt`
    method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个数字的平方根，我们可以使用`sqrt`方法。查看`sqrt`方法的文档，了解更多信息并学习如何调用它。这非常容易！首先，我们写`math`，然后是一个句点（`.`），表示我们想要从math模块中使用某些东西并使用`sqrt`方法：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The square root of `49` is 7\. Our interpreter prints 7.0 as `sqrt` performs
    a floating-point operation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`49`的平方根是7。我们的解释器打印出7.0，因为`sqrt`执行了一个浮点运算。'
- en: 'If you didn''t import the `math` module and instead called `sqrt` directly,
    you will receive the following error:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有导入`math`模块，而是直接调用了`sqrt`，您将收到以下错误：
- en: '![](Images/c2a4dca0-33d7-49c1-89de-445070cc088d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c2a4dca0-33d7-49c1-89de-445070cc088d.png)'
- en: As you may recall when we discussed the `print()` function, we didn't call it
    using any module because it was an in-built function. However, this `sqrt()` function
    is not in-built. It is from an in-built library of Python. Although we don't have
    to install it like any other third-party modules, we have to import it before
    using any of the features provided by it. All of the modules that are provided
    by Python are in lowercase.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得我们讨论`print()`函数时，我们没有使用任何模块来调用它，因为它是一个内置函数。但是，这个`sqrt()`函数不是内置的。它来自Python的内置库。虽然我们不必像其他第三方模块一样安装它，但在使用它提供的任何功能之前，我们必须导入它。Python提供的所有模块都是小写的。
- en: 'We can call a range of functions and constants from math modules. This allows
    us to do numerous operations that support complex mathematical computations. If
    you want to print the value of PI, you can do so with the `math` module, like
    so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从math模块调用一系列函数和常量。这使我们能够进行支持复杂数学计算的多种操作。如果要打印PI的值，可以使用`math`模块，如下所示：
- en: Firstly, we import it with `>>> import math`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们用`>>> import math`导入它。
- en: Then, we use `module_name` and provide a period (`.`) to specify we want to
    use that module and the type operations we want to perform, for example,  `>>>
    math.pi`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`module_name`并提供一个句点（`.`）来指定我们要使用该模块和我们要执行的类型操作，例如`>>> math.pi`。
- en: You can perform algebraic, logarithmic, trigonometric, hyperbolic, and a wide
    range of other operations with math functions. However, this module cannot perform
    math operations for complex numbers, for example, `z = a + ib`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用数学函数执行代数、对数、三角、双曲和各种其他操作。但是，这个模块不能对复数执行数学运算，例如`z = a + ib`。
- en: For those types of complex numbers, we have to import the `cmath` module. Importing
    and working with this module is also similar to that of the `math` module.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些复数类型，我们必须导入`cmath`模块。导入和使用这个模块也类似于`math`模块。
- en: 'If you want to use the functions provided by the `math` module with calls to `print()`
    or `input()` without putting a dot, you can use the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用`math`模块提供的函数与`print()`或`input()`的调用，而不需要加句点，可以使用以下命令：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding command, `*` implies that you want to import everything. It
    is canonically saying *From the math module, import everything*. Now, if you want
    to call any functions from the math module, you can call it directly, similar
    to what we do with the input and print functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`*`表示您想要导入所有内容。它经典地表示*从math模块中导入所有内容*。现在，如果您想从math模块调用任何函数，可以直接调用，类似于我们对输入和打印函数所做的操作：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding function will be executed perfectly and give us a result of 24.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将被完美执行，并给我们一个结果为24。
- en: You may be wondering why the concept of modules wasn't explained at the beginning
    of this book. It's simple! We just learned about operators, operations, and expressions,
    which means it's easy to relate to the math module. Every function we call from
    the `math` module contains operators, operands, and expressions, but its implementation
    is hidden from our eyes. For example, we simply use the `sqrt` function to perform
    a square root operation, but we don't know how the square root is done with expressions
    and logic. We will learn about this in the upcoming chapters when we cover flow
    controls and functions. Hence, modules provide us with a way to perform high-level
    operations without having to know how they work. However, if you want to make
    your own libraries and modules, then the upcoming chapters will help you.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您会想为什么模块的概念没有在本书的开头解释。很简单！我们刚刚学习了运算符、操作和表达式，这意味着很容易与数学模块相关联。我们从`math`模块调用的每个函数都包含运算符、操作数和表达式，但它的实现对我们来说是隐藏的。例如，我们只需使用`sqrt`函数执行平方根操作，但我们不知道如何用表达式和逻辑来做平方根。在接下来的章节中，当我们涵盖流程控制和函数时，我们将学习这个。因此，模块为我们提供了一种执行高级操作的方式，而无需知道它们是如何工作的。但是，如果您想制作自己的库和模块，那么接下来的章节将帮助您。
- en: 'If you want to learn more about modules and functions, you can simply use the
    `help` command. The Python `help` command will give you a complete list of documentation
    for built-in functions, modules, and keywords, as in the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关模块和函数的更多信息，可以简单地使用`help`命令。Python `help`命令将为您提供内置函数、模块和关键字的完整文档列表，如以下示例所示：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That''s enough talk about values and types. Now, let''s look at how we can
    make our code more readable and reusable, that is, others should be able to read
    our code easily. We talked about the rules and conventions that should be followed
    while naming the variable, which also leads to readability. There are two ways
    of making code readable:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于值和类型的讨论就到此为止。现在，让我们看看如何使我们的代码更易读和可重用，也就是说，其他人应该能够轻松阅读我们的代码。我们谈到了在命名变量时应遵循的规则和约定，这也导致了可读性。有两种使代码易读的方法：
- en: Write notes within the program.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序中写注释。
- en: The Pythonic way is to make a function.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pythonic的方法是创建一个函数。
- en: We can add notes to the program via commenting, which will be covered in the
    next section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过注释向程序添加注释，这将在下一节中介绍。
- en: Writing comments in code
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中编写注释
- en: Even if you are making a normal piece of software, it has to interact with data
    in one way or another. Eventually, your code will become lengthier and complicated
    and becomes hard to manage, read, and understand. Although we will eventually
    understand the code we've written, it will be harder in the long run. If you have
    50,000 lines of code and want to debug the semantic and logic errors in it, it
    would be hard for you to search and index them. Hence, comments come in handy.
    Comments are a way of writing notes along with your code so that anyone who tries
    to read your code knows what that program is doing. Comments are not interpreted
    by Python, which means whenever the Python parser sees that the statement starts
    with a hash symbol (`#`), its execution will be skipped.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您正在制作一款普通的软件，它也必须以某种方式与数据进行交互。最终，您的代码将变得更长、更复杂，变得难以管理、阅读和理解。虽然我们最终会理解我们编写的代码，但从长远来看，这将变得更加困难。如果您有
    50,000 行代码，并且想要调试其中的语义和逻辑错误，那么很难搜索和索引它们。因此，注释非常有用。注释是一种在代码中写下注释的方式，以便任何试图阅读您的代码的人都知道该程序在做什么。Python
    不会解释注释，这意味着每当 Python 解析器看到语句以井号符号 (`#`) 开头时，它的执行将被跳过。
- en: 'Python design patterns can be convoluted, which makes it difficult for any
    naive programmer to look at the code and understand what it is doing. Hence, we
    add simple notes about the program in our native language that explains why we
    are writing a particular piece of code. Comments that start with `#` are single-line
    comments. If you write something below the line containing hash, it won''t be
    considered a comment. This is shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python 设计模式可能会很复杂，这使得任何天真的程序员都很难查看代码并理解它在做什么。因此，我们在我们的母语中为程序添加简单的注释，解释为什么我们要编写特定的代码。以
    `#` 开头的注释是单行注释。如果您在包含井号的行下面写点东西，它不会被视为注释。这在以下代码中显示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In Python, there are no multi-line comments. People usually think that triple
    double quotes (`""" """`) are used for multi-line comments, but that''s not true.
    Using hashes is the only way of commenting in Python. In Python 3.x, a string
    inside triple quotes is considered a regular string. You can use triple double
    quotes to remove the broken string. Strings are considered to be broken when the
    scope of the string is not totally enclosed, as in the example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，没有多行注释。人们通常认为三个双引号 (`""" """`) 用于多行注释，但这是不正确的。在 Python 3.x 中，三引号内的字符串被视为常规字符串。您可以使用三个双引号来删除断开的字符串。当字符串的范围没有完全封闭时，字符串被视为断开，就像这个例子中一样：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding string was created with a single quote. An apostrophe was used
    in the string, which creates confusion for the interpreter as it thinks `hey it` is
    a string and it ignores `s me`. This is a broken string. Not every piece of text
    you encounter will be in a string. If you run this code in IDLE, you will get
    the following syntax error:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的字符串是用单引号创建的。字符串中使用了撇号，这会使解释器产生困惑，因为它认为 `hey it` 是一个字符串，而忽略了 `s me`。这是一个断开的字符串。您遇到的文本并不是每一段都在字符串中。如果您在
    IDLE 中运行此代码，将会得到以下语法错误：
- en: '![](Images/c65043ea-afa5-48f8-ab49-d9d9bdea2ce4.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c65043ea-afa5-48f8-ab49-d9d9bdea2ce4.png)'
- en: 'To eradicate this error, you can use a triple quote. A triple quote will remove
    the broken string, even if a double quote or single quote appears on your string:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除此错误，您可以使用三引号。三引号将删除断开的字符串，即使您的字符串中出现双引号或单引号：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Many people think that the preceding line of code represents a multi-line comment,
    and do something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为前面的代码行代表多行注释，并做了这样的事情：
- en: '![](Images/158f7921-4c38-452f-a5af-6a0edad82b41.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/158f7921-4c38-452f-a5af-6a0edad82b41.png)'
- en: 'You can clearly see that, instead of ignoring to execute that command, it has
    reflected our command by creating a string for us. If we do not assign a value
    enclosed in triple double quotes to the variable, it is treated as a garbage collector
    and gives us a string. Many people confuse it as a multi-line comment because
    of its behavior as a docstring. Docstrings are strings that are placed at the
    top of functions, modules, or classes. For example, this is the function that
    performs the add operation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清楚地看到，它不是忽略执行该命令，而是通过为我们创建一个字符串来反映我们的命令。如果我们没有将值封装在三个双引号中的变量中，它将被视为垃圾收集器，并给我们一个字符串。许多人因其作为文档字符串的行为而将其误认为是多行注释。文档字符串是放置在函数、模块或类顶部的字符串。例如，这是执行加法操作的函数：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Obviously, we haven't learned how to create functions yet, but you can get the
    idea that a triple-double quote is used to provide some information about functions,
    classes, and modules. Hence, some people think of it as a multi-line comment.
    You can tell it is not a multi-line comment because the notes inside the triple
    quote can be accessed with a special function of Python.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们还没有学会如何创建函数，但您可以了解到三个双引号用于提供有关函数、类和模块的一些信息。因此，有些人认为它是多行注释。您可以看出它不是多行注释，因为三引号内的注释可以通过
    Python 的特殊函数访问。
- en: Since this is docstring, we can access it through **`obj.__doc__`**. Since it
    can be accessed by a method and it is not ignored by the interpreter, it cannot
    be considered a multi-line comment. Due to this, we can conclude that there are
    only single-line comments in Python. If we do want multi-line comments, it should
    be done using triple double quotes, but we have to make sure that we place them
    above the definition of the function, class, or module.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是文档字符串，我们可以通过 **`obj.__doc__`** 访问它。由于它可以被方法访问，并且解释器不会忽略它，因此它不能被视为多行注释。因此，我们可以得出结论，Python
    中只有单行注释。如果我们确实想要多行注释，应该使用三个双引号，但我们必须确保将它们放在函数、类或模块的定义之上。
- en: 'In the following code, `\n` represents a new line. This will cause a line break
    in the code. As we can see, the following code prints `hey` in the first line
    and `it''s me` on the next line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`\n` 表示换行。这将导致代码中的换行。正如我们所看到的，以下代码在第一行打印 `hey`，在下一行打印 `it's me`：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From this, we can conclude the following about comments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，我们可以得出关于注释的以下结论：
- en: 'Comments are redundant. They simply tell us what every line of code is doing:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释是多余的。它们只是告诉我们每行代码在做什么：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Comments may contain useful information about the code – even some critical
    information that we cannot extract by looking at the code:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释可能包含有关代码的有用信息，甚至一些我们无法通过查看代码提取的关键信息：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we discussed in the previous chapter, we have to follow a convenient pattern
    while creating programs. Although this is not mandatory, it is always good practice.
    In the *Building blocks of Python* section, the first block was requesting user
    input, which will be our next topic of discussion.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，我们在创建程序时必须遵循一种方便的模式。虽然这不是强制性的，但这总是一个很好的做法。在*Python的基本组成*部分，第一个块是请求用户输入，这将是我们下一次讨论的主题。
- en: Requesting user input
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求用户输入
- en: One of the building blocks of programming is to make the user input data with
    their keyboard. Any application, whether it be for management tools or games,
    all should take input from the user. In a user management application, we gather
    user information such as their name, address, and age, and insert it into a database.
    In games, we take user input from the keyboard to make movements. Based on the
    key that's pressed by the user, we can make our character perform some actions.
    For example, pressing the *Shift* key on the keyboard will make the character
    jump. Thus, every application has to be user-friendly, which means it has to make
    the user interact with the application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的基本组成之一是让用户使用键盘输入数据。无论是用于管理工具还是游戏，所有应用程序都应该从用户那里获取输入。在用户管理应用程序中，我们收集用户信息，如他们的姓名、地址和年龄，并将其插入到数据库中。在游戏中，我们从键盘上获取用户输入以进行移动。根据用户按下的键，我们可以让角色执行一些动作。例如，按下键盘上的*Shift*键将使角色跳跃。因此，每个应用程序都必须用户友好，这意味着它必须使用户与应用程序进行交互。
- en: 'Letting a user input something on their keyboard and storing it in a variable
    so that we can process it further when required is a common practice. Python has
    in-built functions to get input from users, which means you don''t have to import
    or install anything to use this function. The `input()` function is used to take
    input from a user:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户在键盘上输入一些内容并将其存储在变量中，以便我们在需要时可以进一步处理，这是一个常见的做法。Python具有内置函数来从用户那里获取输入，这意味着您无需导入或安装任何内容即可使用此函数。`input()`函数用于从用户那里获取输入：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you enter the preceding command, it will give you a place to write something.
    The interpreter holds its other execution until the user presses a button on their
    keyboard and presses *Enter*. On pressing the *Enter* key, the program resumes
    and gives us the text input of the user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您输入上述命令时，它将为您提供一个写东西的地方。解释器在用户按下键盘上的按钮并按下*Enter*之前会保持其其他执行。按下*Enter*键后，程序将恢复并给出用户的文本输入。
- en: 'The following screenshot shows how the `input()` function works in Python:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了`input()`函数在Python中的工作方式：
- en: '![](Images/e15f0424-e5d6-4e2c-a80d-845f6acca596.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e15f0424-e5d6-4e2c-a80d-845f6acca596.png)'
- en: 'In the preceding screenshot, we used the `input()` method and entered the string
    ''I love Python''. The black text color is input from the user, and the interpreter
    instantly gave us some output, which was the same input string from user. You
    can store input text into variables so that we can perform computations on it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，我们使用了`input()`方法并输入了字符串'I love Python'。黑色文本颜色是用户输入的内容，解释器立即给出了一些输出，这是用户输入的相同字符串。您可以将输入文本存储到变量中，以便我们可以对其进行计算：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we have seen how to input data from the user. It is always good practice
    to provide a message or prompt to the user telling them what they need to enter
    in that field. A message or prompt should be given as a string within the parentheses
    of the `input` method, like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了如何从用户那里输入数据。向用户提供消息或提示，告诉他们需要在该字段中输入什么，这总是一个很好的做法。消息或提示应作为`input`方法括号内的字符串给出，如下所示：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding example, when the user inputs something and hits *Enter*,
    our program takes the input from the user and does the specified task. But if
    you want to make an application where you want to take data from the user continuously,
    we have to make use of loops. We will study loops in the upcoming chapters:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，当用户输入内容并按下*Enter*时，我们的程序会接受用户的输入并执行指定的任务。但是，如果您想要创建一个应用程序，其中要连续从用户那里获取数据，我们必须使用循环。我们将在接下来的章节中学习循环：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding statement takes input from the user continuously. It doesn''t
    stop, even after pressing *Enter* or typing in the `return` keyword. In the preceding
    command, `while` is used for looping. `True` is a Boolean type that represents
    the truth value of the logic and Boolean algebra. Boolean types are either `True`
    or `False`. Hence, the `while True` statement implies that the code inside it
    should run infinitely, which asks the user to make input infinitely. The result
    of this is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句连续从用户那里获取输入。即使按下*Enter*或输入`return`关键字后，它也不会停止。在上述命令中，`while`用于循环。`True`是表示逻辑和布尔代数的真值的布尔类型。布尔类型要么是`True`，要么是`False`。因此，`while
    True`语句意味着其中的代码应该无限运行，要求用户无限输入。其结果如下：
- en: '![](Images/80de89ab-ae5c-4db1-8a67-6e9db7c1b42f.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/80de89ab-ae5c-4db1-8a67-6e9db7c1b42f.png)'
- en: 'Anything you enter on your keyboard while calling `input()` method will be
    in string form, even you input it as integers, as in the example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`input()`方法时，您在键盘上输入的任何内容都将以字符串形式呈现，即使您输入的是整数，就像在示例中一样：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you check the type of the `a` variable by using the `type` method, that
    is, `>>> type(a)`, you will see some unexpected results. We input `1` from the
    user and stored it in a variable, `a`. When we check the type of value that''s
    stored in the `a` variable, it won''t be an integer. Instead, it will show `str
    class: <class ''str''>`, which means anything that you enter on your keyboard
    by calling the `input()` method will be of the string type. But sometimes, it
    may be the case that we want the integer that was input by the user to remain
    an integer. In such a case, we have to perform typecasting, which will be covered
    in the next section.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你使用`type`方法检查`a`变量的类型，即`>>> type(a)`，你会看到一些意想不到的结果。我们从用户那里输入`1`并将其存储在变量`a`中。当我们检查存储在`a`变量中的值的类型时，它不会是一个整数。相反，它会显示`str
    class: <class ''str''>`，这意味着你通过调用`input()`方法在键盘上输入的任何内容都将是字符串类型。但有时，也许我们希望用户输入的整数保持为整数。在这种情况下，我们必须执行类型转换，这将在下一节中介绍。'
- en: Typecasting or type conversion
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换或类型转换
- en: 'There may be times where you want to use the input data of a user as an integer.
    We saw that the input data from a user will be a string, even if it is an integer,
    as in the example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望将用户输入的数据作为整数使用。我们看到，用户输入的数据将是一个字符串，即使它是一个整数，就像这个例子中一样：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Age is represented in terms of numbers. However, in the preceding code, it''s
    a string. Hence, we have to convert it into an integer so that information entered
    by the user will be meaningful for computation. This type of conversion is called
    typecasting. However, if you do some computation in this value without casting
    it to the appropriate type, your result will be undesirable. For example, if you
    want to change the value of age by adding 2 to 29, you cannot change it from 29
    to 31\. This is because strings do not support increments; instead, they support
    concatenation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄是用数字表示的。然而，在前面的代码中，它是一个字符串。因此，我们必须将它转换为整数，以便用户输入的信息对计算有意义。这种转换称为类型转换。然而，如果你在不将其转换为适当类型的情况下对这个值进行一些计算，你的结果将是不可取的。例如，如果你想通过将29加2来改变年龄的值，你不能将它从29改变为31。这是因为字符串不支持增量；相反，它们支持连接：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Hence, if you want to use the age that was entered as an integer, we have to
    use typecasting methods. These methods are also in-built functions of Python.
    Some of them are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想使用输入的年龄作为整数，我们必须使用类型转换方法。这些方法也是Python的内置函数。其中一些如下：
- en: '`int(arg1, base)`: This method converts any other data type into an integer.
    If you put a string inside the parentheses of the `int` function, it will convert
    it into an integer. `arg1` is the string to be converted and the base argument
    indicates the base of the data is a string:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(arg1, base)`: 这个方法将任何其他数据类型转换为整数。如果你在`int`函数的括号中放入一个字符串，它将把它转换为整数。`arg1`是要转换的字符串，基本参数表示数据的基数是一个字符串：'
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`float()`: This method converts any integer into a floating-point number, as
    in the example:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float()`: 这个方法将任何整数转换为浮点数，就像这个例子中一样：'
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`str()`: This method converts any other data types into a string, as in the
    example:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str()`: 这个方法将任何其他数据类型转换为字符串，就像这个例子中一样：'
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`ord()`: This method converts a character type into integer and gives back
    its ASCII value, as in this example:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ord()`: 这个方法将字符类型转换为整数，并返回它的ASCII值，就像这个例子中一样：'
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Other functions such as `tuple()`, `list()`, `set()`, and `dict()` will be covered
    in the upcoming chapters.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数，如`tuple()`、`list()`、`set()`和`dict()`，将在接下来的章节中介绍。
- en: Now that you are familiar with the first building block of Python, that is,
    inputting data from the user, let's see how we can format this data using different
    features provided by Python. In the next section, we will look at string operations
    that will, in turn, call different methods provided by Python to manipulate the
    input entered by the user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了Python的第一个构建块，即从用户那里输入数据，让我们看看如何使用Python提供的不同功能来格式化这些数据。在下一节中，我们将看一下字符串操作，这将反过来调用Python提供的不同方法来操作用户输入的数据。
- en: String operations
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'Any data type, be it text, an integer, or a Boolean, written either in double
    quotes (`" "`)  or single quotes (`'' ''`) is considered a string by Python. String
    values uncover the broad meaning of data. Data that''s stored as strings can be
    easily accessed but cannot be changed. Hence, it is considered as immutable data
    types. Let''s take a look at the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据类型，无论是文本、整数还是布尔值，用双引号(`" "`)或单引号(`' '`)括起来，在Python中都被视为字符串。字符串值揭示了数据的广泛含义。存储为字符串的数据可以很容易地访问，但不能被改变。因此，它被视为不可变的数据类型。让我们看一下下面的代码：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding code, we created the `msg` variable and stored a string in
    it. We used the built-in method of the `string` class to manipulate that string
    and when we printed the `msg` variable back, it was unchanged. This implies that
    strings are immutable data types. If you want to change the content of a string,
    you should completely overwrite it, as in this example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了`msg`变量并将一个字符串存储在其中。我们使用了`string`类的内置方法来操作该字符串，当我们将`msg`变量打印回来时，它保持不变。这意味着字符串是不可变的数据类型。如果你想改变字符串的内容，你应该完全覆盖它，就像这个例子中一样：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Strings do not support item assignment. If you want to add an item to the string,
    you have to make a completely new string. Hence, this feature of Python makes
    it immutable, as in this example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不支持项目赋值。如果你想向字符串添加一个项目，你必须创建一个全新的字符串。因此，Python的这个特性使它成为不可变的，就像这个例子中一样：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To use the built-in functions of a string, you have to call a method on the
    string. Let''s look at a pattern we can use in the in-built method, that is, `"String".method_name()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用字符串的内置函数，你必须在字符串上调用一个方法。让我们看一下我们可以在内置方法中使用的模式，即`"String".method_name()`：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can access every element of a string by using square brackets. We should
    put the position inside the square brackets. These positions are called indexes
    in Python. The index of a string starts from 0 and increases by 1 from left to
    right:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用方括号访问字符串的每个元素。我们应该将位置放在方括号内。这些位置在Python中称为索引。字符串的索引从0开始，从左到右每次增加1：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can observe the indexing pattern in the following diagram. Here, we have
    a `Python` string. The index of the string starts from 0\. For each element right
    next to it that has an index, a unit is incremented to that of the previous element.
    This is called positive indexing:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下图表中观察索引模式。在这里，我们有一个`Python`字符串。字符串的索引从0开始。对于紧挨着具有索引的每个元素，都会增加一个单位到前一个元素的索引。这被称为正索引：
- en: '![](Images/0d75ec16-fe47-46f5-a0e7-5f2516730636.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0d75ec16-fe47-46f5-a0e7-5f2516730636.png)'
- en: 'Strings also support negative indexing. If you want the last digits from a
    string, you can give a `-1` index, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串还支持负索引。如果您想要从字符串中获取最后几位数字，可以给出一个`-1`索引，如下所示：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we have learned how to extract the particular elements of a string based
    on indexing. But if you want to extract more than one element from a string, you
    can use string slicing operation. The slicing operation is the same as a pizza
    slice, which represents we are taking out some parts of the string in a sequential
    order. String slicing can be done with the same square brackets that we used for
    extracting a single character from a string. The difference between these two
    operations is seen when we extend our square brackets with a colon and provide
    start, end (exclusive), and step indexes to it. Although the theory of string
    slicing may seem complicated, it is easy to program. Let''s take a look at an
    example to clarify this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何根据索引提取字符串的特定元素。但是，如果您想从字符串中提取多个元素，可以使用字符串切片操作。切片操作与比萨切片相同，表示我们按顺序取出字符串的一些部分。字符串切片可以使用与从字符串中提取单个字符时相同的方括号进行。这两种操作的区别在于，当我们用冒号扩展我们的方括号并为其提供开始、结束（不包括）和步长索引时，就会看到区别。尽管字符串切片的理论可能看起来很复杂，但编程起来很容易。让我们看一个例子来澄清这一点：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Suppose we want to extract the name of a person from this email address. We
    have to track all of the indexes to do so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从这个电子邮件地址中提取一个人的名字。我们必须跟踪所有的索引才能做到这一点：
- en: '![](Images/5bea629a-3190-4d34-8398-c196671068a8.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5bea629a-3190-4d34-8398-c196671068a8.png)'
- en: 'Since we are slicing some parts of that string, we have to imagine it as a
    container where each character resides with its index so that referencing them
    would be easier. To achieve string slicing, follow these steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在切片字符串的一些部分，我们必须将其想象为一个容器，其中每个字符都有其索引，以便更容易地引用它们。要实现字符串切片，请按照以下步骤进行：
- en: 'Use `name_of_string[start: stop`: We use the `[step]]` command for string slicing.
    Here, `start` is the starting index and `stop` is an exclusive position, which
    means if you put an index on it, the element of - 1 will be included but the element
    at the stop index will be excluded. Here, step is optional. We will talk about
    the step index position in an upcoming chapter (Chapter 3: Flow Controls: Build
    Decision Maker For Your Game)'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用`name_of_string[start: stop]`：我们使用`[step]`命令进行字符串切片。这里，`start`是起始索引，`stop`是一个排他位置，这意味着如果您在其上放置一个索引，-1的元素将被包括在内，但在停止索引处的元素将被排除在外。这里，步骤是可选的。我们将在接下来的章节（第3章：流控制：为您的游戏构建决策制定者）中讨论步骤索引位置。'
- en: 'Decide what needs to be extracted first. You cannot extract any part of a string
    randomly. It should be done sequentially. For example, you cannot extract `jo`
    and `mail` with a single command. We can extract `johndoe` because every element
    is in a sequential manner. Let''s try to extract it from our code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先决定需要提取什么。您不能随机提取字符串的任何部分。它应该是按顺序进行的。例如，您不能使用单个命令提取`jo`和`mail`。我们可以提取`johndoe`，因为每个元素都是按顺序排列的。让我们尝试从我们的代码中提取它：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding code, `email[0:7:]` or `email[:7:]` tells us that the first
    index, 0, is starting an index of a string, which means we want to print from
    `start`. Instead of 0, you can also put nothing, which represents the default
    state, and `start` will print from the start. The second index, 7, is the stopping
    position, but it is an exclusion position which means the interpreter will print
    until the `e` character but not `@` because `@` is at position 7\. Finally, the
    third index position is for step. We put an empty space here to represent the
    value it should hold by default, which means we are printing without skipping
    any numbers. If you put step as `>>> email[0:7:2]`, you will get `jhde` as the
    output; it will skip one character between each of them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`email[0:7:]`或`email[:7:]`告诉我们，第一个索引0是字符串的起始索引，这意味着我们要从`start`打印。您也可以放置0，表示默认状态，`start`将从起始位置打印。第二个索引7是停止位置，但它是一个排他位置，这意味着解释器将打印直到`e`字符，但不包括`@`，因为`@`在位置7。最后，第三个索引位置是步长。我们在这里放置一个空格，表示它应该默认持有的值，这意味着我们打印时不跳过任何数字。如果您将步骤放置为`>>>
    email[0:7:2]`，您将得到`jhde`作为输出；它将在每个字符之间跳过一个字符。
- en: 'We can also perform addition and multiplication operations with strings. Adding
    two strings together is called concatenation. We make use of operators such as
    `+` and `*` to perform string operations, as in this example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对字符串执行加法和乘法运算。将两个字符串连接在一起称为连接。我们使用`+`和`*`等运算符来执行字符串操作，就像这个例子中一样：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, you cannot multiply two string types. One must be a string and the
    other must be an integer if we wish to perform multiplication operations with
    strings:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您不能将两种字符串类型相乘。其中一个必须是字符串，另一个必须是整数，如果我们希望对字符串执行乘法操作。
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you also want to add strings, both of the operands must be strings. Otherwise,
    it will throw a type error:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还想要添加字符串，那么操作数必须都是字符串。否则，它将抛出类型错误：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we have learned about the fundamentals of string operations, such as
    assignment, concatenation, and assignment, we will learn about string formatting.
    This is an important concept if we need to change the format of the text based
    on the input.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了字符串操作的基本知识，比如赋值、连接和赋值，我们将学习字符串格式化。如果我们需要根据输入更改文本的格式，这是一个重要的概念。
- en: String formatting
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'String formatting is where we build our string by replacing placeholders with
    the content of variables. We apply % (the modulus operator) to perform string
    formatting. If you want to specify a digit as a placeholder, `%d` is used. If
    it is string, `%s` is used as the placeholder. The result of string formatting
    is also a string. Let''s look at a small example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化是我们通过用变量的内容替换占位符来构建字符串的地方。我们应用%（取模运算符）来执行字符串格式化。如果要指定数字作为占位符，使用`％d`。如果是字符串，使用`％s`作为占位符。字符串格式化的结果也是一个字符串。让我们看一个小例子：
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, the position of `%s` was replaced by the value of the
    key variable and the position of `%d` was replaced by the value of the `value` variable.
    Hence, `%d` and `%s` are placeholders. You cannot assign a string value in place
    of `%d` and cannot assign an integer value in `%d`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`％s`的位置被key变量的值替换，`％d`的位置被value变量的值替换。因此，`％d`和`％s`是占位符。你不能在`％d`的位置上分配字符串值，也不能在`％d`上分配整数值。
- en: 'The number of values that are passed must match the number of format sequences
    used in a string. Otherwise, it will throw a type error, like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的值的数量必须与字符串中使用的格式序列的数量相匹配。否则，它将抛出类型错误，如下所示：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can also format your string using Python''s built-in format function. It
    is relatively easier to format using this function. Instead of using placeholders
    or format sequences such as `%d` and `%s`, we can use curly braces `{}` as placeholders.
    We can also assign numbers inside curly braces so as to format with a particular
    value, like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Python的内置格式函数来格式化字符串。使用这个函数进行格式化相对容易。我们可以使用大括号`{}`作为占位符，而不是使用占位符或格式序列，如`％d`和`％s`。我们还可以在大括号内指定数字，以便格式化为特定值，如下所示：
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that we are familiar with the core programming paradigms of Python, let''s
    hop over to the next section, where we will learn to make our first game: **tic-tac-toe**.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了Python的核心编程范式，让我们跳到下一节，在那里我们将学习制作我们的第一个游戏：**井字棋**。
- en: Building your first game – tic-tac-toe
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作你的第一个游戏-井字棋
- en: 'The Python language is a cross-platform language, which means we can make games
    for any device. However, here, we will focus more on the logic and its implementation
    rather than coding for a specific platform. Coding games with Python is simple
    compared to other languages as its syntax is shorter and it provides rich-content
    libraries that make production faster. With that being said, it isn''t that easy
    if you don''t make plans before coding. We have to break our game entity into
    parts so that each entity can be debugged easily. We will follow these general
    steps while making games from now on:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言是一种跨平台语言，这意味着我们可以为任何设备制作游戏。然而，在这里，我们将更多地关注逻辑及其实现，而不是针对特定平台进行编码。与其他语言相比，使用Python编写游戏更简单，因为它的语法更短，提供了丰富的内容库，使生产速度更快。话虽如此，如果在编码之前不制定计划，那就不那么容易了。我们必须将游戏实体分解成部分，以便每个实体都可以轻松调试。从现在开始，在制作游戏时，我们将遵循以下一般步骤：
- en: Brainstorming and information gathering
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头脑风暴和信息收集
- en: Choosing a proper code editor
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的代码编辑器
- en: Programming model
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程模型
- en: User interaction—user input/manipulation
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户交互-用户输入/操作
- en: So far, we have covered a variety of topics, including variables, operators,
    expressions, taking input from a user, and printing it to a user. Let's apply
    all of these techniques now to make our first game.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了各种主题，包括变量、运算符、表达式、从用户那里获取输入并将其打印给用户。现在让我们将所有这些技术应用到我们的第一个游戏中。
- en: Brainstorming and information gathering
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头脑风暴和信息收集
- en: 'Before we start coding, let''s think about the design and interface of our
    game. Pull out your pen and paper and start thinking about the interface of the
    game!  Did we learn anything about the GUI so far? Obviously not! That means we
    have to make use of a simple interface for our first game. We will modify it later,
    after we learn about some advance concepts of Python. Tic-tac-toe is a game that
    takes input from a user and places either X or O based on the player''s movement.
    Hence, our interface should be a placeholder for these symbols. We will make a
    simple interface containing `_` for now. An underscore (`_`) will be our placeholder
    where we will put either X or O based on player selection:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们考虑一下游戏的设计和界面。拿出你的笔和纸，开始思考游戏的界面吧！到目前为止我们学到了关于GUI的什么？显然没有！这意味着我们必须为我们的第一个游戏使用一个简单的界面。在学习了Python的一些高级概念之后，我们将稍后对其进行修改。井字棋是一个需要从用户那里获取输入并根据玩家的移动放置X或O的游戏。因此，我们的界面应该是这些符号的占位符。我们将制作一个包含“_”的简单界面。下划线（`_`）将是我们的占位符，我们将根据玩家的选择放置X或O。
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding code shows the simple layout of our game. It contains `_` (underscores)
    as placeholders and `|` to separate the symbols:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了我们游戏的简单布局。它包含`_`（下划线）作为占位符和`|`来分隔符号。
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, whenever the player takes a step, we replace that underscore
    with a symbol corresponding to that user's decision. Now, we have a basic interface
    for our game.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每当玩家迈出一步时，我们就用与该用户决定相对应的符号替换下划线。现在，我们有了一个游戏的基本界面。
- en: 'Now that we have planned the interface, we need to work out how to track the
    position of the underscore and how to find out where to replace the underscores
    with the appropriate symbols. We can assign numbers to each of these underscores
    and tell the user to choose a number. Then, based on that number, we can assign
    its symbol to that location, like so:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经规划了界面，我们需要解决如何跟踪下划线的位置以及如何找出在哪里用适当的符号替换下划线的问题。我们可以为这些下划线中的每一个分配一个数字，并告诉用户选择一个数字。然后，根据该数字，我们可以将其符号分配到该位置，如下所示：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, we have gathered enough information to start our simple game. In complex
    real-world games, the brainstorming and information gathering process would take
    around 6 months. Now, let's look at choosing a code editor.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经收集了足够的信息来开始我们的简单游戏。在复杂的现实世界游戏中，头脑风暴和信息收集过程大约需要6个月。现在，让我们来选择一个代码编辑器。
- en: Choosing  proper code editor
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择适当的代码编辑器
- en: 'We have already installed Python On our machine, and we took a look at the
    pre-installed editor of Python, IDLE. We will use that editor for this project.
    Let''s get started:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的机器上安装了Python，并查看了Python的预安装编辑器IDLE。我们将在这个项目中使用该编辑器。让我们开始吧：
- en: 'Search for IDLE in your search bar and open it. You will get the following
    Shell:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中搜索IDLE并打开它。你会得到以下Shell：
- en: '![](Images/87ad6991-f4ca-466c-8ff3-2724089f82d6.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/87ad6991-f4ca-466c-8ff3-2724089f82d6.png)'
- en: This Terminal or Shell is normally used to interpret commands instantly within
    the Shell. This means that one command will execute at a time, but we have to
    write many lines of code to make our game. Hence, writing a game with this Shell
    is not possible. We have to create a file where we can write many lines of code
    and execute them all at once. Python provides us with scripts to facilitate this
    problem.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个终端或Shell通常用于在Shell内立即解释命令。这意味着一次只执行一个命令，但我们必须写很多行代码来制作我们的游戏。因此，用这个Shell编写游戏是不可能的。我们必须创建一个文件，可以在其中写入多行代码并一次性执行它们。Python为我们提供了脚本来解决这个问题。
- en: Click on File and then New File, or press *Ctrl* + *N*. A new script file will
    open where we can write multiple lines of code.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文件，然后新建文件，或按*Ctrl* + *N*。将打开一个新的脚本文件，我们可以在其中写入多行代码。
- en: '![](Images/a3bf3719-f952-461e-afa9-3e591d468030.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a3bf3719-f952-461e-afa9-3e591d468030.png)'
- en: At the top of the window, we will see Untitled, which means we haven't saved
    our file yet. Let's save it first because we have to save it anyway afterward.
    Press *Ctrl* + *S* to save it. I have saved it as `first_game.py`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口顶部，我们会看到未命名，这意味着我们还没有保存我们的文件。让我们先保存，因为无论如何我们都必须保存。按下*Ctrl* + *S*进行保存。我已经将其保存为`first_game.py`。
- en: '![](Images/d9cd0064-2b31-4664-9999-1224565e887d.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d9cd0064-2b31-4664-9999-1224565e887d.png)'
- en: Now that we have selected the proper IDE for development, let's start developing
    our model for the game.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了适合开发的IDE，让我们开始为游戏开发我们的模型。
- en: Programming model or modelling
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程模型或建模
- en: In programming, a model is a way to represent the flow of data in your program.
    In our game, it is about how to use data that's been obtained as user input. We
    uncovered some information in the *Brainstorming and information gathering* section,
    where we talked about positions and how each number was assigned to the position
    that represents player selection. The model does not contain presentation logic;
    instead, it will deal with data logic. The computer doesn't care about layouts
    or interfaces. The user, on the other hand, requires an interface in order to
    react. Thus, every program has a frontend and a backend. The frontend is everything
    that you see in the application, whether it be an aesthetic or visible part of
    the application. **User experience** (**UX**) designers work mostly on frontends
    in big projects. The backend doesn't care about designs—it only cares about the
    algorithms and security that are applied to the data layer for the transaction
    of data. Models are used as a way of communication between the frontend and the
    backend.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，模型是表示程序中数据流的一种方式。在我们的游戏中，这是关于如何使用作为用户输入获得的数据。在*头脑风暴和信息收集*部分，我们揭示了一些信息，讨论了位置以及如何将每个数字分配给代表玩家选择的位置。模型不包含演示逻辑；相反，它将处理数据逻辑。计算机不关心布局或界面。另一方面，用户需要一个界面来做出反应。因此，每个程序都有前端和后端。前端是应用程序中看到的一切，无论是应用程序的美学部分还是可见部分。在大型项目中，**用户体验**（**UX**）设计师主要在前端工作。后端不关心设计，它只关心应用于数据层的算法和安全性。模型被用作前端和后端之间的通信方式。
- en: 'The computer does not care how the model presents data, but the user should
    get data out of the model in an informative and pretty way. Due to this, we made
    simple layouts that look as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不关心模型如何呈现数据，但用户应该以信息丰富和美观的方式从模型中获取数据。因此，我们制作了简单的布局，如下所示：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s start creating our model for the presentation layer:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的演示层模型：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding code represents the layout for our game. It is displayed to the
    user. Let''s break it down line by line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码代表了我们游戏的布局。它显示给用户。让我们逐行分解一下：
- en: '`game_board = [''_''] * 9`: This statement creates 9 underscores, which is
    the placeholder for our game characters. It is stored in the `game_board` variable.
    As you may recall, a variable cannot store multiple values. If we perform multiple
    assignments to the same variable, the variable will store the latest value that
    was added to it. Hence, this board is not a simple type of variable. This is a
    `list` variable. We can store multiple pieces of data in a list. Let''s print
    the value of the board:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game_board = [''_''] * 9`: 这个语句创建了9个下划线，作为我们游戏角色的占位符。它存储在`game_board`变量中。正如你可能记得的，一个变量不能存储多个值。如果我们对同一个变量执行多次赋值，变量将存储最后添加到它的值。因此，这个棋盘不是简单类型的变量。这是一个`list`变量。我们可以在列表中存储多个数据。让我们打印一下棋盘的值：'
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`>>> print(game_board[0] + ''|'' + game_board[1] + ''|'' + game_board[2])`:
    The preceding command prints the first line of the layout. We have learned about
    the `print` statement earlier in this chapter. Anything inside parentheses (either
    a string or variable value) is printed as it is by the `print` statement . We
    passed `board[0]` to get the first element of the board, which is the first underscore
    (`_`) We print a separator (`|`) between each underscore. The output of the preceding
    statement is `_ | _ | _ `.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>>> print(game_board[0] + ''|'' + game_board[1] + ''|'' + game_board[2])`:
    上面的命令打印了布局的第一行。在本章的前面，我们已经学习了`print`语句。括号内的任何内容（字符串或变量值）都会被`print`语句原样打印出来。我们传递了`board[0]`来获取棋盘的第一个元素，也就是第一个下划线（`_`）。我们在每个下划线之间打印一个分隔符（`|`）。上面语句的输出是`_
    | _ | _ `。'
- en: 'We have to print the preceding layouts two more times, which means we have
    to use two more `print` statements:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须再次打印前面的布局两次，这意味着我们必须使用两个`print`语句：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The number that''s inserted in the square brackets is the position that we
    normally call an `index` in programming. This refers to a certain position of
    the `list` variable. The list index always starts with zero indexes:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入在方括号中的数字是我们通常在编程中称为`索引`的位置。这指的是`list`变量的某个位置。列表索引总是从零开始：
- en: '[PRE67]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following code shows the final layout for our tic-tac-toe game. Make sure
    you write the program as a script and press *F5* to run it:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面的代码显示了我们井字棋游戏的最终布局。确保将程序编写为脚本，并按*F5*运行它：
- en: '[PRE68]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we did two things: first, we printed underscore in every
    position of our layout, and then we assigned a number to each of those positions:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了两件事：首先，在我们的布局的每个位置上打印了下划线，然后我们为每个位置分配了一个数字：
- en: '[PRE69]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now that we've developed the programming model that represents the basic layout
    of our game, it's time to make an interaction between the programming model and
    player of the game. In the next section, we will learn how to take user input
    and manipulate it so that we can interact with the model of our game.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经开发了代表游戏基本布局的编程模型，是时候让编程模型与游戏玩家进行交互了。在下一节中，我们将学习如何接受用户输入并对其进行操作，以便与我们游戏的模型进行交互。
- en: User interaction – user input and manipulation
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户交互-用户输入和操作
- en: We're making games for our users to play. Hence, we should make an interface
    so that we can make our application user-friendly. We did this in the previous
    section. Now, we have to take some input from the user and place it to the layout
    through the model. We know that a simple way to take the input from the user is
    by using the `input()` method. Let's use it now.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为用户制作游戏。因此，我们应该制作一个界面，使我们的应用程序更加用户友好。我们在上一节中已经做到了这一点。现在，我们必须从用户那里接受一些输入，并通过模型将其放到布局中。我们知道从用户那里接受输入的一个简单方法是使用`input()`方法。现在让我们使用它。
- en: 'To do this, we will think of this problem: *what should we input from the user?
    Is it a symbol, like X/O, or is it positions?*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要考虑：*我们应该从用户那里输入什么？是一个符号，比如X/O，还是位置？*
- en: 'Taking input as a symbol is useless because after taking it, we should know
    where to place it. Hence, we can take the positions from the user and place the
    symbol into our code automatically:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入作为符号是没有意义的，因为在接受输入后，我们应该知道在哪里放置它。因此，我们可以从用户那里接受位置，并自动将符号放入我们的代码中：
- en: '[PRE70]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s break this down part by part:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一部分一部分地来分解这个问题：
- en: '`while True`: This will run an infinite amount of times. We saw this happen
    in the *Requesting user input* section. Therefore, we will take the input data
    from the user an  infinite amount of times, which means our game loop has no termination.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while True`：这将无限次运行。我们在*请求用户输入*部分看到了这种情况。因此，我们将无限次地从用户那里获取输入数据，这意味着我们的游戏循环没有终止。'
- en: '`pos = input(" Enter any position you want from (0-8): \n")`: This statement
    will take input from the user as a position from 0 to 8 and store it in the `pos`
    variable.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pos = input("输入您想要的任何位置（0-8）：\n")`：这个语句将从用户那里接受0到8的位置输入，并将其存储在`pos`变量中。'
- en: The data that's stored in the `pos` variable will be a string, but the position
    should be an integer. Due to this, we have to typecast it as an integer using
    the `int` method. Then, we store the integer in the `pos` variable as `x = int(x)`.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在`pos`变量中的数据将是一个字符串，但位置应该是一个整数。因此，我们必须使用`int`方法将其转换为整数。然后，我们将整数存储在`pos`变量中，如`x
    = int(x)`。
- en: '`game_board[pos] = ''X''`: This statement assigns `X` to the position that''s
    selected by the user. The `pos` variable contains a position from 0 to 8 that
    was selected by the user in the previous command. Now, we are assigning `X` to
    that position in place of an underscore, like so:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game_board[pos] = ''X''`：这个语句将`X`分配给用户选择的位置。`pos`变量包含了用户在上一个命令中选择的0到8的位置。现在，我们将`X`分配给该位置，取代下划线，如下所示：'
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the user enters, `4` then we will put `X` in `4th` position, as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入`4`，那么我们将在第`4`个位置放置`X`，如下所示：
- en: '[PRE72]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After we assign a player symbol to the specified position, we have to print
    the board again with those three print statements. It should be kept inside the
    loop because we have to print the board every time the user enters a new position
    from the keyboard.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们为指定位置分配了玩家符号之后，我们必须使用这三个打印语句再次打印棋盘。它应该保持在循环内，因为我们必须在用户从键盘输入新位置时每次都打印棋盘。
- en: Now that we have finished making models for rendering layouts and user input,
    we can run the game and observe the output. The game you are going to see won't
    be appealing because it doesn't have a proper layout and it won't have as many
    features that our tic-tac-toe game should have. We will try to make the game as
    playable as possible while learning more Python in the upcoming chapter. For now,
    we will take a look at the possible errors and warnings that may be encountered
    in our game.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了渲染布局和用户输入模型的制作，我们可以运行游戏并观察输出。你将看到的游戏可能不太吸引人，因为它没有一个合适的布局，也不会有我们井字棋游戏应该有的许多功能。在未来的章节中，我们将尽可能地使游戏可玩。现在，让我们来看看可能在我们的游戏中遇到的错误和警告。
- en: Possible errors and warnings
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的错误和警告
- en: 'We''ve only covered the basic fundamentals of Python so far, so you won''t
    have found many semantic errors until now. However, you are likely to be accustomed
    to the syntax error. First and foremost, an error can be caused while naming a
    variable. If you do not follow the rules or conventions for naming a variable,
    you are likely to get the following errors:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只涵盖了Python的基本基础知识，因此到目前为止，你可能还没有发现太多语义错误。但是，你可能已经习惯了语法错误。首先，变量命名可能会导致错误。如果你不遵循变量命名的规则或约定，你可能会遇到以下错误：
- en: '[PRE73]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding name is invalid because you cannot provide spaces while creating
    variable names. You can put an underscore between them to specify that it consists
    of two words. `my_name` is a valid name for a variable.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的名称是无效的，因为在创建变量名称时不能使用空格。你可以在它们之间加一个下划线来指定它由两个单词组成。`my_name`是一个变量的有效名称。
- en: If you spell your variable name incorrectly, you are going to get an error instantly.
    Suppose you created a variable called `Msg` and used it as `msg`. An error will
    be returned, stating that this is the wrong definition. Python is case-sensitive,
    which means that `True` and `true` are different in Python. If you name a variable
    `True`, it will be illegal because it is one of the keywords of Python.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拼错了变量名，你会立即得到一个错误。假设你创建了一个名为`Msg`的变量，并将其用作`msg`。将返回一个错误，说明这是错误的定义。Python是大小写敏感的，这意味着`True`和`true`在Python中是不同的。如果你将一个变量命名为`True`，那将是非法的，因为它是Python的关键字之一。
- en: 'However, you can call a variable `true`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以将一个变量命名为`true`：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The same rule goes for naming modules. In this chapter, we looked at how to
    import the `math` module and use its methods. However, if you spell the module's
    name wrong, it will cause many problems in the long run. You won't see an instant
    error on IDLE; you have to compile your script to see it. Thus, debugging is a
    lot harder with IDLE. Because of this, make sure you spell all of your modules
    and their methods correctly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则也适用于命名模块。在本章中，我们学习了如何导入`math`模块并使用它的方法。然而，如果你拼错了模块的名称，长期来看会导致许多问题。在IDLE上不会立即看到错误；你必须编译你的脚本才能看到。因此，在IDLE上调试要困难得多。因此，请确保你正确拼写所有的模块和它们的方法。
- en: '`>>> import math` will successfully import the `math` module into your project,
    but if you use the wrong module name, you will get the following error:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> import math`将成功地将`math`模块导入到你的项目中，但如果你使用错误的模块名称，你将得到以下错误：'
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There's also another type of error that's more dangerous than a syntax error;
    these are called semantic errors. A semantic error occurs when we didn't get the
    intended results. They won't be detected by the interpreter, and so they are hard
    to debug. We can get semantic errors due to executing expressions incorrectly.
    If we didn't care enough for the rule of precedence, we will end up making wrong
    statements for the program.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种比语法错误更危险的错误类型；这些被称为语义错误。语义错误发生在我们没有得到预期结果时。它们不会被解释器检测到，因此很难调试。我们可能由于错误执行表达式而出现语义错误。如果我们对优先规则不够重视，最终会导致程序出现错误的语句。
- en: The output of the `1 + 3**2` expression is 10, not 16\. However, we can force
    our interpreter to make this statement print 16 by enclosing the statement with
    parenthesis. `(1 + 3) **2` will give us 16.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 + 3**2`表达式的输出是10，而不是16。然而，我们可以通过在括号中包围该语句来强制解释器打印16。`(1 + 3) **2`将给我们16。'
- en: Now that you've learned how to rectify errors that are encountered in your program,
    let's learn about the possible ways to modify our very first tic-tac-toe game.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何纠正程序中遇到的错误，让我们来了解一下修改我们的第一个井字棋游戏的可能方法。
- en: Game testing and possible modifications
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: There are several ways to find errors in your game. First of all, you can reach
    out to your friends and make them play your game. The suggestions that you gather
    the first time you test your game is known as alpha testing and it is an essential
    part of any game development life cycle. After collecting enough information through
    interviewing, you can start modifying your game.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以找到游戏中的错误。首先，你可以向你的朋友们求助，让他们玩你的游戏。你第一次测试游戏时收集到的建议被称为alpha测试，它是任何游戏开发生命周期中的一个重要部分。通过采访收集足够的信息后，你可以开始修改你的游戏。
- en: The things we have learned so far will not be enough to make our game more appealing.
    We will learn about several topics in upcoming chapters and modify our tic-tac-toe
    game accordingly.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们学到的东西还不足以使我们的游戏更有吸引力。我们将在接下来的章节中学习一些主题，并相应地修改我们的井字棋游戏。
- en: The game that we made in this section is bland and does not galvanize our user
    to play, but we have learned so many things by making it. We looked at the basic
    process of creating games using the concepts of models and views. View refers
    to layouts where we render data that helps us to interact with the user through
    the interface, while model refers to the way we communicate data between our program
    and user. We haven't covered advanced Python language paradigms yet and so we
    have limited power. This means that the game in this chapter is simple. However,
    we will make changes to this game after we cover conditionals, looping, and functions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节制作的游戏很单调，没有激励用户去玩，但通过制作它，我们学到了很多东西。我们看了使用模型和视图概念创建游戏的基本过程。视图指的是我们呈现数据的布局，帮助我们通过界面与用户进行交互，而模型指的是我们在程序和用户之间传递数据的方式。我们还没有涵盖高级的Python语言范式，因此我们的能力有限。这意味着本章的游戏很简单。然而，在我们学习条件、循环和函数后，我们将对这个游戏进行修改。
- en: 'The following are some possible modifications we could make to our game:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以对游戏进行的一些可能修改：
- en: Let's analyze our code and see its limitations. We told the user to explicitly
    enter a number from 0 to 8 to specify the movements of the user. What if the user
    didn't input a number and input a string? Our program will terminate the loop
    and crash with an exception. Hence, the first modification we would make is to
    restrict the user to entering only numbers. If they enter anything else, we can
    print a user-friendly message instead of crashing the program. This concept is
    called *exception handling* and will be covered in the next chapter.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们分析一下我们的代码及其局限性。我们告诉用户明确输入0到8之间的数字来指定用户的移动。如果用户没有输入数字而输入了字符串会怎么样？我们的程序将终止循环并因异常而崩溃。因此，我们将进行的第一个修改是限制用户只能输入数字。如果他们输入其他内容，我们可以打印一个用户友好的消息，而不是让程序崩溃。这个概念被称为*异常处理*，将在下一章中介绍。
- en: Currently, this game only works with one player, but tic-tac-toe is a multi-player
    game. Hence, we have to learn about conditionals and flow controls that will help
    us to achieve transition between players. We will do this in the next chapter.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，这个游戏只能与一个玩家一起玩，但井字棋是一个多人游戏。因此，我们必须学习条件和流控制，这将帮助我们实现玩家之间的过渡。我们将在下一章中做到这一点。
- en: When a user captures an entire row, column, or diagonal, then they should be
    considered the winner of the game and the game should complete its execution.
    However, we haven't created any logic to make a player a winner. What we've learned
    so far is not enough, but after we complete the next chapter, we will be able
    to make drastic changes to our game.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户捕获整行、整列或对角线时，他们应被视为游戏的赢家，并且游戏应完成执行。然而，我们还没有创建任何逻辑来使玩家成为赢家。到目前为止，我们所学的还不够，但在完成下一章之后，我们将能够对我们的游戏进行重大改变。
- en: By looking at the modifications we can make to our game, we can see that we
    have bigger things to come in the next chapter. Although the knowledge that we
    acquired in this chapter was enough to create a programming model and allow us
    to interact with a single player, this was not enough for us to interact with
    multiple players, which requires a good understanding of looping and conditional
    structures. We'll cover these concepts in the next chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看我们可以对我们的游戏进行的修改，我们可以看到在下一章中我们有更大的事情要做。尽管我们在本章中获得的知识足以创建一个编程模型并允许我们与单个玩家互动，但这对我们与多个玩家互动来说还不够，这需要对循环和条件结构有很好的理解。我们将在下一章中涵盖这些概念。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered the two basic building blocks of Python: inputting
    and providing formatted output. We looked at Python''s built-in data types in
    this chapter and started by learning about the different data values and their
    types, such as integer, string, float, Boolean, and none. We took a tour of the
    Python ecosystem by learning about variables, numbers, and the `math` module.
    We saw how to use the `math` module and got a good grasp of topics such as the
    rules and conventions that need to be followed while creating variables and using
    modules. These topics are essential if you want to start your programming career
    with Python. These topics not only make for a strong foundation in Python but
    also teach you what good and bad practices in programming need to be followed
    and removed, even if you are a proficient Python programmer. Coding is not only
    writing code—it''s about presenting information in a readable and usable way.
    Hence, we saw how we can use comments in programming to make our code more readable
    and reusable for other programmers.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了Python的两个基本构建模块：输入和提供格式化输出。在本章中，我们查看了Python的内置数据类型，并首先学习了不同数据值及其类型，如整数、字符串、浮点数、布尔值和无值。我们通过学习变量、数字和`math`模块来了解Python生态系统。我们看到了如何使用`math`模块，并对需要遵循的变量创建和使用模块的规则和约定有了很好的理解。如果你想用Python开始你的编程生涯，这些主题是必不可少的。这些主题不仅为Python打下了坚实的基础，还教会了你在编程中需要遵循和消除的好坏实践，即使你是一名熟练的Python程序员。编码不仅仅是编写代码——它是关于以可读和可用的方式呈现信息。因此，我们看到了如何在编程中使用注释来使我们的代码更易读和可重用于其他程序员。
- en: Making the user input data and then using it in our program is the only way
    to make an application user-friendly. Hence, we learned how to make the user input
    data and store it in the structure so that accessing it will be easier for further
    manipulation. We eventually looked at the unusual working behavior of the `input()`
    method, which converts our integer or Boolean input data into strings. Due to
    this, we learned about typecasting methods and we saw how easy it was to perform
    data conversion with Python's built-in methods.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用户输入数据，然后在我们的程序中使用它是使应用程序用户友好的唯一方法。因此，我们学习了如何使用户输入数据并将其存储在结构中，以便进一步操作时更容易访问。我们最终看到了`input()`方法的不寻常的工作行为，它将我们的整数或布尔输入数据转换为字符串。由于这个原因，我们学习了类型转换方法，并看到使用Python的内置方法执行数据转换是多么容易。
- en: A string is the most fundamental and primitive data type and stores text. We
    dedicated an entire section to the creation and manipulation of strings. We learned
    how to access elements of strings. We also learned that string assignment isn't
    possible, and so we concluded that strings are immutable. We learned about the
    basic methods of the string class such as capitalize, join, upper, lower, and
    len. We looked at two formatting techniques for strings, that is, `%s` and `%d`,
    which are used as placeholders and format the method. You can use either of them,
    although it's better to have knowledge of each before you do so.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是最基本和原始的数据类型，用于存储文本。我们专门讨论了字符串的创建和操作。我们学习了如何访问字符串的元素。我们还了解到字符串赋值是不可能的，因此我们得出结论字符串是不可变的。我们学习了字符串类的基本方法，如capitalize、join、upper、lower和len。我们研究了字符串的两种格式化技术，即`%s`和`%d`，它们被用作占位符和格式化方法。你可以使用其中任何一个，尽管最好在这样做之前对每一个都有所了解。
- en: Then, we built our first game. We saw the building games is not only about coding.
    We need to go through a variety of processes, such as brainstorming, modeling,
    and user interaction. We learned how model and view work together. Then, we made
    a simple game and had the chance to revise everything we'd learned so far. Finally,
    we suggested some modifications that we could make to that tic-tac-toe game. Every
    modification will be covered as we progress through this book. In the next chapter,
    we will learn about flow control and how to build a decision-maker for our game.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们建立了我们的第一个游戏。我们看到建立游戏不仅仅是编码。我们需要经历各种过程，如头脑风暴、建模和用户交互。我们学习了模型和视图如何协同工作。然后，我们制作了一个简单的游戏，并有机会复习到目前为止学到的一切。最后，我们提出了一些我们可以对井字棋游戏进行的修改。随着我们在这本书中的进展，每个修改都将被涵盖。在下一章中，我们将学习流控制以及如何为我们的游戏构建决策者。
