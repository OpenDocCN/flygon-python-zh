- en: The Python Automation Framework – Beyond Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python自动化框架-超越基础
- en: In [Chapter 1](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml), *Review of TCP/IP
    Protocol Suite and Python*, we looked at some of the basic structures to get Ansible
    up and running. We worked with Ansible inventory files, variables, and playbooks.
    We also looked at some examples of using network modules for Cisco, Juniper, and
    Arista devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml)中，*TCP/IP协议套件和Python回顾*，我们看了一些基本结构，以使Ansible运行起来。我们使用Ansible清单文件、变量和playbook。我们还看了一些使用Cisco、Juniper和Arista设备的网络模块的示例。
- en: In this chapter, we will further build on the knowledge we have gained from
    the previous chapters and dive deeper into the more advanced topics of Ansible.
    Many books have been written about Ansible, and there is more to Ansible than
    we can cover in two chapters. The goal here is to introduce the majority of the
    features and functions of Ansible that I believe you will need as a network engineer
    and shorten the learning curve as much as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步建立在之前章节所学到的知识基础上，并深入探讨Ansible的更高级主题。关于Ansible已经写了很多书，而且Ansible的内容远不止我们可以在两章中涵盖的。这里的目标是介绍我认为作为网络工程师您需要的大部分Ansible功能和功能，并尽可能地缩短学习曲线。
- en: It is important to point out that if you were not clear on some of the points
    made in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The Python Automation
    Framework – Ansible Basics*, now is a good time to go back and review them as
    they are a prerequisite for this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，如果您对[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中提出的一些观点不清楚，现在是回顾它们的好时机，因为它们是本章的先决条件。
- en: 'In this chapter, we will look into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下主题：
- en: Ansible conditionals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible条件
- en: Ansible loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible循环
- en: Templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Group and host variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组和主机变量
- en: The Ansible Vault
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Vault
- en: Ansible roles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible角色
- en: Writing your own module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的模块
- en: We have a lot of ground to cover, so let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容要涵盖，所以让我们开始吧！
- en: Ansible conditionals
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible条件
- en: Ansible conditionals are similar to conditional statements in programming languages.
    In [Chapter 1](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml), *Review of TCP/IP
    Protocol Suite and Python*,we saw that Python uses conditional statements to only
    execute a section of the code using `if.. then` or `while` statements. In Ansible,
    it uses conditional keywords to only run a task when the condition is met. In
    many cases, the execution of a play or task may depend on the value of a fact,
    variable, or the previous task result. For example, if you have a play to upgrading
    router images, you want to include a step to make sure the new router image is
    on the device before you move on to the next play of rebooting the router.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible条件类似于编程语言中的条件语句。在[第1章](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml)中，*TCP/IP协议套件和Python回顾*，我们看到Python使用条件语句只执行代码的一部分，使用`if..
    then`或`while`语句。在Ansible中，它使用条件关键字只有在条件满足时才运行任务。在许多情况下，play或任务的执行可能取决于事实、变量或上一个任务的结果。例如，如果您有一个升级路由器镜像的play，您希望包括一步来确保新的路由器镜像在移动到下一个重启路由器的play之前已经在设备上。
- en: 'In this section, we will discuss the `when` clause, which is supported for
    all modules, as well as unique conditional states that are supported in Ansible
    networking command modules. Some of the conditions are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论`when`子句，它支持所有模块，以及在Ansible网络命令模块中支持的独特条件状态。一些条件如下：
- en: Equal to (`eq`)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于（`eq`）
- en: Not equal to (`neq`)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不等于（`neq`）
- en: Greater than (`gt`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于（`gt`）
- en: Greater than or equal to (`ge`)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于（`ge`）
- en: Less than (`lt`)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于（`lt`）
- en: Less than or equal to (`le`)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于（`le`）
- en: Contains
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含
- en: The when clause
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: when子句
- en: 'The `when` clause is useful when you need to check the output of a variable
    or a play execution result and act accordingly. We saw a quick example of the
    `when` clause in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The
    Python Automation Framework – Ansible Basic*s, when we looked at the Ansible 2.5
    best practices structure. If you recall, the task only ran when the network operating
    system of the device was the Cisco IOS. Let''s look at another example of its
    use in `chapter5_1.yml`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`子句在您需要检查变量或play执行结果的输出并相应地采取行动时非常有用。我们在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中看到了`when`子句的一个快速示例，*Python自动化框架-
    Ansible基础*，当我们查看Ansible 2.5最佳实践结构时。如果您还记得，只有当设备的网络操作系统是Cisco IOS时，任务才会运行。让我们在`chapter5_1.yml`中看另一个使用它的例子：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have seen all the elements in this playbook before in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics**,* up to the end of the first
    task. For the second task in the play, we are using the `when` clause to check
    if the output contains the `iosv-2` keyword. If true, we will proceed to the task,
    which is using the debug module to display the output. When the playbook is run,
    we will see the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个playbook中看到了之前在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中的所有元素，*Python自动化框架-
    Ansible基础**，直到第一个任务结束。在play的第二个任务中，我们使用`when`子句来检查输出是否包含`iosv-2`关键字。如果是，我们将继续执行任务，该任务使用debug模块来显示输出。当playbook运行时，我们将看到以下输出：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see that the `iosv-r1` device is skipped from the output because the
    clause did not pass. We can further expand this example in `chapter5_2.yml` to
    only apply certain configuration changes when the condition is met:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`iosv-r1`设备被跳过了，因为条件没有通过。我们可以在`chapter5_2.yml`中进一步扩展这个例子，只有当条件满足时才应用某些配置更改：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see the execution output here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到执行输出：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, note in the execution output that `ios-r2` was the only change applied
    while `ios-r1` was skipped. In this case, the logging buffer size was only changed
    on `ios-r2`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意执行输出中`ios-r2`是唯一应用的更改，而`ios-r1`被跳过。在这种情况下，日志缓冲区大小只在`ios-r2`上更改。
- en: 'The `when` clause is also very useful in situations when the setup or facts
    module is used – you can act based on some of the `facts` that were gathered initially.
    For example, the following statement will ensure that only the Ubuntu host with
    major release `16` will be acted upon by placing a conditional statement in the
    clause:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`子句在使用设置或事实模块时也非常有用-您可以根据最初收集的一些`事实`来采取行动。例如，以下语句将确保只有主要版本为`16`的Ubuntu主机将受到条件语句的影响：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more conditionals, check out the Ansible conditionals documentation ([http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多条件，请查看Ansible条件文档([http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html))。
- en: Ansible network facts
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible网络事实
- en: Prior to 2.5, Ansible networking shipped with a number of network-specific fact
    modules. The network fact modules exist, but the naming and usage was different
    between vendors. Starting with version 2.5, Ansible started to standardize its
    network fact module usage. The Ansible network fact modules gather information
    from the system and store the results in facts prefixed with `ansible_net_`. The
    data collected by these modules is documented in the *return values* in the module
    documentation. This is a pretty big milestone for Ansible networking modules,
    as it does a lot of the heavy lifting for you to abstract the fact-gathering process
    by default.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.5之前，Ansible网络配送了许多特定于网络的事实模块。网络事实模块存在，但供应商之间的命名和使用方式不同。从2.5版本开始，Ansible开始标准化其网络事实模块的使用。Ansible网络事实模块从系统中收集信息，并将结果存储在以`ansible_net_`为前缀的事实中。这些模块收集的数据在模块文档中有记录的*返回值*中。这对于Ansible网络模块来说是一个相当重要的里程碑，因为它默认情况下可以为您抽象出事实收集过程的大部分繁重工作。
- en: 'Let''s use the same structure we saw in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, Ansible 2.5 best practices,
    but expand upon it to see how the `ios_facts` module was used to gather facts.
    As a review, our inventory file contains two iOS hosts with the host variables
    residing in the `host_vars` directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中看到的相同结构，*Python自动化框架-
    Ansible基础*，Ansible 2.5最佳实践，但扩展它以查看`ios_facts`模块如何用于收集事实。回顾一下，我们的清单文件包含两个iOS主机，主机变量驻留在`host_vars`目录中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our playbook will have three tasks. The first task will use the `ios_facts`
    module to gather facts for both of our network devices. The second task will display
    certain facts gathered and stored for each of the two devices. You will see that
    the facts we displayed were the default `ansible_net` facts, as opposed to a registered
    variable from the first task. The third task will display all the facts we collected
    for the `iosv-1` host:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook将有三个任务。第一个任务将使用`ios_facts`模块为我们的两个网络设备收集事实。第二个任务将显示为每个设备收集和存储的某些事实。您将看到我们显示的事实是默认的`ansible_net`事实，而不是来自第一个任务的已注册变量。第三个任务将显示我们为`iosv-1`主机收集的所有事实：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run the playbook, you can see that the result for the first two tasks
    were what we would have expected:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行playbook时，您会看到前两个任务的结果是我们预期的：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The third task will display all the network device facts gathered for iOS devices.
    There is a ton of information that has been gathered for iOS devices that can
    help with your networking automation needs:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个任务将显示为iOS设备收集的所有网络设备事实。已经收集了大量有关iOS设备的信息，可以帮助您进行网络自动化需求：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The network facts module in Ansible 2.5 was a big step forward in streamlining
    your workflow and brought it on par with other server modules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 2.5中的网络事实模块是简化工作流程的重要一步，并使其与其他服务器模块齐头并进。
- en: Network module conditional
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络模块条件
- en: 'Let''s take a look at another network device conditional example by using the
    comparison keyword we saw at the beginning of this chapter. We can take advantage
    of the fact that both IOSv and Arista EOS provide the outputs in JSON format for
    the `show` commands. For example, we can check the status of the interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用我们在本章开头看到的比较关键字来查看另一个网络设备条件示例。我们可以利用IOSv和Arista EOS都以JSON格式提供`show`命令的输出这一事实。例如，我们可以检查接口的状态：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we have an operation that we want to perform and it depends on `Ethernet1/3`
    being disabled in order to have no user impact, such as to ensure no users are
    actively connected to `Ethernet1/3`, we can use the following tasks in the `chapter5_3.yml` playbook.
    It uses the `eos_command` module to gather the interface state output, and checks
    the interface status using the `waitfor`  and `eq` keywords before proceeding
    to the next task:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个操作要执行，并且它取决于`Ethernet1/3`被禁用以确保没有用户影响，比如确保没有用户连接到`Ethernet1/3`，我们可以在`chapter5_3.yml`剧本中使用以下任务。它使用`eos_command`模块来收集接口状态输出，并在继续下一个任务之前使用`waitfor`和`eq`关键字来检查接口状态：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Upon the condition being met, the second task will be executed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在满足条件后，将执行第二个任务：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the interface is active, an error will be given as follows following the
    first task:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口处于活动状态，则将在第一个任务后给出错误如下：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Check out the other conditions such as `contains`, `greater than`, and `less
    than`, as they fit into your situation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其他条件，如`包含`，`大于`和`小于`，因为它们符合您的情况。
- en: Ansible loops
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible循环
- en: 'Ansible provides a number of loops in the playbook, such as standard loops,
    looping over files, subelements, do-until, and many more. In this section, we
    will look at two of the most commonly used loop forms: standard loops and looping
    over hash values.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible在playbook中提供了许多循环，例如标准循环，循环文件，子元素，do-until等等。在本节中，我们将看两种最常用的循环形式：标准循环和循环哈希值。
- en: Standard loops
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准循环
- en: 'Standard loops in playbooks are often used to easily perform similar tasks
    multiple times. The syntax for standard loops is very easy: the `{{ item }}` variable
    is the placeholder looping over the `with_items` list. For example, take a look
    at the following section in the `chapter5_4.yml` playbook:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: playbook中的标准循环经常用于轻松多次执行类似任务。标准循环的语法非常简单：`{{ item }}`变量是在`with_items`列表上循环的占位符。例如，看一下`chapter5_4.yml`
    playbook中的以下部分：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It will loop over the five list items with the same `echo` command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用相同的`echo`命令循环遍历五个列表项：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will combine the standard loop with the network command module in the `chapter5_5.yml` playbook
    to add multiple VLANs to the device:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`chapter5_5.yml` playbook中将标准循环与网络命令模块相结合，以向设备添加多个VLAN：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `with_items` list can also be read from a variable, which gives greater
    flexibility to the structure of your playbook:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_items`列表也可以从变量中读取，这样可以更灵活地构建playbook的结构：'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The standard loop is a great time saver when it comes to performing redundant
    tasks in a playbook. It also makes the playbook more readable by reducing the
    lines required for the task.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 标准循环在执行playbook中的冗余任务时是一个很好的时间节省器。它还通过减少任务所需的行数使playbook更易读。
- en: In the next section, we will take a look at looping over dictionaries.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何循环遍历字典。
- en: Looping over dictionaries
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环遍历字典
- en: Looping over a simple list is nice. However, we often have an entity with more
    than one attribute associated with it. If you think about the `vlan` example in
    the last section, each `vlan` would have several unique attributes to it, such
    as the `vlan` description, the gateway IP address, and possibly others. Oftentimes,
    we can use a dictionary to represent the entity to incorporate multiple attributes
    to it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历一个简单的列表很好。然而，我们经常有一个带有多个属性的实体。如果您考虑上一节中的`vlan`示例，每个`vlan`都会有一些独特的属性，比如`vlan`描述，网关IP地址，可能还有其他属性。通常，我们可以使用字典来表示实体，以将多个属性合并到其中。
- en: 'Let''s expand on the `vlan` example in the last section for a dictionary example
    in `chapter5_6.yml`. We defined the dictionary values for three `vlans`, each
    with a nested dictionary for the description and the IP address:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在上一节中的`vlan`示例中扩展为`chapter5_6.yml`中的字典示例。我们为三个`vlan`定义了字典值，每个值都有一个嵌套字典，用于描述和IP地址：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can configure the first task, `add vlans`, by using the key of the each
    of items as the `vlan` number:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用每个项目的键作为`vlan`号来配置第一个任务`add vlans`：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can proceed with configuring the `vlan` interfaces. Note that we use the `parents` parameter
    to uniquely identify the section the commands should be checked against. This
    is due to the fact that the description and the IP address are both configured
    under the `interface vlan <number>` subsection in the configuration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续配置`vlan`接口。请注意，我们使用`parents`参数来唯一标识应该针对哪个部分检查命令。这是因为描述和IP地址都是在配置中的`interface
    vlan <number>`子部分下配置的：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Upon execution, you will see the dictionary being looped through:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，您将看到字典被循环遍历：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s check if the intended configuration is applied to the device:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查所需的配置是否应用到设备上：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For more loop types of Ansible, feel free to check out the documentation ([http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible的更多循环类型，请随时查看文档（[http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html)）。
- en: Looping over dictionaries takes some practice the first few times you use them.
    But just like standard loops, looping over dictionaries will be an invaluable
    tool in your tool belt.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历字典在第一次使用时需要一些练习。但就像标准循环一样，循环遍历字典将成为您工具箱中的一个宝贵工具。
- en: Templates
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: For as long as I can remember, working as a network engineer, I have always
    used a kind of network template. In my experience, many of the network devices
    have sections of the network configuration that are identical, especially if these
    devices serve the same role in the network.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就我所记，作为一名网络工程师，我一直在使用一种网络模板。根据我的经验，许多网络设备的网络配置部分是相同的，特别是如果这些设备在网络中担任相同的角色。
- en: Most of the time, when we need to provision a new device, we use the same configuration
    in the form of a template, replace the necessary fields, and copy the file over
    to the new device. With Ansible, you can automate all of the work by using the
    template module ([http://docs.ansible.com/ansible/template_module.html](http://docs.ansible.com/ansible/template_module.html)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当我们需要为新设备进行配置时，我们使用相同的模板形式的配置，替换必要的字段，并将文件复制到新设备上。使用Ansible，您可以使用模板模块（[http://docs.ansible.com/ansible/template_module.html](http://docs.ansible.com/ansible/template_module.html)）自动化所有工作。
- en: The base template file we are using utilizes the Jinja2 template language ([http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)).
    We briefly discussed the Jinja2 templating language in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, and we will look at it a bit
    more here. Just like Ansible, Jinja2 has its own syntax and method of doing loops
    and conditionals; fortunately, we just need to know the very basics of it for
    our purpose. The Ansible template is an important tool that we will be using in
    our daily task, and we will spend more of this section exploring it. We will learn
    the syntax by gradually building up our playbook from simple to more complex.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的基本模板文件利用了Jinja2模板语言（[http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)）。我们在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中简要讨论了Jinja2模板语言，*Python自动化框架-
    Ansible基础*，我们将在这里更多地了解它。就像Ansible一样，Jinja2有自己的语法和循环和条件的方法；幸运的是，我们只需要了解它的基础知识就足够了。Ansible模板是我们日常任务中将要使用的重要工具，我们将在本节中更多地探索它。我们将通过逐渐从简单到更复杂地构建我们的playbook来学习语法。
- en: The basic syntax for template usage is very simple; you just need to specify
    the source file and the destination location that you want to copy it to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模板使用的基本语法非常简单；你只需要指定源文件和要复制到的目标位置。
- en: 'We will create an empty file for now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个空文件：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will use the following playbook to copy `file1` to `file2`. Note that
    the playbook is executed on the control machine only. Next, we will specify the
    path of both the source and destination files as arguments for the `template`
    module:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下playbook将`file1`复制到`file2`。请注意，playbook仅在控制机上执行。接下来，我们将为`template`模块的参数指定源文件和目标文件的路径：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We do not need to specify a host file during playbook execution since the localhost
    is available by default. However, you will get a warning:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbook执行期间，我们不需要指定主机文件，因为默认情况下localhost是可用的。但是，你会收到一个警告：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The source file can have any extension, but since they are processed through
    the Jinja2 template engine, let''s create a text file called `nxos.j2` as the
    template source. The template will follow the Jinja2 convention of using double
    curly brace to specify the variables:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件可以有任何扩展名，但由于它们是通过Jinja2模板引擎处理的，让我们创建一个名为`nxos.j2`的文本文件作为模板源。模板将遵循Jinja2的惯例，使用双大括号来指定变量：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Jinja2 template
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2模板
- en: 'Let''s also modify the playbook accordingly. In `chapter5_8.yml`, we will make
    the following changes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也相应地修改playbook。在`chapter5_8.yml`中，我们将进行以下更改：
- en: Change the source file to `nxos.j2`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源文件更改为`nxos.j2`
- en: Change the destination file to be a variable
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标文件更改为一个变量
- en: 'Provide the variable values as a dictionary that we will substitute in the
    template:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供作为字典的变量值，我们将在模板中进行替换：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After running the playbook, you will find the destination file called `nx-osv-1.conf`
    with the values filled in and ready to be used:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行playbook后，你会发现名为`nx-osv-1.conf`的目标文件已经填充好，可以使用了：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Jinja2 loops
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2循环
- en: 'We can also loop through a list as well as a dictionary in Jinja2\. We will
    use both as loops in `nxos.j2`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在Jinja2中循环遍历列表和字典。我们将在`nxos.j2`中使用这两种循环：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Provide the additional list and dictionary variables in the `chapter5_8.yml`
    playbook:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter5_8.yml` playbook中提供额外的列表和字典变量：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the playbook, and you will see the configuration for both `vlan` and `vlan_interfaces`
    filled in on the router config.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行playbook，你会看到路由器配置中`vlan`和`vlan_interfaces`的配置都已填写好。
- en: The Jinja2 conditional
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2条件
- en: 'Jinja2 also supports an `if` conditional check. Let''s add this field in for
    turning on the netflow feature for certain devices. We will add the following
    to the `nxos.j2` template:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2还支持`if`条件检查。让我们在某些设备上打开netflow功能的字段中添加这个条件。我们将在`nxos.j2`模板中添加以下内容：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will list out the difference in the playbook:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将列出playbook中的差异：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last step we will undertake is to make `nxos.j2` more scalable by placing
    the `vlan` interface section inside of a `true-false` conditional check. In the
    real world, more often than not, we will have multiple devices with knowledge
    of the `vlan` information, but only one device as the gateway for client hosts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的最后一步是通过将`nxos.j2`放置在`true-false`条件检查中，使其更具可扩展性。在现实世界中，我们往往会有多个设备了解`vlan`信息，但只有一个设备作为客户端主机的网关：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will also add a second device, called `nx-osv-2`, in the playbook:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在playbook中添加第二个设备，名为`nx-osv-2`：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are now ready to run our playbook:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备运行我们的playbook：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s check the differences in the two configuration files to make sure that
    the conditional changes are taking place:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两个配置文件的差异，以确保条件性的更改正在发生：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Neat, huh? This can certainly save us a ton of time for something that required
    repeated copy and paste before. Personally, the template module was a big game
    changer for me. This module alone was enough to motivate me to learn and use Ansible
    a few years ago.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很整洁，对吧？这肯定可以为我们节省大量时间，以前需要重复复制和粘贴。对我来说，模板模块是一个重大的改变。几年前，这个模块就足以激励我学习和使用Ansible。
- en: Our playbook is getting kind of long. In the next section, we will see how we
    can optimize the playbook by offloading the variable files into groups and directories.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook变得有点长了。在下一节中，我们将看到如何通过将变量文件转移到组和目录中来优化playbook。
- en: Group and host variables
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组和主机变量
- en: 'Note that, in the previous playbook, `chapter5_8.yml`, we have repeated ourselves
    in the username and password variables for the two devices under the `nexus_devices`
    variable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在之前的playbook`chapter5_8.yml`中，我们在`nexus_devices`变量下的两个设备的用户名和密码变量中重复了自己：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is not ideal. If we ever need to update the username and password values,
    we will need to remember to update at two locations. This increases the management
    burden as well as the chances of making mistakes. For a best practice, Ansible
    suggests that we use the `group_vars` and `host_vars` directories to separate
    out the variables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。如果我们需要更新用户名和密码的值，我们需要记住在两个位置更新。这增加了管理负担，也增加了出错的机会。作为最佳实践，Ansible建议我们使用`group_vars`和`host_vars`目录来分离变量。
- en: For more Ansible best practices, check out [http://docs.ansible.com/ansible/playbooks_best_practices.html](http://docs.ansible.com/ansible/playbooks_best_practices.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多Ansible最佳实践，请查看[http://docs.ansible.com/ansible/playbooks_best_practices.html](http://docs.ansible.com/ansible/playbooks_best_practices.html)。
- en: Group variables
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组变量
- en: By default, Ansible will look for group variables in the same directory as the
    playbook called `group_vars` for variables that can be applied to the group. By
    default, it will look for the filename that matches the group name in the inventory
    file. For example, if we have a group called `[nexus-devices]` in the inventory
    file, we can have a file under `group_vars` named `nexus-devices` to house all
    the variables that can be applied to the group.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible将在与playbook同一目录中寻找组变量，称为`group_vars`，用于应用于组的变量。默认情况下，它将在清单文件中匹配组名的文件名。例如，如果我们在清单文件中有一个名为`[nexus-devices]`的组，我们可以在`group_vars`下有一个名为`nexus-devices`的文件，其中包含可以应用于该组的所有变量。
- en: We can also use a special file named `all` to include variables applied to all
    the groups.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用名为`all`的特殊文件来包含应用于所有组的变量。
- en: 'We will utilize this feature for our username and password variables. First,
    we will create the `group_vars` directory:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用此功能来处理我们的用户名和密码变量。首先，我们将创建`group_vars`目录：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can create a YAML file called `all` to include the username and password:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个名为`all`的YAML文件来包含用户名和密码：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then use variables for the playbook:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在playbook中使用变量：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Host variables
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机变量
- en: 'We can further separate out the host variables in the same format as the group
    variables. This was how we were able to apply the variables in the Ansible 2.5
    playbook examples in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, and earlier in this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步以与组变量相同的格式分离主机变量。这就是我们能够在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中应用变量的Ansible
    2.5 playbook示例以及本章前面部分的方法：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In our case, we execute the commands on the localhost, and so the file under
    `host_vars` should be named accordingly, such as `host_vars/localhost`. In our
    `host_vars/localhost` file, we can also keep the variables declared in `group_vars`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们在本地主机上执行命令，因此`host_vars`下的文件应该相应地命名，例如`host_vars/localhost`。在我们的`host_vars/localhost`文件中，我们还可以保留在`group_vars`中声明的变量：
- en: '[PRE42]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After we separate out the variables, the playbook now becomes very lightweight
    and only consists of the logic of our operation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分离变量之后，playbook现在变得非常轻量，只包含我们操作的逻辑：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `group_vars` and `host_vars` directories not only decrease our operations
    overhead, they can also help with securing the files by allowing us to encrypt
    the sensitive information with Ansible Vault, which we will look at next.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_vars`和`host_vars`目录不仅减少了我们的操作开销，还可以通过允许我们使用Ansible Vault加密敏感信息来帮助保护文件，接下来我们将看一下。'
- en: The Ansible Vault
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Vault
- en: As you can see from the previous section, in most cases, the Ansible variable
    provides sensitive information such as a username and password. It would be a
    good idea to put some security measures around the variables so that we can safeguard
    against them. The Ansible Vault ([https://docs.ansible.com/ansible/2.5/user_guide/vault.html](https://docs.ansible.com/ansible/2.5/user_guide/vault.html))
    provides encryption for files so they appear in plaintext.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一节中可以看出，在大多数情况下，Ansible变量提供敏感信息，如用户名和密码。最好在变量周围采取一些安全措施，以便我们可以对其进行保护。Ansible
    Vault（[https://docs.ansible.com/ansible/2.5/user_guide/vault.html](https://docs.ansible.com/ansible/2.5/user_guide/vault.html)）为文件提供加密，使其呈现为明文。
- en: 'All Ansible Vault functions start with the `ansible-vault` command. You can
    manually create an encrypted file via the create option. You will be asked to
    enter a password. If you try to view the file, you will find that the file is
    not in clear text. If you have downloaded the book example, the password I used
    was just the word *password*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Ansible Vault函数都以`ansible-vault`命令开头。您可以通过create选项手动创建加密文件。系统会要求您输入密码。如果您尝试查看文件，您会发现文件不是明文。如果您已经下载了本书的示例，我使用的密码只是单词*password*：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To edit or view an encrypted file, we will use the `edit` option for edit or
    view the file via the `view` option:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑或查看加密文件，我们将使用`edit`选项编辑或通过`view`选项查看文件：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s encrypt the `group_vars/all and host_vars/localhost` variable files:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加密`group_vars/all`和`host_vars/localhost`变量文件：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, when we run the playbook, we will get a decryption failed error message:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行playbook时，我们将收到解密失败的错误消息：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will need to use the `--ask-vault-pass` option when we run the playbook:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行playbook时，我们需要使用`--ask-vault-pass`选项：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The decryption will happen in memory for any Vault-encrypted files that are
    accessed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何访问的Vault加密文件，解密将在内存中进行。
- en: Prior to Ansible 2.4, Ansible Vault required all the files to be encrypted with
    the same password. Since Ansible 2.4 and later, you can use vault ID to supply
    a different password file ([https://docs.ansible.com/ansible/2.5/user_guide/vault.html#multiple-vault-passwords](https://docs.ansible.com/ansible/2.5/user_guide/vault.html#multiple-vault-passwords)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.4之前，Ansible Vault要求所有文件都使用相同的密码进行加密。自Ansible 2.4及以后版本，您可以使用vault
    ID来提供不同的密码文件（[https://docs.ansible.com/ansible/2.5/user_guide/vault.html#multiple-vault-passwords](https://docs.ansible.com/ansible/2.5/user_guide/vault.html#multiple-vault-passwords)）。
- en: 'We can also save the password in a file and make sure that the specific file
    has restricted permission:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将密码保存在文件中，并确保特定文件具有受限权限：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can then execute the playbook with the `--vault-password-file` option:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`--vault-password-file`选项执行playbook：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can also encrypt just a string and embed the encrypted string inside of
    the playbook by using the `encrypt_string` option ([https://docs.ansible.com/ansible/2.5/user_guide/vault.html#use-encrypt-string-to-create-encrypted-variables-to-embed-in-yaml](https://docs.ansible.com/ansible/2.5/user_guide/vault.html#use-encrypt-string-to-create-encrypted-variables-to-embed-in-yaml)):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以仅加密一个字符串，并使用`encrypt_string`选项将加密的字符串嵌入到playbook中（[https://docs.ansible.com/ansible/2.5/user_guide/vault.html#use-encrypt-string-to-create-encrypted-variables-to-embed-in-yaml](https://docs.ansible.com/ansible/2.5/user_guide/vault.html#use-encrypt-string-to-create-encrypted-variables-to-embed-in-yaml)）：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The string can then be placed in the playbook file as a variable. In the next
    section, we will optimize our playbook even further with `include` and `roles`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将字符串放置在playbook文件中作为变量。在下一节中，我们将使用`include`和`roles`进一步优化我们的playbook。
- en: The Ansible include and roles
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible包括和角色
- en: The best way to handle complex tasks is to break them down into smaller pieces.
    Of course, this approach is common in both Python and network engineering. In
    Python, we break complicated code into functions, classes, modules, and packages.
    In networking, we also break large networks into sections such as racks, rows,
    clusters, and datacenters. In Ansible, we can use `roles` and `includes` to segment
    and organize a large playbook into multiple files. Breaking up a large Ansible
    playbook simplifies the structure as each of the files focuses on fewer tasks.
    It also allows the sections of the playbook to be reused.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 处理复杂任务的最佳方法是将它们分解成更小的部分。当然，这种方法在Python和网络工程中都很常见。在Python中，我们将复杂的代码分解成函数、类、模块和包。在网络中，我们也将大型网络分成机架、行、集群和数据中心等部分。在Ansible中，我们可以使用“roles”和“includes”将大型playbook分割和组织成多个文件。拆分大型Ansible
    playbook简化了结构，因为每个文件都专注于较少的任务。它还允许playbook的各个部分被重复使用。
- en: The Ansible include statement
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible包含语句
- en: As the playbook grows in size, it will eventually become obvious that many of
    the tasks and plays can be shared across different playbooks. The Ansible `include`
    statement is similar to many Linux configuration files that just tell the machine
    to extend the file the same way as if the file was directly written in. We can
    use an `include` statement for both playbooks and tasks. Here, we will look at
    a simple example of extending our task.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着playbook的规模不断增长，最终会显而易见，许多任务和操作可以在不同的playbook之间共享。Ansible“include”语句类似于许多Linux配置文件，只是告诉机器扩展文件的方式与直接编写文件的方式相同。我们可以在playbook和任务中使用include语句。在这里，我们将看一个扩展我们任务的简单示例。
- en: 'Let''s assume that we want to show outputs for two different playbooks. We
    can make a separate YAML file called `show_output.yml` as an additional task:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要显示两个不同playbook的输出。我们可以制作一个名为“show_output.yml”的单独的YAML文件作为附加任务：
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we can reuse this task in multiple playbooks, such as in `chapter5_11_1.yml`,
    which looks largely identical to the last playbook with the exception of registering
    the output and the include statement at the end:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在多个playbook中重用此任务，例如在“chapter5_11_1.yml”中，它与上一个playbook几乎相同，只是在最后注册输出和包含语句方面有所不同：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Another playbook, `chapter5_11_2.yml`, can reuse `show_output.yml` in the same
    way:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个playbook，“chapter5_11_2.yml”，可以以相同的方式重用“show_output.yml”：
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that both playbooks use the same variable name, `output`, because in `show_output.yml`,
    we hard coded the variable name for simplicity. You can also pass variables into
    the included file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个playbook使用相同的变量名“output”，因为在“show_output.yml”中，我们为简单起见硬编码了变量名。您还可以将变量传递到包含的文件中。
- en: Ansible roles
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible角色
- en: Ansible roles separate the logical function with a physical host to fit your
    network better. For example, you can construct roles such as spines, leafs, core,
    as well as Cisco, Juniper, and Arista. The same physical host can belong to multiple
    roles; for example, a device can belong to both Juniper and the core. This flexibility
    allows us to perform operations, such as upgrade all Juniper devices, without
    worrying about the device's location in the layer of the network.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色将逻辑功能与物理主机分开，以更好地适应您的网络。例如，您可以构建角色，如spines、leafs、core，以及Cisco、Juniper和Arista。同一物理主机可以属于多个角色；例如，设备可以同时属于Juniper和核心。这种灵活性使我们能够执行操作，例如升级所有Juniper设备，而不必担心设备在网络层中的位置。
- en: Ansible roles can automatically load certain variables, tasks, and handlers
    based on a known file infrastructure. The key is that this is a known file structure
    that we automatically include. In fact, you can think of roles as pre-made `include`
    statements by Ansible.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色可以根据已知的文件基础结构自动加载某些变量、任务和处理程序。关键是这是一个已知的文件结构，我们会自动包含。实际上，您可以将角色视为Ansible预先制作的“include”语句。
- en: The Ansible playbook role documentation ([http://docs.ansible.com/ansible/playbooks_roles.html#roles](http://docs.ansible.com/ansible/playbooks_roles.html#roles))
    describes a list of role directories that we can configure. We do not need to
    use all of them. In our example, we will only modify the `tasks and the vars`
    folders. However, it is good to know all of the available options in the Ansible
    role directory structure.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook角色文档（[http://docs.ansible.com/ansible/playbooks_roles.html#roles](http://docs.ansible.com/ansible/playbooks_roles.html#roles)）描述了我们可以配置的角色目录列表。我们不需要使用所有这些目录。在我们的示例中，我们只会修改“tasks和vars”文件夹。但是，了解Ansible角色目录结构中所有可用选项是很好的。
- en: 'The following is what we will use as an example for our roles:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将用作角色示例的内容：
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can see that, at the top level, we have the hosts file as well as the playbooks.
    We also have a folder named `roles`. Inside the folder, we have two roles defined:
    `cisco_nexus` and `spines`. Most of the subfolders under the roles were empty,
    with the exception of the `tasks and vars` folders. There is a file named `main.yml`
    inside each of them. This is the default behavior: the `main.yml` file is your
    entry point that is automatically included in the playbook when you specify the
    role in the playbook. If you need to break out additional files, you can use the
    include statement in the `main.yml` file.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在顶层，我们有主机文件以及playbooks。我们还有一个名为“roles”的文件夹。在文件夹内，我们定义了两个角色：“cisco_nexus”和“spines”。大多数角色下的子文件夹都是空的，除了“tasks和vars”文件夹。每个文件夹内都有一个名为“main.yml”的文件。这是默认行为：main.yml文件是您在playbook中指定角色时自动包含的入口点。如果您需要拆分其他文件，可以在main.yml文件中使用include语句。
- en: 'Here is our scenario:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的情景：
- en: We have two Cisco Nexus devices, `nxos-r1` and `nxos-r2`. We will configure
    the logging server as well as the log link-status for all of them, utilizing the
    `cisco_nexus` role for them.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有两个Cisco Nexus设备，“nxos-r1”和“nxos-r2”。我们将为它们所有配置日志服务器以及日志链路状态，利用“cisco_nexus”角色。
- en: In addition, nxos-r1 is also a spine device, where we will want to configure
    more verbose logging, perhaps because spines are at a more critical position within
    our network.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，nxos-r1也是一个脊柱设备，我们将希望配置更详细的日志记录，也许是因为脊柱在我们的网络中处于更关键的位置。
- en: 'For our `cisco_nexus` role, we have the following variables in `roles/cisco_nexus/vars/main.yml`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`cisco_nexus`角色，我们在`roles/cisco_nexus/vars/main.yml`中有以下变量：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We have the following configuration tasks in `roles/cisco_nexus/tasks/main.yml`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`roles/cisco_nexus/tasks/main.yml`中有以下配置任务：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our playbook is extremely simple, as it just needs to specify the hosts that
    we would like to configure according to `cisco_nexus role`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook非常简单，因为它只需要指定我们想要根据`cisco_nexus`角色配置的主机：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When you run the playbook, the playbook will include the tasks and variables
    defined in the `cisco_nexus` role and configure the devices accordingly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行playbook时，playbook将包括在`cisco_nexus`角色中定义的任务和变量，并相应地配置设备。
- en: 'For our `spine` role, we will have an additional task of more verbose logging
    in `roles/spines/tasks/mail.yml`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`spine`角色，我们将在`roles/spines/tasks/mail.yml`中有一个额外的更详细的日志记录任务：
- en: '[PRE59]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In our playbook, we can specify that it contains both the role of `cisco_nexus`
    as well as `spines`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的playbook中，我们可以指定它包含`cisco_nexus`角色和`spines`角色：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we include both roles in this order, the `cisco_nexus` role tasks will
    be executed, followed by the spines role:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按照这个顺序包括这两个角色时，`cisco_nexus`角色任务将被执行，然后是spines角色：
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Ansible roles are flexible and scalable – just like Python functions and classes.
    Once your code grows beyond a certain level, it is almost always a good idea to
    break it into smaller pieces for maintainability.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色是灵活和可扩展的，就像Python函数和类一样。一旦您的代码增长到一定程度，将其分解成更小的部分以便维护几乎总是一个好主意。
- en: You can find more examples of roles in the Ansible examples Git repository at
    [https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Ansible示例Git存储库中找到更多角色的示例，网址为[https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples)。
- en: '**Ansible Galaxy** ([https://docs.ansible.com/ansible/latest/reference_appendices/galaxy.html](https://docs.ansible.com/ansible/latest/reference_appendices/galaxy.html))
    is a free community site for finding, sharing, and collaborating on roles. You
    can see an example of the Juniper networks supplied by the Ansible role on Ansible
    Galaxy:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible Galaxy** ([https://docs.ansible.com/ansible/latest/reference_appendices/galaxy.html](https://docs.ansible.com/ansible/latest/reference_appendices/galaxy.html))是一个免费的社区网站，用于查找、共享和协作角色。您可以在Ansible
    Galaxy上查看由Juniper网络提供的Ansible角色的示例：'
- en: '![](assets/6809eca8-e5b1-4f7c-8fc6-f690fc747597.png)JUNOS Role on Ansible Galaxy
    ( [https://galaxy.ansible.com/Juniper/junos](https://galaxy.ansible.com/Juniper/junos))'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6809eca8-e5b1-4f7c-8fc6-f690fc747597.png)JUNOS Role on Ansible Galaxy
    ( [https://galaxy.ansible.com/Juniper/junos](https://galaxy.ansible.com/Juniper/junos))'
- en: In the next section, we will take a look at how to write our own custom Ansible
    module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下如何编写我们自己的自定义Ansible模块。
- en: Writing your own custom module
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您自己的自定义模块
- en: By now, you may get the feeling that network management in Ansible is largely
    dependent on finding the right module for your task. There is certainly a lot
    of truth in that logic. Modules provide a way to abstract the interaction between
    the managed host and the control machine; they allow us to focus on the logic
    of our operations. Up to this point, we have seen the major vendors providing
    a wide range of modules for Cisco, Juniper, and Arista.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能会感到Ansible中的网络管理在很大程度上取决于找到适合您任务的正确模块。这种逻辑中肯定有很多道理。模块提供了一种抽象管理主机和控制机之间交互的方式；它们允许我们专注于我们操作的逻辑。到目前为止，我们已经看到主要供应商为Cisco、Juniper和Arista提供了各种模块。
- en: Use the Cisco Nexus modules as an example, besides specific tasks such as managing
    the BGP neighbor (`nxos_bgp`) and the aaa server (`nxos_aaa_server`). Most vendors
    also provide ways to run arbitrary show (`nxos_config`) and configuration commands
    (`nxos_config`). This generally covers most of our use cases.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以Cisco Nexus模块为例，除了特定任务，如管理BGP邻居(`nxos_bgp`)和aaa服务器(`nxos_aaa_server`)。大多数供应商还提供了运行任意show(`nxos_config`)和配置命令(`nxos_config`)的方法。这通常涵盖了我们大部分的用例。
- en: Starting with Ansible 2.5, there is also the streamline naming and usage of
    network facts modules.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ansible 2.5开始，还有网络事实模块的简化命名和用法。
- en: What if the device you are using does not currently have the module for the
    task that you are looking for? In this section, we will look at several ways that
    we can remedy this situation by writing our own custom module.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的设备当前没有您正在寻找的任务的模块怎么办？在本节中，我们将看一下几种方法，通过编写我们自己的自定义模块来解决这种情况。
- en: The first custom module
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个自定义模块
- en: Writing a custom module does not need to be complicated; in fact, it doesn't
    even need to be in Python. But since we are already familiar with Python, we will
    use Python for our custom modules. We are assuming that the module is what we
    will be using ourselves and our team without submitting back to Ansible, therefore
    we will ignore some of the documentation and formatting for the time being.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义模块并不需要复杂；实际上，它甚至不需要用Python编写。但是由于我们已经熟悉Python，我们将使用Python来编写我们的自定义模块。我们假设该模块是我们自己和我们的团队将使用的，而不需要提交给Ansible，因此我们将暂时忽略一些文档和格式。
- en: If you are interested in developing modules that can be submitted upstream to
    Ansible, please consult the developing modules guide from Ansible ([https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣开发可以提交到Ansible的模块，请参阅Ansible的模块开发指南([https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html))。
- en: 'By default, if we create a folder named `library` in the same directory as
    the playbook, Ansible will include the directory in the module search path. Therefore,
    we can put our custom module in the directory and we will be able to use it in
    our playbook. The requirement for the custom module is very simple: all the module
    needs is to return a JSON output to the playbook.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们在与playbook相同的目录中创建一个名为`library`的文件夹，Ansible将包括该目录在模块搜索路径中。因此，我们可以将我们的自定义模块放在该目录中，并且我们将能够在我们的playbook中使用它。自定义模块的要求非常简单：模块只需要返回JSON输出给playbook。
- en: 'Recall that in [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs
    and Intent-Driven Networking*, we used the following NXAPI Python script to communicate
    to the NX-OS device:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml) *API和意图驱动的网络*中，我们使用以下NXAPI
    Python脚本与NX-OS设备进行通信：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When we executed it, we simply received the system version. We can simply modify
    the last line to be a JSON output, as shown in the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行它时，我们只是收到了系统版本。我们可以简单地修改最后一行为JSON输出，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will place this file under the `library` folder:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个文件放在`library`文件夹下：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In our playbook, we can then use the action plugin ([https://docs.ansible.com/ansible/dev_guide/developing_plugins.html](https://docs.ansible.com/ansible/dev_guide/developing_plugins.html)),
    `chapter5_14.yml`, to call this custom module:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的剧本中，我们可以使用动作插件([https://docs.ansible.com/ansible/dev_guide/developing_plugins.html](https://docs.ansible.com/ansible/dev_guide/developing_plugins.html))
    `chapter5_14.yml`来调用这个自定义模块：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note that, just like the `ssh` connection, we are executing the module locally
    with the module making API calls outbound. When you execute this playbook, you
    will get the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，就像`ssh`连接一样，我们正在本地执行模块，并且模块正在进行API调用。当你执行这个剧本时，你将得到以下输出：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, you can write any module that is supported by API, and Ansible
    will happily take any returned JSON output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以编写任何受API支持的模块，Ansible将乐意接受任何返回的JSON输出。
- en: The second custom module
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个自定义模块
- en: Building upon the last module, let's utilize the common module boilerplate from
    Ansible that's stated in the module development documentation ([http://docs.ansible.com/ansible/dev_guide/developing_modules_general.html](http://docs.ansible.com/ansible/dev_guide/developing_modules_general.html)).
    We will modify the last custom module and create `custom_module_2.py` to ingest
    inputs from the playbook.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个模块的基础上，让我们利用Ansible中的常见模块样板，该样板在模块开发文档中有说明([http://docs.ansible.com/ansible/dev_guide/developing_modules_general.html](http://docs.ansible.com/ansible/dev_guide/developing_modules_general.html))。我们将修改最后一个自定义模块，并创建`custom_module_2.py`来接收剧本中的输入。
- en: 'First, we will import the boilerplate code from `ansible.module_utils.basic`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`ansible.module_utils.basic`导入样板代码：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'From there, we can define the main function where we will house our code. `AnsibleModule`,
    which we have already imported, provides lots of common code for handling returns
    and parsing arguments. In the following example, we will parse three arguments
    for `host`, `username`, and `password`, and make them required fields:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义主要函数，我们将在其中放置我们的代码。`AnsibleModule`，我们已经导入了，提供了处理返回和解析参数的常见代码。在下面的示例中，我们将解析`host`、`username`和`password`三个参数，并将它们作为必填字段：
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The values can then be retrieved and used in our code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以检索这些值并在我们的代码中使用：
- en: '[PRE69]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, we will follow the exit code and return the value:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将跟踪退出代码并返回值：
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our new playbook, `chapter5_15.yml`, will look identical to the last playbook,
    except now we can pass values for different devices in the playbook:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新剧本`chapter5_15.yml`将与上一个剧本相同，只是现在我们可以在剧本中为不同的设备传递值：
- en: '[PRE71]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When executed, this playbook will produce the exact same output as the last
    playbook. However, because we are using arguments in the custom module, the custom
    module can now be passed around for other people to use without them knowing the
    details of our module. They can write in their own username, password, and host
    IP in the playbook.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，这个剧本将产生与上一个剧本完全相同的输出。但是，因为我们在自定义模块中使用了参数，所以现在可以将自定义模块传递给其他人使用，而不需要他们了解我们模块的细节。他们可以在剧本中写入自己的用户名、密码和主机IP。
- en: Of course, this is a functional but incomplete module. For one, we did not perform
    any error checking, nor did we provide any documentation for usage. However, it
    is a good demonstration of how easy it is to build a custom module. The additional
    benefit is that we saw how we can use an existing script that we already made
    and turn it into a custom Ansible module.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个功能齐全但不完整的模块。首先，我们没有进行任何错误检查，也没有为使用提供任何文档。但是，这是一个很好的演示，展示了构建自定义模块有多么容易。额外的好处是，我们看到了如何使用我们已经制作的现有脚本，并将其转换为自定义的Ansible模块。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of ground. Building from our previous knowledge
    of Ansible, we expanded into more advanced topics such as conditionals, loops,
    and templates. We looked at how to make our playbook more scalable with host variables,
    group variables, include statements, and roles. We also looked at how to secure
    our playbook with the Ansible Vault. Finally, we used Python to make our own custom
    modules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。基于我们之前对Ansible的了解，我们扩展到了更高级的主题，如条件、循环和模板。我们看了如何通过主机变量、组变量、包含语句和角色使我们的剧本更具可扩展性。我们还看了如何使用Ansible
    Vault保护我们的剧本。最后，我们使用Python制作了自己的自定义模块。
- en: Ansible is a very flexible Python framework that can be used for network automation.
    It provides another abstraction layer separated from the likes of the Pexpect
    and API-based scripts. It is declarative in nature in that it is more expressive
    in terms of matching our intent. Depending on your needs and network environment,
    it might be the ideal framework that you can use to save time and energy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个非常灵活的Python框架，可以用于网络自动化。它提供了另一个抽象层，与Pexpect和基于API的脚本分开。它在性质上是声明式的，更具表达性，符合我们的意图。根据你的需求和网络环境，它可能是你可以用来节省时间和精力的理想框架。
- en: In [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml), *Network Security
    with Python*, we will look at network security with Python.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml) *使用Python进行网络安全*中，我们将使用Python进行网络安全。
