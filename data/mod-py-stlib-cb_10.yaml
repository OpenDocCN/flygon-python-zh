- en: Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: 'In this chapter, we will cover following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Sending emails—sending emails from your application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件-从您的应用程序发送电子邮件
- en: Fetching emails—checking and reading newly-received emails in a folder
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取电子邮件-检查并阅读新收到的邮件
- en: FTP—uploading, listing, and downloading files from FTP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP-从FTP上传、列出和下载文件
- en: Sockets—writing a chat system based on TCP/IP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字-基于TCP/IP编写聊天系统
- en: AsyncIO—an asynchronous HTTP server for static files based on coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncIO-基于协程的异步HTTP服务器，用于静态文件
- en: Remote procedure calls—implementing RPC through XMLRPC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程过程调用-通过XMLRPC实现RPC
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Modern-day applications frequently need to interact with users or other software
    through networks. The more our society moves toward a connected world, the more
    users will expect software to be able to interact with remote services or across
    networks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序经常需要通过网络与用户或其他软件进行交互。我们的社会越向连接的世界发展，用户就越希望软件能够与远程服务或网络进行交互。
- en: Networking-based applications rely on decades of stable and widely-tested tools
    and paradigms, and the Python standard library provides support for the most common
    technologies, from transport to application protocols.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的应用程序依赖于几十年来稳定且经过广泛测试的工具和范例，Python标准库提供了对从传输到应用程序协议的最常见技术的支持。
- en: Apart from providing support for the communication channels themselves, such
    as sockets, the standard library also provides the models to implement event-based
    applications that are typical of networking use cases as in most cases, the application
    will have to react to an input coming from the network and handle it accordingly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供对通信通道本身（如套接字）的支持外，标准库还提供了实现基于事件的应用程序模型，这些模型是网络使用案例的典型，因为在大多数情况下，应用程序将不得不对来自网络的输入做出反应并相应地处理它。
- en: In this chapter, we will see how to handle some of the most common application
    protocols, such as SMTP, IMAP, and FTP. But we will also see how to handle networking
    directly through sockets and how to implement our own protocol for RPC communication.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何处理一些最常见的应用程序协议，如SMTP、IMAP和FTP。但我们还将看到如何通过套接字直接处理网络，并如何实现我们自己的RPC通信协议。
- en: Sending emails
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Emails are the most widespread communication tool nowadays, if you're on the
    internet, it's pretty much granted you have an email address and they are now
    highly integrated in smartphones too, so are accessible on the go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件是当今最广泛使用的通信工具，如果您在互联网上，几乎可以肯定您有一个电子邮件地址，它们现在也高度集成在智能手机中，因此可以随时随地访问。
- en: For all those reasons, emails are the preferred tools for sending notifications
    to users, reports of completion, and results of long-running processes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，电子邮件是向用户发送通知、完成报告和长时间运行进程结果的首选工具。
- en: Sending emails requires some machinery and both the SMTP and MIME protocols
    are quite articulated if you want to support them by yourself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件需要一些机制，如果您想自己支持SMTP和MIME协议，这两种协议都相当复杂。
- en: Luckily, the Python standard library comes with built-in support for both and
    we can rely on the `smtplib` module to interact with the SMTP server to send our
    email and on `email` package to actually create the content of the email and tackle
    all the special formats and encoding required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python标准库内置支持这两种情况，我们可以依赖`smtplib`模块与SMTP服务器交互以发送我们的电子邮件，并且可以依赖`email`包来实际创建电子邮件的内容并处理所需的所有特殊格式和编码。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Sending an email is a three-step process:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件是一个三步过程：
- en: Contact the SMTP server and authenticate to it
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系SMTP服务器并对其进行身份验证
- en: Prepare the email itself
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备电子邮件本身
- en: Provide the email to the SMTP server
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向SMTP服务器提供电子邮件
- en: 'All three phases are covered in the Python standard library and we just need
    to wrap them up for convenience in an easier interface:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中涵盖了所有三个阶段，我们只需要将它们包装起来，以便在更简单的接口中方便使用：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `EmailSender` class can be used to easily send emails through our email
    provider:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`EmailSender`类可用于轻松通过我们的电子邮件提供商发送电子邮件。
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Sending an email requires connecting to an SMTP server, this requires data,
    such as the host on which the server is running, the port where it's exposed,
    and a username and password to authenticate against it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件需要连接到SMTP服务器，这需要数据，如服务器运行的主机、暴露的端口以及用于对其进行身份验证的用户名和密码。
- en: 'All these details will be needed every time we want to send an email, as each
    email will require a separate connection. So, those are all details that our class
    in charge of sending email will always need to have available and thus are requested
    when the instance is created:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要发送电子邮件时，都需要所有这些细节，因为每封电子邮件都需要单独的连接。因此，这些都是我们负责发送电子邮件的类始终需要可用的所有细节，并且在创建实例时请求：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once all the details required to connect to the SMTP server are known, the
    only exposed method of our class is the one to actually send the emails:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道连接到SMTP服务器所需的所有细节，我们类的唯一公开方法就是实际发送电子邮件的方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Which requires the details needed to compose the email: the sender address,
    the address receiving the email, a subject, and the content of the email itself.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要组成电子邮件所需的细节：发件人地址、接收电子邮件的地址、主题和电子邮件内容本身。
- en: 'Our method has to parse the provided sender and recipient. The part with the
    name of the sender and recipient is separated from the part containing the address:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法必须解析提供的发件人和收件人。包含发件人和收件人名称的部分与包含地址的部分是分开的：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `sender` was something like `"Alessandro Molina <amol@myserver.it>"`, `sender_name` would
    be `"Alessandro Molina"` and `sender_addr` would be `"amol@myserver.it"`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sender`类似于`"Alessandro Molina <amol@myserver.it>"`，`sender_name`将是`"Alessandro
    Molina"`，`sender_addr`将是`"amol@myserver.it"`。
- en: This is required because the name part will frequently contain names that are
    not constrained to plain ASCII, the mail might be delivered to China, or Korea,
    or any other place where you would have to properly support Unicode to handle
    recipient names.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必需的，因为名称部分通常包含不受限于纯ASCII的名称，邮件可能会发送到中国、韩国或任何其他需要正确支持Unicode以处理收件人名称的地方。
- en: 'So we have to properly encode those characters in a way that mail clients will
    understand when receiving the email, and that is done by using the `Header` class
    with the provided character set encoding, which in our case was `"UTF-8"`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须以一种邮件客户端在接收电子邮件时能够理解的方式正确编码这些字符，这是通过使用提供的字符集编码的`Header`类来完成的，在我们的情况下是`"UTF-8"`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the sender and recipient names are encoded in the format expected by email
    headers, we can join them back with the address part to build back a full recipient
    and sender in the `"Name <address>"` form:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发件人和收件人的名称以电子邮件标题所期望的格式进行编码，我们就可以将它们与地址部分结合起来，以构建回一个完整的收件人和发件人，形式为`"Name <address>"`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The same goes for `Subject`, which being a header field of the mail needs to
    be encoded too:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的情况也适用于“主题”，作为邮件的一个标题字段，也需要进行编码：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The body of the message instead doesn't have to be encoded as a header and can
    be provided as its plain-bytes representation in any encoding as far as the encoding
    is specified.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，消息的正文不必作为标题进行编码，并且可以以任何编码的纯字节表示形式提供，只要指定了编码。
- en: 'In our case, the message was built with a body encoded to `UTF-8` too:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，消息的正文也被编码为`UTF-8`：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, once the message itself is ready and both the body and headers are properly
    encoded, the only part left is actually getting in touch with the SMTP server
    and sending the email.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦消息本身准备就绪，正文和标题都被正确编码，唯一剩下的部分就是实际与SMTP服务器取得联系并发送电子邮件。
- en: 'This is done by creating an `SMTP` object for the known address and port:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过创建一个已知地址和端口的`SMTP`对象来完成的：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, in case the SMTP server supports encryption through TLS, we start it.
    If it doesn''t, we just ignore the error and proceed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果SMTP服务器支持TLS加密，我们就启动它。如果不支持，我们就忽略错误并继续：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once encryption is enabled, if available, we can finally authenticate against
    the SMTP server and send the mail itself to the involved recipient:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了加密（如果可用），我们最终可以对SMTP服务器进行身份验证，并将邮件本身发送给相关的收件人：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To test that encoding is working as you would expect, you can try sending an
    email with characters that are out of the standard ASCII plane to see whether
    your client properly understands the email:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试编码是否按预期工作，您可以尝试发送一封包含标准ASCII字符之外字符的电子邮件，以查看您的客户端是否正确理解了电子邮件：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If everything worked as expected, you should be able to authenticate against
    your SMTP provider, send the email and see it in your inbox with the proper content.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都按预期进行，您应该能够对SMTP提供程序进行身份验证，发送电子邮件，并在收件箱中看到具有适当内容的电子邮件。
- en: Fetching emails
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取电子邮件
- en: Frequently, applications need to react to some kind of event, they receive a
    message from a user or software and they need to act accordingly. The whole nature
    of networking-based applications lies in reacting to received messages, but a
    very specific and common case of this class of applications are applications that
    need to react to received emails.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，应用程序需要对某种事件做出反应，它们接收来自用户或软件的消息，然后需要相应地采取行动。基于网络的应用程序的整体性质在于对接收到的消息做出反应，但这类应用程序的一个非常特定和常见的情况是需要对接收到的电子邮件做出反应。
- en: The typical case is when a user needs to send some kind of document to your
    application (usually an ID card or signed contracts) and you want to react to
    that event, such as enabling the service once the user sent the signed contract.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 典型情况是，当用户需要向您的应用程序发送某种文档（通常是身份证或签署的合同）时，您希望对该事件做出反应，例如在用户发送签署的合同后启用服务。
- en: This requires us to be able to access the received emails and scan through them
    to detect sender and content.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们能够访问收到的电子邮件并扫描它们以检测发件人和内容。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤如下：
- en: 'Using `imaplib` and `email` modules, it''s possible to build a working IMAP
    client to fetch the most recent messages from a supported IMAP server:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`imaplib`和`email`模块，可以构建一个工作的IMAP客户端，从支持的IMAP服务器中获取最近的消息：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`IMAPReader` can then be used to access a compatible mail server to read the
    most recent emails:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以使用`IMAPReader`访问兼容的邮件服务器以阅读最近的电子邮件：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This returns the title and timestamp of the last two received emails:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这返回了最近两封收到的电子邮件的标题和时间戳：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we need the actual email content and attachments, we can retrieve them by
    using `peek=False` and then calling `IMAPReader.get_message_body` on the retrieved
    messages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要实际的电子邮件内容和附件，我们可以通过使用`peek=False`来检索它们，然后在检索到的消息上调用`IMAPReader.get_message_body`。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: Our class acts as a wrapper over the `imaplib` and `email` modules, providing
    an easier-to-use interface for the need of fetching mail from a folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类充当了`imaplib`和`email`模块的包装器，为从文件夹中获取邮件的需求提供了一个更易于使用的接口。
- en: 'There are actually two different objects that can be created from `imaplib`
    to connect to an IMAP server, one that uses SSL and one that doesn''t. Depending
    on what''s required by your server, you might have to turn it on or off (for example,
    Gmail requires SSL) and that''s abstracted in `__init__`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以从`imaplib`创建两种不同的对象来连接到IMAP服务器，一种使用SSL，一种不使用。根据服务器的要求，您可能需要打开或关闭它（例如，Gmail需要SSL），这在`__init__`中进行了抽象处理：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `__init__` method also takes care of logging you against the IMAP server,
    so that the once the reader is created, it's immediately usable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法还负责登录到IMAP服务器，因此一旦创建了阅读器，它就可以立即使用。'
- en: 'Our reader then provides methods to list folders, so in case you want to read
    messages from all folders or you want to allow users to pick a folder, it''s possible:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的阅读器提供了列出文件夹的方法，因此，如果您想要从所有文件夹中读取消息，或者您想要允许用户选择文件夹，这是可能的：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first thing our `folders` method does is grab the list of folders from
    the server. The `imaplib` methods already report exceptions themselves in case
    there is an error, but as a safety net, we also check that the response is `OK`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`folders`方法的第一件事是从服务器获取文件夹列表。`imaplib`方法已经在出现错误时报告异常，但作为安全措施，我们还检查响应是否为`OK`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: IMAP is a text-based protocol and the server is supposed to always respond `OK
    <response>` if it was able to understand your request and serve a response. Otherwise,
    a bunch of alternative response codes, such as `NO` or `BAD`, can be returned.
    In case any of those is returned, we consider our request failed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: IMAP是一种基于文本的协议，服务器应该始终响应`OK <response>`，如果它能够理解您的请求并提供响应。否则，可能会返回一堆替代响应代码，例如`NO`或`BAD`。如果返回了其中任何一个，我们认为我们的请求失败了。
- en: 'Once we make sure we actually have the folders list, we need to parse it. The
    list is constituted by multiple lines of text. Each line contains details about
    exactly one folder, the details: flags and folder name. Those are separated by
    a separator, which is not standard. On some servers, it''s a dot, while on others,
    it''s a slash, so we need to be pretty flexible when parsing it. That''s why we
    parse it with a regular expression that allows flags and a name separated by any
    separator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确保实际上有文件夹列表，我们需要解析它。列表由多行文本组成。每行包含有关一个文件夹的详细信息，这些详细信息：标志和文件夹名称。它们由一个分隔符分隔，这不是标准的。在某些服务器上，它是一个点，而在其他服务器上，它是一个斜杠，因此我们在解析时需要非常灵活。这就是为什么我们使用允许标志和名称由任何分隔符分隔的正则表达式来解析它：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we know how to parse those lines from the response, we can just build
    a list of dictionaries out of them that contain the name and the flags for those
    folders:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道如何解析响应中的这些行，我们就可以根据它们构建一个包含名称和这些文件夹的标志的字典列表：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The flags themselves can then be parsed further using the `imaplib.ParseFlags`
    class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用`imaplib.ParseFlags`类进一步解析这些标志。
- en: 'Once we know the name of the folder we want to fetch messages for, we can retrieve
    the messages through the `messages` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道要获取消息的文件夹的名称，我们就可以通过`messages`方法检索消息：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As IMAP is a stateful protocol, the first thing we need to do is select the
    folder for which we want to run subsequent commands:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IMAP是一种有状态的协议，我们需要做的第一件事是选择我们想要运行后续命令的文件夹：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We provide a `readonly` option so we can't inadvertently destroy our emails,
    and we verify the response code as usual.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供一个`readonly`选项，这样我们就不会无意中销毁我们的电子邮件，并像往常一样验证响应代码。
- en: Then the content of the response of the `select` method is actually the ID of
    the last message that was uploaded to that folder.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`select`方法的响应内容实际上是上传到该文件夹的最后一条消息的ID。
- en: 'As those IDs are incremental numbers, we can use it to generate the IDs of
    the last `limit` messages to fetch the most recent messages:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些ID是递增的数字，我们可以使用它来生成要获取的最近消息的最后`limit`条消息的ID：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, based on the caller choice, we select what we want to download of those
    messages. If only the headers or the whole content:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据调用者的选择，我们选择要下载的消息的内容。如果只有标题或整个内容：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The mode will be provided to the `fetch` method to tell it what data we want
    to download:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模式将被提供给`fetch`方法，告诉它我们要下载什么数据：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The message itself is then composed as a list that contains a tuple of two
    elements. The first element contains the size and mode the message is returned
    in (as we provided the mode ourselves, we don''t really care), and the last element
    of the tuple contains the message itself, so we just grab it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，消息本身被组合成一个包含两个元素的元组列表。第一个元素包含消息返回的大小和模式（由于我们自己提供了模式，所以我们并不真的在乎），元组的最后一个元素包含消息本身，所以我们只需抓取它：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have the message available, we feed it to `BytesParser` so that we
    can get back a `Message` instance:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了可用的消息，我们将其提供给`BytesParser`，以便我们可以得到一个`Message`实例：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We loop over all the messages, parse them, and add to the list of messages
    that we will return. We stop as soon as we reach the desired amount of messages:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环遍历所有消息，解析它们，并添加到我们将返回的消息列表中。一旦达到所需数量的消息，我们就停止：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the `messages` method, we get back a list of `Message` objects, for which
    we can easily access all data, apart from the body of the message itself. Because
    the body might actually be composed by multiple items (think of a message with
    attachments – it has text, images, PDF files, or whatever was attached).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从`messages`方法中，我们得到一个`Message`对象的列表，我们可以轻松访问除消息正文之外的所有数据。因为正文实际上可能由多个项目组成（想象一条带附件的消息
    - 它包含文本、图像、PDF文件或任何附件）。
- en: 'For this reason, the reader provides a `get_message_body` method that retrieves
    all the parts of the message body in case it''s a multipart message and returns
    them:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，读取器提供了一个`get_message_body`方法，用于检索消息正文的所有部分（如果是多部分消息），并将它们返回：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Combining the `messages` and `get_message_body` methods, we are able to grab
    messages and their content from a mailbox, and then process them however we need.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合`messages`和`get_message_body`方法，我们能够从邮箱中抓取消息及其内容，然后根据需要对其进行处理。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Writing a feature-complete and fully functioning IMAP client is a standalone
    project that is outside the scope of this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个功能完备且完全运行的IMAP客户端是一个独立的项目，超出了本书的范围。
- en: IMAP is a complex protocol that includes support for flags, searching, and many
    more features. Most of these commands are provided by `imaplib` and it's also
    possible to upload messages to the server or create tools to perform backups or
    copy messages from one mail account to another.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: IMAP是一个复杂的协议，包括对标志、搜索和许多其他功能的支持。大多数这些命令都由`imaplib`提供，还可以上传消息到服务器或创建工具来执行备份或将消息从一个邮件帐户复制到另一个邮件帐户。
- en: Also, when parsing complex emails, the `email` module will handle the various
    representation of data specified by the email-related RFCs, for example, our recipe
    returns dates as a string, but `email.utils.parsedate` can parse them to Python
    objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当解析复杂的电子邮件时，`email`模块将处理电子邮件相关的RFCs指定的各种数据表示，例如，我们的示例将日期返回为字符串，但`email.utils.parsedate`可以将其解析为Python对象。
- en: FTP
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP
- en: FTP is the most widely-used solution to save and retrieve files from a remote
    server. It has been around for decades and it's a fairly easy protocol to use
    that can deliver good performance as it provides minimal overhead over transferred
    content, while supporting powerful features, such as transfer recovery.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: FTP是保存和从远程服务器检索文件的最广泛使用的解决方案。它已经存在了几十年，是一个相当容易使用的协议，可以提供良好的性能，因为它在传输内容上提供了最小的开销，同时支持强大的功能，如传输恢复。
- en: Often, software needs to receive files automatically uploaded by other software;
    FTP has been frequently used as a robust solution in these scenarios over the
    years. Whether your software is the one in need of uploading the content or the
    one that has to receive it, the Python standard library has support for FTP built-in
    so we can rely on `ftplib` to use the FTP protocol.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件需要接收由其他软件自动上传的文件；多年来，FTP一直被频繁地用作这些场景中的强大解决方案。无论您的软件是需要上传内容的软件，还是需要接收内容的软件，Python标准库都内置了对FTP的支持，因此我们可以依靠`ftplib`来使用FTP协议。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`ftplib` is a powerful foundation on which we can provider an easier API to
    interact with an FTP server, both to store and retrieve files:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ftplib`是一个强大的基础，我们可以在其上提供一个更简单的API来与FTP服务器进行交互，用于存储和检索文件：'
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we can test our class by uploading and fetching back a simple file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过上传和获取一个简单的文件来测试我们的类：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If everything worked as expected, the output should be `Hello World!`
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，输出应该是`Hello World!`
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `FTPClient` class provides an initializer that is in charge of setting up
    the correct connection to the server and a bunch of methods to actually do work
    against the connected server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTPClient`类提供了一个初始化程序，负责设置与服务器的正确连接以及一堆方法来实际对连接的服务器进行操作。'
- en: '`__init__` does quite a lot of work to try setting up the proper connection
    to the remote server:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`做了很多工作，尝试建立与远程服务器的正确连接：'
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First it tries a TLS connection, which guarantees encrypting, because otherwise
    FTP is a plain-text protocol that would send all out data in a clear text way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先它尝试建立TLS连接，这可以保证加密，否则FTP是一种明文协议，会以明文方式发送所有数据。
- en: If our remote server supports TLS, it is enabled on the control connection by
    calling `.auth()` and then on the data-transfer connection by calling `prot_p()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的远程服务器支持TLS，可以通过调用`.auth()`在控制连接上启用它，然后通过调用`prot_p()`在数据传输连接上启用它。
- en: FTP is based on two kinds of connections, the control connection where we send
    and receive the commands for the server and their result, and a data connection
    where we send the uploaded and downloaded data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: FTP基于两种连接，控制连接用于发送和接收服务器的命令及其结果，数据连接用于发送上传和下载的数据。
- en: If possible, both of them should be encrypted. If our server doesn't support
    them, we fall back to a plain FTP connection and proceed by just authenticating
    against it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，它们两者都应该加密。如果我们的服务器不支持它们，我们将退回到普通的FTP连接，并继续通过对其进行身份验证来进行操作。
- en: If your server doesn't require any authentication, providing `anonymous` as
    the username with an empty password is usually enough to get in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务器不需要任何身份验证，提供`anonymous`作为用户名，空密码通常足以登录。
- en: 'Once we are connected, we are free to move around the server, and that can
    be done with the `cwd` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接上了，我们就可以自由地在服务器上移动，可以使用`cwd`命令来实现：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method is just a proxy to the internal client one, as the internal one
    is already easy to use and fully functional.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是内部客户端方法的代理，因为内部方法已经很容易使用并且功能齐全。
- en: 'But once we get into a directory, we need to fetch its content and here''s
    where the `dir()` method comes into play:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦我们进入一个目录，我们需要获取它的内容，这就是`dir()`方法发挥作用的地方：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `dir()` method calls the `mlsd` method of the internal client, which is
    in charge of returning the list of files in the current directory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir()`方法调用内部客户端的`mlsd`方法，负责返回当前目录中文件的列表。'
- en: 'This list is returned as a tuple of two elements:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表被返回为一个包含两个元素的元组：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first entry of the tuple contains the filename, while the second contains
    its properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的第一个条目包含文件名，而第二个条目包含其属性。
- en: Our own method does just two additional steps, it skips the first returned entry—as
    that is always the current directory (the one we picked with `cwd())`—and then
    skips any special entry for the parent or current directory. We are not really
    interested in them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的方法只做了两个额外的步骤，它跳过了第一个返回的条目——因为那总是当前目录（我们用`cwd()`选择的目录）——然后跳过了任何特殊的父目录或当前目录的条目。我们对它们并不感兴趣。
- en: 'Once we are able to move around the structure of the directories, we can finally
    `upload` and `download` files into those directories:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够在目录结构中移动，我们最终可以将文件`upload`和`download`到这些目录中：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Those two methods are pretty straightforward, they just open local files for
    reading when we upload and for writing when we download, and send the FTP command
    required to retrieve or store a file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法非常简单，当我们上传文件时，它们只是打开本地文件进行读取，当我们下载文件时，它们只是打开本地文件进行写入，并发送FTP命令来检索或存储文件。
- en: When uploading a new `remotefile`, a file will be created with the same content
    that `localfile` had. When downloading, `localfile` is opened to write inside
    it the content that `remotefile` has.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当上传一个新的`remotefile`时，将创建一个具有与`localfile`相同内容的文件。当下载时，将打开`localfile`以在其中写入`remotefile`的内容。
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Not all FTP servers support the same commands. The protocol saw many extensions
    over the years, so some commands might be missing or have a different semantic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的FTP服务器都支持相同的命令。多年来，该协议进行了许多扩展，因此一些命令可能缺失或具有不同的语义。
- en: For example, the `mlsd` function might be missing, but you might have `LIST`
    or `nlst`, which can perform a similar job.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`mlsd`函数可能会缺失，但您可能有`LIST`或`nlst`，它们可以执行类似的工作。
- en: You can refer to RFC 959 to know how the FTP protocol should work, but frequently
    experimenting explicitly with the FTP server you should be connecting to is the
    best way to assess which commands and which signature it's going to accept.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考RFC 959了解FTP协议应该如何工作，但经常通过明确与您要连接的FTP服务器进行实验是评估它将接受哪些命令和签名的最佳方法。
- en: Frequently, FTP servers implement a `HELP` command you can use it to fetch the
    list of supported functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，FTP服务器实现了一个`HELP`命令，您可以使用它来获取支持的功能列表。
- en: Sockets
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字
- en: Sockets are one of the lowest-level concepts that you can use to write networking
    applications. It means managing the whole connection ourselves, usually when relying
    on sockets directly, you would have to handle connection requests, accept them,
    and then start a thread or a loop to handle the subsequent commands or data that
    is sent through the newly created connection channel.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是您可以用来编写网络应用程序的最低级别概念之一。这意味着我们通常要自己管理整个连接，当直接依赖套接字时，您需要处理连接请求，接受它们，然后启动一个线程或循环来处理通过新创建的连接通道发送的后续命令或数据。
- en: This is a flow that nearly all applications that rely on networking have to
    implement, everything you call a server usually has as a foundation in the aforementioned
    loop.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎所有依赖网络的应用程序都必须实现的流程，通常您调用服务器时都有一个基础在上述循环中。
- en: The Python standard library provides a great foundation to avoid having to manually
    rewrite that flow every time you have to work on a networking-based application.
    We can use the `socketserver` module and let it handle the connection loop for
    us, while we focus on just implementing the application layer protocol and handling
    messages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了一个很好的基础，避免每次必须处理基于网络的应用程序时手动重写该流程。我们可以使用`socketserver`模块，让它为我们处理连接循环，而我们只需专注于实现应用程序层协议和处理消息。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps for this recipe:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您需要执行以下步骤：
- en: 'Mixing the `TCPServer` and `ThreadingMixIn` classes, we can easily build a
    multithreaded server that will handle concurrent connections through TCP:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过混合`TCPServer`和`ThreadingMixIn`类，我们可以轻松构建一个通过TCP处理并发连接的多线程服务器：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we have a working server, to test it, we need a client to send messages
    to it. For convenience, we will keep the client simple and just make it connect,
    send a message, and wait back for a short reply:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有一个工作的服务器，为了测试它，我们需要一个客户端向其发送消息。为了方便起见，我们将保持客户端简单，只需连接，发送消息，然后等待一个简短的回复：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have both the server and client, we can test that our server works
    as expected:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们既有服务器又有客户端，我们可以测试我们的服务器是否按预期工作：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If everything worked properly, you should see:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该看到：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The server part is composed of three different classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器部分由三个不同的类组成。
- en: '`EchoServer`, which orchestrates the server and provides the high-level API
    we can use. `EchoRequestHandler`, which manages the incoming messages and serves
    them. And `ThreadedTCPServer`, which is in charge of the whole networking part,
    opening sockets, listening on them, and spawning threads to handle connections.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`EchoServer`，它编排服务器并提供我们可以使用的高级API。`EchoRequestHandler`，它管理传入的消息并提供服务。`ThreadedTCPServer`，它负责整个网络部分，打开套接字，监听它们，并生成线程来处理连接。'
- en: '`EchoServer` allows to start and stop our server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`EchoServer`允许启动和停止我们的服务器：'
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It creates a new thread where the server will be running and starts it if it's
    not already running. The thread will just run the `ThreadedTCPServer.serve_forever`
    method that loops over and over, serving one request after the other.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个新的线程，服务器将在其中运行并启动它（如果尚未运行）。该线程将只运行`ThreadedTCPServer.serve_forever`方法，该方法循环运行，依次为每个请求提供服务。
- en: When we are done with our server, we can call the `stop()` method, which will
    shut down the server and wait for its completion (it will quit as soon as it is
    finished all currently-running requests).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成服务器时，我们可以调用`stop()`方法，它将关闭服务器并等待其完成（一旦完成所有当前运行的请求，它将退出）。
- en: '`ThreadedTCPServer` is pretty much the standard one provided by the standard
    library, if not for the reason that we inherit from `ThreadingMixIn` too. `Mixin`
    is a set of additional features that you can inject in a class by inheriting from
    it, in this specific case, it provides threading features for the socket server.
    So instead of being able to serve a single request at a time, we can server multiple
    requests concurrently.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadedTCPServer`基本上是标准库提供的标准服务器，如果不是因为我们也继承自`ThreadingMixIn`。`Mixin`是一组附加功能，您可以通过继承它来注入类中，在这种特定情况下，它为套接字服务器提供了线程功能。因此，我们可以同时处理多个请求，而不是一次只能处理一个请求。'
- en: We also set the `allow_reuse_address = True` attribute of the server, so that
    in case it crashes or in case of timeouts, the socket can be instantly reused
    instead of having to wait for the system to close them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了服务器的`allow_reuse_address = True`属性，以便在发生崩溃或超时的情况下，套接字可以立即重用，而不必等待系统关闭它们。
- en: Finally `EchoRequestHandler` is the one providing the whole message-handling
    and parsing. Whenever `ThreadedTCPServer` receives a new connection, it will call
    the `handle` method on the handler, and it's up to the handler to do the right
    thing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`EchoRequestHandler`提供了整个消息处理和解析。每当`ThreadedTCPServer`接收到新连接时，它将在处理程序上调用`handle`方法，由处理程序来执行正确的操作。
- en: 'In our case, we are just implementing a simple server that responds back whatever
    was sent to it, so the handler has to do two things:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只是实现了一个简单的服务器，它会回复发送给它的内容，因此处理程序必须执行两件事：
- en: Parse the incoming message to understand its content
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析传入的消息以了解其内容
- en: Send back a message with the same content
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送一个具有相同内容的消息
- en: One of the major complexities when working with sockets is that they are not
    really message-based. They are a continuous stream of data (well, UDP is message-based,
    but for what concerns us, the interface doesn't change much). This means that
    it is impossible to know when a new message begins and when a message ends.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用套接字时的一个主要复杂性是它们实际上并不是基于消息的。它们是一连串的数据（好吧，UDP是基于消息的，但就我们而言，接口并没有太大变化）。这意味着不可能知道新消息何时开始以及消息何时结束。
- en: The `handle` method just tells us that there is a new connection, but on that
    connection, multiple messages might be sent one after the other and unless we
    have a way of knowing where a message ends, we would read them as a single big
    message.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle`方法只告诉我们有一个新连接，但在该连接上，可能会连续发送多条消息，除非我们知道消息何时结束，否则我们会将它们读取为一条大消息。'
- en: To solve this need, we use a very simple yet effective approach, that is, prefixing
    all messages with their own size. Thus, when a new message is received we always
    know that we just need to read the size of the message and then, once the size
    is known, we will read the remaining bytes specified by the size.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用了一个非常简单但有效的方法，即给所有消息加上它们自己的大小前缀。因此，当接收到新消息时，我们总是知道我们只需要读取消息的大小，然后一旦知道大小，我们将读取由大小指定的剩余字节。
- en: 'To read those messages, we rely on a utility method, `recv_message`, that will
    be able to read a message made this way from any provided socket:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取这些消息，我们依赖于一个实用方法`recv_message`，它将能够从任何提供的套接字中读取以这种方式制作的消息：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first thing that the function does is read from the socket exactly `MESSAGE_HEADER_LEN`
    bytes. Those will be the bytes that contain the size of the message. All sizes
    must be the same size. For this reason, sizes such as `10` will have to be represented
    as `00010`. The prefixed zeros will then be ignored. Then, this size is converted
    using `int`, and we will get back the right number. The sizes must be all the
    same, otherwise we wouldn't know how many bytes we need to read to fetch the size.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一件事是从套接字中精确读取`MESSAGE_HEADER_LEN`个字节。这些字节将包含消息的大小。所有大小必须相同。因此，诸如`10`之类的大小将必须表示为`00010`。然后前缀的零将被忽略。然后，该大小使用`int`进行转换，我们将得到正确的数字。大小必须全部相同，否则我们将不知道需要读取多少字节来获取大小。
- en: 'We decided to constrain our message size to 65,000, this leads to a `MESSAGE_HEADER_LEN`
    of five as five digits are necessary to represent numbers up to 65,536:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定将消息大小限制为65,000，这导致`MESSAGE_HEADER_LEN`为五，因为需要五位数字来表示最多65,536的数字：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The size doesn't really matter, and we just picked a fairly big value. The bigger
    the messages are that you allow, the more bytes you will need to represent their
    sizes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大小并不重要，我们只选择了一个相当大的值。允许的消息越大，就需要更多的字节来表示它们的大小。
- en: 'The `recv_message` method is then used by `handle()` to read the sent message:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`recv_message`方法由`handle()`使用来读取发送的消息：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the message is known, the `handle()` method also sends back a new message
    prepared the same way and to prepare the response, it relies on `prepare_message`,
    which is also used by the client to send the messages in the first place:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息知道，`handle()`方法还会以相同的方式准备发送回一条新消息，并且为了准备响应，它依赖于`prepare_message`，这也是客户端用来发送消息的方法：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What this function does is, given a message, it ensures it's not bigger than
    the maximum allowed size and then prefixes it with its size.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的作用是，给定一条消息，它确保消息不会超过允许的最大大小，然后在消息前面加上它的大小。
- en: 'The size is computed by grabbing the length of the message as text and then
    encoding it as bytes using `ascii` encoding. As the size will only contain numbers,
    the `ascii` encoding is more than enough to represent them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该大小是通过将消息的长度作为文本获取，然后使用`ascii`编码将其编码为字节来计算的。由于大小只包含数字，因此`ascii`编码已经足够表示它们了：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As the resulting string can have any size (from one to five bytes), we always
    pad it with zeros until it reaches the expected size:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的字符串可以有任何大小（从一到五个字节），我们总是用零填充它，直到达到预期的大小：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The resulting bytes are then prepended to the message and the prepared message
    is returned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将生成的字节添加到消息前面，并返回准备好的消息。
- en: With those two functions, the server is able to receive and send back messages
    of arbitrary size.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个函数，服务器就能够接收和发送任意大小的消息。
- en: 'The client function works nearly the same way, as it has to send a message
    and then receive the answer back:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端函数的工作方式几乎相同，因为它必须发送一条消息，然后接收答案：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It still uses `EchoRequestHandler.prepare_message` to prepare the message to
    send to the server, and `EchoRequestHandler.recv_message` to read the server response.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然使用`EchoRequestHandler.prepare_message`来准备发送到服务器的消息，以及`EchoRequestHandler.recv_message`来读取服务器的响应。
- en: The only additional parts are related to connecting to the server. To do this,
    we actually create a socket of type `AF_INET`, `SOCK_STREAM`, which actually means
    we want to use TCP/IP.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的额外部分与连接到服务器有关。为此，我们实际上创建了一个类型为`AF_INET`、`SOCK_STREAM`的套接字，这实际上意味着我们要使用TCP/IP。
- en: Then we connect to the `ip` and `port` where the server is running, and once
    we're connected, we just send the message through the resulting socket `sock`
    and read the answer back on the same socket.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们连接到服务器运行的`ip`和`port`，一旦连接成功，我们就通过生成的套接字`sock`发送消息并在同一个套接字上读取答案。
- en: When we are done, we have to remember to close the socket or we will be leaking
    them until the OS decides to kill them because they were inactive for too long.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们必须记得关闭套接字，否则它们将一直泄漏，直到操作系统决定杀死它们，因为它们长时间不活动。
- en: AsyncIO
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AsyncIO
- en: While asynchronous solutions have been around for years, they are getting more
    and more common these days. The primary reason is that having an application without
    thousands of concurrent users is not an uncommon scenario anymore; it's actually
    the norm for a small/medium-sized application and we can scale to millions with
    major services used worldwide.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异步解决方案已经存在多年，但这些天它们变得越来越普遍。主要原因是，拥有一个没有数千个并发用户的应用程序不再是一个不寻常的场景；对于一个小型/中型应用程序来说，这实际上是一个常态，而且我们可以通过全球范围内使用的主要服务扩展到数百万用户。
- en: Being able to serve such volumes doesn't scale well with approaches based on
    threads or processes. Especially when many of the connections that users are triggering
    might be sitting there doing nothing most of the time. Think of a service such
    as Facebook Messenger or WhatsApp. Whichever you use, you probably send a message
    once in a while and most of the time your connection to the server is sitting
    there doing nothing. Maybe you are a heavy chatter and you receive a message every
    second, but that still means that out of the millions of clocks per second your
    computer can do, most of them will be doing nothing. Most of the heavy lifting
    in this kind of application is done by the networking part, so there are a lot
    of resources that can be shared by undergoing multiple connections in a single
    process.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 能够提供这样的服务量，使用基于线程或进程的方法并不适合。特别是当用户触发的许多连接大部分时间可能都在那里无所事事。想想Facebook Messenger或WhatsApp这样的服务。无论你使用哪一个，你可能偶尔发送一条消息，大部分时间你与服务器的连接都在那里无所事事。也许你是一个热络的聊天者，每秒收到一条消息，但这仍然意味着在你的计算机每秒钟可以做的数百万次操作中，大部分时间都在无所事事。这种应用程序中的大部分繁重工作是由网络部分完成的，因此有很多资源可以通过在单个进程中进行多个连接来共享。
- en: Asynchronous technologies allow exactly that, to write a networking application
    that instead of requiring multiple separate threads (that would be wasting memory
    and kernel efforts), we can have a single process and thread composed by multiple
    coroutines that do nothing until there is actually something to do.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 异步技术正好允许这样做，编写一个网络应用程序，而不是需要多个单独的线程（这将浪费内存和内核资源），我们可以有一个由多个协程组成的单个进程和线程，直到实际有事情要做时才会执行。
- en: As long as what the coroutines have to do is super-quick (such as grabbing a
    message and forwarding it to another contact of yours), most of the work will
    happen at the networking layer and thus can proceed in parallel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只要协程需要做的事情非常快速（比如获取一条消息并将其转发给你的另一个联系人），大部分工作将在网络层进行，因此可以并行进行。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的步骤如下：
- en: 'We are going to replicate our echo server, but instead of using threads, it''s
    going to use AsyncIO and coroutines to serve requests:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将复制我们的回显服务器，但不再使用线程，而是使用AsyncIO和协程来提供请求：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we have the server implementation, we need a client to test it. As
    in practice the client does the same that we did for the previous recipe, we are
    just going to reuse the same client implementation. So the client won''t be AsyncIO-
    and coroutines-based, but will be a normal function using `socket`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了服务器实现，我们需要一个客户端来测试它。由于实际上客户端做的与我们之前的配方相同，我们只是要重用相同的客户端实现。因此，客户端不会是基于AsyncIO和协程的，而是一个使用`socket`的普通函数：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now we can put the pieces together. To run both client and server in the same
    process, we are going to run the `asyncio` loop in a separate thread. So, we can
    concurrently start clients against it. This is not in any way required to serve
    multiple clients, it's just a convenience to avoid having to start two different
    Python scripts to play server and client.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以把这些部分放在一起。为了在同一个进程中运行客户端和服务器，我们将在一个单独的线程中运行`asyncio`循环。因此，我们可以同时启动客户端。这并不是为了服务多个客户端而必须的，只是为了方便，避免不得不启动两个不同的Python脚本来玩服务器和客户端。
- en: 'First of all, we create a thread for the server that will go on for `3` seconds.
    After `3` seconds, we will explicitly stop our server:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为服务器创建一个将持续`3`秒的线程。3秒后，我们将明确停止我们的服务器：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, as soon as the server has started, we make the three clients and send
    three messages:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一旦服务器启动，我们就创建三个客户端并发送三条消息：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once finished, we wait for the server to quit, as after 3 seconds it should
    stop and quit:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们等待服务器退出，因为3秒后它应该停止并退出：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If everything worked as expected, you should see the server start, serve three
    clients, and then quit:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切按预期进行，你应该看到服务器启动，为三个客户端提供服务，然后退出：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The client side of this recipe is mostly taken as is from the socket serve recipe.
    The difference lies in the server side, which is not threaded anymore; instead,
    it's based on coroutines.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的客户端大部分是直接从套接字服务配方中取出来的。区别在于服务器端不再是多线程的，而是基于协程的。
- en: 'Given an `asyncio` event loop (the one we created with `asyncio.new_event_loop()`
    within the `serve_for_3_seconds` thread) the `EchoServer.serve` method creates
    a new coroutine-based server and tells the loop to serve requests forever until
    the server itself is not closed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`asyncio`事件循环（我们在`serve_for_3_seconds`线程中使用`asyncio.new_event_loop()`创建的），`EchoServer.serve`方法创建一个基于协程的新服务器，并告诉循环永远提供请求，直到服务器本身关闭为止：
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`loop.run_until_complete` will block until the specified coroutine doesn''t
    quit, and `self._server.wait_closed()` will quit only when the server itself is
    stopped.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop.run_until_complete`将阻塞，直到指定的协程退出，而`self._server.wait_closed()`只有在服务器本身停止时才会退出。'
- en: To ensure that the server is stopped after a short time, when we created the
    loop, we issued the `loop.call_later(3, server.stop)` call. This means that after
    3 seconds, the server will stop and thus the whole loop will quit.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保服务器在短时间内停止，当我们创建循环时，我们发出了`loop.call_later(3, server.stop)`的调用。这意味着3秒后，服务器将停止，整个循环将退出。
- en: 'Meanwhile, until the server is actually stopped, it will serve requests. Each
    request will spawn a coroutine that runs the `handle` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，直到服务器真正停止，它将继续提供服务。每个请求都会生成一个运行`handle`函数的协程：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The handler will receive two streams as arguments. One for incoming data and
    the other for outgoing data.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序将接收两个流作为参数。一个用于传入数据，另一个用于传出数据。
- en: 'Much like we did in the case of the threaded socket server, we read the incoming
    message from the `reader` stream. To do so, we reimplement the `recv_message`
    as a coroutine, so that we can read the data concurrently with other requests
    being served:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在使用线程套接字服务器的情况下所做的那样，我们从`reader`流中读取传入的消息。为此，我们将`recv_message`重新实现为一个协程，这样我们就可以同时读取数据和处理其他请求：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When both the size of the message and the message itself are available, we just
    return the message so that the `send_message` function can echo it back to the
    client.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息的大小和消息本身都可用时，我们只需返回消息，以便`send_message`函数可以将其回显到客户端。
- en: 'The only particular change from `socketserver` in this context is that we write
    to the stream writer, but then we have to drain it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，与`socketserver`的唯一特殊更改是我们要写入流写入器，但然后我们必须将其排空：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is done because after we wrote into the socket, we needed to send back
    control to the `asyncio` loop so that it had a chance actually to flush this data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在我们写入套接字后，我们需要将控制权发送回`asyncio`循环，以便它有机会实际刷新这些数据。
- en: After three seconds, the `server.stop` method is called and that will stop the
    server, wake up the `wait_closed()` function, and thus make the `EchoServer.serve`
    method quit as it is completed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 三秒后，调用`server.stop`方法，这将停止服务器，唤醒`wait_closed()`函数，从而使`EchoServer.serve`方法退出，因为它已经完成。
- en: Remote procedure calls
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: There are hundreds of systems to perform RPC in Python, but because it has powerful
    networking tools and is a dynamic language, everything we need is already built
    into the standard library.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百种系统可以在Python中执行RPC，但由于它具有强大的网络工具并且是一种动态语言，我们需要的一切都已经内置在标准库中。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'You need to perform the following steps for this recipe:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来完成此操作：
- en: 'Using `xmlrpc.server`, we can easily create an XMLRPC-based server that exposes
    multiple services:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`xmlrpc.server`，我们可以轻松创建一个基于XMLRPC的服务器，该服务器公开多个服务：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Particularly, we are going to expose two services: one to get back current
    time, and the other to multiply a number by `2`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别是，我们将公开两项服务：一个用于获取当前时间，另一个用于将数字乘以`2`：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Once we have our services, we can consume them using `xmlrpc.client.ServerProxy`,
    which provides a simple call interface against the XMLRPC server.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的服务，我们可以使用`xmlrpc.client.ServerProxy`来消费它们，它提供了一个简单的调用接口来对XMLRPC服务器进行操作。
- en: 'As usual, to start both client and server in the same process, we can use a
    thread for the server and let the server run within that thread while the client
    drives the main thread:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，为了在同一进程中启动客户端和服务器，我们可以使用一个线程来启动服务器，并让服务器在该线程中运行，而客户端驱动主线程：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If everything worked properly, you should see the current time being printed
    on the terminal:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该在终端上看到当前时间的打印：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `XMLRPCServices` class takes all services that we want to expose as initialization
    arguments and exposes them:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLRPCServices`类接受我们要公开的所有服务作为初始化参数并将它们公开：'
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is done because we expose a local object (`ExposedServices`) that by default
    is empty, but we attach to its instance all the provided services as attributes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们公开了一个本地对象（`ExposedServices`），默认情况下为空，但我们将提供的所有服务作为属性附加到其实例上：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'So, we end up exposing a `self.services` object that has two attributes: `math`
    and `time`, which refer to the `MathServices` and `TimeServices` classes.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终暴露了一个`self.services`对象，它有两个属性：`math`和`time`，它们分别指向`MathServices`和`TimeServices`类。
- en: 'Serving them is actually done by the `XMLRPCServices.serve` method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上是由`XMLRPCServices.serve`方法来提供它们的：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This creates a `SimpleXMLRPCServer` instance, which is the HTTP server in charge
    of responding to the XMLRPC requests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个`SimpleXMLRPCServer`实例，它是负责响应XMLRPC请求的HTTP服务器。
- en: 'To that instance, we then attach the `self.services` object we created before
    and allow it to access subproperties so that the nested `math` and `time` attributes
    are exposed as services:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`self.services`对象附加到该实例，并允许它访问子属性，以便嵌套的`math`和`time`属性可以作为服务公开：
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before actually starting the server, we also enabled introspection functions.
    Those are all the functions that allow us to access the list of exposed services,
    and ask for their help and signature:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际启动服务器之前，我们还启用了内省功能。这些都是允许我们访问公开服务列表并请求其帮助和签名的所有功能：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then we actually start the server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实际上启动了服务器：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will block the `serve` method and loop forever serving requests until the
    `stop` method is called.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止`serve`方法并循环提供请求，直到调用`stop`方法为止。
- en: That's the reason why, in the example, we started the server in a separate thread;
    that is, so that it won't block the main thread that we could use for the client.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在示例中，我们在单独的线程中启动服务器的原因；也就是说，这样就不会阻塞我们可以用于客户端的主线程。
- en: 'The `stop` method is in charge of stopping the server, so that the `serve`
    method can exit. This method asks the server to terminate as soon as it finishes
    the current request and then closes the associated network connection:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`方法负责停止服务器，以便`serve`方法可以退出。该方法要求服务器在完成当前请求后立即终止，然后关闭关联的网络连接：'
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'So, just creating `XMLRPCServices` and serving it is enough to have our RPC
    server up and running:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需创建`XMLRPCServices`并提供它就足以使我们的RPC服务器正常运行：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'On the client side, the code base is a lot easier; it''s just a matter of creating
    a `ServerProxy` against the URL where the server is exposed:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，代码基础要简单得多；只需创建一个针对服务器公开的URL的`ServerProxy`即可：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, all the methods of the services exposed by the server will be accessible
    through dot notation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器公开的服务的所有方法都可以通过点表示法访问：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`XMLRPCServices` has big security implications, and so you should never use
    `SimpleXMLRPCServer` on an open network.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLRPCServices`具有很大的安全性影响，因此您不应该在开放网络上使用`SimpleXMLRPCServer`。'
- en: The most obvious concern is that you are allowing remote-code execution to anyone
    as the XMLRPC server is unauthenticated. So, the server should only run on private
    networks where you can ensure that only trusted clients will be able to access
    the services.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的问题是，您允许任何人执行远程代码，因为XMLRPC服务器未经身份验证。因此，服务器应仅在您可以确保只有受信任的客户端能够访问服务的私人网络上运行。
- en: But even if you provide proper authentication in front of the service (which
    is possible by using any HTTP proxy in front of it), you still want to ensure
    that you trust the data your clients are going to send because `XMLRPCServices`
    suffers from some security limitations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使您在服务前提供适当的身份验证（通过在其前面使用任何HTTP代理来实现），您仍希望确保信任客户端将要发送的数据，因为`XMLRPCServices`存在一些安全限制。
- en: The data being served is exchanged in clear text, so anyone able to sniff your
    network will be able to see it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的数据是以明文交换的，因此任何能够嗅探您网络的人都能够看到它。
- en: This can be worked around with some effort by subclassing the `SimpleXMLRPCServer`
    and replacing its `socket` instance with an SSL-wrapped one (the same should happen
    for the client to be able to connect).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过一些努力绕过这个问题，通过对`SimpleXMLRPCServer`进行子类化，并用SSL包装的`socket`实例替换它（客户端也需要这样做才能连接）。
- en: But, even when a hardening of the communication channel is involved, you still
    need to trust the data that will be sent because the parser is naive and can be
    brought out of service by sending large amounts of recursive data. Imagine you
    have an entity that's expanded to dozens of entities that each expand to dozens
    of entities and so on for 10-20 levels. That will quickly require gigabytes and
    gigabytes of RAM to decode, but requires no more than a few kilobytes to build
    and send through the network.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使涉及到通信渠道的加固，您仍需要信任将要发送的数据，因为解析器是天真的，可以通过发送大量递归数据来使其失效。想象一下，您有一个实体，它扩展到数十个实体，每个实体又扩展到数十个实体，依此类推，达到10-20个级别。这将迅速需要大量的RAM来解码，但只需要几千字节来构建并通过网络发送。
- en: Also, the fact that we are exposing subproperties means we are exposing far
    more than we expect.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们暴露子属性意味着我们暴露了比我们预期的要多得多。
- en: 'You certainly expect to expose the `currentTime` method of the `time` service:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定希望暴露`time`服务的`currentTime`方法：
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that you are exposing every single property or method declared in `TimeServices`
    whose name does not start with an `_`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您正在暴露`TimeServices`中声明的每个不以`_`开头的属性或方法。
- en: 'In older Python versions (such as 2.7), this actually meant exposing internal
    code too, as you could access all public variables by doing something such as:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的Python（如2.7）中，这实际上意味着也暴露了内部代码，因为您可以通过诸如以下方式访问所有公共变量：
- en: '[PRE74]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You could then retrieve their values through:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过以下方式检索它们的值：
- en: '[PRE75]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This was a major security concern.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重大的安全问题。
- en: Luckily, the `im_func` attribute of functions was renamed to `__func__` and,
    thus, is no longer accessible. However, the concern still remains for any attribute
    you declared yourself.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，函数的`im_func`属性已更名为`__func__`，因此不再可访问。但是，对于您自己声明的任何属性，仍然存在这个问题。
