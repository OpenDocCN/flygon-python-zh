- en: Nonlinearity in Finance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金融中的非线性
- en: In recent years, there has been a growing interest in research on nonlinear
    phenomena in economic and financial theory. With nonlinear serial dependence playing
    a significant role in the returns of many financial time series, this makes security
    valuation and pricing very important, leading to an increase in studies on the
    nonlinear modeling of financial products.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，对经济和金融理论中的非线性现象的研究越来越受到关注。由于非线性串行依赖在许多金融时间序列的回报中起着重要作用，这使得证券估值和定价非常重要，从而导致对金融产品的非线性建模研究增加。
- en: Practitioners in the financial industry use nonlinear models to forecast volatility,
    price derivatives, and compute **Value at Risk** (**VAR**). Unlike linear models,
    where linear algebra is used to find a solution, nonlinear models do not necessarily
    infer a global optimal solution. Numerical root-finding methods are usually employed
    to converge toward the nearest local optimal solution, which is a root.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 金融业的从业者使用非线性模型来预测波动性、价格衍生品，并计算风险价值（VAR）。与线性模型不同，线性代数用于寻找解决方案，非线性模型不一定推断出全局最优解。通常采用数值根查找方法来收敛到最近的局部最优解，即根。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Nonlinearity modeling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非线性建模
- en: Examples of nonlinear models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非线性模型的例子
- en: Root-finding algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根查找算法
- en: SciPy implementations in root-finding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根查找中的SciPy实现
- en: Nonlinearity modeling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非线性建模
- en: 'While linear relationships aim to explain observed phenomena in the simplest
    way possible, many complex physical phenomena cannot be explained using such models.
    A nonlinear relationship is defined as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管线性关系旨在以最简单的方式解释观察到的现象，但许多复杂的物理现象无法用这样的模型来解释。非线性关系定义如下：
- en: '![](Images/4155a161-47cc-4585-b881-1544650269c4.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4155a161-47cc-4585-b881-1544650269c4.png)'
- en: Even though nonlinear relationships may be complex, to fully understand and
    model them, we will take a look at the examples that are applied in the context
    of finance and in time-series models.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非线性关系可能很复杂，但为了充分理解和建模它们，我们将看一下在金融和时间序列模型的背景下应用的例子。
- en: Examples of nonlinear models
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非线性模型的例子
- en: 'Many nonlinear models have been proposed for academic and applied research
    to explain certain aspects of economic and financial data that are left unexplained
    by linear models. The literature on nonlinearity in finance is simply too broad
    and deep to be adequately explained in this book. In this section, we will briefly
    discuss some examples of nonlinear models that we may come across for practical
    uses: the implied volatility model, Markov switching model, threshold model, and
    smooth transition model.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非线性模型已被提出用于学术和应用研究，以解释线性模型无法解释的经济和金融数据的某些方面。金融领域的非线性文献实在太广泛和深刻，无法在本书中得到充分解释。在本节中，我们将简要讨论一些非线性模型的例子，这些模型可能在实际应用中遇到：隐含波动率模型、马尔可夫转换模型、阈值模型和平滑转换模型。
- en: The implied volatility model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐含波动率模型
- en: Perhaps one of the most widely-studied option-pricing models is the Black-Scholes-Merton
    model, or simply the Black-Scholes model. A call option is a right, but not an
    obligation, to buy the underlying security at a particular price and time. A put
    option is a right, but not an obligation, to sell the underlying security at a
    particular price and time. The Black-Scholes model helps determine the fair price
    of an option with the assumption that the returns of the underlying security are
    normally distributed (N(.)) or that asset prices are log-normally distributed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最广泛研究的期权定价模型之一是Black-Scholes-Merton模型，或简称Black-Scholes模型。看涨期权是在特定价格和时间购买基础证券的权利，而不是义务。看跌期权是在特定价格和时间出售基础证券的权利，而不是义务。Black-Scholes模型有助于确定期权的公平价格，假设基础证券的回报服从正态分布（N(.)）或资产价格呈对数正态分布。
- en: 'The formula takes on the following assumed variables—the strike price (*K*),
    the time to expiry (*T*), the risk-free rate (*r*), the volatility of the underlying
    returns (σ), the current price of the underlying asset (*S*), and its yield (*q*).
    The mathematical formula for a call option, *C*(*S,t*), is represented as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该公式假定以下变量：行权价（*K*）、到期时间（*T*）、无风险利率（*r*）、基础收益的波动率（σ）、基础资产的当前价格（*S*）和其收益（*q*）。看涨期权的数学公式，*C*(*S,t*)，表示如下：
- en: '![](Images/af298b08-2488-4b90-aa40-4455d4c604a0.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/af298b08-2488-4b90-aa40-4455d4c604a0.png)'
- en: 'Here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里：
- en: '![](Images/223c14fe-493f-4a93-98df-66b36a3d97fd.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/223c14fe-493f-4a93-98df-66b36a3d97fd.png)'
- en: By way of market forces, the price of an option may deviate from the price that's
    been derived from the Black-Scholes formula. In particular, the realized volatility
    (that is, the observed volatility of the underlying returns from historical market
    prices) could differ from the volatility value as implied by the Black-Scholes
    model, which is indicated by σ.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过市场力量，期权的价格可能偏离从Black-Scholes公式推导出的价格。特别是，实现波动性（即从历史市场价格观察到的基础收益的波动性）可能与由Black-Scholes模型隐含的波动性值不同，这由σ表示。
- en: Think back to the **Capital Asset Pricing Model **(**CAPM**) discussed in [Chapter
    2](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)*, The Importance of Linearity in
    Finance*. In general, securities that have higher returns exhibit higher risk,
    as indicated by the volatility or standard deviation of returns.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在[第2章](7b247a98-9fcc-4ec8-8d5d-3c5b77353f38.xhtml)中讨论的**资本资产定价模型**（**CAPM**），即金融中的线性重要性。一般来说，具有更高回报的证券表现出更高的风险，这表明回报的波动性或标准差。
- en: With volatility being such an important factor in security pricing, many volatility
    models have been proposed for studies. One such model is the implied volatility
    modeling of option prices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于波动性在证券定价中非常重要，因此已经提出了许多波动性模型进行研究。其中一种模型是期权价格的隐含波动率建模。
- en: 'Suppose we plot the implied volatility values of an equity option given by
    the Black-Scholes formula with a particular maturity for every strike price available.
    In general, we get a curve commonly known as the **volatility smile** due to its
    shape:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们绘制了给定特定到期日的Black-Scholes公式给出的股票期权的隐含波动率值。一般来说，我们得到一个常被称为**波动率微笑**的曲线，因为它的形状：
- en: '![](Images/4db85299-43b0-4706-8202-7f67684526a4.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4db85299-43b0-4706-8202-7f67684526a4.png)'
- en: The **Implied volatility** typically is at its highest for deep in-the-money and
    out-of-the-money options driven by heavy speculation and at its lowest for at-the-money
    options.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐含波动率**通常在深度实值和虚值期权上最高，受到大量投机驱动，而在平值期权上最低。'
- en: 'The characteristics of options are explained as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 期权的特征解释如下：
- en: '**In-the-money options** (**ITM**): A call option is considered ITM when its
    strike price is below the market price of the underlying asset. A put option is
    considered ITM when its strike price is above the market price of the underlying
    asset. ITM options have an intrinsic value when exercised.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实值期权**（**ITM**）：当认购期权的行权价低于标的资产的市场价格时，被视为实值期权。当认沽期权的行权价高于标的资产的市场价格时，被视为实值期权。实值期权在行使时具有内在价值。'
- en: '**Out-of-the-money options** (**OTM**): A call option is considered OTM when
    its strike price is above the market price of the underlying asset. A put option
    is considered OTM when its strike price is below the market price of the underlying
    asset. OTM options have no intrinsic value when exercised, but may still have
    time value.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚值期权**（**OTM**）：当认购期权的行权价高于标的资产的市场价格时，被视为虚值期权。当认沽期权的行权价低于标的资产的市场价格时，被视为虚值期权。虚值期权在行使时没有内在价值，但可能仍具有时间价值。'
- en: '**At-the-money options** (**ATM**): An option is considered ATM when its strike
    price is the same as the market price of the underlying asset. ATM options have
    no intrinsic value, but may still have time value.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平值期权**（**ATM**）：当期权的行权价与标的资产的市场价格相同时，被视为平值期权。平值期权在行使时没有内在价值，但可能仍具有时间价值。'
- en: From the preceding volatility curve, one of the objectives in implied volatility
    modeling is to seek the lowest implied volatility value possible or, in other
    words, to *find the root*. When found, the theoretical price of an ATM option
    for a particular maturity can be deduced and compared against the market prices
    for potential opportunities, such as for studying near ATM options or far OTM
    options. However, since the curve is nonlinear, linear algebra cannot adequately
    solve the root. We will take a look at a number of root-finding methods in the
    next section, *Root-finding algorithms*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述波动率曲线中，隐含波动率建模的一个目标是寻找可能的最低隐含波动率值，或者换句话说，*找到根*。一旦找到，就可以推断出特定到期日的平值期权的理论价格，并与市场价格进行比较，以寻找潜在的机会，比如研究接近平值期权或远虚值期权。然而，由于曲线是非线性的，线性代数无法充分解决根的问题。我们将在下一节*根查找算法*中看一些根查找方法。
- en: The Markov regime-switching model
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 马尔可夫转换模型
- en: To model nonlinear behavior in economic and financial time series, Markov switching
    models can be used to characterize time series in different states of the world
    or regimes. Examples of such states could be a *volatile* state, as seen in the
    2008 global economic downturn, or the *growth* state of a steadily recovering
    economy. The ability to transition between these structures lets the model capture
    complex dynamic patterns.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对经济和金融时间序列中的非线性行为进行建模，可以使用马尔可夫转换模型来描述不同世界或状态下的时间序列。这些状态的例子可能是一个*波动*状态，就像在2008年全球经济衰退中看到的，或者是稳步复苏经济的*增长*状态。能够在这些结构之间转换的能力让模型能够捕捉复杂的动态模式。
- en: The Markov property of stock prices implies that only the present values are
    relevant for predicting the future. Past stock-price movements are irrelevant
    to the way the present has emerged.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 股票价格的马尔可夫性质意味着只有当前价值对于预测未来是相关的。过去的股价波动对于当前的出现方式是无关紧要的。
- en: 'Let''s take an example of a Markov regime-switching model with *m=2* regimes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以*m=2*个状态的马尔可夫转换模型为例：
- en: '![](Images/1c381167-4141-4ef1-a642-e548fb4c7a63.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1c381167-4141-4ef1-a642-e548fb4c7a63.png)'
- en: 'ϵ[t] is an **independent and identically-distributed** (**i**.**i**.**d**)
    white noise. White noise is a normally-distributed random process with a mean
    of zero. The same model can be represented with dummy variables:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ϵ[t]是一个**独立同分布**（**i**.**i**.**d**）白噪声。白噪声是一个均值为零的正态分布随机过程。同样的模型可以用虚拟变量表示：
- en: '![](Images/469acdb8-a49c-4eb9-ada9-60b87503044b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/469acdb8-a49c-4eb9-ada9-60b87503044b.png)'
- en: '![](Images/c1bda288-73f1-4b27-82f9-0ad7cf0102ef.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c1bda288-73f1-4b27-82f9-0ad7cf0102ef.png)'
- en: '![](Images/3b35aee2-f2f3-48ad-b857-0dc351aa1af2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b35aee2-f2f3-48ad-b857-0dc351aa1af2.png)'
- en: 'The application of Markov switching models includes representing the real GDP
    growth rate and inflation rate dynamics. These models in turn drive the valuation
    models of interest-rate derivatives. The probability of switching from the previous
    state, *i*, to the current state, *j*, can be written as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫转换模型的应用包括代表实际GDP增长率和通货膨胀率动态。这些模型反过来推动利率衍生品的估值模型。从前一状态*i*转换到当前状态*j*的概率可以写成如下形式：
- en: '![](Images/9c728e76-fddf-4295-9ca0-cf169522a08d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9c728e76-fddf-4295-9ca0-cf169522a08d.png)'
- en: The threshold autoregressive model
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阈自回归模型
- en: One popular class of nonlinear time series models is the **threshold autoregressive**
    (**TAR**) model, which looks very similar to the Markov switching models. Using
    regression methods, simple AR models are arguably the most popular models to explain
    nonlinear behavior. Regimes in the threshold model are determined by past, *d*,
    values of its own time series, relative to a threshold value, *c*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的非线性时间序列模型类别是**阈自回归**（**TAR**）模型，它看起来与马尔可夫转换模型非常相似。使用回归方法，简单的AR模型可以说是最流行的模型来解释非线性行为。阈值模型中的状态是由其自身时间序列的过去值*d*相对于阈值*c*确定的。
- en: 'The following is an example of a **self-exciting TAR** (**SETAR**) model. The
    SETAR model is self-exciting because switching between different regimes depends
    on the past values of its own time series:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个**自激励TAR**（SETAR）模型的例子。SETAR模型是自激励的，因为在不同制度之间的切换取决于其自身时间序列的过去值：
- en: '![](Images/19032cd6-d384-436e-9753-fc1c5ef40731.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/19032cd6-d384-436e-9753-fc1c5ef40731.png)'
- en: 'Using dummy variables, the SETAR model can also be represented as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟变量，SETAR模型也可以表示如下：
- en: '![](Images/02286653-b81d-4261-bbda-9d813b845e68.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02286653-b81d-4261-bbda-9d813b845e68.png)'
- en: '![](Images/826e2e31-0e85-4aa7-97d8-6d4747cff9c4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/826e2e31-0e85-4aa7-97d8-6d4747cff9c4.png)'
- en: '![](Images/dba92602-e4e1-4eda-9594-3a5d40877cd0.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dba92602-e4e1-4eda-9594-3a5d40877cd0.png)'
- en: The use of the TAR model may result in sharp transitions between the states
    as controlled by the threshold variable, *c*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TAR模型的使用可能会导致状态之间出现急剧的转变，这由阈值变量*c*控制。
- en: Smooth transition models
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑转换模型
- en: 'Abrupt regime changes in the threshold models appear to be unrealistic against
    real-world dynamics. This problem can be overcome by introducing a smoothly-changing
    continuous function from one regime to another. The SETAR model becomes a **logistic
    smooth transition threshold autoregressive** (**LSTAR**) model with the logistic
    function of *G(y[t−1];γ,c)*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值模型中的突然制度变化似乎与现实世界的动态不符。通过引入一个平滑变化的连续函数，可以克服这个问题，从一个制度平滑地过渡到另一个制度。SETAR模型成为一个**逻辑平滑转换阈值自回归**（**LSTAR**）模型，其中使用逻辑函数*G(y[t−1];γ,c)*：
- en: '![](Images/98085bf4-eeb1-4eda-aeac-d2c76e2c4d43.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/98085bf4-eeb1-4eda-aeac-d2c76e2c4d43.png)'
- en: 'The SETAR model now becomes an LSTAR model, as shown in the following equation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SETAR模型现在变成了LSTAR模型，如下方程所示：
- en: '![](Images/bfc7c90a-2e13-4be8-a8b2-85775744c094.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bfc7c90a-2e13-4be8-a8b2-85775744c094.png)'
- en: The γ parameter controls the smooth transition from one regime to another. For
    large values of γ, the transition is the fastest, as *y[t−d]* approaches the threshold
    variable, *c*. When γ=0, the LSTAR model is equivalent to a simple *AR(1)* one-regime
    model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 参数γ控制从一个制度到另一个制度的平滑过渡。对于γ的大值，过渡是最快的，因为*y[t−d]*接近阈值变量*c*。当γ=0时，LSTAR模型等同于简单的*AR(1)*单制度模型。
- en: Root-finding algorithms
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根查找算法
- en: In the preceding section, we discussed some nonlinear models commonly used for
    studying economics and financial time series. From the model data given in continuous
    time, the intention is therefore to search for the extrema that could possibly
    infer valuable information. The use of numerical methods, such as root-finding
    algorithms, can help us find the roots of a continuous function, *f*, such that
    *f(x)=0*, which can either be the maxima or the minima of the function. In general,
    an equation may either contain a number of roots or none at all.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们讨论了一些用于研究经济和金融时间序列的非线性模型。从连续时间给定的模型数据，因此意图是搜索可能推断有价值信息的极值点。使用数值方法，如根查找算法，可以帮助我们找到连续函数*f*的根，使得*f(x)=0*，这可能是函数的极大值或极小值。一般来说，一个方程可能包含多个根，也可能根本没有根。
- en: One example of the use of root-finding methods on nonlinear models is the Black-Scholes
    implied volatility modeling discussed earlier, in *The implied volatility model*
    section. An option trader would be interested in deriving implied prices based
    on the Black-Scholes model and comparing them with market prices. In the next
    chapter, [Numerical Methods for Pricing Options](bd8dfd19-c025-4223-8d5e-b7c7893874c3.xhtml),
    we will see how we can combine a root-finding method with a numerical-option pricing
    procedure to create an implied volatility model based on the market prices of
    a particular option.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在非线性模型上使用根查找方法的一个例子是前面讨论的Black-Scholes隐含波动率建模，在*隐含波动率模型*部分。期权交易员有兴趣根据Black-Scholes模型推导隐含价格，并将其与市场价格进行比较。在下一章，[期权定价的数值方法](bd8dfd19-c025-4223-8d5e-b7c7893874c3.xhtml)，我们将看到如何将根查找方法与数值期权定价程序结合起来，以根据特定期权的市场价格创建一个隐含波动率模型。
- en: Root-finding methods use an iterative routine that requires a start point or
    the estimation of the root. The estimation of the root can either converge toward
    a solution, converge to a root that is not sought, or may not even find a solution
    at all. Thus, it is crucial to find a good approximation to the root.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根查找方法使用迭代程序，需要一个起始点或根的估计。根的估计可能会收敛于一个解，收敛于一个不需要的根，或者根本找不到解决方案。因此，找到根的良好近似是至关重要的。
- en: 'Not every nonlinear function can be solved using root-finding methods. The
    following figure shows an example of a continuous function, ![](Images/92660661-9bf5-4f04-853c-19418fd6f079.png),
    where root-finding methods may fail to arrive at a solution. There are discontinuities
    at *x=0* and *x=2* for the *y* values in the range of -20 to 20:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个非线性函数都可以使用根查找方法解决。下图显示了一个连续函数的例子，![](Images/92660661-9bf5-4f04-853c-19418fd6f079.png)，在这种情况下，根查找方法可能无法找到解。在*x=0*和*x=2*处，*y*值在-20到20的范围内存在不连续性：
- en: '![](Images/7068c1c2-39af-41ff-9aa9-ac25775958eb.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7068c1c2-39af-41ff-9aa9-ac25775958eb.png)'
- en: There is no fixed rule as to how a good approximation can be defined. It is
    recommended that you bracket or define the lower and upper search bounds before
    starting the root-finding iterative procedure. We certainly do not want to keep
    searching endlessly in the wrong direction for our root.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有固定的规则来定义良好的近似。建议在开始根查找迭代程序之前，先确定下界和上界的搜索范围。我们当然不希望在错误的方向上无休止地搜索我们的根。
- en: Incremental search
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增量搜索
- en: A crude method of solving a nonlinear function is by doing an incremental search.
    Using an arbitrary starting point, *a*, we can obtain values of *f(a)* for every
    increment of *dx*. We assume that the values of *f*(*a+dx*), *f*(*a+2dx*), *f*(*a+3dx*)…
    are going in the same direction as indicated by their sign. Once the sign changes,
    a solution is deemed as found. Otherwise, the iterative search terminates when
    it crosses the boundary point, *b*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决非线性函数的一种粗糙方法是进行增量搜索。使用任意起始点*a*，我们可以获得每个*dx*增量的*f(a)*值。我们假设*f*(*a+dx*)，*f*(*a+2dx*)，*f*(*a+3dx*)…的值与它们的符号指示的方向相同。一旦符号改变，解决方案被认为已找到。否则，当迭代搜索越过边界点*b*时，迭代搜索终止。
- en: 'A pictorial example of the root-finder method for iteration is given in the
    following graph:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代的根查找方法的图示示例如下图所示：
- en: '![](Images/49efa5b2-fb95-44f7-a82b-9634de40256a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/49efa5b2-fb95-44f7-a82b-9634de40256a.png)'
- en: 'An example can be seen from the following Python code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从以下Python代码中看到一个例子：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At every iterative procedure, `a` will be replaced by `c`, and `c` will be incremented
    by `dx` before the next comparison. Should a root be found, it is plausible that
    it lies between `a` and `c`, both inclusive. In the event that the solution does
    not rest at either point, we will simply return the average of the two points
    as the best estimation. The *n* variable keeps track of the number of iterations
    that underwent the process of finding our root.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代过程中，`a`将被`c`替换，并且在下一次比较之前，`c`将被`dx`递增。如果找到了根，那么它可能位于`a`和`c`之间，两者都包括在内。如果解决方案不在任何一个点上，我们将简单地返回这两个点的平均值作为最佳估计。变量*n*跟踪经历了寻找根的过程的迭代次数。
- en: 'We will use the equation that has an analytic solution of ![](Images/64e18993-4c00-4174-9dcd-0bfdf3a7583e.png)
    to demonstrate and measure our root-finder, where *x* is bounded between -5 and
    5\. A small *dx* value of 0.001 is given, which also acts as a precision tool.
    Smaller values of *dx* produce better precision but also require more search iterations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用具有解析解![](Images/64e18993-4c00-4174-9dcd-0bfdf3a7583e.png)的方程来演示和测量我们的根查找器，其中*x*被限制在-5和5之间。给出了一个小的*dx*值0.001，它也充当精度工具。较小的*dx*值产生更好的精度，但也需要更多的搜索迭代：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The incremental search root-finder method is a basic demonstration of the fundamental
    behavior of a root-finding algorithm. The accuracy is at its best when defined
    by *dx*, and consumes an extremely long computational time in the worst possible
    scenario. The higher the accuracy demanded, the longer it takes for the solution
    to converge. For practical reasons, this method is the least preferred of all
    root-finding algorithms, and we will take a look at alternative methods to find
    the roots of our equation that can give us better performance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 增量搜索根查找方法是根查找算法基本行为的基本演示。当由*dx*定义时，精度最佳，并且在最坏的情况下需要极长的计算时间。要求的精度越高，解决方案收敛所需的时间就越长。出于实际原因，这种方法是所有根查找算法中最不受欢迎的，我们将研究替代方法来找到我们方程的根，以获得更好的性能。
- en: The bisection method
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分法
- en: The bisection method is considered the simplest one-dimensional root-finding
    algorithm. The general interest is to find the value, *x*, of a continuous function, *f*,
    such that *f(x)=0*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 二分法被认为是最简单的一维根查找算法。一般的兴趣是找到连续函数*f*的值*x*，使得*f(x)=0*。
- en: Suppose we know the two points of an interval, *a* and *b*, where *a* < *b*,
    and that *f(a)<0* and *f(b)>0* lie along the continuous function, taking the midpoint
    of this interval as *c*, where ![](Images/12ba4631-1b1e-4281-9d52-2204938de47d.png); the
    bisection method then evaluates this value as *f(c)*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道区间*a*和*b*的两个点，其中*a*<*b*，并且连续函数上有*f(a)<0*和*f(b)>0*，则取该区间的中点作为*c*，其中![](Images/12ba4631-1b1e-4281-9d52-2204938de47d.png)；然后二分法计算该值*f(c)*。
- en: 'Let''s illustrate the setup of points along a nonlinear function with the following
    graph:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下图示来说明沿着非线性函数设置点的情况：
- en: '![](Images/6ecf4f90-5e2b-4d10-a867-cdc235884bf3.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6ecf4f90-5e2b-4d10-a867-cdc235884bf3.png)'
- en: Since the value of *f(a)* is negative and *f(b)* is positive, the bisection
    method assumes that the root, *x*, lies somewhere between *a* and *b* and gives
    *f(x)=0*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*f(a)*的值为负，*f(b)*的值为正，二分法假设根*x*位于*a*和*b*之间，并给出*f(x)=0*。
- en: If *f(c)=0* or is very close to zero by some predetermined error-tolerance value,
    a root is declared as found. If *f(c)<0*, we may conclude that a root exists along
    the *c* and *b* interval, or the *a* and *c* interval otherwise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f(c)=0*或者非常接近零，通过预定的误差容限值，就宣布找到了一个根。如果*f(c)<0*，我们可以得出结论，根存在于*c*和*b*的区间，或者*a*和*c*的区间。
- en: In the next evaluation, *c* is replaced as either *a* or *b* accordingly. With
    the new interval shortened, the bisection method repeats with the same evaluation
    to determine the next value of *c*. This process continues, shrinking the width
    of the *ab* interval until the root is considered found.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次评估中，*c*将相应地替换为*a*或*b*。随着新区间缩短，二分法重复相同的评估，以确定*c*的下一个值。这个过程继续，缩小*ab*的宽度，直到根被认为找到。
- en: The biggest advantage of using the bisection method is its guarantee to converge
    to an approximation of the root, given a predetermined error-tolerance level and
    the maximum number of iterations allowed. It should be noted that the bisection
    method does not require knowledge of the derivative of the unknown function. In
    certain continuous functions, the derivative could be complex or even impossible
    to calculate. This makes the bisection method extremely valuable for working on
    functions that are not smooth.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二分法的最大优势是保证在给定预定的误差容限水平和允许的最大迭代次数下收敛到根的近似值。应该注意的是，二分法不需要未知函数的导数知识。在某些连续函数中，导数可能是复杂的，甚至不可能计算。这使得二分法对于处理不平滑函数非常有价值。
- en: Because the bisection method does not require derivative information from the
    continuous function, its major drawback is that it takes up more computational
    time in the iterative evaluation than other root-finder methods. Also, since the
    search boundary of the bisection method lies in the *a* and *b* intervals, it
    would require a good approximation to ensure that the root falls within this range.
    Otherwise, an incorrect solution may be obtained, or even none at all. Using large
    values of *a* and *b* might consume more computational time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二分法不需要来自连续函数的导数信息，其主要缺点是在迭代评估中花费更多的计算时间。此外，由于二分法的搜索边界位于*a*和*b*区间内，因此需要一个良好的近似值来确保根落在此范围内。否则，可能会得到不正确的解，甚至根本没有解。使用较大的*a*和*b*值可能会消耗更多的计算时间。
- en: The bisection is considered to be stable without the use of an initial guess
    value for convergence to happen. Often, it is used in combination with other methods,
    such as the faster Newton's method, to converge quickly with precision.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 二分法被认为是稳定的，无需使用初始猜测值即可收敛。通常，它与其他方法结合使用，例如更快的牛顿法，以便快速收敛并获得精度。
- en: 'The Python code for the bisection method is given as follows. Save this as
    `bisection.py`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 二分法的Python代码如下。将其保存为`bisection.py`：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, we bounded the anonymous `lambda` function to the `y` variable with an
    input parameter, `x`, and attempted to solve the ![](Images/8f4c7e93-c309-4a2d-93ff-ad18aab35ca9.png) equation
    as before, in the interval between -5 to 5 to an accuracy of 0.00001 with a maximum
    iteration of 100.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将匿名的`lambda`函数绑定到`y`变量，带有输入参数`x`，并尝试解决![](Images/8f4c7e93-c309-4a2d-93ff-ad18aab35ca9.png)方程，与之前一样，在-5到5之间的区间内，精度为0.00001，最大迭代次数为100。
- en: As we can see, the result from the bisection method gives us better precision
    in far fewer iterations over the incremental search method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，与增量搜索方法相比，二分法给出了更好的精度，迭代次数更少。
- en: Newton's method
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牛顿法
- en: '**Newton''s method**, also known as the **Newton-Raphson method**, uses an
    iterative procedure to solve for a root using information about the derivative
    of a function. The derivative is treated as a linear problem to be solved. The
    first-order derivation, *f′*, of the function, *f*, represents the tangent line.
    The approximation to the next value of *x*, given as *x[1]*, is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法，也称为牛顿-拉弗森法，使用迭代过程来求解根，利用函数的导数信息。导数被视为一个要解决的线性问题。函数的一阶导数*f′*代表切线。给定*x*的下一个值的近似值，记为*x[1]*，如下所示：
- en: '![](Images/83f6a2db-d36c-4456-9e65-b66aa64f69c7.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/83f6a2db-d36c-4456-9e65-b66aa64f69c7.png)'
- en: 'Here, the tangent line intersects the *x* axis at *x[1]*, which produces *y=0*.
    This also represents the first-order Taylor expansion about *x[1]*, such that
    that the new point, *![](Images/098dae2a-368f-42ca-8d70-e3a5d30631cf.png)*, solves
    the following equation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，切线与*x*轴相交于*x[1]*，产生*y=0*。这也表示关于*x[1]*的一阶泰勒展开，使得新点*![](Images/098dae2a-368f-42ca-8d70-e3a5d30631cf.png)*解决以下方程：
- en: '![](Images/3ad672d5-727a-4a6f-b135-19d2ce53e032.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3ad672d5-727a-4a6f-b135-19d2ce53e032.png)'
- en: This process is repeated with *x* taking the value of *x[1]* until the maximum
    number of iterations is reached, or the absolute difference between *x[1]* and
    *x* is within an acceptable accuracy level.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重复这个过程，*x*取值为*x[1]*，直到达到最大迭代次数，或者*x[1]*和*x*之间的绝对差在可接受的精度水平内。
- en: An initial guess value is required to compute the values of *f(x)* and *f'(x)*.
    The rate of convergence is quadratic, which is considered to be extremely fast
    at obtaining the solution with high levels of accuracy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个初始猜测值来计算*f(x)*和*f'(x)*的值。收敛速度是二次的，被认为是以极高的精度获得解决方案的非常快速的速度。
- en: The drawback to Newton's method is that it does not guarantee global convergence
    to the solution. Such a situation arises when the function contains more than
    one root, or when the algorithm arrives at a local extremum and is unable to compute
    the next step. As this method requires knowledge of the derivative of its input
    function, it is required that the input function be differentiable. However, in
    certain circumstances, it is impossible for the derivative of a function to be
    known, or otherwise be mathematically easy to compute.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法的缺点是它不能保证全局收敛到解决方案。当函数包含多个根或算法到达局部极值且无法计算下一步时，就会出现这种情况。由于该方法需要知道其输入函数的导数，因此需要输入函数可微。然而，在某些情况下，函数的导数是无法知道的，或者在数学上很容易计算。
- en: 'A graphical representation of Newton''s method is shown in the following screenshot.
    *x[0]* is the initial *x* value. The derivative of *f(x[0])* is evaluated, which
    is a tangent line crossing the *x* axis at *x[1]*. The iteration is repeated,
    evaluating the derivative at points *x[1]*, *x[2]*, *x[3]*, and so on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿法的图形表示如下截图所示。*x[0]*是初始*x*值。评估*f(x[0])*的导数，这是一个切线，穿过*x*轴在*x[1]*处。迭代重复，评估点*x[1]*，*x[2]*，*x[3]*等处的导数：
- en: '![](Images/44c5361f-e2b4-4a9b-a6bd-c8a6c45dc95b.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/44c5361f-e2b4-4a9b-a6bd-c8a6c45dc95b.png)'
- en: 'The implementation of Newton''s method in Python is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python中牛顿法的实现如下：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will use the same function used in the bisection example and take a look
    at the results from Newton''s method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用二分法示例中使用的相同函数，并查看牛顿法的结果：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Beware of division by zero exceptions! In Python 2, using values such as 5.0,
    instead of 5, lets Python recognize the variable as a float, avoids the problem
    of treating variables as integers in calculations, and gives us better precision.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意除零异常！在Python 2中，使用值如5.0，而不是5，让Python将变量识别为浮点数，避免了将变量视为整数进行计算的问题，并给出了更好的精度。
- en: With Newton's method, we obtained a really close solution with less iteration
    over the bisection method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用牛顿法，我们获得了一个非常接近的解，迭代次数比二分法少。
- en: The secant method
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 割线法
- en: The secant method uses secant lines to find the root. A secant line is a straight
    line that intersects two points of a curve. In the secant method, a line is drawn
    between two points on the continuous function, such that it extends and intersects
    the *x* axis. This method can be thought of as a Quasi-Newton method. By successively
    drawing such secant lines, the root of the function can be approximated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用割线法来寻找根。割线是一条直线，它与曲线的两个点相交。在割线法中，画一条直线连接连续函数上的两个点，使其延伸并与*x*轴相交。这种方法可以被视为拟牛顿法。通过连续画出这样的割线，可以逼近函数的根。
- en: 'The secant method is graphically represented in the following screenshot. An
    initial guess of the two *x* axis values, *a* and *b*, is required to find *f(a)*
    and *f(b)*. A secant line, *y*, is drawn from *f(b)* to *f(a)* and intersects
    at the *c* point on the *x* axis, such that:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法在以下截图中以图形方式表示。需要找到两个*x*轴值的初始猜测，*a*和*b*，以找到*f(a)*和*f(b)*。从*f(b)*到*f(a)*画一条割线*y*，并在*x*轴上的点*c*处相交，使得：
- en: '![](Images/204bd4e1-084d-49a8-a8d9-f1042d68d554.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/204bd4e1-084d-49a8-a8d9-f1042d68d554.png)'
- en: 'The solution to *c* is therefore as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*c*的解如下：
- en: '![](Images/4f09d442-9dc2-4ce9-9422-09b1e5fdcaa6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4f09d442-9dc2-4ce9-9422-09b1e5fdcaa6.png)'
- en: 'On the next iteration, *a* and *b* will take on the values of *b* and *c*,
    respectively. The method repeats itself, drawing secant lines for the *x* axis
    values of *a* and *b*, *b* and *c*, *c* and *d*, and so on. The solution terminates
    when the maximum number of iterations has been reached, or the difference between
    *b* and *c* has reached a pre-specified tolerance level, as shown in the following
    graph:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，*a*和*b*将分别取*b*和*c*的值。该方法重复自身，为*x*轴值*a*和*b*、*b*和*c*、*c*和*d*等画出割线。当达到最大迭代次数或*b*和*c*之间的差异达到预先指定的容限水平时，解决方案终止，如下图所示：
- en: '![](Images/e525602d-220b-457d-b4db-8f44ace834f8.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e525602d-220b-457d-b4db-8f44ace834f8.png)'
- en: The rate of convergence of the secant method is considered to be superlinear.
    Its secant method converges much faster than the bisection method and slower than
    Newton's method. In Newton's method, the number of floating-point operations takes
    up twice as much time as the secant method in the computation of both its function
    and its derivative on every iteration. Since the secant method requires only the
    computation of its function at every step, it can be considered faster in absolute
    time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法的收敛速度被认为是超线性的。其割线法比二分法收敛速度快得多，但比牛顿法慢。在牛顿法中，浮点运算的数量在每次迭代中占用的时间是割线法的两倍，因为需要计算函数和导数。由于割线法只需要在每一步计算其函数，因此在绝对时间上可以认为更快。
- en: The initial guess values of the secant method must be close to the root, otherwise
    it has no guarantee of converging to the solution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法的初始猜测值必须接近根，否则无法保证收敛到解。
- en: 'The Python code for the secant method is given as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法的Python代码如下所示：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, we will reuse the same nonlinear function and return the results from
    the secant method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次重用相同的非线性函数，并返回割线法的结果：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Though all of the preceding root-finding methods gave very close solutions,
    the secant method performs with fewer iterations compared to the bisection method,
    but with more than Newton's method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有先前的根查找方法都给出了非常接近的解，割线法与二分法相比，迭代次数更少，但比牛顿法多。
- en: Combing root-finding methods
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合根查找方法
- en: 'It is perfectly possible to write your own root-finding algorithms using a
    combination of the previously-mentioned root-finding methods. For example, you
    may use the following implementation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以使用前面提到的根查找方法的组合来编写自己的根查找算法。例如，可以使用以下实现：
- en: Use the faster secant method to converge the problem to a pre-specified error-tolerance
    value or a maximum number of iterations
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用更快的割线法将问题收敛到预先指定的误差容限值或最大迭代次数
- en: Once a pre-specified tolerance level is reached, switch to using the bisection
    method to converge to the root by halving the search interval with each iteration
    until the root is found
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦达到预先指定的容限水平，就切换到使用二分法，通过每次迭代将搜索区间减半，直到找到根
- en: '**Brent''s method** or the **Wijngaarden-Dekker-Brent** **method** combines
    the bisection root-finding method, secant method, and inverse quadratic interpolation.
    The algorithm attempts to use either the secant method or inverse quadratic interpolation
    whenever possible, and uses the bisection method where necessary. Brent''s method
    can also be found in the `scipy.optimize.brentq` function of SciPy.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**布伦特法**或**Wijngaarden-Dekker-Brent**方法结合了二分根查找方法、割线法和反向二次插值。该算法尝试在可能的情况下使用割线法或反向二次插值，并在必要时使用二分法。布伦特法也可以在SciPy的`scipy.optimize.brentq`函数中找到。'
- en: SciPy implementations in root-finding
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根查找中的SciPy实现
- en: Before starting to write your root-finding algorithm to solve nonlinear or even
    linear problems, take a look at the documentation of the `scipy.optimize` methods.
    SciPy contains a collection of scientific computing functions as an extension
    of Python. Chances are that these open source algorithms might fit into your applications
    off the shelf.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写根查找算法来解决非线性甚至线性问题之前，先看看`scipy.optimize`方法的文档。SciPy包含一系列科学计算函数，作为Python的扩展。这些开源算法很可能适合您的应用程序。
- en: Root-finding scalar functions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找标量函数的根
- en: 'Some root-finding functions that can be found in the `scipy.optimize` modules
    include `bisect`, `newton`, `brentq`, and `ridder`. Let''s set up the examples
    that we have discussed in the *Incremental search s*ection using the implementations
    by SciPy:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.optimize`模块中可以找到一些根查找函数，包括`bisect`、`newton`、`brentq`和`ridder`。让我们使用SciPy的实现来设置我们在*增量搜索*部分中讨论过的示例：'
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we run the preceding code, the following output is generated:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行上述代码时，将生成以下输出：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the SciPy implementation gives us very similar answers to our
    derived ones.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，SciPy的实现给出了与我们推导的答案非常相似的答案。
- en: 'It should be noted that SciPy has a set of well-defined conditions for every
    implementation. For example, the function call of the bisection routine in the
    documentation is given as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，SciPy对每个实现都有一组明确定义的条件。例如，在文档中二分法例程的函数调用如下所示：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function will strictly evaluate the function, *f*, to return a zero of the
    function. *f(a)* and *f(b)* cannot have the same signs. In certain scenarios,
    it is difficult to fulfill these constraints. For example, in solving for nonlinear
    implied volatility models, volatility values cannot be negative. In active markets,
    finding a root or a zero of the volatility function is almost impossible without
    modifying the underlying implementation. In such cases, implementing our own root-finding
    methods might perhaps give us more authority over how our application should behave.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将严格评估函数*f*以返回函数的零点。*f(a)*和*f(b)*不能具有相同的符号。在某些情况下，很难满足这些约束条件。例如，在解决非线性隐含波动率模型时，波动率值不能为负。在活跃市场中，如果不修改基础实现，几乎不可能找到波动率函数的根或零点。在这种情况下，实现我们自己的根查找方法也许可以让我们更加掌控我们的应用程序应该如何执行。
- en: General nonlinear solvers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般非线性求解器
- en: 'The `scipy.optimize` module also contains multidimensional general solvers
    that we can use to our advantage. The `root` and `fsolve` functions are some examples
    with the following function properties:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.optimize`模块还包含了我们可以利用的多维通用求解器。`root`和`fsolve`函数是一些具有以下函数属性的例子：'
- en: '`root(fun, x0[, args, method, jac, tol, ...])`: This finds a root of a vector
    function.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root(fun, x0[, args, method, jac, tol, ...])`：这找到向量函数的根。'
- en: '`fsolve(func, x0[, args, fprime, ...])`: This finds the roots of a function.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fsolve(func, x0[, args, fprime, ...])`：这找到函数的根。'
- en: 'The outputs are returned as dictionary objects. Using our example as input
    to these functions, we will get the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以字典对象的形式返回。使用我们的示例作为这些函数的输入，我们将得到以下输出：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using an initial guess value of `5`, our solution converged to the root at
    `1.24189656`, which is pretty close to the answers we''ve had so far. What happens
    when we choose a value on the other side of the graph? Let''s use an initial guess
    value of `-5`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用初始猜测值`5`，我们的解收敛到了根`1.24189656`，这与我们迄今为止得到的答案非常接近。当我们选择图表另一侧的值时会发生什么？让我们使用初始猜测值`-5`：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see from the display output, the algorithms did not converge and
    returned a root that is a little bit different from our previous answers. If we
    take a look at the equation on a graph, there are a number of points along the
    curve that lie very close to the root. A root-finder would be needed to obtain
    the desired level of accuracy, while solvers attempt to solve for the nearest
    answer in the fastest time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从显示输出中可以看出，算法没有收敛，并返回了一个与我们先前答案略有不同的根。如果我们在图表上看方程，会发现曲线上有许多点非常接近根。需要一个根查找器来获得所需的精度水平，而求解器则试图以最快的时间解决最近的答案。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we briefly discussed the persistence of nonlinearity in economics
    and finance. We looked at some nonlinear models that are commonly used in finance
    to explain certain aspects of data left unexplained by linear models: the Black-Scholes
    implied volatility model, Markov switching model, threshold model, and smooth
    transition models.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要讨论了经济和金融中非线性的持久性。我们看了一些在金融中常用的非线性模型，用来解释线性模型无法解释的数据的某些方面：Black-Scholes隐含波动率模型、Markov转换模型、阈值模型和平滑转换模型。
- en: In Black-Scholes implied-volatility modeling, we discussed the volatility smile,
    which was made up of implied volatilities derived via the Black-Scholes model
    from the market prices of call or put options for a particular maturity. You may
    be interested enough to seek the lowest implied-volatility value possible, which
    can be useful for inferring theoretical prices and comparing against market prices
    for potential opportunities. However, since the curve is nonlinear, linear algebra
    cannot adequately solve for the optimal point. To do so, we will require the use
    of root-finding methods.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Black-Scholes隐含波动率建模中，我们讨论了波动率微笑，它由通过Black-Scholes模型从特定到期日的看涨或看跌期权的市场价格推导出的隐含波动率组成。您可能会对寻找可能的最低隐含波动率值感兴趣，这对于推断理论价格并与潜在机会的市场价格进行比较可能是有用的。然而，由于曲线是非线性的，线性代数无法充分解决最优点的问题。为此，我们将需要使用根查找方法。
- en: Root-finding methods attempt to find the root of a function or its zero. We
    discussed common root-finding methods, such as the bisection method, Newton's
    method, and the secant method. Using a combination of root-finding algorithms
    may help us to find roots of complex functions faster. One such example is Brent's
    method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根查找方法试图找到函数的根或零点。我们讨论了常见的根查找方法，如二分法、牛顿法和割线法。使用根查找算法的组合可能有助于更快地找到复杂函数的根。Brent方法就是一个例子。
- en: We explored functionalities in the `scipy.optimize` module that contains these
    root-finding methods, albeit with constraints. One of these constraints requires
    that the two boundary input values be evaluated with a pair of a negative value
    and a positive value for the solution to converge successfully. In implied volatility
    modeling, this evaluation is almost impossible, since volatilities do not have
    negative values. Implementing our own root-finding methods might perhaps give
    us more authority over how our application should perform.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了`scipy.optimize`模块中包含的这些根查找方法的功能，尽管有约束条件。其中一个约束条件要求两个边界输入值被评估为一个负值和一个正值的对，以便解收敛成功。在隐含波动率建模中，这种评估几乎是不可能的，因为波动率没有负值。实现我们自己的根查找方法也许可以让我们更加掌控我们的应用程序应该如何执行。
- en: Using general solvers is another way to find roots. They may also converge to
    our solution more quickly, but such convergence is not guaranteed by the initial
    given values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通用求解器是另一种寻找根的方法。它们可能会更快地收敛到我们的解，但这种收敛并不由初始给定的值保证。
- en: Nonlinear modeling and optimization are inherently a complex task, and there
    is no universal solution or sure way to reach a conclusion. This chapter serves
    to introduce nonlinearity studies for finance in general.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性建模和优化本质上是一项复杂的任务，没有通用的解决方案或确定的方法来得出结论。本章旨在介绍金融领域的非线性研究。
- en: In the next chapter, we will take a look at numerical methods commonly used
    for options pricing. By pairing a numerical procedure with a root-finding algorithm,
    we will learn how to build an implied volatility model with the market prices
    of an equity option.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍常用于期权定价的数值方法。通过将数值程序与寻根算法配对，我们将学习如何利用股票期权的市场价格构建隐含波动率模型。
