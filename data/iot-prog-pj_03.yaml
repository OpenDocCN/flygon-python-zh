- en: Using the GPIO to Connect to the Outside World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPIO连接到外部世界
- en: In this chapter we will start unlocking the real power behind the Raspberry
    Pi—the GPIO, or General Purpose Input Output. The GPIO allows you to connect your
    Raspberry Pi to the outside world through the use of pins that may be set to input
    or output, and are controlled through code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始解锁树莓派背后真正的力量——GPIO，或通用输入输出。 GPIO允许您通过可以设置为输入或输出的引脚将树莓派连接到外部世界，并通过代码进行控制。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Python libraries for the Raspberry Pi
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派的Python库
- en: Accessing Raspberry Pi’s GPIO
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问树莓派的GPIO
- en: Setting up the circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置电路
- en: Hello LED
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你好LED
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we start by exploring Raspberry Pi-specific libraries for Python.
    We will demonstrate these with a few examples by using the Raspberry Pi camera
    module and Pibrella HAT. We will try a few coding examples with the Sense Hat
    emulator before moving on to designing a physical circuit using the Fritzing program.
    Using a breadboard, we will set up this circuit and connect it to our Raspberry
    Pi.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探索了Python的树莓派特定库。我们将使用树莓派相机模块和Pibrella HAT的几个示例来演示这些内容。在转到使用Fritzing程序设计物理电路之前，我们将尝试使用Sense
    Hat模拟器进行一些编码示例。使用面包板，我们将设置这个电路并将其连接到我们的树莓派。
- en: We will finish off this chapter by building a Morse code generator that transmits
    weather data in Morse code from the class we created in [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml),
    *Writing Python Programs Using Raspberry Pi*. This chapter should take an afternoon
    to complete.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在[第2章](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml)中创建的类中构建一个摩尔斯电码生成器，该生成器将以摩尔斯电码传输天气数据来结束本章，*使用树莓派编写Python程序*。完成本章应该需要一个下午的时间。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is required to complete this project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此项目需要以下内容：
- en: A Raspberry Pi Model 3 (2015 model or newer)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派3型号（2015年或更新型号）
- en: A USB power supply
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB电源适配器
- en: Computer monitor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机显示器
- en: A USB keyboard
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB键盘
- en: A USB mouse
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB鼠标
- en: A Raspberry Pi camera module (optional)—[https://www.raspberrypi.org/products/camera-module-v2/](https://www.raspberrypi.org/products/camera-module-v2/)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派相机模块（可选）—[https://www.raspberrypi.org/products/camera-module-v2/](https://www.raspberrypi.org/products/camera-module-v2/)
- en: A Pribrella HAT (optional)—[www.pibrella.com](http://www.pibrella.com)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pribrella HAT（可选）—[www.pibrella.com](http://www.pibrella.com)
- en: A Sense HAT (optional, as we will be using the emulator in this chapter)—[https://www.raspberrypi.org/products/sense-hat/a](https://www.raspberrypi.org/products/sense-hat/)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sense HAT（可选，因为我们将在本章中使用模拟器）—[https://www.raspberrypi.org/products/sense-hat/a](https://www.raspberrypi.org/products/sense-hat/)
- en: A breadboard
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: Male-to-female jumper wires
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母对公跳线
- en: An LED
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED
- en: Python libraries for the Raspberry Pi
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树莓派的Python库
- en: 'We will turn our attention to the Python libraries or packages that come pre-installed
    with Raspbian. To view these packages from Thonny, click on Tools | Manage Packages.
    After a short delay, you should see many packages listed in the dialog:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把注意力转向Raspbian预装的Python库或包。要从Thonny查看这些包，请单击工具|管理包。稍等片刻后，您应该会在对话框中看到许多列出的包：
- en: '![](assets/f8e2919c-6c5f-4f6b-b422-44c9bad7d1ed.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8e2919c-6c5f-4f6b-b422-44c9bad7d1ed.png)'
- en: Let's explore a few of these packages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索其中一些包。
- en: picamera
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: picamera
- en: 'The camera port, or CSI, on the Raspberry Pi allows you to connect the specially
    designed Raspberry Pi camera module to your Pi. This camera can take both photos
    and videos, and has functionality to do time-lapse photography and slow-motion
    video recording. The `picamera` package gives us access to the camera through
    Python. The following is a picture of a Raspberry Pi camera module connected to
    a Raspberry Pi 3 Model B through the camera port:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派上的相机端口或CSI允许您将专门设计的树莓派相机模块连接到您的Pi。该相机可以拍摄照片和视频，并具有进行延时摄影和慢动作视频录制的功能。`picamera`包通过Python使我们可以访问相机。以下是连接到树莓派3
    Model B的树莓派相机模块的图片：
- en: '![](assets/60d9b712-4c92-452c-9930-4b35240bbf9f.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60d9b712-4c92-452c-9930-4b35240bbf9f.png)'
- en: 'Connect your Raspberry Pi camera module to your Pi, open up Thonny, and type
    in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将树莓派相机模块连接到您的Pi，打开Thonny，并输入以下代码：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code imports the `picamera` and `time` packages, and then creates a `picamera`
    object called `picam`. From there, we start the preview and then sleep for `10`
    seconds, before stopping the preview and then closing the camera. After running
    the program, you should see a `10` second preview from the camera on your screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导入了`picamera`和`time`包，然后创建了一个名为`picam`的`picamera`对象。从那里，我们开始预览，然后睡眠`10`秒，然后停止预览并关闭相机。运行程序后，您应该在屏幕上看到来自相机的`10`秒预览。
- en: Pillow
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枕头
- en: 'The Pillow package is used for image processing with Python. To test this out,
    download an image to the same directory as your project files. Create a new file
    in Thonny and type in the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow包用于Python图像处理。要测试这一点，请将图像下载到与项目文件相同的目录中。在Thonny中创建一个新文件，然后输入以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should see the format and size of the image (in brackets) printed at the
    commandline that follows.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在随后的命令行中看到图像的格式和大小（括号内）打印出来。
- en: sense-hat and sense-emu
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sense-hat和sense-emu
- en: The Sense HAT is a sophisticated add-on board for the Raspberry Pi. The Sense
    HAT is the main component in the Astro Pi kit, part of a program to have young
    students program a Raspberry Pi for the International Space Station.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT是树莓派的一个复杂的附加板。Sense HAT是Astro Pi套件的主要组件，是一个让年轻学生为国际空间站编程树莓派的计划的一部分。
- en: The Astro Pi competition was officially opened in January of 2015 to all primary
    and secondary school-aged children in the United Kingdom. During a mission to
    the International Space Station, British astronaut Tim Peake deployed Astro Pi
    computers on board the station.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Astro Pi比赛于2015年1月正式向英国所有小学和中学年龄的孩子开放。在对国际空间站的任务中，英国宇航员蒂姆·皮克在航天站上部署了Astro Pi计算机。
- en: The winning Astro Pi competition code was loaded onto an Astro Pi while in orbit.
    The data generated was collected and sent back to Earth.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 获胜的Astro Pi比赛代码被加载到太空中的Astro Pi上。生成的数据被收集并发送回地球。
- en: 'The Sense HAT contains an array of LEDs that can be used as a display. The
    Sense HAT also has the following sensors onboard:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Sense HAT包含一组LED，可用作显示器。Sense HAT还具有以下传感器：
- en: Accelerometer
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计
- en: Temperature sensor
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度传感器
- en: Magnetometer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁力计
- en: Barometric pressure sensor
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气压传感器
- en: Humidity sensor
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 湿度传感器
- en: Gyroscope
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陀螺仪
- en: We can access the sensors and LEDs on the Sense HAT through the `sense-hat` package.
    For those that do not have a Sense HAT, the Sense HAT emulator in Raspbian may
    be used instead. We use the `sense-emu` package to access the emulated sensors
    and LED display on the Sense HAT emulator.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`sense-hat`包访问Sense HAT上的传感器和LED。对于那些没有Sense HAT的人，可以使用Raspbian中的Sense
    HAT模拟器。我们使用`sense-emu`包来访问Sense HAT模拟器上模拟的传感器和LED显示。
- en: 'To demonstrate this, perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，请执行以下步骤：
- en: Create a new file in Thonny and name it `sense-hat-test.py`, or something similar.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny中创建一个新文件，并将其命名为`sense-hat-test.py`，或类似的名称。
- en: 'Type in the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入以下代码：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Load the Sense HAT Emulator program from Application Menu | Programming | Sense
    HAT Emulator.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序菜单|编程|Sense HAT模拟器加载Sense HAT模拟器程序。
- en: 'Arrange your screen so that you can see the LED display of the Sense HAT emulator
    and the full window of Thonny (see the following screenshot):'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整屏幕，以便您可以看到Sense HAT模拟器的LED显示和Thonny的完整窗口（请参见下一张截图）：
- en: '![](assets/366ddf47-8fe3-40c4-ae0a-3eadd23b99ff.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/366ddf47-8fe3-40c4-ae0a-3eadd23b99ff.png)'
- en: Click on the **Run current script** button.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行当前脚本**按钮。
- en: You should see the `Hello World!` message scroll across the LED display of the
    Sense HAT emulator one letter at a time (see the previous screenshot).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到“Hello World！”消息一次一个字母地滚动在Sense HAT模拟器的LED显示器上（请参见上一张截图）。
- en: Accessing Raspberry Pi's GPIO
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问树莓派的GPIO
- en: 'Through the GPIO, we are able to connect to the outside world. Here is a diagram
    of the Raspberry Pi GPIO pins:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GPIO，我们能够连接到外部世界。以下是树莓派GPIO引脚的图示：
- en: '![](assets/79dbd754-d3e8-462d-83c5-4eba89aed7ac.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79dbd754-d3e8-462d-83c5-4eba89aed7ac.jpg)'
- en: 'The following is an explanation of these pins:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些引脚的解释：
- en: Red pins represent power coming out of the GPIO. The GPIO provides 3.3 Volts
    and 5 Volts.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色引脚代表GPIO输出的电源。GPIO提供3.3伏特和5伏特。
- en: Black pins represent pins used for electrical ground. As you can see, there
    are 8 ground pins on the GPIO.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑色引脚代表用于电气接地的引脚。正如您所看到的，GPIO上有8个接地引脚。
- en: Blue pins are used for Raspberry Pi **Hardware Added on Top** (**HATs**). They
    allow communication between the Raspberry Pi and the HAT's **Electrical Erasable
    Programmable Read-Only Memory** (**EEPROM**).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色引脚用于树莓派的**硬件附加在顶部**（**HATs**）。它们允许树莓派和HAT的**电可擦可编程只读存储器**（**EEPROM**）之间的通信。
- en: Green pins represent the input and output pins that we may program for. Please
    note that some of the green GPIO pins double up with additional functionality.
    We will not be covering the additional functionality for this project.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色引脚代表我们可以为其编程的输入和输出引脚。请注意，一些绿色GPIO引脚具有额外的功能。我们将不会涵盖这个项目的额外功能。
- en: The GPIO is what lies at the heart of the Raspberry Pi. We can connect LEDs,
    buttons, buzzers, and so on to the Raspberry Pi through the GPIO. We can also
    access the GPIO through HATs designed for the Raspberry Pi. One of those, called `Pibrella`,
    is what we will use next to explore connecting to the GPIO through Python code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO是树莓派的核心。我们可以通过GPIO将LED、按钮、蜂鸣器等连接到树莓派上。我们还可以通过为树莓派设计的HAT来访问GPIO。其中之一叫做“Pibrella”，这是我们接下来将使用的，用来通过Python代码探索连接到GPIO。
- en: Raspberry Pi 1 Models A and B only have the first 26 pins (as shown by the dotted
    line). Models since then, including Raspberry Pi 1 Models A+ and B+, Raspberry
    Pi 2, Raspberry Pi Zero and Zero W, and Raspberry Pi 3 Model B and B+, have 40
    GPIO pins.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派1型A和B型只有前26个引脚（如虚线所示）。从那时起的型号，包括树莓派1型A+和B+，树莓派2，树莓派Zero和Zero W，以及树莓派3型B和B+，都有40个GPIO引脚。
- en: Pibrella
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pibrella
- en: 'Pibrella is a relatively inexpensive Raspberry Pi HAT that makes connecting
    to the GPIO easy. The following are the components on-board of Pibrella:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pibrella是一个相对便宜的树莓派HAT，可以轻松连接到GPIO。以下是Pibrella板上的组件：
- en: 1 red LED
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个红色LED
- en: 1 yellow LED
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个黄色LED
- en: 1 green LED
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个绿色LED
- en: Small speaker
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小音箱
- en: Push button
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按键
- en: 4 inputs
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个输入
- en: 4 outputs
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个输出
- en: Micro USB power connector for delivering more power to the outputs
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB电源连接器，用于向输出提供更多电源
- en: Pibrella was designed for early Raspberry Pi models and thus only has a 26-pin
    input. It can, however, be connected to later models through the first 26 pins.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Pibrella是为早期的树莓派型号设计的，因此只有26个引脚输入。但是，它可以通过前26个引脚连接到后来的型号。
- en: 'To install the Pibrella Hat, line up the pin connectors on the Pibrella with
    the first 26 pins on the Raspberry Pi, and push down. In the following picture,
    we are installing Pibrella on a Raspberry Pi 3 Model B:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Pibrella Hat，将Pibrella上的引脚连接器与树莓派上的前26个引脚对齐，并向下按。在下图中，我们正在将Pibrella安装在树莓派3型B上：
- en: '![](assets/e0cdda19-675f-4dd9-8be8-92b39e77bb6b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e0cdda19-675f-4dd9-8be8-92b39e77bb6b.png)'
- en: 'Pibrella should fit snugly when installed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Pibrella时应该很合适：
- en: '![](assets/4db07f13-e208-4307-9997-1d85ee2adc90.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4db07f13-e208-4307-9997-1d85ee2adc90.png)'
- en: 'The libraries needed to connect to Pibrella do not come pre-installed with
    Raspbian (as of the time of writing), so we have to install them ourselves. To
    do that, we will use the `pip3` command from the Terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到Pibrella所需的库在Raspbian中没有预先安装（截至撰写本文的时间），因此我们必须自己安装它们。为此，我们将使用终端中的`pip3`命令：
- en: 'Load the Terminal by clicking on it on the top tool bar (fourth icon from the
    left). At the Command Prompt, type the following:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击顶部工具栏上的终端（从左起的第四个图标）加载终端。在命令提示符下，键入以下内容：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the package load from the Terminal:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到终端加载软件包：
- en: '![](assets/98d08ff7-12f1-4e83-8cad-e317d2db3e8d.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/98d08ff7-12f1-4e83-8cad-e317d2db3e8d.png)'
- en: With the `Pibrella` library, there is no need to know the GPIO pin numbers in
    order to access the GPIO. The functionality is wrapped up in the `Pibrella` object
    we import into our code. We will do a short demonstration.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Pibrella`库，无需知道GPIO引脚编号即可访问GPIO。该功能被包装在我们导入到代码中的`Pibrella`对象中。我们将进行一个简短的演示。
- en: 'Create a new file in Thonny called `pibrella-test.py`, or name it something
    similar. Type in the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny中创建一个名为`pibrella-test.py`的新文件，或者取一个类似的名字。键入以下代码：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code by clicking on the Run current script button. If you typed everything
    in correctly, you should see the red light on the Pibrella board turn on for `5`
    seconds before a short melody is played over the speaker.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行当前脚本按钮运行代码。如果您输入的一切都正确，您应该看到Pibrella板上的红灯在`5`秒钟内亮起，然后扬声器发出短暂的旋律。
- en: Congratulations, you have now crossed the threshold into the world of physical
    computing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您现在已经跨越了物理计算的门槛。
- en: RPi.GPIO
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPi.GPIO
- en: 'The standard Python package for accessing the GPIO is called `RPi.GPIO`. The
    best way to describe how it works is with some code (this is for demonstration
    purposes only; we will be running code to access the GPIO in the upcoming section):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问GPIO的标准Python包称为`RPi.GPIO`。描述它的最佳方式是使用一些代码（这仅用于演示目的；我们将在接下来的部分中运行代码来访问GPIO）：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, this code seems a little bit confusing. We will step through
    it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这段代码似乎有点混乱。我们将逐步介绍它：
- en: 'First, we import the `RPi.GPIO` and `time` libraries:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入`RPi.GPIO`和`time`库：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we set the mode to `BCM`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将模式设置为`BCM`：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In BCM mode, we access the pin through GPIO numbers (the ones shown in our Raspberry
    Pi GPIO graphic). The alternative is to access the pins through their physical
    location (`GPIO.BOARD`).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BCM模式下，我们通过GPIO编号（显示在我们的树莓派GPIO图形中的编号）访问引脚。另一种方法是通过它们的物理位置（`GPIO.BOARD`）访问引脚。
- en: 'To set GPIO pin `18` to an output, we use the following line:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将GPIO引脚`18`设置为输出，我们使用以下行：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then set GPIO `18` to `HIGH` for `5` seconds before setting it to `LOW`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将GPIO `18`设置为`HIGH`，持续`5`秒，然后将其设置为`LOW`：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we had set up the circuit and run the code, we would see our LED light for
    `5` seconds before turning off, similar to the Pibrella example.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了电路并运行了代码，我们会看到LED在`5`秒钟内亮起，然后关闭，类似于Pibrella示例。
- en: GPIO zero
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO零
- en: An alternative to `RPi.GPIO` is the GPIO Zero package. As with `RPi.GPIO`, this
    package comes pre-installed with Raspbian. The zero in the name refers to zero
    boilerplate or setup code (code that we are forced to enter every time).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`的替代方案是GPIO Zero包。与`RPi.GPIO`一样，这个包已经预装在Raspbian中。名称中的零指的是零样板或设置代码（我们被迫每次输入的代码）。'
- en: 'To accomplish the same task of turning an LED on and off for `5` seconds, we
    use the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成打开和关闭LED灯5秒钟的相同任务，我们使用以下代码：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with our `RPi.GPIO` example, this code is for demonstration purposes only
    as we haven't set up a circuit yet. It's obvious that the GPIO Zero code is far
    simpler than the `RPi.GPIO` example. This code is pretty self-explanatory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`RPi.GPIO`示例一样，这段代码仅用于演示目的，因为我们还没有设置电路。很明显，GPIO Zero代码比`RPi.GPIO`示例简单得多。这段代码非常容易理解。
- en: In the following sections, we will start building a physical circuit on a breadboard
    with an LED, and use our code to turn it on and off.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将在面包板上构建一个物理电路，其中包括LED，并使用我们的代码来打开和关闭它。
- en: Setting up the circuit
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置电路
- en: The Pibrella HAT gave us a simple way of programming the GPIO, however, the
    ultimate goal of Raspberry Pi projects is to create a customized working circuit.
    We will now take the steps to design our circuit, and then create the circuit
    using a breadboard.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Pibrella HAT为我们提供了一种简单的编程GPIO的方法，然而，树莓派项目的最终目标是创建一个定制的工作电路。我们现在将采取步骤设计我们的电路，然后使用面包板创建电路。
- en: The first step is to design our circuit on the computer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在计算机上设计我们的电路。
- en: Fritzing
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fritzing
- en: 'Fritzing is a free circuit design software available for Windows, macOS, and
    Linux. There is a version in the Raspberry Pi store that we will install on our
    Raspberry Pi:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Fritzing是一款免费的电路设计软件，适用于Windows、macOS和Linux。树莓派商店中有一个版本，我们将在树莓派上安装它：
- en: 'From the Application Menu, choose Preferences | Add / Remove Software. In the
    Search box, type in `Fritzing`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用菜单中，选择首选项|添加/删除软件。在搜索框中，键入`Fritzing`：
- en: '![](assets/732813b5-525b-4bad-aac3-de11bd72da0a.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/732813b5-525b-4bad-aac3-de11bd72da0a.png)'
- en: Select all three boxes and click on Apply, and then OK. After installation,
    you should be able to load Fritzing from Application Menu | Programming | Fritzing.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有三个框，然后单击应用，然后单击确定。安装后，您应该能够从应用菜单|编程|Fritzing中加载Fritzing。
- en: Click on the Breadboard tab to access the breadboard design screen. A full size
    breadboard dominates the middle of the screen. We will make it smaller as our
    circuit is small and simple.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击面包板选项卡以访问面包板设计屏幕。一个全尺寸的面包板占据了屏幕的中间。我们将它缩小，因为我们的电路很小而简单。
- en: Click on the breadboard. In the Inspector box, you will see a heading called
    Properties.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击面包板。在检查器框中，您会看到一个名为属性的标题。
- en: Click on the Size dropdown and select Mini.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击大小下拉菜单，选择Mini。
- en: To add a Raspberry Pi to our circuit, type in `Raspberry Pi` in the search box.
    Drag a Raspberry Pi 3 under our breadboard.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将树莓派添加到我们的电路中，在搜索框中键入`Raspberry Pi`。将树莓派3拖到我们的面包板下方。
- en: From here, we may drag and drop components onto our breadboard.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们可以将组件拖放到面包板上。
- en: 'Add an LED and 330 Ohm resistor to our breadboard, shown in the following diagram.
    We use the resistor to protect both the LED and Raspberry Pi from excessive currents
    that may cause damage:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED和330欧姆电阻器添加到我们的面包板上，如下图所示。我们使用电阻器来保护LED和树莓派免受可能造成损坏的过大电流：
- en: '![](assets/d26a7e02-67c4-48f9-9591-588675500457.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d26a7e02-67c4-48f9-9591-588675500457.png)'
- en: You will notice that as we hover our mouse over each pin on our Raspberry Pi
    component, a yellow tip will pop up with the pin's BCM name. Click on GPIO 18
    and drag a line over to the positive leg of our LED (the longer one).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将鼠标悬停在树莓派组件的每个引脚上时，会弹出一个黄色提示，显示引脚的BCM名称。点击GPIO 18，将线拖到LED的正极（较长的引脚）。
- en: Do the same to drag a GND connection to the left-hand side of the resistor.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将GND连接拖到电阻的左侧。
- en: This is the circuit we will build for our Raspberry Pi.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将为树莓派构建的电路。
- en: Building our circuit
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的电路
- en: To build our physical circuit, start by inserting components into our breadboard.
    Referring to our diagram from before, we can see that some of the holes are green.
    This indicates continuity in the circuit. For example, we connect the negative
    leg of the LED to the 330 Ohm resistor through the same vertical column. Thus,
    the two component legs are connected together through the breadboard.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的物理电路，首先要将组件插入我们的面包板。参考之前的图表，我们可以看到一些孔是绿色的。这表示电路中有连续性。例如，我们通过同一垂直列将LED的负极连接到330欧姆电阻。因此，两个组件的引脚通过面包板连接在一起。
- en: 'We take this into account as we start to place our components on the breadboard:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始在面包板上放置组件时，我们要考虑这一点：
- en: '![](assets/f4d79016-46de-4fd7-9baa-94beaf95042d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4d79016-46de-4fd7-9baa-94beaf95042d.png)'
- en: Insert the LED into our breadboard, as shown in the preceding picture. We are
    following our Fritzing diagram and have the positive leg in the lower hole.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED插入我们的面包板，如上图所示。我们遵循我们的Fritzing图表，并将正极插入下方的孔中。
- en: Follow our Fritzing diagram and wire up the 330 Ohm resistor. Using female-to-male
    jumper wires, connect the Raspberry Pi to our breadboard.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照我们的Fritzing图表，连接330欧姆电阻。使用母对公跳线，将树莓派连接到面包板上。
- en: Refer to our Raspberry Pi GPIO diagram to find GPIO 18 and GND on the Raspberry
    Pi board.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考我们的树莓派GPIO图表，在树莓派主板上找到GPIO 18和GND。
- en: It is a good practice to have the Raspberry Pi powered off when connecting jumpers
    to the GPIO.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接跳线到GPIO时，最好将树莓派断电。
- en: 'As you can see in the following image, the complete circuit resembles our Fritzing
    diagram (only our breadboard and Raspberry Pi are turned sideways):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，完整的电路类似于我们的Fritzing图表（只是我们的面包板和树莓派被转向）：
- en: '![](assets/df8f25c1-4ead-4c0a-a641-2146ccb891ab.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/df8f25c1-4ead-4c0a-a641-2146ccb891ab.png)'
- en: Connect the Raspberry Pi back up to the monitor, power supply, keyboard, and
    mouse.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派重新连接到显示器、电源、键盘和鼠标。
- en: We are now ready to program our first real GPIO circuit.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好编程我们的第一个真正的GPIO电路。
- en: Hello LED
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello LED
- en: 'We will jump right into the code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入代码：
- en: Create a new file in Thonny, and call it `Hello LED.py` or something similar.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny中创建一个新文件，并将其命名为`Hello LED.py`或类似的名称。
- en: 'Type in the following code and run it:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码并运行：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Blink LED using gpiozero
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gpiozero闪烁LED
- en: If we wired up our circuit and typed in our code correctly, we should see our
    LED blink for 10 seconds in 1 second intervals. The blink function in the `gpiozero
    LED` object allows us to set `on_time` (the length of time in seconds that the
    LED stays on), `off_time` (the length of time in seconds that the LED is turned
    off for), `n` or the number of times the LED blinks, and `background` (set to
    `True` to allow other code to run while the LED is flashing).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确连接了电路并输入了正确的代码，我们应该看到LED以1秒的间隔闪烁10秒。`gpiozero LED`对象中的`blink`函数允许我们设置`on_time`（LED保持打开的时间长度，以秒为单位）、`off_time`（LED关闭的时间长度，以秒为单位）、`n`或LED闪烁的次数，以及`background`（设置为`True`以允许LED闪烁时运行其他代码）。
- en: 'The `blink` function call with its default parameters looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 带有默认参数的`blink`函数调用如下：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Without parameters passed into the function, the LED will blink non-stop at
    1 second intervals. Notice how we do not need to import the `time` library like
    we did when we used the `RPi.GPIO` package for accessing the GPIO. We simply pass
    a number into the `blink` function to represent the time in seconds we want the
    LED on or off.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中不传递参数时，LED将以1秒的间隔不停地闪烁。请注意，我们不需要像使用`RPi.GPIO`包访问GPIO时那样导入`time`库。我们只需将一个数字传递给`blink`函数，表示我们希望LED打开或关闭的时间（以秒为单位）。
- en: Morse code weather data
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摩尔斯码天气数据
- en: In [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml), *Writing Python
    Programs Using Raspberry Pi*, we wrote code that simulates calls to a web service
    that supplies weather information. Taking what we learned in this chapter, let's
    revisit that code and give it a physical computing upgrade. We will use our LED
    to flash a Morse code representation of our weather data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml)中，*使用树莓派编写Python程序*，我们编写了模拟调用提供天气信息的网络服务的代码。根据本章学到的知识，让我们重新审视该代码，并对其进行物理计算升级。我们将使用LED来闪烁表示我们的天气数据的摩尔斯码。
- en: Many of us believe that the world only started to become connected in the 1990s
    with the World Wide Web. Little do we realize that we already had such a world
    beginning in the 19th century with the introduction of the telegraph and trans-world
    telegraph cables. The language of this so-called Victorian Internet was Morse
    code, with the Morse code operator as its gate keeper.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人认为，世界直到1990年代才开始通过万维网变得连接起来。我们很少意识到，19世纪引入电报和跨世界电报电缆时，我们已经有了这样一个世界。这个所谓的维多利亚时代互联网的语言是摩尔斯码，摩尔斯码操作员是它的门卫。
- en: 'The following are the steps for flashing Morse code representation of our weather
    data:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是闪烁摩尔斯码表示我们的天气数据的步骤：
- en: 'We will first start by creating a `MorseCodeGenerator` class:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将创建一个`MorseCodeGenerator`类：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After importing the `gpiozero` and `time` libraries into our `MorseCodeGenerator`
    class, we define GPIO 18 as our LED with the line `led=LED(18)`
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`MorseCodeGenerator`类中导入`gpiozero`和`time`库后，我们将GPIO 18定义为我们的LED，代码为`led=LED(18)`
- en: We set the duration of how long a `dot` lasts with the line `dot_duration =
    0.3`
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`dot_duration = 0.3`来设置`dot`持续的时间。
- en: We then define the duration of the dash and spacing between words based on the
    `dot_duration`
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们根据`dot_duration`定义破折号的持续时间和单词之间的间距。
- en: To speed up or slow down our Morse code transmutation, we may adjust `dot_duration`
    accordingly
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了加快或减慢我们的莫尔斯码转换，我们可以相应地调整`dot_duration`。
- en: We use a Python dictionary with the name `MORSE_CODE`. We use this dictionary
    to translate letters to Morse code
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用一个名为`MORSE_CODE`的Python字典。我们使用这个字典将字母转换为莫尔斯码。
- en: Our `transmit_message` function steps through each letter of the message, and
    then each character in the Morse code, which is equivalent to using the `dash_dot`
    variable
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`transmit_message`函数逐个遍历消息中的每个字母，然后遍历莫尔斯码中的每个字符，这相当于使用`dash_dot`变量。
- en: 'The magic of our class happens in the `dot` and `dash` methods by using the
    `blink` function from the `gpiozero` library:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的类的魔力在`dot`和`dash`方法中发生，它们使用了`gpiozero`库中的`blink`函数：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `dot` method, we can see that we turn the LED on for the duration set
    in `dot_duration`, and then we turn it off for the same amount of time. We only
    blink it once as set it by the number `1` in the `blink` method call. We also
    set the background parameter to `False`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dot`方法中，我们可以看到我们将LED打开的持续时间设置为`dot_duration`，然后我们将其关闭相同的时间。我们只闪烁一次，因为在`blink`方法调用中将其设置为数字`1`。我们还将背景参数设置为`False`。
- en: This last parameter is very important, as if we leave it to the default of `True`,
    the code will continue to run before the LED has a chance to blink on and off.
    Basically, the code won't work unless the background parameter is set to `False`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的参数非常重要，因为如果我们将其保留为默认值`True`，那么LED在有机会闪烁之前，代码将继续运行。基本上，除非将背景参数设置为`False`，否则代码将无法工作。
- en: We forgo the usual `Hello World` for our test message and instead use the standard
    `SOS`, which is familiar to the most casual of Morse code enthusiasts. We may
    test our class by clicking on the Run button and, if all is set up correctly,
    we will see the LED blink SOS in Morse code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试消息中，我们放弃了通常的“Hello World”，而是使用了标准的“SOS”，这对于大多数莫尔斯码爱好者来说是熟悉的。我们可以通过单击“运行”按钮来测试我们的类，如果一切设置正确，我们将看到LED以莫尔斯码闪烁SOS。
- en: 'Now, let''s revisit our `CurrentWeather` class from [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml),
    *Writing Python Programs Using Raspberry Pi*. We will make a few minor modifications:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视一下[第2章](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml)中的`CurrentWeather`类，即*使用树莓派编写Python程序*。我们将进行一些小的修改：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We start by importing our `MorseCodeGenerator` class (make sure that both files
    are in the same directory). As we do not have a Morse code equivalent of `/`,
    we take out the km/h in the `weather_data` data set. The rest of the class remains
    the same as it did in [Chapter 2](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml),
    *Writing Python Programs Using Raspberry Pi*. In our test section, we instantiate
    both a `CurrentWeather` class and a `MorseCodeGenerator` class. Using the `CurrentWeather`
    class, we pass the weather conditions for Toronto into the `MorseCodeGenerator`
    class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入我们的`MorseCodeGenerator`类（确保两个文件在同一个目录中）。由于我们没有`/`的莫尔斯码等价物，我们从`weather_data`数据集中去掉了km/h。类的其余部分与[第2章](f310884c-55e6-48a4-8329-05ff04e48e19.xhtml)中的内容保持一致，即*使用树莓派编写Python程序*。在我们的测试部分，我们实例化了`CurrentWeather`类和`MorseCodeGenerator`类。使用`CurrentWeather`类，我们将多伦多的天气条件传递给`MorseCodeGenerator`类。
- en: If there aren't any mistakes made in entering the code, we should see our LED
    blink `partly sunny` in Morse code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入代码时没有出现任何错误，我们应该能够看到LED以莫尔斯码闪烁“部分晴天”。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A lot was covered in this chapter. By the end of it, you should be feeling pretty
    good about developing applications on the Raspberry Pi.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了很多内容。到最后，您应该对在树莓派上开发应用程序感到非常满意。
- en: The `picamera`, `Pillow`, and `sense-hat` libraries make it easy to communicate
    with the outside world with your Raspberry Pi. Using the Raspberry Pi camera module
    and `picamera`, we open up a whole new world of possibilities with our Pi. We
    only touched on a small part of what `picamera` can do. Additionally, we only
    scratched the surface of image processing with the `Pillow` library. The Sense
    HAT emulator allowed us to save spending money on buying the actual HAT and test
    out our code. With `sense-hat` and the Raspberry Pi Sense HAT, we truly expand
    our reach into the physical world.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`picamera`，`Pillow`和`sense-hat`库使得使用树莓派与外部世界进行通信变得很容易。使用树莓派摄像头模块和`picamera`，我们为树莓派打开了全新的可能性。我们只是触及了`picamera`的一小部分功能。此外，我们只是浅尝了`Pillow`库的图像处理功能。Sense
    HAT模拟器使我们可以节省购买实际HAT的费用，并测试我们的代码。通过`sense-hat`和树莓派Sense HAT，我们真正扩展了我们在物理世界中的影响力。'
- en: The inexpensive Pibrella HAT provided an easy way to jump into the physical
    computing world. By installing the `pibrella` library, we are giving our Python
    code access to an assortment of LEDs, a speaker, and a button, all neatly packaged
    into a Raspberry Pi HAT.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 廉价的Pibrella HAT提供了一个简单的方式来进入物理计算世界。通过安装`pibrella`库，我们让我们的Python代码可以访问一系列LED、扬声器和按钮，它们都被整齐地打包在一个树莓派HAT中。
- en: However, the true ultimate goal with physical computing is to build electronic
    circuits that bridge the gap between our Raspberry Pi and the outside world. We
    started our journey of building electronic circuits with the Fritzing circuit
    builder, available from the Raspberry Pi store. From there, we built our first
    circuit on a breadboard with an LED and resistor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，物理计算的真正终极目标是构建电子电路，以弥合我们的树莓派和外部世界之间的差距。我们开始使用树莓派商店提供的Fritzing电路构建器来构建电子电路。然后，我们在面包板上用LED和电阻器构建了我们的第一个电路。
- en: We concluded this chapter by creating a Morse code generator with our Raspberry
    Pi and LED circuit. In a twist of old meets new, we were able to transmit weather
    data in Morse code via a blinking LED.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用树莓派和LED电路创建了一个莫尔斯码生成器来结束本章。在新旧结合的转折中，我们能够通过闪烁LED以莫尔斯码传输天气数据。
- en: In [Chapter 4](626664bb-0130-46d1-b431-682994472fc1.xhtml), *Subscribing to
    Web Services*, we will incorporate web services into our code, thereby connecting
    the internet world with the real world in a concept called the Internet of Things.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章]（626664bb-0130-46d1-b431-682994472fc1.xhtml）中，*订阅Web服务*，我们将把Web服务纳入我们的代码中，从而将互联网世界与现实世界连接起来，形成一个称为物联网的概念。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the name of the Python package that allows you access to the Raspberry
    Pi camera module?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python包的名称是什么，可以让您访问树莓派相机模块？
- en: True or false? A Raspberry Pi with code written by students was deployed on
    the international space station.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？由学生编写的树莓派已部署在国际空间站上。
- en: What are the sensors included with Sense HAT?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sense HAT包含哪些传感器？
- en: True or false? We do not need to buy a Raspberry Pi Sense HAT for development,
    as an emulator of this HAT exists in Raspbian.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？我们不需要为开发购买树莓派Sense HAT，因为Raspbian中存在这个HAT的模拟器。
- en: How many ground pins are there on the GPIO?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPIO上有多少个接地引脚？
- en: True or false? Raspberry Pi's GPIO has pins that supply both 5V and 3.3V.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？树莓派的GPIO引脚提供5V和3.3V。
- en: What is a Pibrella?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pibrella是什么？
- en: True or false? You may only use a Pibrella on early Raspberry Pi computers.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？只能在早期的树莓派计算机上使用Pibrella。
- en: What does BCM mode mean?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BCM模式是什么意思？
- en: True or false? BOARD is the alternative to BCM.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？BOARD是BCM的替代品。
- en: What does the Zero in `gpiozero` refer to?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpiozero`中的Zero指的是什么？'
- en: True or false? Using Fritzing, we are able to design a GPIO circuit for our
    Raspberry Pi.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？使用Fritzing，我们可以为树莓派设计一个GPIO电路。
- en: What is the default background parameter in the `gpiozero` LED `blink` function
    set to?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gpiozero` LED `blink`函数中的默认背景参数设置为什么？'
- en: True or false? It is far easier to use the `gpiozero` library to access the
    GPIO than it is to use the `RPi.GPIO` library.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假？使用`gpiozero`库访问GPIO比使用`RPi.GPIO`库更容易。
- en: What is the Victorian Internet?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是维多利亚时代的互联网？
- en: Further reading
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A lot of concepts were covered in this chapter, with the assumption that the
    skills needed were not beyond the average developer and tinkerer. To further solidify
    understanding of these concepts, please Google the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了许多概念，假设所需的技能不超出普通开发人员和修补者的能力。为了进一步巩固对这些概念的理解，请谷歌以下内容：
- en: How to install the Raspberry Pi camera module
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装树莓派相机模块
- en: How to use a breadboard
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用面包板？
- en: An introduction to the Fritzing circuit design software
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fritzing电路设计软件简介
- en: Python dictionaries
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python字典
- en: 'For those of you that are as fascinated about technology of the past as I am,
    the following is a great book to read on the age of the Victorian Internet: *The
    Victorian Internet*, by Tom Standage.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些像我一样对过去的技术着迷的人，以下是一本关于维多利亚时代互联网的好书：*维多利亚时代的互联网*，作者汤姆·斯坦德奇。
