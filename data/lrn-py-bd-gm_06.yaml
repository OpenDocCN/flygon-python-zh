- en: Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Programming is not only about writing programs—it's just as important to understand
    them so that we can fix the bugs and errors in them, if there are any. Thus, we
    say that programmers are born to read and understand code. However, as programs
    become more and more complicated, it becomes more difficult to write programs
    that maintain readability. We have written both aesthetic and messy code in this
    book. We made a tic-tac-toe game with sequential programming that had less readability.
    We can consider these programs as inelegant because we will have a hard time reading
    and understanding their code and sequential flow. After writing those programs,
    we modified them using functions, which upgraded our messy code so that it was
    more elegant. However, if you are working on programs containing thousands of
    lines of code, it's hard to write a program within the same file and understand
    each and every behavior of the functions you're using. Thus, discovering and fixing
    the bugs of programs  written in a procedural manner is also difficult. Due to
    this, we need a way in which we can easily break multi-line programs into smaller
    modules or parts so that discovering and fixing these bugs is easier. There are
    many ways of achieving this, but the most efficient and popular way is using the
    **object-oriented programming** (**OOP**) approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程不仅仅是编写程序，同样重要的是理解它们，这样我们就可以修复其中的错误和漏洞。因此，我们说程序员天生就是用来阅读和理解代码的。然而，随着程序变得越来越复杂，编写易读的程序变得更加困难。在本书中，我们既写了美观的代码，也写了混乱的代码。我们用顺序编程制作了一个井字棋游戏，其可读性较低。我们可以将这些程序视为不优雅的，因为我们很难阅读和理解它们的代码和顺序流程。在编写这些程序之后，我们使用函数对其进行了修改，从而使我们混乱的代码更加优雅。然而，如果你正在处理包含数千行代码的程序，很难在同一个文件中编写程序并理解你正在使用的每个函数的行为。因此，发现和修复以过程方式编写的程序的错误也是困难的。因此，我们需要一种方法，可以将多行程序轻松地分解成更小的模块或部分，以便更容易地发现和修复这些错误。有许多实现这一目标的方法，但最有效和流行的方法是使用**面向对象编程**（**OOP**）方法。
- en: As it turns out, we have been using objects since the beginning of this book,
    but haven't understood how precisely they are made and used. This chapter will
    help you to learn about the terminology and concepts of object-oriented programming
    through some simple examples. We will also modify our Snake game code that we
    wrote using functions in the preceding chapters in line with the OOP approach
    at the end of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们从本书的开头就一直在使用对象，但并没有准确地了解它们是如何制作和使用的。本章将帮助您通过一些简单的示例了解面向对象编程的术语和概念。本章末尾，我们还将根据OOP方法修改我们在前几章中使用函数编写的贪吃蛇游戏代码。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程概述
- en: Python classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python类
- en: Encapsulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Snake game implementation using OOP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OOP实现的贪吃蛇游戏
- en: Possible errors and modifications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的错误和修改
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will require the following in order to get the most out of this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章，您将需要以下内容：
- en: Python version 3.5 or newer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5或更新版本
- en: Python IDLE (Python's inbuilt IDE)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python IDLE（Python内置IDE）
- en: A text editor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: A web browser
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络浏览器
- en: The files for this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter06](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter06)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter06](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter06)
- en: 'Check out the following video to see the code in action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际运行情况：
- en: '[http://bit.ly/2oKD6D2](http://bit.ly/2oKD6D2)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oKD6D2](http://bit.ly/2oKD6D2)'
- en: Overview of OOP
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程概述
- en: '*Everything in Python is an object*. We have been eloquently stating this remark
    from the beginning of this book and we have been proving this statement in every
    chapter. Everything is an object. Objects can be a collection of elements, properties,
    or functions. Data structures, variables, numbers, and functions are objects.
    OOP is a programming paradigm that provides an elegant way of structuring programs
    with the help of objects. The behavior and properties of the objects are bundled
    together into templates, which we call a class. That behavior and their properties
    can be called from the different objects of that class. Don''t get confused by
    the terms behavior and properties. They are just different names for methods and
    variables, respectively. Functions that are defined inside some classes are referred
    to as methods.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python中的一切都是对象*。我们从本书的开头就一直在雄辩地陈述这一观点，并且在每一章中都在证明这个说法。一切都是对象。对象可以是元素、属性或函数的集合。数据结构、变量、数字和函数都是对象。面向对象编程是一种编程范式，它通过对象的帮助提供了一种优雅的程序结构方式。对象的行为和属性被捆绑到模板中，我们称之为类。这些行为和属性可以从该类的不同对象中调用。不要被行为和属性这些术语搞混了。它们只是方法和变量的不同名称。在某些类中定义的函数被称为方法。'
- en: We will dig into the concepts of classes and methods later in this chapter,
    but for now, let's learn more about objects before actually making a template
    for them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面深入探讨类和方法的概念，但现在，让我们在实际为它们制作模板之前更多地了解对象。
- en: 'We have been using objects unknowingly from the beginning of this book. We
    have used methods from different classes before, such as the `randint()` method.
    This method was used by importing a module named `random`. This method is also
    a built-in Python class. A class is a template where we can write functions of
    objects. For example, a man can be represented as an object. A man has different
    characteristics, such as a `name`, `age`, and `hair_color`, which are unique properties.
    However, the actions that the man performs, such as eating, walking, and sleeping,
    are behaviors or methods. We can make as many objects as we like from these templates.
    But for now, let''s visualize two objects:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这本书的开始就在不知不觉地使用对象。我们以前使用过不同类的方法，比如`randint()`方法。这个方法是通过导入一个名为`random`的模块来使用的。这个方法也是Python的内置类。类是一个模板，我们可以在其中编写对象的函数。例如，一个人可以被表示为一个对象。一个人有不同的特征，比如`name`、`age`和`hair_color`，这些是唯一的属性。然而，人所执行的行为，比如吃饭、走路和睡觉，是行为或方法。我们可以从这些模板中创建任意多的对象。但现在，让我们想象两个对象：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding two objects, `name`, `age`, and `hair_color` are unique. All
    of the objects will have unique properties, but the behavior or method that they
    perform is the same as eating, walking, and sleeping. Thus, we can conclude that
    the data model that interacts with the input and output is a property since it
    will be fed into the methods. Based on the unique properties of each object, the
    methods of the classes will produce different results.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个对象中，`name`、`age`和`hair_color`是唯一的。所有的对象都有唯一的属性，但它们执行的行为或方法是相同的，比如吃饭、走路和睡觉。因此，我们可以得出结论，与输入和输出交互的数据模型是一个属性，因为它将被输入到方法中。根据每个对象的唯一属性，类的方法将产生不同的结果。
- en: 'Thus, we can say that OOP is the approach of modeling real-world entities as
    objects that have unique data associated with them and can execute certain functions.
    Functions that are defined inside classes are called methods, and so we just have
    to switch from functions to methods. Note, however, that the way methods work
    is similar to that of functions. Just like functions are called with the names
    or signs of it, methods also need to be called with their names. However, this
    call should be initiated with objects. Let''s look at a simple example to clarify
    this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说，面向对象编程是将现实世界的实体建模为具有唯一数据关联的对象，并且可以执行某些函数的方法。在类内部定义的函数称为方法，因此我们只需要从函数切换到方法。然而，请注意，方法的工作方式与函数的工作方式类似。就像函数是通过其名称或标志调用的一样，方法也需要通过其名称调用。但是，这个调用应该由对象发起。让我们看一个简单的例子来澄清这一点：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We looked at these methods in the preceding chapters. But if you take a good
    look at this code, you will find that we are making a method call from the object.
    We used the `pop` method and called it on the list-objects. This is a simple prototype
    of object-oriented programming. One of the advantages of OOP is that it hides
    the inner complexity of the method call. As you may recall, we called the `randint`
    method with the random module. We didn't even look at the content of the random
    library. Thus, we obviate the working complexities of the library. This feature
    of OOP will allow us to focus only on the important parts of the program rather
    than the internal working of the methods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中看过这些方法。但是如果你仔细看这段代码，你会发现我们是从对象中调用方法。我们使用了`pop`方法，并在列表对象上调用它。这是面向对象编程的一个简单原型。面向对象编程的一个优点是它隐藏了方法调用的内部复杂性。正如你可能记得的，我们用随机模块调用了`randint`方法。我们甚至没有查看随机库的内容。因此，我们避免了库的工作复杂性。面向对象编程的这个特性将使我们只关注程序的重要部分，而不是方法的内部工作。
- en: The two main entities of object-oriented programming are objects and classes.
    We can remember a class by emulating it with templates where methods and attributes
    are mapped. Methods are a synonym for functions, while attributes are the properties
    that distinguish each object from another. Let's get a good grasp of this terminology
    by making a simple class and object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的两个主要实体是对象和类。我们可以通过使用模板来模拟类，其中方法和属性被映射。方法是函数的同义词，而属性是将每个对象与另一个对象区分开的属性。让我们通过创建一个简单的类和对象来对这个术语有一个很好的理解。
- en: Python classes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python类
- en: 'As we discussed in the previous section, objects inherit all the code that''s
    written inside the classes. Thus, we can use methods and attributes that are mapped
    inside the body of class. A class is a template from which instances can be created.
    Take a look at the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，对象继承了类内部编写的所有代码。因此，我们可以使用在类主体内映射的方法和属性。类是一个模板，可以从中创建实例。看一下下面的例子：
- en: '![](Images/f96c5006-9dd8-4944-b0c4-3c0a5dfd2257.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f96c5006-9dd8-4944-b0c4-3c0a5dfd2257.png)'
- en: 'In the preceding, the `Bike` class can be considered a template from which
    objects can be instantiated. In the `Bike` class, there are attributes that uniquely
    represent objects that are created from this class. Each object that is created
    will have different properties, such as name, color, and price, but they will
    invoke the same methods. This method should be invoked with the instance of the
    class. Let''s see how classes can be created in Python:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面，`Bike`类可以被认为是一个模板，可以从中实例化对象。在`Bike`类中，有一些属性，这些属性唯一地代表了从这个类创建的对象。每个创建的对象都会有不同的属性，比如名称、颜色和价格，但它们会调用相同的方法。这个方法应该与类的实例一起调用。让我们看看如何在Python中创建类：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We create a class in Python with a class keyword, followed by the name of the
    class. Usually, the first letter of the class name is written in uppercase; here
    we have written `Bike`, with a capital B. Now globally, we have created the `Bike`
    class. Instead of methods and attributes, we have written a pass inside the body
    of the class. Now, let''s make the object of this class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用class关键字在Python中创建一个类，后面跟着类的名称。通常，类名的第一个字母是大写的；在这里，我们写了`Bike`，B是大写的。现在，在全局范围内，我们已经创建了`Bike`类。在类的主体内，我们写了一个pass，而不是方法和属性。现在，让我们创建这个类的对象：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we made an instance named `Suzuki` from the `Bike` class.
    The instantiation expression looks similar to the function call. Now, if you check
    the type of the `Suzuki` object, it is a type of the `Bike` class. Thus, the type
    of any object will be the class type because objects are an instance of classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们从`Bike`类中创建了一个名为`Suzuki`的实例。实例化表达式看起来类似于函数调用。现在，如果您检查`Suzuki`对象的类型，它是`Bike`类的类型。因此，任何对象的类型都将是类类型，因为对象是类的实例。
- en: 'It''s now time to add a couple of methods to this `Bike` class. This is similar
    to the declaration of the function. The `def` keyword, followed by the names of
    the methods, is the best way to declare the methods of a class. Let''s take a
    look at the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向这个`Bike`类添加一些方法了。这类似于函数的声明。`def`关键字，后面跟着方法的名称，是声明类的方法的最佳方式。让我们看一下以下代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have added three methods to the `Bike` class. The parameter that we used
    while declaring these methods was the `self` variable. This `self` variable or
    keyword is also an instance of the class. You can compare this `self` variable
    with the pointer, which is pointing to the current object. At each instantiation,
    the `self` variable represents the pointer object that is pointing to the current
    class. We will clarify the usage and importance of the `self` keyword shortly,
    but before that, take a look at the preceding code, where we created a `Suzuki`
    object and called the methods of the class with it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`Bike`类添加了三个方法。在声明这些方法时使用的参数是`self`变量。这个`self`变量或关键字也是类的一个实例。您可以将这个`self`变量与指针进行比较，该指针指向当前对象。在每次实例化时，`self`变量表示指向当前类的指针对象。我们将很快澄清`self`关键字的用法和重要性，但在此之前，看一下上面的代码，我们创建了一个`Suzuki`对象，并用它调用了类的方法。
- en: The preceding code is similar to the code where we called the `randint` method
    from the random module. This is because we are using methods of the random library.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码类似于我们从random模块调用`randint`方法的代码。这是因为我们正在使用random库的方法。
- en: 'When any classes are defined, only the representation for the object is defined
    with it, which eventually reduces memory loss. In the preceding example, we made
    a prototype with the name `Bike`. Different instances can be made out of it, las
    follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义任何类时，只定义了对象的表示，这最终减少了内存损失。在上面的例子中，我们用名为`Bike`的原型制作了一个原型。可以从中制作不同的实例，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we''ve looked at how to create objects and use the methods that are
    defined inside the class, we will add attributes to the class. The attributes
    or properties define the unique features of each object. Let''s add some attributes,
    such as `name`, `color`, and `price`, to our class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过如何创建对象并使用类内定义的方法，我们将向类添加属性。属性或属性定义了每个对象的独特特征。让我们向我们的类添加一些属性，比如`name`，`color`和`price`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s a lot of jargon in the preceding code. Under the hood, this program
    is about the creation of classes and objects. We have added three attributes:
    `name`, `color`, and `price`. To use those properties of the class, we have to
    reference them with the `self` keyword. The `name`, `color`, and `price` arguments
    are passed into the `info` function and are assigned to the corresponding `name`,
    `color`, and `price` properties of the `Bike` class. The `self.name, self.color,
    self.price = name,color,price` statement is going to initialize the class variables.
    This process is called initialization. We can also do initialization using a constructor,
    like so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中有很多行话。在幕后，这个程序是关于类和对象的创建。我们添加了三个属性：`name`，`color`和`price`。要使用类的这些属性，我们必须用`self`关键字引用它们。`name`，`color`和`price`参数被传递到`info`函数中，并分配给`Bike`类的相应`name`，`color`和`price`属性。`self.name,
    self.color, self.price = name,color,price`语句将初始化类变量。这个过程称为初始化。我们也可以使用构造函数进行初始化，就像这样：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In Python, the special `init` method is going to simulate the constructor. A
    constructor is a method or function that's used to initialize the attributes of
    the class. The definition of the constructor is executed when we make instances
    of the class. Depending on the `init` definition, we can provide any number of
    arguments while creating the objects of the class. The first method of the class
    should be a constructor, and it must initialize the members of the class. The
    basic format of the class should have an attribute declaration at the beginning
    and the methods after it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，特殊的`init`方法将模拟构造函数。构造函数是用于初始化类的属性的方法或函数。构造函数的定义在我们创建类的实例时执行。根据`init`的定义，我们可以在创建类的对象时提供任意数量的参数。类的第一个方法应该是构造函数，并且必须初始化类的成员。类的基本格式应该在开始时有属性声明，然后是方法。
- en: Now that we've created our own class and declared some methods of it let's explore
    some essential features of the object-oriented paradigm. We will start with **encapsulation**,
    which is used to embed the access permissions of the methods and variables that
    are declared within the classes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自己的类并声明了一些方法，让我们探索面向对象范式的一些基本特性。我们将从**封装**开始，它用于嵌入在类内声明的方法和变量的访问权限。
- en: Encapsulation
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: 'Encapsulation is a way of binding data with the code into a single unit known
    as a capsule. This way, it provides security so that no unwanted modifications
    can be made to the code. The code that''s written with the object-oriented paradigm
    will have critical data in the form of attributes. Thus, we have to prevent that
    data from being corrupted or becoming vulnerable. This is known as data hiding,
    and is the prime feature of encapsulation. To prevent data from being modified
    accidentally, encapsulation plays a vital role. We can make members of the class
    private members in order to embrace encapsulation. Private members, either methods
    or properties, can be made using double underscores at the beginning of their
    signature. In the following example, `__updateTech` is a private method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是将数据与代码绑定为一个称为胶囊的单元的一种方式。这样，它提供了安全性，以防止对代码进行不必要的修改。使用面向对象范式编写的代码将以属性的形式具有关键数据。因此，我们必须防止数据被损坏或变得脆弱。这就是所谓的数据隐藏，是封装的主要特性。为了防止数据被意外修改，封装起着至关重要的作用。我们可以将类的成员设为私有成员以实现封装。私有成员，无论是方法还是属性，都可以在其签名的开头使用双下划线来创建。在下面的例子中，`__updateTech`是一个私有方法：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, we were unable to invoke the `updateTech` method
    from the object of the class. This is due to encapsulation. We made this method
    private using a double underscore at the beginning of it. But sometimes we may
    need to modify the value of these attributes or behaviors. We can modify this
    using getters and setters. These methods will get the value and set the value
    for the attributes of the class. Thus, we can conclude that encapsulation is a
    feature of OOP that will prevent us from modifying and accessing data accidentally,
    but not intentionally. The private members of the class are not actually hidden;
    instead, they are just made unique from other members so that the Python parser
    will interpret them uniquely. The `updateTech` method is made unique and private
    using a double underscore (`__`) at the beginning of its name. The attributes
    of the class can also be made private using the same technique. Let''s take a
    look at this now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们无法从类的对象中调用`updateTech`方法。这是由于封装。我们使用双下划线将此方法设为私有。但有时我们可能需要修改这些属性或行为的值。我们可以使用getter和setter来修改。这些方法将获取类的属性的值并设置值。因此，我们可以得出结论，封装是面向对象编程的一个特性，它将防止我们意外修改和访问数据，但不是有意的。类的私有成员实际上并不是隐藏的；相反，它们只是与其他成员区分开来，以便Python解析器能够唯一解释它们。`updateTech`方法是通过在其名称开头使用双下划线(`__`)来使其成为私有和唯一的。类的属性也可以使用相同的技术来私有化。现在让我们来看一下：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can clearly see that the `name` and `color` attributes are private as they
    begin with double underscores. Now, let''s try to modify those values using an
    object:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到`name`和`color`属性是私有的，因为它们以双下划线开头。现在，让我们尝试使用对象来修改这些值：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We tried to modify the color attribute of the `Bike` class, but nothing happened.
    This shows us that encapsulation will prevent accidental changes from being made.
    But what if we need to change it intentionally? This can be done with getters
    and setters. Take a look at the following example to find out more about getters
    and setters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试修改`Bike`类的颜色属性，但什么也没发生。这表明封装将防止意外更改。但如果我们需要有意地进行更改呢？这可以通过getter和setter来实现。看看以下例子以了解更多关于getter和setter的信息：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding program, we defined a `Bike` class with some private members,
    such as `name` and `color`. We used the `init` constructor to initialize the values
    of the attributes while creating the instance of the class. We tried to modify
    its value. However, we couldn't change its value because the Python parser treats
    these attributes as private. Thus, we used the `setNewColor` setter to set a new
    value for that private member. By providing these getters and setter methods,
    we can make a class either read-only or write-only, which prevents accidental
    data modification and intentional theft.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们定义了一个`Bike`类，其中包含一些私有成员，如`name`和`color`。我们使用`init`构造函数在创建类的实例时初始化属性的值。我们尝试修改它的值。然而，我们无法更改其值，因为Python解析器将这些属性视为私有。因此，我们使用`setNewColor`
    setter为该私有成员设置新值。通过提供这些getter和setter方法，我们可以使类成为只读或只写，从而防止意外数据修改和有意的窃取。
- en: Now, it's time to take a look at another important feature of the object-oriented
    paradigm known as inheritance. Inheritance helps us write classes that will inherit
    each and every member from its parent class and also allows us to modify them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候来看一下面向对象范式的另一个重要特性——继承。继承帮助我们编写将从其父类继承每个成员并允许我们修改它们的类。
- en: Inheritance
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is the most important and well-known feature of the object-oriented
    programming paradigm. Do you remember the reusability feature of functions? Inheritance
    also provides reusability but with a lot of code. To use inheritance, we must
    have an existing class with some code inside it. This must be inherited by a new
    class. Such an existing class is called a **Parent** or **Base** class. We can
    create a new class as a `Child` class, which will acquire and access all the properties
    and methods of the parent class, so that we don't have to write the code from
    scratch. We can also modify the definitions and specifications of the methods
    that are inherited by the child class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程范式中最重要和最知名的特性。你还记得函数的可重用特性吗？继承也提供了可重用性，但伴随着大量的代码。要使用继承，我们必须有一个包含一些代码的现有类。这必须由一个新类继承。这样的现有类称为**父**类或**基**类。我们可以创建一个新类作为`Child`类，它将获取并访问父类的所有属性和方法，这样我们就不必从头开始编写代码。我们还可以修改子类继承的方法的定义和规范。
- en: 'In the following illustration, we can see that the **Child** class, or the **Derived**
    class, is pointing to the **Base** or **Parent** class, which implies that there
    is a single inheritance:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以看到**Child**类或**Derived**类指向**Base**或**Parent**类，这意味着存在单一继承：
- en: '![](Images/49a3b5cc-20a5-4a22-935d-770befb3da2a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/49a3b5cc-20a5-4a22-935d-770befb3da2a.png)'
- en: 'In Python, it is easy to use inheritance. A `Child` class can inherit from
    a `Parent` class by mentioning the name of the `Parent` class within the brackets
    after the `Child` class. The following code shows how we can implement single
    inheritance:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用继承很容易。通过在`Child`类后面的括号中提及`Parent`类的名称，`Child`类可以从`Parent`类继承。以下代码显示了如何实现单一继承：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A single class can also inherit multiple classes. We can achieve this by writing
    all of those classes'' names within the brackets:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单个类也可以继承多个类。我们可以通过在括号内写入所有这些类的名称来实现这一点：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s write a simple example so that we can understand inheritance a little
    more. In the following example, `Bike` will be the `Parent` class and `Suzuki`
    will be the `Child` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的例子，以便更好地理解继承。在下面的例子中，`Bike`将是`Parent`类，`Suzuki`将是`Child`类：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's have a look at the preceding code and be amazed by inheritance. First,
    we created a `Base` class with two methods in it. After that, we created another
    class, that is, the child or derived class, called `Suzuki`. It is a child class
    because it has inherited the members of its parent `Bike` class with the `class
    Suzuki(Bike)` syntax. We added a couple of methods to the child class too. After
    creating these two classes, we created an object of the child class. We know that,
    when an object is created, the method that is going to be invoked automatically
    is a constructor, or `init`. Thus, we passed a value that was demanded by the
    constructor while creating the object of that class. After that, we made a call
    to the `Ride` method from the object of the `Suzuki` class. You can check the
    `Ride` method inside the body of the `Suzuki` class. It isn't there—instead, it's
    inside the suite of the `Bike` class. Due to inheritance, we were able to call
    the methods of the `Base` class as if they were inside the `Child` class. We can
    also use every property that's defined inside the `Base` class in the `Child`
    class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下前面的代码，并对继承感到惊讶。首先，我们创建了一个`Base`类，并在其中添加了两个方法。之后，我们创建了另一个类，即子类或派生类，称为`Suzuki`。它是一个子类，因为它使用`class
    Suzuki(Bike)`语法继承了其父类`Bike`的成员。我们还向子类添加了一些方法。创建这两个类后，我们创建了子类的对象。我们知道，当创建对象时，将自动调用要调用的方法是构造函数或`init`。因此，在创建该类的对象时，我们传递了构造函数要求的值。之后，我们从`Suzuki`类的对象中调用`Ride`方法。您可以在`Suzuki`类的主体内检查`Ride`方法。它不在那里——相反，它在`Bike`类的套件中。由于继承，我们能够调用`Base`类的方法，就好像它们在`Child`类中一样。我们还可以在`Child`类中使用在`Base`类中定义的每个属性。
- en: 'However, not all features are inherited inside the child class. When we create
    instances of the child class, the `init` method of the child class was called,
    but not those of the `Parent`. However, there is a way to call that constructor:
    by using the `super` method. This is shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有特性都在子类中继承。当我们创建子类的实例时，子类的`init`方法被调用，但`Parent`的方法没有被调用。然而，有一种方法可以调用该构造函数：使用`super`方法。这在下面的代码中显示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `super()` method refers to the superclass or `Parent` class. Thus, after
    the instantiation of the superclass, we made a call to the `init` method of that
    superclass.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`super()`方法指的是超类或`Parent`类。因此，在实例化超类之后，我们调用了该超类的`init`方法。'
- en: It is similar to `Bike().__init__()`, but in this case Bike is starting.. will
    be printed twice because the `Bike()` statement is going to create an object of
    the `Bike` class. This means that the `init` method will be called automatically.
    The second call is made with the object of the `Bike` class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于`Bike().__init__()`，但在这种情况下，Bike is starting..将被打印两次，因为`Bike()`语句将创建一个`Bike`类的对象。这意味着`init`方法将被自动调用。第二次调用是使用`Bike`类的对象进行的。
- en: 'In Python, multi-level inheritance is available. This is a chained sequence
    that''s created when any child class inherits from another child class. There
    are no limits regarding how a multi-level inheritance chain can be created. The
    following diagram depicts multiple classes inheriting features from their parent
    class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，多级继承是可用的。当任何子类从另一个子类继承时，将创建一个链接的序列。关于如何创建多级继承链，没有限制。以下图表描述了多个类从其父类继承特性：
- en: '![](Images/4dfded1e-55cf-43fa-8e23-5512ec11b5ff.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4dfded1e-55cf-43fa-8e23-5512ec11b5ff.png)'
- en: 'The following code shows the features of multi-level inheritance. We have made
    three classes, with each one inheriting the features of the preceding one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了多级继承的特点。我们创建了三个类，每个类都继承了前一个类的特点：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we've looked at inheritance, it's time to have a look at another feature,
    known as polymorphism. In a literal sense, **polymorphism** is the ability to
    accommodate different forms. Thus, this feature is going to help us use the same
    code in a different form so that multiple tasks can be carried out with it. Let's
    take a look.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过继承，是时候看看另一个特性，即多态。从字面上看，**多态**是适应不同形式的能力。因此，这个特性将帮助我们以不同的形式使用相同的代码，以便可以用它执行多个任务。让我们来看一下。
- en: Polymorphism
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: In the object-oriented paradigm, polymorphism allows us to define methods in
    the `Child` class with the same signature that's defined in the `Parent` class.
    As we know, inheritance allows us to use every method of the `Parent` class as
    if it were inside the `Child` class with the help of child class objects. However,
    we may encounter a situation where we have to modify the specification of the
    method that is defined inside the parent class so that it is executed independently
    of the `Parent` class. This technique is called method overriding. As the name
    suggests, we are overriding the existed method of the `Base` class with the new
    specification inside the `Child` class. Using method overriding, we can call both
    of the methods independently. If you have overridden a method of the parent class
    in the child class, then any version of that method (either the new one of the
    child or the old one of the parent) will be called based on the type of object
    it is being used to call. For example, if you want to call the new version of
    the method, you should call it with the `Child` class object. Speaking of the
    Parent class method, we have to use a `Parent` class object to call it. Thus,
    we can visualize that the two sets of methods have been developed but with the
    same name and signature, which signifies basic polymorphism. In programming, polymorphism
    is where the same function or method is used in different forms or types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的范式中，多态性允许我们在`Child`类中定义与`Parent`类中定义的相同签名的方法。正如我们所知，继承允许我们使用`Parent`类的每个方法，就好像它们是在`Child`类中的子类对象的帮助下。然而，我们可能会遇到这样的情况，我们必须修改在父类中定义的方法的规格，以便它独立于`Parent`类执行。这种技术称为方法重写。顾名思义，我们正在用`Child`类内部的新规格覆盖`Base`类的已有方法。使用方法重写，我们可以独立调用这两个方法。如果你在子类中重写了父类的方法，那么该方法的任何版本（无论是子类的新版本还是父类的旧版本）都将根据使用它的对象的类型来调用。例如，如果你想调用方法的新版本，你应该使用`Child`类对象来调用它。谈到父类方法，我们必须使用`Parent`类对象来调用它。因此，我们可以想象到这两组方法已经开发出来，但是具有相同的名称和签名，这意味着基本的多态性。在编程中，多态性是指相同的函数或方法以不同的形式或类型使用。
- en: 'We can start thinking about examples of polymorphism from what we have learned
    so far. Do you remember the `len()` function? This is a built-in Python function
    and takes an object as a parameter. Here, an object can be anything; it can be
    a string, list, tuple, and so on. Even if it has the same name, it is not limited
    to performing a single task—it can be used in different forms, as shown in the
    following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从到目前为止学到的知识中开始思考多态性的例子。你还记得`len()`函数吗？这是一个内置的Python函数，以对象作为参数。这里，对象可以是任何东西；它可以是字符串、列表、元组等。即使它有相同的名称，它也不限于执行单一任务——它可以以不同的形式使用，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s look at an example to demonstrate polymorphism with inheritance. We
    will write a program that will create three classes; one will be a `Base` class
    while the other two will be `Child` classes. The two `Child` classes will inherit
    each and every member of the `Parent` class, but each of them will have one method
    implemented independently. This will be the application of method overriding.
    Let''s look at an example of polymorphism using the concept of polymorphism with
    inheritance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来演示继承的多态性。我们将编写一个程序，创建三个类；一个是`Base`类，另外两个是`Child`类。这两个`Child`类将继承`Parent`类的每一个成员，但它们每个都会独立实现一个方法。这将是方法重写的应用。让我们看一个使用继承的多态性概念的例子：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing you see is that the `Dance` method is common among all three
    classes. But in each of these classes, we have different specifications for the
    `Dance` method. This feature is particularly useful because, in some cases, we
    may want to customize the method that is inherited from the `Parent` class, which
    may not have any significance in the `Child` class. In such cases, we redefine
    this method with the same signature that's inside the `Child` class. This technique
    of reimplementing a method is known as method overriding, and the different methods
    it creates using this process enable polymorphism.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的第一件事是`Dance`方法在所有三个类中都是共同的。但在这些类的每一个中，我们对`Dance`方法有不同的规格。这个特性特别有用，因为在某些情况下，我们可能想要定制从`Parent`类继承的方法，在`Child`类中可能没有任何意义。在这种情况下，我们使用与`Child`类内部相同签名的方法重新定义这个方法。这种重新实现方法的技术称为方法重写，通过这个过程创建的不同方法实现了多态性。
- en: Now that we've learned about the important concepts of object-oriented programming
    and their prime features, such as encapsulation, inheritance, and polymorphism,
    it's time to use this knowledge to modify the Snake game that we made using curses
    in the previous chapter. Since we can't use these object-oriented principles to
    make the code from the previous chapter less messy and abstruse, we will make
    our code more reusable and readable. We will start modifying our game with OOP
    in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了面向对象编程的重要概念及其主要特性，比如封装、继承和多态性，是时候利用这些知识来修改我们在上一章中使用curses制作的蛇游戏了。由于我们无法使用这些面向对象的原则来使上一章的代码变得不那么混乱和晦涩，我们将使我们的代码更具可重用性和可读性。我们将在下一节开始使用OOP修改我们的游戏。
- en: Snake game implementation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛇游戏实现
- en: We've explored various features of object-oriented programming in this chapter,
    including inheritance, polymorphism, data hiding, and encapsulation. One feature
    that we didn't cover, known as method overloading, will be covered in [Chapter
    9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model Implementation*. We
    have learned enough about OOP to make our code more readable and reusable. Let's
    start this section by following the conventional pattern, that is, brainstorming
    and information gathering.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了面向对象编程的各种特性，包括继承、多态性、数据隐藏和封装。我们没有涉及的一个特性，称为方法重载，将在[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)“数据模型实现”中介绍。我们已经学到了足够多关于OOP的知识，使我们的代码更易读和可重用。让我们按照传统模式开始这一部分，即头脑风暴和信息收集。
- en: Brainstorming and information gathering
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头脑风暴和信息收集
- en: As we have already discussed, object-oriented programming is not related to
    game interface programming; instead, it is a paradigm that makes code sturdier
    as well as more lucid. Thus, our interface will be similar to that of programs
    that are made by the curses module—text-based terminals. However, we will use
    the object-oriented paradigm to refine our code, and we will focus on the object
    rather than the actions and logic. We know that OOP is a data-driven methodology.
    Thus, our program must accommodate the game screen and user events data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，面向对象编程与游戏界面编程无关；相反，它是一种使代码更加稳健和更加清晰的范式。因此，我们的界面将类似于由curses模块制作的程序——基于文本的终端。然而，我们将使用面向对象的范式来完善我们的代码，并且我们将专注于对象而不是动作和逻辑。我们知道面向对象编程是一种数据驱动的方法。因此，我们的程序必须容纳游戏屏幕和用户事件数据。
- en: 'The main aims of using the object-oriented principle in our game are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏中使用面向对象的原则的主要目标如下：
- en: To divide programs into smaller parts, called objects. This will make programs
    more readable and allow us to track bugs and errors easily.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将程序分成较小的部分，称为对象。这将使程序更易读，并允许我们轻松跟踪错误和错误。
- en: To be able to communicate between objects through functions.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过函数在对象之间进行通信。
- en: Data is secure as it cannot be used by outer functions. This is called encapsulation.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是安全的，因为它不能被外部函数使用。这就是封装。
- en: We will put more emphasis on the data rather than the methods or procedures.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将更加注重数据而不是方法或程序。
- en: Making modifications to the program, such as adding properties and methods,
    can be done easily.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对程序进行修改，如添加属性和方法，可以很容易地完成。
- en: Now, let's start brainstorming and gather some information about the game model.
    Obviously, we have to use the same code from the previous chapter for the game
    layout and its characters, that is, `Snake` and `Food`. Thus, we have to take
    two classes for each of them. The `Snake` and `Food` classes will have methods
    defined in them that will control game layouts and user events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始头脑风暴并收集一些关于游戏模型的信息。显然，我们必须使用上一章的相同代码来布局游戏和其角色，即`Snake`和`Food`。因此，我们必须为它们各自取两个类。`Snake`和`Food`类将在其中定义控制游戏布局和用户事件的方法。
- en: 'We have to use curses events such as `KEY_DOWN`, `KEY_UP`, `KEY_LEFT`, and
    `KEY_RIGHT` to handle the movement of the snake character. Let''s visualize the
    essential classes and methods:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用诸如`KEY_DOWN`、`KEY_UP`、`KEY_LEFT`和`KEY_RIGHT`等curses事件来处理蛇角色的移动。让我们来可视化一下基本的类和方法：
- en: First, we have to import curses to initialize the game screen and handle user
    key movements.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须导入curses来初始化游戏屏幕并处理用户按键移动。
- en: Then, we have to import the random module as we have to generate food in a random
    position once the snake has eaten it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须导入随机模块，因为一旦蛇吃了食物，我们就必须在随机位置生成食物。
- en: After that, we initialize the constants, such as screen height, width, default
    snake length, and timeout.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们初始化常量，如屏幕高度、宽度、默认蛇长度和超时时间。
- en: Then, we declare eh `Snake` class with a constructor, which will initialize
    the default position of the snake, window, head position, and the body of the
    snake.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用构造函数声明了`Snake`类，它将初始化蛇的默认位置、窗口、头部位置和蛇的身体。
- en: 'Inside the `Snake` class, we will add a couple of methods, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Snake`类内部，我们将添加一些方法，如下：
- en: '`eat_food` will check whether the snake has eaten the food. If it has, the
    length of the snake will increase.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eat_food`将检查蛇是否吃了食物。如果吃了，蛇的长度将增加。'
- en: '`collision` will check whether the snake has collided with itself.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collision`将检查蛇是否与自身发生了碰撞。'
- en: '`update` will be invoked every time the user makes a move and changes the position
    of the `Snake` character.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`将在用户移动并改变`Snake`角色的位置时被调用。'
- en: Finally, we declare the `Food` class and define the render and reset methods
    to generate and delete the food from a random position.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们声明`Food`类并定义渲染和重置方法来在随机位置生成和删除食物。
- en: Now, let's start writing the program by declaring the constants and importing
    the essential modules. This is no different from the previous chapter—we will
    use curses to initialize the game screen and handle user events. We will use the
    random module to generate a random position on the game console so that we can
    generate new food at that position.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过声明常量和导入必要的模块来开始编写程序。这与上一章没有什么不同——我们将使用curses来初始化游戏屏幕并处理用户事件。我们将使用随机模块在游戏控制台上生成一个随机位置，以便我们可以在该位置生成新的食物。
- en: Declaring constants and initializing the screen
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明常量并初始化屏幕
- en: 'Similar to the preceding chapter, we are going to import the curses module
    so that we can initialize the game screen and customize it by specifying the height
    and width. We have to declare the default snake length and its position as constants.
    The following code will be familiar to you, except for the `name == "__main__"` pattern:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一章类似，我们将导入curses模块，以便我们可以初始化游戏屏幕并通过指定高度和宽度来自定义它。我们必须声明默认蛇长度和其位置作为常量。以下代码对你来说将是熟悉的，除了`name
    == "__main__"`模式：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have declared a bunch of constants to specify the
    height, width, default snake length, and timeout. We are familiar with all of
    these terms, except for the `__name__ == "__main__"` pattern. Let''s talk about
    it in detail:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一堆常量来指定高度、宽度、默认蛇长度和超时时间。我们对所有这些术语都很熟悉，除了`__name__ == "__main__"`模式。让我们详细讨论一下：
- en: 'By looking at this pattern, we can conclude that the assignment of the `"main"` string
    is done in the name variable. Just like `__init__()` was a special method, `__name__`
    is a special variable. Whenever we execute our script file, the Python interpreter
    will execute the code that is written at the zero indentation level. But in Python,
    there is no `main()` function like there is in C/C++, which is invoked automatically.
    Thus, the Python interpreter will set the special `__name__` variable with the
    `__main__` string. Whenever the Python script is executed as a main program, the
    interpreter sets the special variable with the string. But when the file is being
    imported from another module, the value of the name variable will be set to that
    module name. Thus, we can conclude that the name variable will determine the current
    working module. We can evaluate how this pattern works as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个模式，我们可以得出结论，将`"main"`字符串赋值给name变量。就像`__init__()`是一个特殊方法一样，`__name__`是一个特殊变量。每当我们执行脚本文件时，Python解释器将执行写在零缩进级别的代码。但是在Python中，没有像C/C++中那样自动调用的`main()`函数。因此，Python解释器将使用特殊的`__name__`变量设置为`__main__`字符串。每当Python脚本作为主程序执行时，解释器将使用该字符串设置特殊变量。但是当文件从另一个模块导入时，name变量的值将设置为该模块的名称。因此，我们可以得出结论，name变量将确定当前的工作模块。我们可以评估这个模式的工作方式如下：
- en: '**When the current source code file is the main program**:When we run the current
    source file as the main program, that is, `C:/> python example.py`, the interpreter
    will assign the`"__main__"` string to the special name variable known as `name
    == "__main__"`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当前源代码文件是主程序时**：当我们将当前源文件作为主程序运行，即`C:/> python example.py`，解释器将把`"__main__"`字符串赋给特殊的name变量，即`name
    == "__main__"`。'
- en: '**When another program is importing your module**: Suppose any other program
    is the main program and it is importing our module. The `>>> import example` statement
    will import the example module into the main program. Now, the Python interpreter
    will refine the name of the script file by removing the `.py` extension and setting
    that module name to the name variable, that is, `name == "example"`. Due to this,
    the code that is written in the example module will be available for the main
    program. After the special variable has been set up, the Python interpreter will
    execute the statements line by line.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当另一个程序导入您的模块时**：假设任何其他程序是主程序，并且它正在导入我们的模块。`>>> import example`语句将example模块导入主程序。现在，Python解释器将通过删除`.py`扩展名来细化脚本文件的名称，并将该模块名称设置为name变量，即`name
    == "example"`。由于这个原因，写在example模块中的代码将对主程序可用。特殊变量设置完成后，Python解释器将逐行执行语句。'
- en: Thus, the `__name__ == "__main__"` pattern can be used to execute the code that's
    written inside it if the source file is executed directly, and is not imported.
    We can conclude that the code that's written inside this pattern is the code that
    will be executed. Functions, classes, and the code inside them that isn't defined
    aren't going to run until they are called from the zero indentation level. This
    is due to the lack of a `main()` function in Python, which is automatically invoked
    in low-level programming languages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`__name__ == "__main__"`模式可用于执行其中写入的代码，如果源文件直接执行，而不是导入。我们可以得出结论，写在此模式内的代码将被执行。在Python中，没有`main()`函数，它是在低级编程语言中自动调用的。
- en: In this case, the top-level code starts with an `if` block that's followed by
    the pattern's **name**, which evaluates the current working module. If the current
    program is `main`, we are going to execute the code that's written inside the
    `if` block, which initializes the game screen and creates a new window for the
    game by using curses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，顶层代码以一个`if`块开始，后面跟着模式的**name**，评估当前的工作模块。如果当前程序是`main`，我们将执行写在`if`块内的代码，通过curses初始化游戏屏幕并在游戏中创建一个新窗口。
- en: 'Now that we have started writing a program that''s initialized the game screen
    and declared some constants, it''s time to create some classes. We have two characters
    in the game: `Snake` and `Food`. We will begin by creating two classes for now
    and modify them according to our needs. Let''s start by creating the `Snake` class.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始编写一个程序，初始化了游戏屏幕并声明了一些常量，是时候创建一些类了。游戏中有两个角色：`Snake`和`Food`。我们将从现在开始创建两个类，并根据需要对它们进行修改。让我们从创建`Snake`类开始。
- en: Creating the snake class
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建蛇类
- en: 'After creating the screen for our game, our next focus will be on rendering
    the game character in our screen. We will start off by creating the `Snake` class.
    We know that classes will have different members, that is, attributes and methods.
    As we mentioned in the previous chapter, while creating the `Snake` character,
    we have to track the *x* and *y* positions of the snake in the game window. To
    track the body position of the snake, we have to extract the *x* and *y* coordinates
    of the snake. We should use alphabetical characters to make up the body of the
    snake as curses only supports text-based Terminals. Let''s start creating the
    `Body` class, which will provide us with the position of the snake and provide
    the character for the body of the snake:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在为游戏创建屏幕后，我们的下一个重点将是在屏幕上渲染游戏角色。我们将首先创建`Snake`类。我们知道类将有不同的成员，即属性和方法。正如我们在上一章中提到的，创建`Snake`角色时，我们必须跟踪蛇在游戏窗口中的*x*和*y*位置。为了跟踪蛇的身体位置，我们必须提取蛇的*x*和*y*坐标。我们应该使用字母字符来构成蛇的身体，因为curses只支持基于文本的终端。让我们开始创建`Body`类，它将为我们提供蛇的位置并提供蛇身体的字符：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding program, `#` is used to make up the body structure of the
    snake. We have defined two members inside the `Body` class: the constructor and
    the `coor` method. The `coor` method is used to extract the current coordinates
    of the snake body.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`#`用于构成蛇的身体结构。我们在`Body`类内定义了两个成员：构造函数和`coor`方法。`coor`方法用于提取蛇身体的当前坐标。
- en: 'Now, let''s create a class for the game characters. We will start with the `Snake`
    class. We should maintain a listed data structure so that we can store the body
    position of the snake. Initializing these properties should be done using a constructor.
    Let''s start writing the constructor for the `Snake` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为游戏角色创建一个类。我们将从`Snake`类开始。我们应该维护一个列出的数据结构，以便我们可以存储蛇的身体位置。应该使用构造函数来初始化这些属性。让我们开始编写`Snake`类的构造函数：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Inside the `Snake` class, we made a dictionary. Each of the keys and values
    represents a reverse direction. If you are confused about how the direction on
    the screen is represented, go back to the previous chapter. The positions of the
    characters are represented in the coordinates. We declared the constructor, which
    allows us to initialize the properties of the classes. We made `body_list` to
    hold the snake body; a window object that represents the game screen for the snake
    game; the default direction of the snake, which is the RIGHT direction; and a
    direction map, which accommodates the movement of the character with curses constants
    such as `KEY_UP`, `KEY_DOWN`, `KEY_LEFT`, and `KEY_RIGHT`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Snake`类中，我们创建了一个字典。每个键和值表示一个相反的方向。如果您对屏幕上的方向表示感到困惑，请返回到上一章。字符的位置用坐标表示。我们声明了构造函数，它允许我们初始化类的属性。我们创建了`body_list`来保存蛇的身体；一个代表蛇游戏屏幕的窗口对象；蛇的默认方向，即右方向；和一个方向映射，其中包含使用curses常量如`KEY_UP`、`KEY_DOWN`、`KEY_LEFT`和`KEY_RIGHT`来容纳角色的移动。
- en: For every direction map, we make a call to the `move_up`, `move_down`, `move_left`,
    and `move_right` functions. We will create these methods shortly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个方向映射，我们调用`move_up`、`move_down`、`move_left`和`move_right`函数。我们将很快创建这些方法。
- en: 'The following lines of code are declared inside the `Snake` class and will
    add the coordinates of the snake body to `body_list`. The `Body(x-i,y)` statement
    is the instance of `Body` class that will specify the coordinates of the snake''s
    body. In the constructor of the `Body` class, `#` is used to specify the layout
    of the snake''s body:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码行声明在`Snake`类中，并将蛇身体的坐标添加到`body_list`中。`Body(x-i,y)`语句是`Body`类的实例，它将指定蛇身体的坐标。在`Body`类的构造函数中，`#`用于指定蛇身体的布局：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s take a look at the preceding code and explore it. This code is going
    to extend the characteristics of the `Snake` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下前面的代码并探索一下。这段代码将扩展`Snake`类的特性：
- en: 'First, we have to begin by adding some new members inside the `Snake` class.
    We start by adding a simple method that will extend the body of the snake:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过在`Snake`类中添加一些新成员来开始。我们首先添加一个简单的方法，它将扩展蛇的身体：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we have to create another method that will render game objects onto the
    screen. One of the important steps of this program is to render the snake''s body
    onto the game screen. Since we have to represent the snake with`#`, we can use
    curses for this and use the `addstr` method. In the following render method, we
    looped the entire `body_list` of the snake and added `''#''` to each instance:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须创建另一个方法，将游戏对象渲染到屏幕上。这个程序的一个重要步骤是将蛇的身体渲染到游戏屏幕上。由于我们必须用`#`表示蛇，我们可以使用curses，并使用`addstr`方法。在下面的渲染方法中，我们循环遍历了蛇的整个`body_list`，并为每个实例添加了`'#'`：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s create the object of the `Snake` class. We can create it inside
    the `name == ''__main__''` pattern:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Snake`类的对象。我们可以在`name == '__main__'`模式中创建它：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding program, we created a snake object. Since the constructor of
    the `Snake` class will be automatically invoked while creating an object of it,
    we passed in the `SNAKE_X` and `SNAKE_Y` arguments, which provide the default
    position of the snake and window, The window object screen is created by the `newwin`
    method from curses. Inside the while loop, we used the snake object to invoke
    the render method, which will add a snake in the game screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，我们创建了一个蛇对象。由于在创建对象时`Snake`类的构造函数将自动调用，我们传入了`SNAKE_X`和`SNAKE_Y`参数，这提供了蛇和窗口的默认位置。窗口对象屏幕是通过curses的`newwin`方法创建的。在while循环中，我们使用蛇对象调用渲染方法，这将在游戏屏幕中添加一个蛇。
- en: Although we have successfully rendered the snake into the game console, our
    game isn't ready to test yet because the program is unable to address certain
    actions, for example, whenever the user presses the LEFT, RIGHT, UP, and DOWN
    keys on the keyboard to move the `Snake` character. We know that the curses module
    provides us with a method so that we can get input from the user, and we can handle
    it accordingly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经成功将蛇渲染到游戏控制台中，但我们的游戏还没有准备好测试，因为程序无法处理某些操作，例如用户按键盘上的左、右、上和下键来移动`Snake`角色。我们知道curses模块提供了一个方法，让我们可以从用户那里获取输入，并相应地处理它。
- en: Handling user events
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户事件
- en: 'As we saw in the previous chapter, it is really easy to take input from the
    user and handle it using the curses module. In this section, we are going to add
    those methods inside the `Snake` class because methods related to the user''s
    actions are related to the movement of the `Snake` character. Let''s add a couple
    of methods inside the `Snake` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到使用curses模块从用户那里获取输入并处理输入是非常容易的。在本节中，我们将把这些方法添加到`Snake`类中，因为与用户操作相关的方法与`Snake`角色的移动相关。让我们在`Snake`类中添加一些方法：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding method is going to change the direction of the snake. Here, we
    have initialized the `REV_DIR_MAP` directory, which contains the key and value
    that represent their opposite directions. Thus, we pass the current direction
    to this method to change it based on the event that's pressed by the user. The
    direction argument is inputted from the user.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法将改变蛇的方向。在这里，我们初始化了`REV_DIR_MAP`字典，其中包含表示相反方向的键和值。因此，我们将当前方向传递给这个方法，根据用户按下的事件来改变它。方向参数是从用户那里输入的。
- en: 'Now, it''s time to extract the head and coordinates for the head of snake.
    We know that the head position of the snake changes while the snake moves. Even
    when crossing the boundary of the snake, we must make the snake appear from the
    other side. Thus, the snake''s head position will change according to the user''s
    movements. We need to create a method that can accommodate these changes. We can
    use the property decorator for this, which will treat changing the head properties
    of the `Snake` class as a method. This works like a getter. Don''t be overwhelmed
    by these terms, as we will cover these in a later chapter (List Comprehension
    and Properties). This being said, let''s take a look at the following example.
    This example will help you understand the `@property` decorator:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候提取蛇的头部和头部的坐标了。我们知道蛇的头部位置在蛇移动时会改变。即使穿过蛇的边界，我们也必须使蛇从另一侧出现。因此，蛇的头部位置将根据用户的移动而改变。我们需要创建一个可以适应这些变化的方法。我们可以使用属性装饰器来实现这一点，它将把`Snake`类的头部属性的更改视为方法。这就像一个getter。不要被这些术语所压倒，因为我们将在以后的章节中介绍这些内容（列表推导和属性）。话虽如此，让我们来看一下以下示例。这个例子将帮助你理解`@property`装饰器：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s change the value of the `first` attribute and print all those values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变`first`属性的值并打印所有这些值：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can clearly see that the change has not been reflected in the email. The
    name for the email has been preserved from the previous value of `Ross`. Thus,
    in order to make the program accommodate changes spontaneously, we need to make
    the attributes property decorators. Let''s make the email a property and observe
    the result:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，更改没有反映在电子邮件中。电子邮件的名称已经保留了之前的`Ross`值。因此，为了使程序自动适应变化，我们需要将属性设置为装饰器。让我们将电子邮件设置为属性并观察结果：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code is executed in the Python shell:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在Python shell中执行：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The change we have made to the attribute has been reflected spontaneously in
    the attribute of the class with the help of the decorator property. We will learn
    about this in detail in the next chapter. This was just a quick introduction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对属性所做的更改已经在类的属性中得到了自发的反映，这得益于装饰器属性的帮助。我们将在下一章中详细了解这一点。这只是一个快速的介绍。
- en: 'We only covered it because it''s an essential part of making the head attribute
    of the snake a property decorator:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只涵盖了它，因为这是使蛇的头属性成为属性装饰器的重要部分：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `head` method is going to extract the last element of the list, which indicates
    the head of the snake. The `coor` method is going to return a tuple containing
    the (*x*,*y*) coordinates, which represent the head of the snake.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`方法将提取列表的最后一个元素，表示蛇的头部。`coor`方法将返回一个包含（*x*，*y*）坐标的元组，表示蛇的头部。'
- en: 'Let''s add one more function that will update the direction of the snake:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个函数，用于更新蛇的方向：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding `update` method is going to pop out the last part of the body
    and insert it with the head position before updating the new head position.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`update`方法将弹出身体的最后一部分，并将其插入到更新新头部位置之前。
- en: 'Now, let''s handle the user events using the curses module:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用curses模块处理用户事件：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We learned about the working mechanism in the preceding code in the previous
    chapter, so you shouldn''t have any problems grasping it. Now, let''s make the
    snake move in a certain direction. Previously, in the `Snake` class, we added
    the `direction_map` attribute, which held the dictionary mapping to different
    functions, such as `move_up`, `move_down`, `move_left`, and `move_right`. These
    functions will change the position of the snake based on the user''s action:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章的前面代码中学习了工作机制，所以你不应该有任何问题理解它。现在，让我们让蛇朝着某个方向移动。在`Snake`类中，我们之前添加了`direction_map`属性，其中包含了映射到不同函数的字典，如`move_up`、`move_down`、`move_left`和`move_right`。这些函数将根据用户的操作改变蛇的位置：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We made this logic in the previous chapter and will make the snake move either
    up, down, left, or right. We can imagine the screen as a matrix containing rows
    and columns. With the up action, the snake will move in the Y-axis, and so the
    y position should be decreased; similarly, with the down action, the snake will
    move to down the Y-axis, and so we need to increment the y coordinate. For the
    LEFT and RIGHT movements of the snake, we will have to decrement and increment
    the X-axis, respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中制定了这个逻辑，并将使蛇向上、向下、向左或向右移动。我们可以将屏幕想象成一个包含行和列的矩阵。通过向上的动作，蛇将在Y轴上移动，因此y位置应该减小；同样，通过向下的动作，蛇将向下移动Y轴，因此我们需要增加y坐标。对于蛇的左右移动，我们将分别减小和增加X轴。
- en: Now, that we have handled user events, this concludes the `Snake` class. It's
    time to handle the collision, if there is one. We also have to add another character
    to the game, that is, `Food`, which will be made by creating a new class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经处理了用户事件，这结束了`Snake`类。如果有碰撞，现在是处理碰撞的时候了。我们还必须向游戏添加另一个角色，即`Food`，这将通过创建一个新类来实现。
- en: Handling collisions elp of decorator property.
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理碰撞装饰器属性的帮助。
- en: 'No noble logic will be created in this section. We have to check whether the
    head of the snake has collided with the body part of the snake. This should be
    done by checking the coordinates of the head (*y*,*x*) against any of the coordinates
    of the snake''s body. Thus, let''s make a new method, `@property`, which will
    check for the collision:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分不会创建高尚的逻辑。我们必须检查蛇的头部是否与蛇的身体部分发生了碰撞。这应该通过检查头部的坐标（*y*，*x*）是否与蛇的身体的任何坐标相匹配来完成。因此，让我们制作一个新的`@property`方法，用于检查碰撞：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, any function will return `True` if any item in the
    iterable is `True`; otherwise, it will return `False`. The statement inside the
    `any` function is a list comprehension statement that checks whether the coordinates
    for the head of the snake are the same as the coordinates for any part of the
    body of the snake.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，如果可迭代对象中的任何项为`True`，则任何函数将返回`True`；否则，它将返回`False`。`any`函数中的语句是一个列表推导语句，用于检查蛇头的坐标是否与蛇身的任何部分的坐标相同。
- en: 'Now, let''s invoke this method with the `snake` object in our main loop:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在主循环中使用`snake`对象调用这个方法：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adding the food class
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加食物类
- en: 'The next character we need to add to our game is `Food`. As we have already
    said, we have to make a different class for each character because they should
    have different behaviors and attributes. Let''s create another class for the `Food`
    character. We will call this the `Food` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到游戏中的下一个角色是`Food`。正如我们已经说过的，我们必须为每个角色创建一个不同的类，因为它们应该具有不同的行为和属性。让我们为`Food`角色创建另一个类。我们将称之为`Food`类。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you read the *Python classes* section in this chapter carefully, this section
    should not create any confusion for you. To create a class in Python, we use the
    `class` keyword, followed by the class name. However, we have to use parentheses
    to show inheritance. If you left the parentheses empty, they will throw an error.
    Thus, we have added an object inside the parentheses, which is optional. You can
    simply remove the parentheses and they will work perfectly. We used the `randint`
    method from the random module to create food in a random position. The render
    method is going to add the `X` character to the specified (*y*,*x*) position.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读了本章的*Python类*部分，这一节不应该让你感到困惑。在Python中创建一个类，我们使用`class`关键字，后面跟着类名。然而，我们必须使用括号来表示继承。如果你将括号留空，它们将抛出一个错误。因此，我们在括号内添加了一个对象，这是可选的。你可以简单地移除括号，它们将完美地工作。我们使用了random模块中的`randint`方法来在随机位置创建食物。`render`方法将在指定的(*y*,*x*)位置添加`X`字符。
- en: 'Now, let''s create the object of the `Food` class and render the food on the
    screen by invoking the `render` method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Food`类的对象，并通过调用`render`方法在屏幕上渲染食物：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may recall, the logic that we''ve created to make the snake eat the
    food is the same logic that we used for the snake head coordinate colliding with
    the food coordinate. Before we actually make that logic, we will make another
    method for the `Snake` class that will add the logic for the aftermath of eating
    the food:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们创建的逻辑使蛇吃食物的方式与蛇头坐标与食物坐标发生碰撞的逻辑相同。在实际制作这个逻辑之前，我们将为`Snake`类制作另一个方法，用于处理吃食物后的后续逻辑：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding logic is going to be called after the snake eats the food. After
    eating the food, we will reset it, which means the food will be generated in the
    next random position. We will then make an increment in the body position by adding
    the last coordinate of the food to the body of the snake.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在蛇吃了食物之后，上述逻辑将被调用。吃了食物之后，我们将重置它，这意味着食物将在下一个随机位置生成。然后，我们将通过将食物的最后一个坐标添加到蛇的身体上来增加身体的位置。
- en: 'Now, let''s add some logic that will make sure we invoke this method. As we
    have already discussed, the logic will be simple: whenever the head of the snake
    collides with the position of the food, we will invoke the `eat_food` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些逻辑，确保我们调用这个方法。正如我们已经讨论过的，逻辑将会很简单：每当蛇头与食物的位置发生碰撞时，我们将调用`eat_food`方法。
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s run our game and observe the output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏并观察输出：
- en: '![](Images/2e913c55-45cb-4b3c-ae48-3d794eb98a42.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2e913c55-45cb-4b3c-ae48-3d794eb98a42.png)'
- en: Finally, we have modified the game with the object-oriented paradigm. You might
    feel that working with classes and objects is more complicated and lengthy, but
    with more practice, you will become more comfortable with it. That being said,
    OOP has provided more readability and reusability features in our program. As
    an example, if you find a bug in the `Snake` character, you can simply track it
    down by overlooking the unnecessary code for the food. Now, let's hop over to
    the next section, where we will test the game and make the necessary modifications
    to it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经用面向对象的范式修改了游戏。你可能觉得使用类和对象更复杂和冗长，但通过更多的练习，你会变得更加熟悉。话虽如此，面向对象编程为我们的程序提供了更多的可读性和可重用性特性。举个例子，如果你在`Snake`角色中发现了一个bug，你可以通过检查食物的不必要代码来追踪它。现在，让我们跳到下一节，测试游戏并对其进行必要的修改。
- en: Game testing and possible modification
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: The curses application cannot be run directly from the Python script by pressing
    *F5*. Thus, we have to run it externally from the command prompt with the `filename.py` command.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 无法通过按下*F5*直接从Python脚本运行curses应用程序。因此，我们必须通过命令提示符外部运行它，使用`filename.py`命令。
- en: 'Now, let''s add the score to our game:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在游戏中添加分数：
- en: 'First of all, we have to initialize the score value as 0 at the `Snake` class.
    We will also add a `score` method in the `Snake` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Snake`类中将分数值初始化为0。我们还将在`Snake`类中添加一个`score`方法：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we have to increase this score every time the snake eats the food. The
    method that will be called after the snake eats food is the `eat_food` method.
    Thus, we will increase the score inside this method:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在蛇吃食物时每次增加这个分数。蛇吃食物后将调用的方法是`eat_food`方法。因此，我们将在这个方法中增加分数：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s render the score with the `addstr` method of the curses window
    object:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用curses窗口对象的`addstr`方法渲染分数：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding statement will call the `score` method from the snake object and
    add the score at the (0,5) position. Remember that, in curses, the first position
    is y and the second is x.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述语句将从蛇对象中调用`score`方法，并在(0,5)位置添加分数。请记住，在curses中，第一个位置是y，第二个位置是x。
- en: 'Let''s run our game one more time:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行游戏：
- en: '![](Images/ffdafeea-9cb8-407a-a07b-35439d08ce74.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ffdafeea-9cb8-407a-a07b-35439d08ce74.png)'
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about one of the most important paradigms in programming—object-oriented
    programming. We covered all the concepts of classes and objects to make it easier
    for you to read and write your own code. We also explored how to define the members
    of a class and access them. We got familiar with the features of the object-oriented
    approach by implementing hands-on examples. We also learned about inheritance,
    encapsulation, polymorphism, and method overriding. These features will be used
    in upcoming chapters too, so make sure you have a good grasp of each of these
    topics.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了编程中最重要的范式之一——面向对象编程。我们涵盖了类和对象的所有概念，以使您更容易阅读和编写自己的代码。我们还探讨了如何定义类的成员并访问它们。通过实际示例，我们熟悉了面向对象方法的特性。我们还学习了继承、封装、多态和方法重写。这些特性也将在接下来的章节中使用，所以确保您对这些主题每个都有很好的掌握。
- en: In the next chapter, we will learn about list comprehension and properties.
    The aim of the next chapter is to find a way to optimize code to make the program
    shorter and faster in terms of its execution. We will look at how to work with
    conditions and logic in order to implement one-line code that will be more readable
    and easier to debug. We will also use that concept to modify our Snake game.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习列表推导和属性。下一章的目的是找到一种优化代码的方法，使程序在执行方面更短、更快。我们将学习如何处理条件和逻辑，以实现更易读和更易调试的单行代码。我们还将利用这个概念来修改我们的贪吃蛇游戏。
