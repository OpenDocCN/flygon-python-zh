- en: Chapter 9. Extending Our GUI with the wxPython Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。使用wxPython库扩展我们的GUI
- en: In this chapter, we will enhance our Python GUI by using the wxPython library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用wxPython库增强我们的Python GUI。
- en: How to install the wxPython library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装wxPython库
- en: How to create our GUI in wxPython
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在wxPython中创建我们的GUI
- en: Quickly adding controls using wxPython
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用wxPython快速添加控件
- en: Trying to embed a main wxPython app in a main tkinter app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在主tkinter应用程序中嵌入主wxPython应用程序
- en: Trying to embed our tkinter GUI code into wxPython
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将我们的tkinter GUI代码嵌入到wxPython中
- en: How to use Python to control two different GUI frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Python控制两个不同的GUI框架
- en: How to communicate between the two connected GUIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在两个连接的GUI之间通信
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will introduce another Python GUI toolkit that currently
    does not ship with Python. It is called wxPython.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍另一个Python GUI工具包，它目前不随Python一起发布。它被称为wxPython。
- en: There are two versions of this library. The original is called Classic while
    the newest is called by its development project code name, Phoenix.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库有两个版本。原始版本称为Classic，而最新版本称为开发项目的代号Phoenix。
- en: In this book, we are solely programming using Python 3, and because the new
    Phoenix project is aimed at supporting Python 3, this is the version of wxPython
    we are using in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们仅使用Python 3进行编程，因为新的Phoenix项目旨在支持Python 3，这就是我们在本章中使用的wxPython版本。
- en: First, we will create a simple wxPython GUI, and then we will try to connect
    both the tkinter-based GUIs we developed in this book with the new wxPython library.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个简单的wxPython GUI，然后我们将尝试将我们在本书中开发的基于tkinter的GUI与新的wxPython库连接起来。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: wxPython is a Python binding to wxWidgets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython是Python绑定到wxWidgets的库。
- en: The w in wxPython stands for the Windows OS and the x stands for Unix-based
    operating systems such as Linux and OS X.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython中的w代表Windows操作系统，x代表Unix操作系统，如Linux和OS X。
- en: If things don't work out using these two GUI toolkits in unison, we will attempt
    to use Python to solve any problems and then we will use **Inter Process Communication**
    (**IPC**) within Python to make sure that our Python code works as we want it
    to work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时使用这两个GUI工具包出现问题，我们将尝试使用Python解决任何问题，然后我们将使用Python内的**进程间通信**（**IPC**）来确保我们的Python代码按我们希望的方式工作。
- en: How to install the wxPython library
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安装wxPython库
- en: The wxPython library does not ship with Python, so, in order to use it, we first
    have to install it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython库不随Python一起发布，因此，为了使用它，我们首先必须安装它。
- en: This recipe will show us where and how to find the right version to install
    to match both the installed version of Python and the operating system we are
    running.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤将向我们展示在哪里以及如何找到正确的版本来安装，以匹配已安装的Python版本和正在运行的操作系统。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The wxPython third-party library has been around for more than 17 years, which
    indicates that it is a robust library.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython第三方库已经存在了17年多，这表明它是一个强大的库。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to use wxPython with Python 3, we have to install the wxPython Phoenix
    version.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python 3中使用wxPython，我们必须安装wxPython Phoenix版本。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: When searching online for wxPython, we will probably find the official website
    at [www.wxpython.org](http://www.wxpython.org).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索wxPython时，我们可能会在[www.wxpython.org](http://www.wxpython.org)找到官方网站。
- en: '![How to do it...](graphics/B04829_09_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_01.jpg)'
- en: If we click on the download link for MS Windows, we can see several Windows
    installers, all of which are for Python 2.x only.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击MS Windows的下载链接，我们可以看到几个Windows安装程序，所有这些安装程序都仅适用于Python 2.x。
- en: '![How to do it...](graphics/B04829_09_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_02.jpg)'
- en: 'To use wxPython with Python 3, we have to install the wxPython/Phoenix library.
    We can find the installer at the snapshot-builds link:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python 3和wxPython，我们必须安装wxPython/Phoenix库。我们可以在快照构建链接中找到安装程序：
- en: '[http://wxpython.org/Phoenix/snapshot-builds/](http://wxpython.org/Phoenix/snapshot-builds/)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wxpython.org/Phoenix/snapshot-builds/](http://wxpython.org/Phoenix/snapshot-builds/)'
- en: From here, we can select the wxPython/Phoenix version that matches both our
    versions of Python and our OS. I am using Python 3.4 running on a 64-bit Windows
    7 OS.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以选择与我们的Python版本和操作系统版本匹配的wxPython/Phoenix版本。我正在使用运行在64位Windows 7操作系统上的Python
    3.4。
- en: '![How to do it...](graphics/B04829_09_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_03.jpg)'
- en: The Python wheel (`.whl`) installer package has a numbering scheme.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python wheel（.whl）安装程序包有一个编号方案。
- en: For us, the most important part of this scheme is that we are installing the
    wxPython/Phoenix build that is for Python 3.4 (the cp34 in the installer name)
    and for the Windows 64-bit OS (the win_amd64 part of the installer name).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这个方案最重要的部分是我们正在安装的wxPython/Phoenix版本是为Python 3.4（安装程序名称中的cp34）和Windows
    64位操作系统（安装程序名称中的win_amd64）。
- en: '![How to do it...](graphics/B04829_09_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_04.jpg)'
- en: After successfully downloading the wxPython/Phoenix package, we can now navigate
    to the directory where it resides and install this package using pip.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 成功下载wxPython/Phoenix包后，我们现在可以转到该包所在的目录，并使用pip安装此包。
- en: '![How to do it...](graphics/B04829_09_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_05.jpg)'
- en: We have a new folder called `wx` in our Python `site-packages` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python“site-packages”文件夹中有一个名为“wx”的新文件夹。
- en: '![How to do it...](graphics/B04829_09_06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_06.jpg)'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`wx` is the folder name the wxPython/Phoenix library installed into. We will
    import this module into our Python code.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “wx”是wxPython/Phoenix库安装的文件夹名称。我们将在Python代码中导入此模块。
- en: We can verify that our installation worked by executing this simple demo script
    from the official wxPython/Phoenix website. The link to the official website is
    [http://wxpython.org/Phoenix/docs/html/](http://wxpython.org/Phoenix/docs/html/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行来自官方wxPython/Phoenix网站的简单演示脚本来验证我们的安装是否成功。官方网站的链接是[http://wxpython.org/Phoenix/docs/html/](http://wxpython.org/Phoenix/docs/html/)。
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running the preceding Python 3 script creates the following GUI using wxPython/Phoenix.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述Python 3脚本将使用wxPython/Phoenix创建以下GUI。
- en: '![How to do it...](graphics/B04829_09_07.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_07.jpg)'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we successfully installed the correct version of the wxPython
    toolkit, which we can use with Python 3\. We found the Phoenix project for this
    GUI toolkit, which is the current and active development line. Phoenix will replace
    the Classic wxPython toolkit in time and is especially aimed at working well with
    Python 3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们成功安装了与Python 3兼容的正确版本的wxPython工具包。我们找到了这个GUI工具包的Phoenix项目，这是当前和活跃的开发线。Phoenix将在未来取代Classic
    wxPython工具包，特别适用于与Python 3良好地配合使用。
- en: After successfully installing the wxPython/Phoenix toolkit, we then created
    a GUI using this toolkit in only five lines of code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装了wxPython/Phoenix工具包后，我们只用了五行代码就创建了一个GUI。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We previously achieved the same results by using tkinter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用tkinter实现了相同的结果。
- en: How to create our GUI in wxPython
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在wxPython中创建我们的GUI
- en: In this recipe, we will start to create our Python GUIs using the wxPython GUI
    toolkit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将开始使用wxPython GUI工具包创建我们的Python GUI。
- en: We will first recreate several of the widgets we previously created using tkinter,
    which ships with Python.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用随Python一起提供的tkinter重新创建我们之前创建的几个小部件。
- en: Then, we will explore some of the widgets the wxPython GUI toolkit offers, which
    are harder to create using tkinter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探索一些使用tkinter更难创建的wxPython GUI工具包提供的小部件。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The previous recipe showed you how to install the correct version of wxPython
    that matches both your version of Python and the OS you are running.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的食谱向您展示了如何安装与您的Python版本和操作系统匹配的正确版本的wxPython。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A good place to start exploring the wxPython GUI toolkit is by going to the
    following URL: [http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 开始探索wxPython GUI工具包的一个好地方是访问以下网址：[http://wxpython.org/Phoenix/docs/html/gallery.html](http://wxpython.org/Phoenix/docs/html/gallery.html)
- en: This webpage displays many wxPython widgets. By clicking on any of them, we
    are taken to their documentation, which is a very nice and helpful feature to
    quickly learn about a wxPython control.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网页显示了许多wxPython小部件。点击任何一个小部件，我们会进入它们的文档，这是一个非常好的和有用的功能，可以快速了解wxPython控件。
- en: '![How to do it...](graphics/B04829_09_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_08.jpg)'
- en: The following screenshot shows the documentation for a wxPython button widget.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了wxPython按钮小部件的文档。
- en: '![How to do it...](graphics/B04829_09_09.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_09.jpg)'
- en: 'We can very quickly create a working window that comes with a title, a menu
    bar, and also a status bar. This status bar displays the text of a menu item when
    hovering the mouse over it. This can be achieved by writing the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常快速地创建一个带有标题、菜单栏和状态栏的工作窗口。当鼠标悬停在菜单项上时，状态栏会显示菜单项的文本。这可以通过编写以下代码来实现：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates the following GUI, which is written in Python using the wxPython
    library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了以下使用wxPython库编写的Python GUI。
- en: '![How to do it...](graphics/B04829_09_10.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_10.jpg)'
- en: In the previous code, we inherited from `wx.Frame`. In the following code, we
    inherit from `wx.Panel` and we pass in `wx.Frame` to the `__init__()` method of
    our class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们继承自`wx.Frame`。在下面的代码中，我们继承自`wx.Panel`，并将`wx.Frame`传递给我们的类的`__init__()`方法。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In wxPython, the top-level GUI window is called a frame. There cannot be a wxPython
    GUI without a frame and the frame has to be created as part of a wxPython application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，顶级GUI窗口称为框架。没有框架就不能有wxPython GUI，框架必须作为wxPython应用程序的一部分创建。
- en: We create both the application and the frame at the bottom of our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码底部同时创建应用程序和框架。
- en: In order to add widgets to our GUI, we have to attach them to a panel. The parent
    of the panel is the frame (our top-level window) and the parent of the widgets
    we place into the panel is the panel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向我们的GUI添加小部件，我们必须将它们附加到一个面板上。面板的父级是框架（我们的顶级窗口），我们放置在面板中的小部件的父级是面板。
- en: The following code adds a multiline textbox widget to a panel whose parent is
    a frame. We also add a button widget to the panel widget, which, when clicked,
    prints out some text to the textbox.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向一个面板小部件添加了一个多行文本框小部件。我们还向面板小部件添加了一个按钮小部件，当点击时，会向文本框打印一些文本。
- en: 'Here is the complete code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the preceding code and clicking our wxPython button widget results
    in the following GUI output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码并点击我们的wxPython按钮小部件会产生以下GUI输出：
- en: '![How to do it...](graphics/B04829_09_11.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_11.jpg)'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We have created our own GUI in this recipe using the mature wxPython GUI toolkit.
    In only a few lines of Python code, we were able to create a fully functional
    GUI that comes with `Minimize`, `Maximize`, and `Exit` buttons. We added a menu
    bar, a multi-line text-control, and a button. We also created a status bar that
    displays text when we select a menu item. We placed all these widgets into a Panel
    container widget.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用成熟的wxPython GUI工具包创建了自己的GUI。只需几行Python代码，我们就能创建一个带有“最小化”、“最大化”和“退出”按钮的完全功能的GUI。我们添加了一个菜单栏，一个多行文本控件和一个按钮。我们还创建了一个状态栏，当我们选择菜单项时会显示文本。我们将所有这些小部件放入了一个面板容器小部件中。
- en: We hooked up the button to print to the text control.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按钮连接到文本控件以打印文本。
- en: When hovering over a menu item, some text gets displayed in the status bar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标悬停在菜单项上时，状态栏会显示一些文本。
- en: Quickly adding controls using wxPython
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用wxPython快速添加控件
- en: In this recipe, we will recreate the GUI we originally created earlier in this
    book with tkinter , but this time, we will be using the wxPython library. We will
    see how easy and quick it is to use the wxPython GUI toolkit to create our own
    Python GUIs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将重新创建我们在本书中早期使用tkinter创建的GUI，但这次，我们将使用wxPython库。我们将看到使用wxPython GUI工具包创建我们自己的Python
    GUI是多么简单和快速。
- en: We will not recreate the entire functionality we created in previous chapters.
    For example, we will not internationalize our wxPython GUI nor connect it to a
    MySQL database. We will recreate the visual aspects of the GUI and add some functionality.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重新创建我们在之前章节中创建的整个功能。例如，我们不会国际化我们的wxPython GUI，也不会将其连接到MySQL数据库。我们将重新创建GUI的视觉方面并添加一些功能。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Comparing different libraries gives us the choice of which toolkits to use for
    our own Python GUI development and we can combine several of those toolkits in
    our own Python code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 比较不同的库可以让我们选择使用哪些工具包来开发我们自己的Python GUI，并且我们可以在我们自己的Python代码中结合几个工具包。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have the wxPython module installed to follow this recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经安装了wxPython模块以便按照这个步骤进行。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we create our Python `OOP` class as we did before using tkinter, but
    this time we inherit from and extend the `wx.Frame` class. For clarity reasons,
    we no longer call our class `OOP` but instead rename it as `MainFrame`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像以前在tkinter中那样创建我们的Python“OOP”类，但这次我们继承并扩展了“wx.Frame”类。出于清晰的原因，我们不再将我们的类称为“OOP”，而是将其重命名为“MainFrame”。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In wxPython, the main GUI window is called a Frame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，主GUI窗口被称为Frame。
- en: We also create a callback method that closes the GUI when we click the `Exit`
    Menu Item and declare a light-gray `tuple` as the background color for our GUI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个回调方法，当我们单击“退出”菜单项时关闭GUI，并将浅灰色的“元组”声明为我们GUI的背景颜色。
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we add a tabbed control to our GUI by creating an instance of the wxPython
    `Notebook` class and assign it as the parent to our own custom class named `Widgets`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建wxPython“Notebook”类的实例并将其分配为我们自己的名为“Widgets”的自定义类的父类，向我们的GUI添加一个选项卡控件。
- en: The `notebook` class instance variable has `wx.Panel` as its parent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “notebook”类实例变量的父类是“wx.Panel”。
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In wxPython, the tabbed widget is named `Notebook`, just as in tkinter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，选项卡小部件被命名为“Notebook”，就像在tkinter中一样。
- en: Every `Notebook` widget needs to have a parent and, in order to lay out widgets
    in the `Notebook` in wxPython, we use different kinds of sizers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个“Notebook”小部件都需要一个父类，并且为了在wxPython中布局“Notebook”中的小部件，我们使用不同类型的sizers。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: wxPython sizers are layout managers similar to tkinter's grid layout manager.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython sizers是类似于tkinter的网格布局管理器的布局管理器。
- en: Next, we add controls to our Notebook page. We do this by creating a separate
    class that inherits from `wx.Panel`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向我们的Notebook页面添加控件。我们通过创建一个从“wx.Panel”继承的单独类来实现这一点。
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We modularize our GUI code by breaking it into small methods, following Python
    OOP programming best practices, which keeps our code manageable and understandable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将GUI代码模块化为小方法来遵循Python OOP编程最佳实践，这样可以使我们的代码易于管理和理解。
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using wxPython StaticBox widgets, in order to successfully lay them out,
    we use a combination of a `StaticBoxSizer` and a regular `BoxSizer`. The wxPython
    StaticBox is very similar to the tkinter LabelFrame widget.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用wxPython StaticBox小部件时，为了成功地对其进行布局，我们使用了“StaticBoxSizer”和常规的“BoxSizer”的组合。wxPython
    StaticBox与tkinter的LabelFrame小部件非常相似。
- en: 'Embedding a `StaticBox` within another `StaticBox` is straightforward in tkinter,
    but using wxPython is a little non-intuitive. One way to make it work is shown
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在tkinter中，将一个“StaticBox”嵌入另一个“StaticBox”很简单，但在wxPython中使用起来有点不直观。使其工作的一种方法如下所示：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we create a horizontal `BoxSizer`. Next, we create a vertical `StaticBoxSizer`
    because we want to arrange two labels in a vertical layout in this frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个水平的“BoxSizer”。接下来，我们创建一个垂直的“StaticBoxSizer”，因为我们想在这个框架中以垂直布局排列两个标签。
- en: In order to arrange another widget to the right of the embedded `StaticBox`,
    we have to assign both the embedded `StaticBox` with its children controls and
    the next widget to the horizontal `BoxSizer` and then assign this `BoxSizer`,
    which now contains both our embedded `StaticBox` and our other widgets, to the
    main `StaticBox`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将另一个小部件排列到嵌入的“StaticBox”的右侧，我们必须将嵌入的“StaticBox”及其子控件和下一个小部件都分配给水平的“BoxSizer”，然后将这个“BoxSizer”（现在包含了我们的嵌入的“StaticBox”和其他小部件）分配给主“StaticBox”。
- en: Does this sound confusing?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来令人困惑吗？
- en: You have to just experiment with these sizers to get a feel for how to use them.
    Start with the code for this recipe and comment out some code, or modify some
    x and y coordinates to see the effects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要尝试使用这些sizers来感受如何使用它们。从这个步骤的代码开始，注释掉一些代码，或者修改一些x和y坐标来看看效果。
- en: It is also good to read the official wxPython documentation to learn more.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读官方的wxPython文档也是很有帮助的。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The important thing is knowing where in the code to add to the different sizers
    in order to achieve the layout we wish.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道在代码中的哪里添加不同的sizers以实现我们希望的布局。
- en: In order to create the second `StaticBox` below the first, we create separate
    `StaticBoxSizers` and assign them to the same panel.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在第一个下面创建第二个“StaticBox”，我们创建单独的“StaticBoxSizers”并将它们分配给同一个面板。
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following code instantiates the main event loop which runs our wxPython
    GUI program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实例化了主事件循环，运行我们的wxPython GUI程序。
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final result of our wxPython GUI looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的wxPython GUI的最终结果如下：
- en: '![How to do it...](graphics/B04829_09_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_12.jpg)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We design and lay out our wxPython GUI in several classes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几个类中设计和布局我们的wxPython GUI。
- en: Once we have done this in the bottom section of our Python module, we create
    an instance of the wxPython application. Next, we instantiate our wxPython GUI
    code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python模块的底部部分完成这些操作后，我们创建了一个wxPython应用程序的实例。接下来，我们实例化我们的wxPython GUI代码。
- en: After that, we call the main GUI event loop that executes all of our Python
    code running within this application process. This displays our wxPython GUI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们调用主GUI事件循环，该循环执行在此应用程序进程中运行的所有Python代码。这将显示我们的wxPython GUI。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whatever code we place between the creation of the app and calling its main
    event loop becomes our wxPython GUI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放置在创建应用程序和调用其主事件循环之间的任何代码都成为我们的wxPython GUI。
- en: 'It might take some time to really get used to the wxPython library and its
    API, but once we understand how to use it, this library is really fun and a powerful
    tool to build our own Python GUIs. There also is a visual designer tool that can
    be used with wxPython: [http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view](http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一些时间来真正熟悉wxPython库及其API，但一旦我们了解如何使用它，这个库就真的很有趣，是构建自己的Python GUI的强大工具。还有一个可与wxPython一起使用的可视化设计工具：[http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view](http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view)
- en: This recipe used OOP to learn how to use the wxPython GUI toolkit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用面向对象编程来学习如何使用wxPython GUI工具包。
- en: Trying to embed a main wxPython app in a main tkinter app
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试将主要的wxPython应用程序嵌入到主要的tkinter应用程序中
- en: Now that we have created the same GUI using both the Python's built-in tkinter
    library as well as the wxPython wrapper of the wxWidgets library, we really do
    need to combine the GUIs we created using these technologies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用Python内置的tkinter库以及wxWidgets库的wxPython包装器创建了相同的GUI，我们确实需要结合使用这些技术创建的GUI。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both the wxPython and the tkinter libraries have their own advantages. In online
    forums such as [http://stackoverflow.com/](http://stackoverflow.com/), we often
    see questions such as, which one is better? Which GUI toolkit should I use? This
    suggests that we have to make an "either-or" decision. We do not have to make
    such a decision.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython和tkinter库都有各自的优势。在诸如[http://stackoverflow.com/](http://stackoverflow.com/)的在线论坛上，我们经常看到诸如哪个更好？应该使用哪个GUI工具包？这表明我们必须做出“二选一”的决定。我们不必做出这样的决定。
- en: One of the main challenges in doing so is that each GUI toolkit has to have
    its own event loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要挑战之一是每个GUI工具包都必须有自己的事件循环。
- en: In this recipe, we will try to embed a simple wxPython GUI by calling it from
    our tkinter GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将尝试通过从我们的tkinter GUI中调用它来嵌入一个简单的wxPython GUI。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will reuse the tkinter GUI we built in a previous recipe in [Chapter 1](ch01.html
    "Chapter 1. Creating the GUI Form and Adding Widgets"), *Creating the GUI Form
    and Adding Widgets*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用在[第1章](ch01.html "第1章。创建GUI表单并添加小部件")中构建的tkinter GUI。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are starting from a simple tkinter GUI that looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的tkinter GUI开始，看起来像这样：
- en: '![How to do it...](graphics/B04829_09_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_13.jpg)'
- en: Next, we will try to invoke a simple wxPython GUI, which we created in a previous
    recipe in this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试调用在本章前一篇示例中创建的简单wxPython GUI。
- en: 'This is the entire code to do this in a simple, non-OOP way:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以简单的非面向对象编程方式完成此操作的整个代码：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the preceding code starts a wxPython GUI from our tkinter GUI after
    clicking the tkinter `Button` control.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，单击tkinter `Button`控件后，从我们的tkinter GUI启动了一个wxPython GUI。
- en: '![How to do it...](graphics/B04829_09_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_14.jpg)'
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The important part is that we placed the entire wxPython code into its own function,
    which we named `def wxPythonApp()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们将整个wxPython代码放入了自己的函数中，我们将其命名为`def wxPythonApp()`。
- en: In the callback function for the button click-event, we simply call this code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮单击事件的回调函数中，我们只需调用此代码。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing to note is that we have to close the wxPython GUI before we can continue
    using the tkinter GUI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，在继续使用tkinter GUI之前，我们必须关闭wxPython GUI。
- en: Trying to embed our tkinter GUI code into wxPython
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试将我们的tkinter GUI代码嵌入到wxPython中
- en: In this recipe, we will go in the opposite direction to the previous recipe
    and try to call our tkinter GUI code from within a wxPython GUI.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将与上一个示例相反，尝试从wxPython GUI中调用我们的tkinter GUI代码。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will reuse some of the wxPython GUI code we created in a previous recipe
    in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用在本章前一篇示例中创建的一些wxPython GUI代码。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will start from a simple wxPython GUI, which looks like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的wxPython GUI开始，看起来像这样：
- en: '![How to do it...](graphics/B04829_09_15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_15.jpg)'
- en: Next, we will try to invoke a simple tkinter GUI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试调用一个简单的tkinter GUI。
- en: 'This is the entire code to do this in a simple, non-OOP way:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以简单的非面向对象编程方式完成此操作的整个代码：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running the preceding code starts a tkinter GUI from our wxPython GUI after
    clicking the wxPython `Button` widget. We can then enter text into the tkinter
    textbox. By clicking its button, the button text gets updated with the name.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码后，单击wxPython `Button`小部件后，从我们的wxPython GUI启动了一个tkinter GUI。然后我们可以在tkinter文本框中输入文本。通过单击其按钮，按钮文本将更新为该名称。
- en: '![How to do it...](graphics/B04829_09_16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_16.jpg)'
- en: After starting the tkinter event loop, the wxPython GUI is still responsive
    because we can type into the `TextCtrl` widget while the tkinter GUI is up and
    running.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动tkinter事件循环后，wxPython GUI仍然可以响应，因为我们可以在tkinter GUI运行时输入`TextCtrl`小部件。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous recipe, we could not use our tkinter GUI until we had closed
    the wxPython GUI. Being aware of this difference can help our design decisions
    if we want to combine the two Python GUI technologies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们在关闭wxPython GUI之前无法使用我们的tkinter GUI。意识到这种差异可以帮助我们的设计决策，如果我们想要结合这两种Python
    GUI技术。
- en: We can also create several tkinter GUI instances by clicking the wxPython GUI
    button several times. We cannot, however, close the wxPython GUI while any tkinter
    GUIs are still running. We have to close them first.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多次单击wxPython GUI按钮，我们还可以创建几个tkinter GUI实例。但是，只要有任何tkinter GUI仍在运行，我们就不能关闭wxPython
    GUI。我们必须先关闭它们。
- en: '![How to do it...](graphics/B04829_09_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_17.jpg)'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we went in the opposite direction to the previous recipe by first
    creating a GUI using wxPython and then, from wit-hin it, creating several GUI
    instances built using tkinter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们与上一个示例相反，首先使用wxPython创建GUI，然后在其中使用tkinter创建了几个GUI实例。
- en: The wxPython GUI remained responsive while one or more tkinter GUIs were running.
    However, clicking the tkinter button only updated its button text in the first
    instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个tkinter GUI正在运行时，wxPython GUI仍然保持响应。但是，单击tkinter按钮只会更新第一个实例中的按钮文本。
- en: How to use Python to control two different GUI frameworks
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用Python来控制两种不同的GUI框架
- en: In this recipe, we will explore ways to control the tkinter and wxPython GUI
    frameworks from Python. We have already used the Python threading module to keep
    our GUI responsive in the previous chapter, so here we will attempt to use the
    same approach.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何从Python控制tkinter和wxPython GUI框架。在上一章中，我们已经使用Python的线程模块来保持我们的GUI响应，所以在这里我们将尝试使用相同的方法。
- en: We will see that things don't always work in a way that would be intuitive.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到事情并不总是按照直觉的方式工作。
- en: However, we will improve our tkinter GUI from being unresponsive while we invoke
    an instance of the wxPython GUI from within it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将改进我们的tkinter GUI，使其在我们从中调用wxPython GUI的实例时不再无响应。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will extend a previous recipe from this chapter in which we tried
    to embed a main wxPython GUI into our tkinter GUI.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将扩展本章的一个先前配方，我们试图将一个主要的wxPython GUI嵌入到我们的tkinter GUI中。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: When we created an instance of a wxPython GUI from our tkinter GUI, we could
    no longer use the tkinter GUI controls until we closed the one instance of the
    wxPython GUI. Let's improve on this now.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从tkinter GUI创建了一个wxPython GUI的实例时，我们就不能再使用tkinter GUI控件，直到关闭了wxPython GUI的一个实例。让我们现在改进一下。
- en: Our first attempt might be to use threading from the tkinter button callback
    function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一次尝试可能是在tkinter按钮回调函数中使用线程。
- en: 'For example, our code might look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的代码可能是这样的：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At first, this seems to be working, which would be intuitive as the tkinter
    controls are no longer disabled and we can create several instances of the wxPython
    GUI by clicking the button. We can also type into and select the other tkinter
    widgets.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎是有效的，这是直观的，因为tkinter控件不再被禁用，我们可以通过单击按钮创建几个wxPython GUI的实例。我们还可以在其他tkinter小部件中输入和选择。
- en: '![How to do it...](graphics/B04829_09_18.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_18.jpg)'
- en: However, once we try to close the GUIs, we get an error from wxWidgets, and
    our Python executable crashes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们试图关闭GUI，我们会从wxWidgets得到一个错误，我们的Python可执行文件会崩溃。
- en: '![How to do it...](graphics/B04829_09_19.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_09_19.jpg)'
- en: In order to avoid this, instead of trying to run the entire wxPython application
    in a thread, we can change the code to make only the wxPython `app.MainLoop` run
    in a thread.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以改变代码，只让wxPython的`app.MainLoop`在一个线程中运行，而不是尝试在一个线程中运行整个wxPython应用程序。
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first tried to run the entire wxPython GUI application in a thread, but this
    did not work as the wxPython main event loop expects to be the main thread of
    the application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初尝试在一个线程中运行整个wxPython GUI应用程序，但这并不起作用，因为wxPython的主事件循环期望成为应用程序的主线程。
- en: We found a workaround for this by only running the wxPython `app.MainLoop` in
    a thread, which tricks it into believing it is the main thread.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了一个解决方法，只在一个线程中运行wxPython的`app.MainLoop`，这样就可以欺骗它认为它是主线程。
- en: One side-effect of this approach is that we can no longer individually close
    all of the wxPython GUI instances. At least one of them only closes when we close
    the wxPython GUI which created the threads as daemons.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个副作用是，我们不能再单独关闭所有的wxPython GUI实例。至少其中一个只有在我们关闭创建线程为守护进程的wxPython GUI时才关闭。
- en: I am not quite sure why this is. Intuitively, one might expect to be able to
    close all daemon threads without having to wait for the main thread that created
    them to close first.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太确定为什么会这样。直觉上，人们可能期望能够关闭所有守护线程，而不必等待创建它们的主线程先关闭。
- en: It possibly has to do with a reference counter not having been set to zero while
    our main thread is still running.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与引用计数器没有被设置为零，而我们的主线程仍在运行有关。
- en: On a pragmatic level, this is how it currently works.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际层面上，这是当前的工作方式。
- en: How to communicate between the two connected GUIs
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在两个连接的GUI之间进行通信
- en: In the previous recipes, we found ways to connect a wxPython GUI with a tkinter
    GUI, invoking one from the other and vice versa.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们找到了连接wxPython GUI和tkinter GUI的方法，相互调用彼此。
- en: While both GUIs were successfully running at the same time, they did not really
    communicate with each other as they were only launching one another.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个GUI成功同时运行，但它们实际上并没有真正相互通信，因为它们只是互相启动。
- en: In this recipe, we will explore ways to make the two GUIs talk to each other.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨使这两个GUI相互通信的方法。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading one of the previous recipes might be a good preparation for this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读之前的一些配方可能是为这个配方做好准备的好方法。
- en: In this recipe, we will use a slightly modified GUI code compared to the previous
    recipe, but most of the basic GUI-building code is the same.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用与之前配方相比略有修改的GUI代码，但大部分基本的GUI构建代码是相同的。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the previous recipes, one of our main challenges was how to combine two GUI
    technologies that were designed to be the one-and-only GUI toolkit for an application.
    We found various simple ways to combine them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们的主要挑战之一是如何将两个设计为应用程序的唯一GUI工具包的GUI技术结合起来。我们找到了各种简单的方法来将它们结合起来。
- en: We will again launch the wxPython GUI from a tkinter GUI main event loop and
    start the wxPython GUI in its own thread that runs within the tkinter process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从tkinter GUI的主事件循环中启动wxPython GUI，并在tkinter进程中启动wxPython GUI的自己的线程。
- en: In order to do this, we will use a shared global multiprocessing Python queue.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用一个共享的全局多进程Python队列。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it is often best to avoid global data in this recipe, they are a practical
    solution and Python globals are really only global in the module they have been
    declared in.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个配方中最好避免全局数据，但它们是一个实际的解决方案，Python全局变量实际上只在它们被声明的模块中是全局的。
- en: Here is the Python code that makes the two GUIs communicate with each other
    to a certain degree. In order to save space, this is not pure OOP code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使两个GUI在一定程度上相互通信的Python代码。为了节省空间，这不是纯粹的面向对象编程代码。
- en: We are also not showing the creation code for all of the widgets. That code
    is the same as in previous recipes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也没有展示所有部件的创建代码。该代码与之前的示例中相同。
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running the preceding code first creates the tkinter part of the program and,
    when we click the button in this GUI, it runs the wxPython GUI. Both are running
    at the same time as before, but this time, there is an extra level of communication
    between the two GUIs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行上述代码会创建程序的tkinter部分，当我们在这个GUI中点击按钮时，它会运行wxPython GUI。与之前一样，两者同时运行，但这次，两个GUI之间有了额外的通信层级。
- en: '![How to do it...](graphics/B04829_09_20.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_09_20.jpg)'
- en: The tkinter GUI is shown on the left-hand side of the preceding screenshot and,
    by clicking the **Call wxPython GUI** button, we invoke an instance of the wxPython
    GUI. We can create several instances by clicking the button several times.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图的左侧显示了tkinter GUI，通过点击**Call wxPython GUI**按钮，我们调用了一个wxPython GUI的实例。我们可以通过多次点击按钮来创建多个实例。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of the created GUIs remain responsive. They do not crash nor freeze.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建的GUI都保持响应。它们不会崩溃或冻结。
- en: Clicking the **Print** button on any of the wxPython GUI instances writes one
    sentence to its own `TextCtrl` widget and then writes another line to itself as
    well as to the tkinter GUI. You will have to scroll up to see the first sentence
    in the wxPython GUI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一个wxPython GUI实例上点击**Print**按钮会向其自己的`TextCtrl`部件写入一句话，然后也会向自己以及tkinter GUI写入另一行。您需要向上滚动以在wxPython
    GUI中看到第一句话。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The way this works is by using a module-level queue and a tkinter `Text` widget
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式是通过使用模块级队列和tkinter的`Text`部件来实现的。
- en: One important element to note is that we create a thread to run the wxPython
    `app.MainLoop`, as we did in the previous recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，我们创建一个线程来运行wxPython的`app.MainLoop`，就像我们在之前的示例中所做的那样。
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create a class that inherits from `wx.Panel` and name it `GUI`. We then instantiate
    an instance of this class in the preceding code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从`wx.Panel`继承并命名为`GUI`的类。然后我们在上述代码中实例化了这个类。
- en: We create a button click-event callback method in this class, which then calls
    the procedural code that was written above it. Because of this, the class has
    access to the functions and can write to the shared queue.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中创建了一个按钮点击事件回调方法，然后调用了上面编写的过程代码。因此，该类可以访问这些函数并将数据写入共享队列。
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first check if the data has been placed in the shared queue in the preceding
    method and, if that is the case, we then print the common data to both GUIs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查在上述方法中是否已将数据放入共享队列，如果是这样，我们就将公共数据打印到两个GUI中。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `putDataIntoQueue()` line places data into the queue and `readDataFromQueue()`
    reads it back out saving it in the `data` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`putDataIntoQueue()`将数据放入队列，`readDataFromQueue()`将其读取出来并保存在`data`变量中。'
- en: '`text.insert(''0.0'', data)` is the line that writes this data into the tkinter
    GUI from the **Print** button''s wxPython callback method.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`text.insert(''0.0'', data)`是将这些数据从**Print**按钮的wxPython回调方法写入到tkinter GUI中的代码行。'
- en: Following are the procedural functions (not methods, for they are not bound)
    that are being called in the code and that make it work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在代码中被调用并使其工作的过程函数（不是方法，因为它们没有绑定）。
- en: '[PRE17]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are using a simple Boolean flag named `dataInQueue` to communicate when the
    data is available in the queue.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`dataInQueue`的简单布尔标志来通知数据何时可用于队列中。
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: In this recipe, we have successfully combined the two GUIs we created in a similar
    fashion, but previously standalone and not talking to each other. However, in
    this recipe, we connected them further by making one GUI launch another and, via
    a simple multiprocessing Python queue mechanism, we were able to make them communicate
    with each other, writing data from a shared queue into both GUIs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们成功地以类似的方式将我们之前独立的两个GUI结合在一起，但彼此之间没有交流。然而，在这个示例中，我们通过使一个GUI启动另一个GUI，并通过一个简单的多进程Python队列机制，进一步连接它们，我们能够使它们相互通信，将数据从共享队列写入到两个GUI中。
- en: There are many very advanced and complicated technologies available to connect
    different processes, threads, pools, locks, pipes, TCP/IP connections, and so
    on.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多非常先进和复杂的技术可用于连接不同的进程、线程、池、锁、管道、TCP/IP连接等。
- en: In the Pythonic spirit, we found a simple solution that works for us. Once our
    code becomes more complicated, we might have to refactor it, but this is a good
    beginning.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python精神中，我们找到了一个对我们有效的简单解决方案。一旦我们的代码变得更加复杂，我们可能需要重构它，但这是一个很好的开始。
