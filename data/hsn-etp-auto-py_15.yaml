- en: Interacting with the OpenStack API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与OpenStack API交互
- en: For a long time, IT infrastructure depended on commercial software (from vendors
    such as VMWare, Microsoft, and Citrix) to provide virtual environments for running
    workloads and managing resources (such as computing, storage, and networking).
    However, IT industry is moving to cloud era and engineers are migrating workloads
    and applications to the cloud (either public or private), and that requires a
    new framework that is able to manage all application resources, providing an open
    and robust API interface to interact with external calls from other applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，IT基础设施依赖于商业软件（来自VMWare、Microsoft和Citrix等供应商）提供运行工作负载和管理资源（如计算、存储和网络）的虚拟环境。然而，IT行业正在迈向云时代，工程师正在将工作负载和应用程序迁移到云（无论是公共还是私有），这需要一个能够管理所有应用程序资源的新框架，并提供一个开放和强大的API接口，以与其他应用程序的外部调用进行交互。
- en: OpenStack provides an open access and integration to manage all of your computing,
    storage, and networking resources, avoiding a vendor lock-in when you're building
    your cloud. It can control a large pool of compute nodes, storage arrays, and
    networking devices, regardless of the vendor for each resource and provide a seamless
    integration between all resources. The core idea of OpenStack is to abstract all
    configuration applied on the underlay infrastructure into a *project* which is
    responsible for managing the resource. so you will find a project that manage
    the compute resources (called Nova) , another project that provide networking
    to the instances (neutron) and a projects to interact with different storage type
    (Swift and Cinder).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack提供了开放访问和集成，以管理所有计算、存储和网络资源，避免在构建云时出现供应商锁定。它可以控制大量的计算节点、存储阵列和网络设备，无论每个资源的供应商如何，并在所有资源之间提供无缝集成。OpenStack的核心思想是将应用于底层基础设施的所有配置抽象为一个负责管理资源的*项目*。因此，您将找到一个管理计算资源的项目（称为Nova），另一个提供实例网络的项目（neutron），以及与不同存储类型交互的项目（Swift和Cinder）。
- en: You can find a full list of the current OpenStack  projects in this link
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接中找到当前OpenStack项目的完整列表
- en: '[https://www.OpenStack.org/software/project-navigator/](https://www.openstack.org/software/project-navigator/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.OpenStack.org/software/project-navigator/](https://www.openstack.org/software/project-navigator/)'
- en: Also OpenStack provide unified API access to the application developer and system
    administrators  to orchestrate the resource creation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OpenStack为应用程序开发人员和系统管理员提供统一的API访问，以编排资源创建。
- en: In this chapter, we will explore the new and open world of OpenStack, and will
    learn how we can leverage Python and Ansible to interact with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索OpenStack的新开放世界，并学习如何利用Python和Ansible与其交互。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding RESTful web services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解RESTful web服务
- en: Setting up the environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Sending requests to OpenStack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向OpenStack发送请求
- en: Creating workloads from Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python创建工作负载
- en: Managing OpenStack instances using Ansible
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible管理OpenStack实例
- en: Understanding RESTful web services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解RESTful web服务
- en: '**Representational State Transfer** (**REST**) depends on HTTP protocol to
    transfer messages between the client and server. HTTP was originally designed
    to deliver HTML pages from web servers (servers) to browsers (clients), when requested.
    The pages represent a set of resources that the user wants to access, and are
    requested by **Universal Resource Identifiers** (**URIs**).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**表述状态转移**（**REST**）依赖于HTTP协议在客户端和服务器之间传输消息。HTTP最初设计用于在请求时从Web服务器（服务器）向浏览器（客户端）传递HTML页面。页面代表用户想要访问的一组资源，并由**统一资源标识符**（**URI**）请求。'
- en: 'An HTTP request typically contains a method that indicates the type of operation
    that needs to be executed on the resource. For example, when visiting a website
    from your browser, you can see (in the following screenshot) that the method is
    `GET`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求通常包含一个方法，该方法指示需要在资源上执行的操作类型。例如，当从浏览器访问网站时，您可以看到（在下面的屏幕截图中）方法是`GET`：
- en: '![](../images/00195.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00195.jpeg)'
- en: 'The following are the most common HTTP methods, and their usage:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的HTTP方法及其用法：
- en: '| HTTP Method | Action |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 操作 |'
- en: '| `GET` | The client will ask the server to retrieve the resource. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 客户端将要求服务器检索资源。 |'
- en: '| `POST` | The client will instruct the server to create a new resource. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 客户端将指示服务器创建新资源。 |'
- en: '| `PUT` | The client will ask the server to modify/update the resource. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 客户端将要求服务器修改/更新资源。 |'
- en: '| `DELETE` | The client will ask the server to delete the resource. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 客户端将要求服务器删除资源。 |'
- en: The application developer can expose certain resources of his application, to
    be consumed by the clients in the outside world. The transport protocol that carries
    the requests from the clients to servers and returns the responses back is HTTP.
    It is responsible for securing the communication and  encoding the packet with
    the appropriate data encoding mechanism that is accepted by the server, and it
    is a stateless communication across both of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发人员可以公开其应用程序的某些资源，以供外部世界的客户端使用。携带请求从客户端到服务器并返回响应的传输协议是HTTP。它负责保护通信并使用服务器接受的适当数据编码机制对数据包进行编码，并且在两者之间进行无状态通信。
- en: On the other hand, the packet payloads are usually encoded in either XML or
    JSON, to represent the structure of the request handled by the server and how
    the client prefers the response back.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，数据包有效载荷通常以XML或JSON编码，以表示服务器处理的请求结构以及客户端偏好的响应方式。
- en: There are many companies around the world that provide public access to their
    data for developers, in real time. For example, the Twitter API ([https://developer.twitter.com/](https://developer.twitter.com/))
    provides a data fetch in real time, allowing other developers to consume the data
    in third-party applications like ads, searches, and marketing. The same goes for
    big names like Google ([https://developers.google.com/apis-explorer/#p/discovery/v1/](https://developers.google.com/apis-explorer/#p/discovery/v1/)),
    LinkedIn ([https://developer.linkedin.com/](https://developer.linkedin.com/)),
    and Facebook ([https://developers.facebook.com/](https://developers.facebook.com/)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地有许多公司为开发人员提供其数据的公共访问权限，实时提供。例如，Twitter API（[https://developer.twitter.com/](https://developer.twitter.com/)）提供实时数据获取，允许其他开发人员在第三方应用程序中使用数据，如广告、搜索和营销。谷歌（[https://developers.google.com/apis-explorer/#p/discovery/v1/](https://developers.google.com/apis-explorer/#p/discovery/v1/)）、LinkedIn（[https://developer.linkedin.com/](https://developer.linkedin.com/)）和Facebook（[https://developers.facebook.com/](https://developers.facebook.com/)）等大公司也是如此。
- en: Public access to APIs is usually limited to a specific number of requests, either
    per hour of per day, for a single application, in order to not overwhelm the public
    resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对API的公共访问通常限制为特定数量的请求，无论是每小时还是每天，对于单个应用程序，以免过度使用公共资源。
- en: Python provides a large set of tools and libraries to consume the APIs, encode
    the messages, and parse the responses. For example, Python has a `requests` package
    that can format and send HTTP requests to external resources. Also, it has tools
    to parse the responses in a JSON format and convert them to the standard dictionary
    in Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了大量的工具和库来消耗API、编码消息和解析响应。例如，Python有一个`requests`包，可以格式化并发送HTTP请求到外部资源。它还有工具来解析JSON格式的响应并将其转换为Python中的标准字典。
- en: Python also has many frameworks that can expose your resources to the external
    world. `Django` and `Flask` are among the best, serving as full stack frameworks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有许多框架可以将您的资源暴露给外部世界。`Django`和`Flask`是最好的之一，可以作为全栈框架。
- en: Setting up the environment
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: OpenStack is a free and open source project, used with **Infrastructure as a
    Service** (**IaaS**), that can control your hardware resources in terms of CPU,
    memory, and storage and provide an open framework for many vendors to build and
    integrate plugins.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack是一个免费的开源项目，用于**基础设施即服务**（**IaaS**），可以控制CPU、内存和存储等硬件资源，并为许多供应商构建和集成插件提供一个开放的框架。
- en: To set up our lab, I will use the latest `OpenStack-rdo` release (at the time
    of writing), Queens, and install it onto CentOS 7.4.1708\. The installation steps
    are pretty straightforward, and can be found at [https://www.rdoproject.org/install/packstack/](https://www.rdoproject.org/install/packstack/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的实验室，我将使用最新的`OpenStack-rdo`版本（在撰写时），即Queens，并将其安装到CentOS 7.4.1708上。安装步骤非常简单，可以在[https://www.rdoproject.org/install/packstack/](https://www.rdoproject.org/install/packstack/)找到。
- en: Our environment consists of a machine that has 100 GB storage, 12 vCPU, and
    32 GB of RAM, This server will contains the OpenStack controller, the compute
    and neutron roles on the same server. The OpenStack server is connected to the
    same switch that has our automation server and in same subnet. Note that this
    is not always the case in a production environment, but you need to make sure
    that your server that runs Python code can reach the OpenStack.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境包括一台具有100GB存储、12个vCPU和32GB RAM的机器。该服务器将包含OpenStack控制器、计算和neutron角色在同一台服务器上。OpenStack服务器连接到具有我们自动化服务器的相同交换机和相同子网。请注意，这在生产环境中并不总是这样，但您需要确保运行Python代码的服务器可以访问OpenStack。
- en: 'The lab topology is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室拓扑如下：
- en: '![](../images/00196.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00196.jpeg)'
- en: Installing rdo-OpenStack package
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装rdo-OpenStack软件包
- en: 'The steps for installing rdo-OpenStack on RHEL 7.4 and CentOS are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在RHEL 7.4和CentOS上安装rdo-OpenStack的步骤如下：
- en: On RHEL 7.4
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RHEL 7.4上
- en: 'First, make sure that your system is up to date, and then install the `rdo-release.rpm`
    from the website to get the latest version. Finally, install the `OpenStack-packstack`
    package that will automate the OpenStack installation, as shown in the following
    snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保您的系统是最新的，然后从网站安装`rdo-release.rpm`以获取最新版本。最后，安装`OpenStack-packstack`软件包，该软件包将自动化OpenStack安装，如下段所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On CentOS 7.4
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CentOS 7.4上
- en: 'First, make sure that your system is up to date, and then install the rdoproject
    to get the latest version. Finally, install the `centos-release-OpenStack-queens`
    package that will automate the OpenStack installation, as shown in the following
    snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保您的系统是最新的，然后安装rdoproject以获取最新版本。最后，安装`centos-release-OpenStack-queens`软件包，该软件包将自动化OpenStack安装，如下段所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Generating answer file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成答案文件
- en: 'Now, you will need to generate the answer file that contains the deployment
    parameters. Most of these parameters are fine on their defaults, but we will change
    a few things:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要生成包含部署参数的答案文件。这些参数中的大多数都是默认值，但我们将更改一些内容：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Editing answer file
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑答案文件
- en: 'Edit the `EnterpriseAutomtion` file with your favorite editor, and change the
    following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器编辑`EnterpriseAutomtion`文件，并更改以下内容：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CELIOMETER` and `AODH` are an optional projects within OpenStack ecosystem
    and could be ignored in lab environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`CELIOMETER`和`AODH`是OpenStack生态系统中的可选项目，可以在实验室环境中忽略。'
- en: Also we setup a `KEYSTONE` password that used to generate temp token for accessing
    the resource using API and used also to access the OpenStack GUI
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了一个用于生成临时令牌以访问API资源并访问OpenStack GUI的`KEYSTONE`密码
- en: Run the packstack
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行packstack
- en: 'Save the file and run the installation through the `packstack`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并通过`packstack`运行安装：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command will download the packages from the Queens repository and install
    the OpenStack services, then start them. After the installation has completed
    successfully, the following message will be printed on the console:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从Queens存储库下载软件包并安装OpenStack服务，然后启动它们。安装成功完成后，将在控制台上打印以下消息：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Access the OpenStack GUI
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问OpenStack GUI
- en: 'You can now access the OpenStack GUI using `http://<server_ip_address>/dashboard`.
    The credentials will be admin and access123 (depending on what you wrote in `CONFIG_KEYSTONE_ADMIN_PW`
    in the previous steps):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用`http://<server_ip_address>/dashboard`访问OpenStack GUI。凭证将是admin和access123（取决于您在之前步骤中在`CONFIG_KEYSTONE_ADMIN_PW`中写入了什么）：
- en: '![](../images/00197.gif)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00197.gif)'
- en: Our cloud is now up and running, ready to receive requests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的云现在已经启动运行，准备接收请求。
- en: Sending requests to the OpenStack keystone
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向OpenStack keystone发送请求
- en: OpenStack contains collections of services that work together to manage the
    virtual machine **create, read, update, and delete** (**CRUD**) operations. Each
    service can expose its resources to be consumed by external requests. For example,
    the `nova` service is responsible for spawning the virtual machine and acts as
    a hypervisor layer (though it's not a hypervisor itself, it can control other
    hypervisors, like KVM and vSphere). Another service is `glance`, responsible for
    hosting the instance images in either an ISO or qcow2 format. The `neutron` service
    is responsible for providing networking services to spawned instances and ensures
    that the instances located on different tenants (projects) are isolated from each
    other, while instances on the same tenants can reach each others through an overlays
    network (VxLAN or GRE).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack包含一系列服务，这些服务共同工作以管理虚拟机的创建、读取、更新和删除（CRUD）操作。每个服务都可以将其资源暴露给外部请求进行消费。例如，`nova`服务负责生成虚拟机并充当一个hypervisor层（虽然它本身不是一个hypervisor，但可以控制其他hypervisors，如KVM和vSphere）。另一个服务是`glance`，负责以ISO或qcow2格式托管实例镜像。`neutron`服务负责为生成的实例提供网络服务，并确保位于不同租户（项目）上的实例相互隔离，而位于相同租户上的实例可以通过覆盖网络（VxLAN或GRE）相互访问。
- en: In order to access the APIs of each of the preceding services, you will need
    to have an authenticated token that is used for a specific period of time. That's
    the role of the `keystone`, which provides an identity service and manages the
    roles and permissions of each user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问上述每个服务的API，您需要具有用于特定时间段的经过身份验证的令牌。这就是`keystone`的作用，它提供身份服务并管理每个用户的角色和权限。
- en: 'First, we need to install the Python bindings on our automation server. These
    bindings contain python code used to access each service and authenticate the
    request with the token generated from KEYSTONE. Also bindings contains supported
    operation for each project (like create/delete/update/list):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在自动化服务器上安装Python绑定。这些绑定包含用于访问每个服务并使用从KEYSTONE生成的令牌进行身份验证的Python代码。此外，绑定包含每个项目的支持操作（如创建/删除/更新/列出）：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the Python client name is `python-<service_name>client`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python客户端名称为`python-<service_name>client`
- en: 'You can download into your site''s global packages or the Python `virtualenv`
    environment. Then, you will need OpenStack admin privileges, which can be found
    in the following path, inside the OpenStack server:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其下载到站点的全局包或Python `virtualenv`环境中。然后，您将需要OpenStack管理员权限，这些权限可以在OpenStack服务器内的以下路径中找到：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we will use the keystone version 3 in both the `OS_AUTH_URL` and
    `OS_IDENTITY_API_VERSION` parameters when we communicate with the OpenStack keystone
    service. Most of the Python clients are compatible with older versions, but require
    you to change your script a little bit. Other parameters are also required during
    token generation, so make sure that you have access to the `keystonerc_admin`
    file. Also the access credentials can be found in `OS_USERNAME` and `OS_PASSWORD`
    in the same file
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们与OpenStack keystone服务通信时，我们将在`OS_AUTH_URL`和`OS_IDENTITY_API_VERSION`参数中使用keystone版本3。大多数Python客户端与旧版本兼容，但需要您稍微更改脚本。在令牌生成期间还需要其他参数，因此请确保您可以访问`keystonerc_admin`文件。还可以在同一文件中的`OS_USERNAME`和`OS_PASSWORD`中找到访问凭证。
- en: 'our Python script will be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Python脚本将如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, the following applies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，以下内容适用：
- en: '`python-keystoneclient` made a request to the keystone API using the `v3` class
    (which reflects the keystone API version). This class is available inside of `keystoneayth1.identity`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-keystoneclient`使用`v3`类（反映了keystone API版本）向keystone API发出请求。此类可在`keystoneayth1.identity`内使用。'
- en: Then, we supplied the full credentials taken from the `keystonerc_admin` file
    to the `auth` variable.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将从`keystonerc_admin`文件中获取的完整凭证提供给`auth`变量。
- en: Finally, we established the session, using the session manager inside of the
    keystone client. Notice that we set `verify` to `False`, since we don't use the
    certificate to generate the token. Otherwise, you can supply the certificate path.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们建立了会话，使用keystone客户端内的会话管理器。请注意，我们将`verify`设置为`False`，因为我们不使用证书来生成令牌。否则，您可以提供证书路径。
- en: The token generated can be used with any service, and it will last for one hour,
    then expire. Also, if you change the user role, the token will expire immediately,
    without waiting for an hour.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的令牌可以用于任何服务，并将持续一个小时，然后过期。此外，如果更改用户角色，令牌将立即过期，而不必等待一个小时。
- en: OpenStack administrators can configure the `admin_token` field inside the `/etc/keystone/keystone.conf`
    file, which never expires. However, this is not recommended in a production environment,
    for security reasons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack管理员可以在`/etc/keystone/keystone.conf`文件中配置`admin_token`字段，该字段永不过期。但出于安全原因，这在生产环境中不被推荐。
- en: 'If you don''t want to store the credentials inside the Python script, you can
    store them in the `ini` file and load them using the `configparser` module. First,
    create a `creds.ini` file in the automation server, and give it appropriate Linux
    permissions, so it can only be opened with your own account:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想将凭证存储在Python脚本中，可以将它们存储在`ini`文件中，并使用`configparser`模块加载它们。首先，在自动化服务器上创建一个`creds.ini`文件，并赋予适当的Linux权限，以便只能使用您自己的帐户打开它。
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The modified script is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的脚本如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `configparser` module will parse the `creds.ini` file and look at the `os_creds`
    section inside the file. Then, it will get the value in front of each parameter
    by using the `get()` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`configparser`模块将解析`creds.ini`文件并查看文件内部的`os_creds`部分。然后，它将使用`get()`方法获取每个参数前面的值。'
- en: The `config.get()` method will accept two arguments. The first argument is the
    section name inside the `.ini` file, and the second is the parameter name. The
    method will return the value associated with the parameter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.get()`方法将接受两个参数。第一个参数是`.ini`文件内的部分名称，第二个是参数名称。该方法将返回与参数关联的值。'
- en: This method should provide additional security to your cloud credentials. Another
    valid method to secure your file is to load the `keystonerc_admin` file into the
    environmental variables using the Linux `source` command, and read the credentials
    using the `environ()` method inside of the `os` module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法应该为您的云凭据提供额外的安全性。保护文件的另一种有效方法是使用Linux的`source`命令将`keystonerc_admin`文件加载到环境变量中，并使用`os`模块内的`environ()`方法读取凭据。
- en: Creating instances from Python
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python创建实例
- en: To get instance up and running, OpenStack instances require three components.
    The boot image, which is provided by `glance`, the network ports, which provided
    by `neutron`, and finally, the compute flavor that defines the number of  CPUs,
    amount of RAM that will be allocated to the instance and disk size. The flavor
    is provided by `nova` project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使实例运行起来，OpenStack实例需要三个组件。由`glance`提供的引导镜像，由`neutron`提供的网络端口，最后是由`nova`项目提供的定义分配给实例的CPU数量、RAM数量和磁盘大小的计算flavor。
- en: Creating the image
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像
- en: 'We will start by downloading a `cirros` image to the automation server. `cirros`
    is a lightweight, Linux-based image, used by many OpenStack developers and testers
    around the world to validate the functionality of OpenStack services:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先下载一个`cirros`图像到自动化服务器。`cirros`是一个轻量级的基于Linux的图像，被许多OpenStack开发人员和测试人员用来验证OpenStack服务的功能：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, we will upload the image to the OpenStack image repository using `glanceclient`.
    Notice that we need to have the keystone token and the session parameter first,
    in order to communicate with `glance`, otherwise, `glance` won't accept any API
    requests from us.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`glanceclient`将图像上传到OpenStack图像存储库。请注意，我们需要首先具有keystone令牌和会话参数，以便与`glance`通信，否则，`glance`将不接受我们的任何API请求。
- en: 'The script will be as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将如下所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, the following applies:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，适用以下内容：
- en: Since we are communicating with `glance` (the image hosting project), we will
    import the `client` from the installed `glanceclient` module.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们正在与`glance`（图像托管项目）通信，因此我们将从安装的`glanceclient`模块导入`client`。
- en: The same keystone scripts  used to generate the `sess` that holds the keystone
    token.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的keystone脚本生成包含keystone令牌的`sess`。
- en: We created the glance parameter that initializes the client manager with `glance`
    and provide the version (`version 2` ) and the generated token.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了glance参数，该参数使用`glance`初始化客户端管理器，并提供版本（`版本2`）和生成的令牌。
- en: You can see all supported API versions by accessing the OpenStack GUI | API
    Access tab as in below screenshot. notice also the supported version for each
    project.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过访问OpenStack GUI | API Access选项卡来查看所有支持的API版本，如下面的屏幕截图所示。还要注意每个项目的支持版本。
- en: '![](../images/00198.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00198.jpeg)'
- en: The glance client manager is designed to operate on the glance OpenStack service.
    the manager is instructed to create an image with a name `CirrosImage` and disk
    type is in `qcow2` format.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: glance客户端管理器旨在在glance OpenStack服务上运行。指示管理器使用名称`CirrosImage`创建一个磁盘类型为`qcow2`格式的图像。
- en: Finally, we will open the downloaded image as a binary, using the `'rb'` flag,
    and will upload it to the created image. Now, `glance` will import the image to
    the newly created file in the image repository.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将以二进制形式打开下载的图像，使用'rb'标志，并将其上传到创建的图像中。现在，`glance`将图像导入到图像存储库中新创建的文件中。
- en: 'You can validate that the operation was successful in two ways:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式验证操作是否成功：
- en: If no error is printed back after executing `glance.images.upload()`, it means
    that the request is correctly formatted and has been accepted by the OpenStack
    `glance` API.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`glance.images.upload()`后如果没有打印出错误，这意味着请求格式正确，并已被OpenStack `glance` API接受。
- en: 'Run the `glance.images.list()` . The returned output will be a generate which
    you can iterate over it to see more details about the uploaded image:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`glance.images.list()`。返回的输出将是一个生成器，您可以遍历它以查看有关上传图像的更多详细信息：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Assigning a flavor
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配flavor
- en: Flavors are used to determine the CPU, memory, and storage size of the instance.
    OpenStack comes with a predefined set of flavors, with different sizes that range
    from tiny to extra large. For the `cirros` image, we will use the small flavor,
    which has 2 GB RAM, 1 vCPU, and 20 GB storage. Access to flavors doesn't have
    a standalone API client; rather, it's a part of the `nova` client.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Flavors用于确定实例的CPU、内存和存储大小。OpenStack带有一组预定义的flavors，具有从微小到超大的不同大小。对于`cirros`图像，我们将使用小型flavor，它具有2GB
    RAM，1个vCPU和20GB存储。访问flavors没有独立的API客户端；而是作为`nova`客户端的一部分。
- en: 'You can see all available built-in flavors at OpenStack GUI | Admin | Flavors:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在OpenStack GUI | Admin | Flavors中查看所有可用的内置flavors：
- en: '![](../images/00199.gif)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00199.gif)'
- en: 'The script will be as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将如下所示：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding script, the following applies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，适用以下内容：
- en: Since we will communicate with `nova`  (the compute service) to retrieve the
    flavor, we will import the `novaclient` module as `nclient`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将与`nova`（计算服务）通信以检索flavor，因此我们将导入`novaclient`模块作为`nclient`。
- en: The same keystone script is used to generate the `sess` that holds the keystone
    token.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的keystone脚本生成包含keystone令牌的`sess`。
- en: We created the `nova` parameter that initialized the client manager with the
    `nova` and provide the version to the client (version 2.1) and the generated token.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`nova`参数，用它来初始化具有`nova`的客户端管理器，并为客户端提供版本（版本2.1）和生成的令牌。
- en: Finally, we used the `nova.flavors.find()` method to locate the desired flavor,
    which is `m1.small`. The name has to match the name in OpenStack exactly, otherwise
    it will throw an error.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`nova.flavors.find()`方法来定位所需的规格，即`m1.small`。名称必须与OpenStack中的名称完全匹配，否则将抛出错误。
- en: Creating the network and subnet
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网络和子网
- en: 'Creating the network for the instance requires two things: the network itself,
    and associating subnet with it. First, we need to supply the network properties,
    such as the ML2 driver (Flat, VLAN, VxLAN, and so on), the segmentation ID that
    differentiates between the networks running on the same interface, the MTU, and
    the physical interface, if the instance traffic needs to traverse external networks.
    Second, we need to provide the subnet properties, such as the network CIDR, the
    gateway IP, The IPAM parameters (DHCP/DNS server if defined), and which network
    ID is associated with the subnet as in below screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为实例创建网络需要两件事：网络本身和将子网与之关联。首先，我们需要提供网络属性，例如ML2驱动程序（Flat、VLAN、VxLAN等），区分在同一接口上运行的网络之间的分段ID，MTU和物理接口，如果实例流量需要穿越外部网络。其次，我们需要提供子网属性，例如网络CIDR、网关IP、IPAM参数（如果定义了DHCP/DNS服务器）以及与子网关联的网络ID，如下面的屏幕截图所示：
- en: '![](../images/00200.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00200.jpeg)'
- en: Now we will develop a Python script to interact with the neutron project and
    create a network with a subnet
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开发一个Python脚本来与neutron项目进行交互，并创建一个带有子网的网络
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding script, the following applies:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，以下内容适用：
- en: Since we will communicate with `neutron` (the network service) to create both
    the network and associated subnet, we will import the `neutronclient` module as
    the `neuclient`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将与`neutron`（网络服务）通信来创建网络和关联子网，我们将导入`neutronclient`模块作为`neuclient`。
- en: The same keystone script is used to generate the `sess` that holds the keystone
    token used later to access neutron resource.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的keystone脚本用于生成`sess`，该`sess`保存后来用于访问neutron资源的keystone令牌。
- en: We will create the `neutron` parameter that initializes the client manager with
    neutron and provide the version to it (version 2) and the generated token.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建`neutron`参数，用它来初始化具有neutron的客户端管理器，并为其提供版本（版本2）和生成的令牌。
- en: Then, we created two Python dictionaries, `body_network` and `body_subnet` which
    hold the message bodies for the network and subnet respectively. Note that the
    dictionary keys are static and can't be changed, while the values could be changed
    and usually provided from external portal system or Excel sheet, depending on
    your deployment. Also, I commented on the parts that are not necessary during
    network creation, such as `provider:physical_network` and `provider:network_type`,
    since our `cirros` image won't communicate with the provider network (networks
    defined outside OpenStack domains) but provided here for reference.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个Python字典，`body_network`和`body_subnet`，它们分别保存了网络和子网的消息主体。请注意，字典键是静态的，不能更改，而值可以更改，并且通常来自外部门户系统或Excel表格，具体取决于您的部署。此外，我对在网络创建过程中不必要的部分进行了评论，例如`provider:physical_network`和`provider:network_type`，因为我们的`cirros`镜像不会与提供者网络（在OpenStack域之外定义的网络）通信，但这里提供了参考。
- en: Finally the subnet and the network associated together by getting first the
    `network_id` through the `list_networks()` method and access the id and providing
    it as a value to `network_id` key inside the `body_subnet` variable.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过`list_networks()`方法获取`network_id`，并将其作为值提供给`body_subnet`变量中的`network_id`键，将子网和网络关联在一起。
- en: Launching the instance
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动实例
- en: 'The final part is to glue everything together. We have the boot image, the
    instance flavor, and the network that connects the machine with the other instances.
    We''re ready to launch the instance using the `nova` client (remember that `nova`
    is responsible for the virtual machine life cycle and the CRUD operations on the
    VM):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是将所有内容粘合在一起。我们有引导镜像、实例规格和连接机器与其他实例的网络。我们准备使用`nova`客户端启动实例（记住`nova`负责虚拟机的生命周期和VM上的CRUD操作）：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding script, we used the `nova.servers.create()` method and passed
    all of the information required to spawn the instance(instance name, operating
    system, flavor and networks). Additionally, we implemented a polling mechanism
    that polls the nova service for the server current status. If the server is still
    in `BUILD` phase,  then the script will sleeps for five seconds then poll again.
    The loop will exit when the server status is changes to either `ACTIVE` or `FAILURE`
    and will prints the server status at the end.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，我们使用了`nova.servers.create()`方法，并传递了生成实例所需的所有信息（实例名称、操作系统、规格和网络）。此外，我们实现了一个轮询机制，用于轮询nova服务的服务器当前状态。如果服务器仍处于`BUILD`阶段，则脚本将休眠五秒，然后再次轮询。当服务器状态更改为`ACTIVE`或`FAILURE`时，循环将退出，并在最后打印服务器状态。
- en: 'The script''s output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出如下：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, you can check the instance from the OpenStack GUI | Compute | Instances:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以从OpenStack GUI | 计算 | 实例中检查实例：
- en: '![](../images/00201.gif)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00201.gif)'
- en: Managing OpenStack instances from Ansible
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Ansible管理OpenStack实例
- en: Ansible provides modules that can manage the OpenStack instance life cycle,
    just like we did using APIs. You can find the full list of supported modules at
    [http://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#OpenStack](http://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了可以管理OpenStack实例生命周期的模块，就像我们使用API一样。您可以在[http://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#OpenStack](http://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack)找到支持的模块的完整列表。
- en: All OpenStack modules rely on the Python library called `shade` ([https://pypi.python.org/pypi/shade](https://pypi.python.org/pypi/shade)),
    which provides a wrapper around OpenStack clients.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有OpenStack模块都依赖于名为`shade`的Python库（[https://pypi.python.org/pypi/shade](https://pypi.python.org/pypi/shade)），该库提供了对OpenStack客户端的包装。
- en: Once you have installed `shade` on the automation server, you will have access
    to the `os-*` modules that can manipulate the OpenStack configuration, such as
    `os_image` (to handle OpenStack images), `os_network` (to create the network),
    `os_subnet` (to create and associate the subnet with the created network), `os_nova_flavor` (to
    create flavors, given the RAM, CPU, and disk), and finally, the `os_server` module
    (to bring up the OpenStack instance).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在自动化服务器上安装了`shade`，您将可以访问`os-*`模块，这些模块可以操作OpenStack配置，比如`os_image`（处理OpenStack镜像），`os_network`（创建网络），`os_subnet`（创建并关联子网到创建的网络），`os_nova_flavor`（根据RAM、CPU和磁盘创建flavors），最后是`os_server`模块（启动OpenStack实例）。
- en: Shade and Ansible installation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Shade和Ansible
- en: 'In the automation server, use the Python `pip` to download and install `shade`,
    with all dependencies:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化服务器上，使用Python的`pip`来下载和安装`shade`，以及所有依赖项：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After installation, you will have `shade` under the normal `site-packages` in
    Python, but we will use Ansible instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您将在Python的正常`site-packages`下拥有`shade`，但我们将使用Ansible。
- en: 'Also, you will need to install Ansible in the automation server, if you haven''t
    done it in previous chapters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您之前没有在自动化服务器上安装Ansible，您将需要安装Ansible：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify that Ansible has installed successfully by querying the Ansible version
    from the command line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从命令行查询Ansible版本来验证Ansible是否已成功安装：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Building the Ansible playbook
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Ansible playbook
- en: As we saw in [Chapter 13](part0168.html#506UG0-9cfcdc5beecd470bbeda046372f0337f),
    *Ansible for Administration*, depends on a YAML file to contain everything you
    will need to execute against hosts in the inventory. In this case, we will instruct
    the playbook to establish a local connection to the `shade` library on the automation
    server, and provide the playbook with the `keystonerc_admin` credentials that
    help `shade` to send requests to our OpenStack server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第13章](part0168.html#506UG0-9cfcdc5beecd470bbeda046372f0337f)中所看到的，*用于管理的Ansible*，依赖于一个YAML文件，其中包含了您需要针对清单中的主机执行的一切。在这种情况下，我们将指示playbook在自动化服务器上建立与`shade`库的本地连接，并提供`keystonerc_admin`凭据，以帮助`shade`向我们的OpenStack服务器发送请求。
- en: 'The playbook script is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: playbook脚本如下：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the playbook, we make use of the `os_*` modules to upload the image to the
    OpenStack `glance` server, create a new flavor (and not using this built-in),
    and create the network with the subnet associated; then, we glue everything together
    in `os_server`, which communicates with the `nova` server to spawn the machine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbook中，我们使用`os_*`模块将镜像上传到OpenStack的`glance`服务器，创建一个新的flavor（而不是使用内置的flavor），并创建与子网关联的网络；然后，我们在`os_server`中将所有内容粘合在一起，该模块与`nova`服务器通信以生成机器。
- en: Please note that the hosts will be the localhost (or the machine name that hosts
    the `shade` library), while we added the OpenStack keystone credentials in the
    environmental variables.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主机将是本地主机（或托管`shade`库的机器名称），同时我们在环境变量中添加了OpenStack keystone凭据。
- en: Running the playbook
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行playbook
- en: 'Upload the playbook to the automation server and execute the following command
    to run it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将playbook上传到自动化服务器并执行以下命令来运行它：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The playbook''s output will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: playbook的输出将如下所示：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can access the OpenStack GUI to validate that the instance was created
    from the Ansible playbook:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问OpenStack GUI来验证实例是否是从Ansible playbook创建的：
- en: '![](../images/00202.gif)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00202.gif)'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Nowadays, the IT industry is trying to avoid vendor lock-in by moving to the
    open source world whenever possible. OpenStack provides a window into this world;
    many large organizations and telecom operators are considering moving their workloads
    to OpenStack, to build their private clouds in its data center. They can then
    build their own tools to interact with the open source APIs provided by OpenStack.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，IT行业正在尽可能地避免供应商锁定，转向开源世界。OpenStack为我们提供了窥视这个世界的窗口；许多大型组织和电信运营商正在考虑将其工作负载迁移到OpenStack，以在其数据中心构建私有云。然后，他们可以构建自己的工具来与OpenStack提供的开源API进行交互。
- en: In the next chapter, we will explore another (paid) public Amazon cloud, and
    will learn how we can leverage Python to automate instance creation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索另一个（付费的）公共亚马逊云，并学习如何利用Python来自动化实例创建。
