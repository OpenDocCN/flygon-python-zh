- en: Reducing User Error with Validation and Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过验证和自动化减少用户错误
- en: 'Our form works, and both the director and data entry personnel are thrilled
    with the form design, but we''re not ready for production yet! Our form doesn''t
    yet perform the promised task of preventing or discouraging user errors. Number
    boxes still allow letters, combo boxes aren''t limited to the choices given, and
    dates have to be filled in by hand. In this chapter, we''re going to cover the
    following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单有效，主管和数据输入人员都对表单设计感到满意，但我们还没有准备好投入生产！我们的表单还没有履行承诺的任务，即防止或阻止用户错误。数字框仍然允许字母，组合框不限于给定的选择，日期必须手动填写。在本章中，我们将涵盖以下主题：
- en: Deciding on the best approach for validating user input
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定验证用户输入的最佳方法
- en: Learning how to use Tkinter's validation system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Tkinter的验证系统
- en: Creating custom widgets for our form that validate entered data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的表单创建自定义小部件，验证输入的数据
- en: Automating default values where appropriate in our form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的表单中适当的情况下自动化默认值
- en: Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Validating user input
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: At first glance, Tkinter's selection of the input widgets seems a little disappointing.
    It doesn't give us a true number entry that only allows digits, nor a true drop-down
    selector that only allows items from the drop-down list to be selected. We have
    no date inputs, email inputs, or other specially-formatted input widgets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，Tkinter的输入小部件选择似乎有点令人失望。它没有给我们一个真正的数字输入，只允许数字，也没有一个真正的下拉选择器，只允许从下拉列表中选择项目。我们没有日期输入、电子邮件输入或其他特殊格式的输入小部件。
- en: But these weaknesses can become strengths. Because these widgets assume nothing,
    we can make them behave in a way that's appropriate to our specific needs, rather
    than some generic way that may or may not work optimally. For example, letters
    may seem inappropriate in a number entry, but are they? In Python, strings such
    as `NaN` and `Infinity` are valid float values; having a box that could increment
    numerals but also handle those string values may be very useful in some applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些弱点可以成为优势。因为这些小部件什么都不假设，我们可以使它们以适合我们特定需求的方式行为，而不是以可能或可能不会最佳地工作的通用方式。例如，字母在数字输入中可能看起来不合适，但它们呢？在Python中，诸如`NaN`和`Infinity`之类的字符串是有效的浮点值；拥有一个既可以增加数字又可以处理这些字符串值的框在某些应用中可能非常有用。
- en: We're going to learn how to shape our widgets to our needs, but before we learn
    how to control this behavior, let's think about what we want to do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何根据需要调整我们的小部件，但在学习如何控制这种行为之前，让我们考虑一下我们想要做什么。
- en: Strategies to prevent data errors
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止数据错误的策略
- en: 'There is no universal answer to how a widget should react to a user trying
    to enter bad data. The validation logic found in various graphics toolkits can
    differ greatly; when bad data is entered, an input widget might validate the user
    input as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小部件如何响应用户尝试输入错误数据，没有通用答案。各种图形工具包中的验证逻辑可能大不相同；当输入错误数据时，输入小部件可能会验证用户输入如下：
- en: Prevent the invalid keystrokes from registering at all
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止无效的按键注册
- en: Accept the input, but return an error or list of errors when the form is submitted
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受输入，但在提交表单时返回错误或错误列表
- en: Show an error when the user leaves the entry field, perhaps disabling form submission
    until it's corrected
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户离开输入字段时显示错误，可能会禁用表单提交，直到它被纠正
- en: Lock the user in the entry field until valid data is entered
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户锁定在输入字段中，直到输入有效数据
- en: Silently correct the bad data using a best-guess algorithm
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最佳猜测算法悄悄地纠正错误的数据
- en: The correct behavior in a data entry form (which is filled out hundreds of times
    a day by users who may not even be looking at it) may be different from an instrument
    control panel (where values absolutely must be correct to avoid a disaster) or
    an online user registration form (which is filled out once by a user who has never
    seen it before). We need to ask ourselves and our users about which behavior will
    best minimize errors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据输入表单中的正确行为（每天由甚至可能根本不看它的用户填写数百次）可能与仪器控制面板（值绝对必须正确以避免灾难）或在线用户注册表单（用户以前从未见过的情况下填写一次）不同。我们需要向自己和用户询问哪种行为将最大程度地减少错误。
- en: 'After discussing this with your users on the data entry staff, you come to
    the following set of guidelines:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据输入人员讨论后，您得出以下一组指南：
- en: Whenever possible, meaningless keystrokes should be ignored (for example, letters
    in a number field)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能忽略无意义的按键（例如数字字段中的字母）
- en: An empty field should register an error (all fields are required), with the
    exception of `Notes`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字段应该注册一个错误（所有字段都是必填的），但`Notes`除外
- en: Fields containing bad data should be marked in some visible way with an error
    describing the problem
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含错误数据的字段应以某种可见的方式标记，并描述问题
- en: Form submission should be disabled if there are fields with errors
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在错误字段，则应禁用表单提交
- en: 'Let''s add the following requirements to our specification before moving on.
    Under the `Required Features` section, update the hard requirements as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在继续之前，将以下要求添加到我们的规范中。在“必要功能”部分，更新硬性要求如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, how do we implement this?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现这一点呢？
- en: Validation in Tkinter
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter中的验证
- en: 'Tkinter''s validation system is one of those parts of the toolkit that is less
    than intuitive. It relies on the following three configuration options that we
    can pass into any input widget:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的验证系统是工具包中不太直观的部分之一。它依赖于以下三个配置选项，我们可以将其传递到任何输入小部件中：
- en: '`validate`: This option determines which type of event will trigger the validation
    callback'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate`：此选项确定哪种类型的事件将触发验证回调'
- en: '`validatecommand`: This option takes the command that will determine if the
    data is valid'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validatecommand`：此选项接受将确定数据是否有效的命令'
- en: '`invalidcommand`: This option takes a command that will run if `validatecommand`
    returns `False`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidcommand`：此选项接受一个命令，如果`validatecommand`返回`False`，则运行该命令'
- en: This seems pretty straightforward, but there are some unexpected curves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很简单，但有一些意想不到的曲线。
- en: 'The values we can pass to `validate` are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递给“validate”的值如下：
- en: '| **Validates string** | **Triggers when** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **验证字符串** | **触发时** |'
- en: '| `none` | It is none that turns off validation |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 它是关闭验证的无'
- en: '| `focusin` | The user enters or selects the widget |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `focusin` | 用户输入或选择小部件 |'
- en: '| `unfocus` | The user leaves the widget |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|“unfocus”|用户离开小部件'
- en: '| `focus` | Either `focusin` or `focusout` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | `focusin`或`focusout` |'
- en: '| `key` | The user enters text in the widget |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|“key”|用户在小部件中输入文本'
- en: '| `all` | `focusin`, `focusout`, and `key` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|“all”| `focusin`，`focusout`和`key` |'
- en: The `validatecommand` argument is where things get tricky. You might think this
    takes the name of a Python function or method, but that's not quite it. Instead,
    we need to give it a tuple containing a reference to a Tcl/`Tk` function, and
    optionally some **substitution codes** that specify information about the triggering
    event that we want to pass into the function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: “validatecommand”参数是事情变得棘手的地方。您可能会认为这需要Python函数或方法的名称，但事实并非如此。相反，我们需要给它一个包含对Tcl/“Tk”函数的引用的元组，并且可以选择一些**替换代码**，这些代码指定我们要传递到函数中的触发事件的信息。
- en: How do we get a reference to a Tcl/`Tk` function? Fortunately, this isn't too
    hard; we just pass a Python callable to the `.register()` method on any Tkinter
    widget. This returns a string that we can use with `validatecommand`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获得对Tcl/“Tk”函数的引用？幸运的是，这并不太难；我们只需将Python可调用对象传递给任何Tkinter小部件的`.register（）`方法。这将返回一个字符串，我们可以在`validatecommand`中使用。
- en: Of course, validation functions aren't very useful unless we pass in some data
    to be validated. To do this, we add one or more substitution codes to our `validatecommand`
    tuple.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除非我们传入要验证的数据，否则验证函数没有什么用。为此，我们向我们的“validatecommand”元组添加一个或多个替换代码。
- en: 'These codes are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码如下：
- en: '| **Code** | **Value passed** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **传递的值** |'
- en: '| `%d` | A code indicating the action being attempted: `0` for `delete`, `1`
    for insert, and `-1` for other events. Note that this is passed as a string, and
    not as an integer. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|“％d”|指示正在尝试的操作的代码：`0`表示`delete`，`1`表示插入，`-1`表示其他事件。请注意，这是作为字符串而不是整数传递的。'
- en: '| `%P` | The proposed value that the field would have after the change (key
    events only). |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|“％P”|更改后字段将具有的建议值（仅限键事件）。'
- en: '| `%s` | The value currently in the field (key events only). |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|“％s”|字段中当前的值（仅限键事件）。'
- en: '| `%i` | The index (from `0`) of the text being inserted or deleted on key
    events, or `-1` on non-key events. Note that this is passed as a string, not as
    an integer. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|“％i”|在键事件上插入或删除的文本的索引（从`0`开始），或在非键事件上为`-1`。请注意，这是作为字符串而不是整数传递的。'
- en: '| `%S` | For insertion or deletion, the text that is being inserted or deleted
    (key events only). |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|“％S”|对于插入或删除，正在插入或删除的文本（仅限键事件）。'
- en: '| `%v` | The widget''s `validate` value. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|“％v”|小部件的“验证”值。'
- en: '| `%V` | The event that triggered validation: `focusin`, `focusout`, `key`,
    or `forced` (indicating the text variable was changed). |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|“％V”|触发验证的事件：`focusin`，`focusout`，`key`或`forced`（表示文本变量已更改）。'
- en: '| `%W` | The widget''s name in Tcl/`Tk`, as a string. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|“％W”|Tcl/“Tk”中小部件的名称，作为字符串。'
- en: The `invalidcommand` option works exactly the same way, requiring the use of
    the `.register()` method and substitution codes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “invalidcommand”选项的工作方式完全相同，需要使用`.register（）`方法和替换代码。
- en: 'To see what this looks like together, consider the following code for an `Entry` widget
    that only accepts five characters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些内容是什么样子，请考虑以下代码，用于仅接受五个字符的“Entry”小部件：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we've created a function that simply returns whether or not the length
    of a string is less than or equal to five characters. We then register this function
    with `Tk` using the `register()` method, saving its reference string as `wrapped_function`.
    Next, we build our `validatecommand` tuple using the reference string and the
    `'%P'` substitution code, which represents the proposed value (the value that
    the entry would have if the key event was accepted).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个简单的函数，它只返回字符串的长度是否小于或等于五个字符。然后，我们使用“register（）”方法将此函数注册到“Tk”，将其引用字符串保存为“wrapped_function”。接下来，我们使用引用字符串和“'％P'”替换代码构建我们的“validatecommand”元组，该替换代码表示建议的值（如果接受键事件，则输入将具有的值）。
- en: You can pass in as many substitution codes as you wish, and in any order, as
    long as your function is written to accept those arguments. Finally, we'll create
    our `Entry` widget, setting the validation type to `key` and passing in our validation
    command tuple.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传入任意数量的替换代码，并且可以按任何顺序，只要您的函数是写入接受这些参数的。最后，我们将创建我们的“Entry”小部件，将验证类型设置为“key”，并传入我们的验证命令元组。
- en: Notice we did not define an `invalidcommand` method in this case; when validation
    is triggered by a keystroke, returning `False` from the `validate` command will
    cause the keystroke to be ignored. This is not the case when triggering validation
    from a focus or other event type; in that case, there is no default behavior defined
    and an `invalidcommand` method is necessary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，我们没有定义“invalidcommand”方法；当通过按键触发验证时，从“validate”命令返回`False`将导致忽略按键。当通过焦点或其他事件类型触发验证时，情况并非如此；在这种情况下，没有定义默认行为，需要“invalidcommand”方法。
- en: 'Consider the following alternate, class-based version of `FiveCharEntry`, which
    allows you to type as much as you want, but truncates your text when you leave
    the field:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下“FiveCharEntry”的替代基于类的版本，它允许您输入任意数量的文本，但在离开字段时会截断您的文本：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This time, we've implemented validation by subclassing `Entry` and defining
    our validation logic in a method rather than an external function. This simplifies
    access to the widget in our validation methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们通过对“Entry”进行子类化并在方法中定义我们的验证逻辑来实现验证，而不是在外部函数中。这简化了我们在验证方法中访问小部件。
- en: The underscores at the beginning of `_validate()`  and `_on_invalid()` indicate
    that these are internal methods meant to be accessible only within the class.
    While it's not necessary to make this code work correctly, and Python does not
    treat it any differently from a normal method, it lets other programmers know
    that these methods are for internal use and shouldn't be called outside the class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`_validate()`和`_on_invalid()`开头的下划线表示这些是内部方法，只能在类内部访问。虽然这并不是必要的，而且Python并不会将其与普通方法区别对待，但它让其他程序员知道这些方法是供内部使用的，不应该在类外部调用。'
- en: We've also changed the `validate` argument to `focusout` and added an `_on_invalid()`
    method that truncates the value in `Entry`. Whenever the widget loses focus, the
    `_validate()` method will be called with the entered text. If it fails, `_on_invalid()`
    will be called, causing the contents to be truncated using the `Entry` widget's
    `delete()` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`validate`参数更改为`focusout`，并添加了一个`_on_invalid()`方法，该方法将使用`Entry`小部件的`delete()`方法截断值。每当小部件失去焦点时，将调用`_validate()`方法并传入输入的文本。如果失败，将调用`_on_invalid()`，导致内容被截断。
- en: Creating a DateEntry widget
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个DateEntry小部件
- en: 'Let''s try creating a validating version of our `Date` field. We''ll make a
    `DateEntry` widget that prevents most erroneous keystrokes, then checks for date
    validity on `focusout`. If the date is invalid, we''ll mark the field in some
    way and display an error. Let''s perform the following steps to do the same:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个验证版本的`Date`字段。我们将创建一个`DateEntry`小部件，它可以阻止大多数错误的按键，并在`focusout`时检查日期的有效性。如果日期无效，我们将以某种方式标记该字段并显示错误。让我们执行以下步骤来完成相同的操作：
- en: 'Open a new file called `DateEntry.py` and begin with the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个名为`DateEntry.py`的新文件，并从以下代码开始：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we'll need `datetime` for our validation method, we import it here at
    the top.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要在验证方法中使用`datetime`，所以我们在这里导入它。
- en: We subclass `ttk.Entry`, then start our constructor method with a call to `super().__init__()`
    as usual.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对`ttk.Entry`进行子类化，然后在构造方法中开始调用`super().__init__()`，就像往常一样。
- en: Next, we use `self.config()` to alter the configuration of the widget. You might
    wonder why we don't pass these arguments into the `super().__init__()` call; the
    reason is that the `self.register()` method doesn't exist until the underlying
    `Entry` widget has been initialized.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`self.config()`来更改小部件的配置。你可能会想知道为什么我们没有将这些参数传递给`super().__init__()`调用；原因是直到底层的`Entry`小部件被初始化之后，`self.register()`方法才存在。
- en: 'We''re registering the following two methods: `self._validate` and `self._on_invalid`,
    which we''ll write shortly:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们注册以下两种方法：`self._validate`和`self._on_invalid`，我们将很快编写：
- en: '`_validate()`: This method will get the inserted text (`%S`), the index of
    insertion (`%i`), the type of event (`%V`), and the action performed (`%d`).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_validate()`：这个方法将获取插入的文本（`%S`），插入的索引（`%i`），事件类型（`%V`）和执行的操作（`%d`）。'
- en: '`_on_invalid()`: This method will only get the event type. Since we want to
    validate on both keystrokes and `focusout`, we''ll set `validate` to `all`. Our
    validation methods can figure out which event is taking place by looking at the
    event type (`%V`).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_on_invalid()`：这个方法只会获取事件类型。由于我们希望在按键和`focusout`时进行验证，所以我们将`validate`设置为`all`。我们的验证方法可以通过查看事件类型（`%V`）来确定正在发生的事件。'
- en: Finally, we create `StringVar` to hold our error text; this will be accessed
    outside the class, so we don't use the leading underscore in its name.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建`StringVar`来保存我们的错误文本；这将在类外部访问，所以我们不在其名称中使用前导下划线。
- en: 'The next method we create is `_toggle_error()`, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的下一个方法是`_toggle_error()`，如下所示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re using this method to consolidate the widget''s behavior in the case
    of an error. It starts by setting our `error` variable to the string provided.
    If the string is not blank, we turn on the error marking (in this case, turning
    the text red); if it''s blank, we turn off the error marking. The `_validate()`
    method is as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用这种方法来在出现错误的情况下整合小部件的行为。它首先将我们的`error`变量设置为提供的字符串。如果字符串不为空，我们会打开错误标记（在这种情况下，将文本变为红色）；如果为空，我们会关闭错误标记。`_validate()`方法如下：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing we do is toggle off our error status and set a `valid` flag
    to `True`. Our input will be `innocent until proven guilty`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是切换关闭我们的错误状态，并将`valid`标志设置为`True`。我们的输入将是“无罪直到被证明有罪”。
- en: Then, we'll look at keystroke events. `if action == '0':` tells us if the user
    is trying to delete characters. We always want to allow this so that the user
    can edit the field.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将查看按键事件。`if action == '0':`告诉我们用户是否尝试删除字符。我们总是希望允许这样做，以便用户可以编辑字段。
- en: 'The basic format of an ISO date is: four digits, a dash, two digits, a dash,
    and two digits. We can test whether the user is following this format by checking
    whether the inserted characters match our expectation at the inserted `index`.
    For example, `index in (''0'', ''1'', ''2'', ''3'', ''5'', ''6'', ''8'', ''9'')`
    will tell us if the character being inserted is one of the positions that requires
    a digit, and if so we check that the character is a digit. An index of `4` or
    `7` should be a dash. Any other keystroke is invalid.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ISO日期的基本格式是：四位数字，一个破折号，两位数字，一个破折号，和两位数字。我们可以通过检查插入的字符是否与我们在插入的`index`位置的期望相匹配来测试用户是否遵循这种格式。例如，`index
    in ('0', '1', '2', '3', '5', '6', '8', '9')`将告诉我们插入的字符是否是需要数字的位置之一，如果是，我们检查该字符是否是数字。索引为`4`或`7`应该是一个破折号。任何其他按键都是无效的。
- en: Although you might expect them to be integers, Tkinter passes the action codes
    and indexes them as strings. Keep this in mind when writing your comparisons.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能期望它们是整数，但Tkinter将动作代码传递为字符串并将其索引化。在编写比较时要记住这一点。
- en: While this is a hopelessly naive heuristic for a correct date, since it allows
    for complete nonsense dates like `0000-97-46` or right-looking-but-still-wrong
    dates like `2000-02-29`, it at least enforces the basic format and removes a large
    number of invalid keystrokes. A completely accurate partial date analyzer is a
    project unto itself, so for now this will do.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个对于正确日期的幼稚的启发式方法，因为它允许完全无意义的日期，比如`0000-97-46`，或者看起来正确但仍然错误的日期，比如`2000-02-29`，但至少它强制执行了基本格式并消除了大量无效的按键。一个完全准确的部分日期分析器是一个单独的项目，所以现在这样做就可以了。
- en: 'Checking our date for correctness on `focusout` is simpler and much more foolproof,
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`focusout`上检查我们的日期是否正确更简单，也更可靠，如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we have access to the final value the user meant to enter at this point,
    we can use `datetime.strptime()` to try to convert the string to a Python `datetime`
    using the format `%Y-%m-%d`. If this fails, we know the date is invalid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这一点上可以访问用户打算输入的最终值，我们可以使用`datetime.strptime()`来尝试使用格式`%Y-%m-%d`将字符串转换为Python的`datetime`。如果失败，我们就知道日期是无效的。
- en: To end the method, we return our `valid` flag.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结束方法时，我们返回我们的`valid`标志。
- en: Validation methods must always return a Boolean value. If, for some reason,
    your validation method doesn't return a value (or returns `None`), your validation
    will silently break without any error. Be careful to make sure your methods will
    always return a Boolean value, especially if you're using multiple `return` statements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 验证方法必须始终返回一个布尔值。如果由于某种原因，您的验证方法没有返回值（或返回`None`），您的验证将在没有任何错误的情况下悄悄中断。请务必确保您的方法始终返回一个布尔值，特别是如果您使用多个`return`语句。
- en: As you saw previously, for invalid keystrokes, it's sufficient to return `False`
    and prevent the character from being inserted, but for errors on focus events,
    we'll need to respond in some way.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前看到的，对于无效的按键，只需返回`False`并阻止插入字符就足够了，但对于焦点事件上的错误，我们需要以某种方式做出响应。
- en: 'Take a look at the  `_on_invalid()` method in the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码中的`_on_invalid()`方法：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We pass only the event type into this method, which we'll use to ignore keystroke
    events (they're already adequately handled by the default behavior). For any other
    event type, we'll use our `_toggle_error()` method to display the error.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将事件类型传递给这个方法，我们将使用它来忽略按键事件（它们已经被默认行为充分处理）。对于任何其他事件类型，我们将使用我们的`_toggle_error()`方法来显示错误。
- en: 'To test our `DateEntry` class, add the following test code to the bottom of
    the file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的`DateEntry`类，请将以下测试代码添加到文件的底部：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save the file and run it to try the new `DateEntry` class. Try entering various
    bad dates or invalid keystrokes, and see what happens.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行它以尝试新的`DateEntry`类。尝试输入各种错误的日期或无效的按键，并看看会发生什么。
- en: Implementing validated widgets in our form
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的表单中实现验证小部件
- en: Now that you know how to validate your widgets, you have your work cut out for
    you! We have 16 input widgets, and you'll have to write code like that shown in
    the previous section for all of them to get the behavior we need. Along the way,
    you'll need to make sure the widgets respond consistently to errors and present
    a consistent API to the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何验证您的小部件，您有很多工作要做！我们有16个输入小部件，您将不得不为所有这些编写代码，以获得我们需要的行为。在这个过程中，您需要确保小部件对错误的响应是一致的，并向应用程序提供一致的API。
- en: If that sounds like something you'd like to put off indefinitely, I can't blame
    you. Maybe there's a way we can cut down the amount of code we need to write.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来像是你想无限期推迟的事情，我不怪你。也许有一种方法可以减少我们需要编写的代码量。
- en: Exploiting the power of multiple inheritance
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用多重继承的力量
- en: So far, we have learned that Python allows us to create new classes by subclassing,
    inheriting features from the super class, and only adding or changing what's different
    about our new class. Python also supports **multiple inheritance**, where a subclass
    can inherit from multiple superclasses. We can exploit this feature to our advantage
    by creating what's called a **mixin** class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到Python允许我们通过子类化创建新的类，从超类继承特性，并只添加或更改新类的不同之处。Python还支持**多重继承**，其中子类可以从多个超类继承。我们可以利用这个特性来为我们带来好处，创建所谓的**混合**类。
- en: Mixin classes contain only a specific set of functionalities that we want to
    be able to mix in with other classes to compose a new class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类只包含我们想要能够与其他类混合以组成新类的特定功能集。
- en: 'Take a look at the following example code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We implement a basic class called `Displayer` with a `display()` method that
    prints a message. Then, we create a mixin class called `LoggerMixin`, which both
    adds a `log()` method to write a message to a text file and overrides the `display()`
    method to add a call to `log()`. Finally, we create a subclass by inheriting from
    both `LoggerMixin` and `Displayer`. The subclass then overrides the `log()` method
    and sets a different filename.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个名为`Displayer`的基本类，其中包含一个`display()`方法，用于打印消息。然后，我们创建了一个名为`LoggerMixin`的混合类，它添加了一个`log()`方法来将消息写入文本文件，并覆盖了`display()`方法以调用`log()`。最后，我们通过同时继承`LoggerMixin`和`Displayer`来创建一个子类。子类然后覆盖了`log()`方法并设置了不同的文件名。
- en: When we create a class using multiple inheritance, the rightmost class we specify
    is called the **base class**, and mixin classes should be specified before it.
    There's no special syntax for a mixin class as opposed to any other class, but
    pay attention to the use of `super()` in the mixin's `display()` method. Technically,
    `LoggerMixin` inherits from Python's built-in `object` class, which has no `display()`
    method. How, then, can we call `super().display()` here?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个使用多重继承的类时，我们指定的最右边的类称为**基类**，混合类应该在它之前指定。对于混合类与任何其他类没有特殊的语法，但要注意混合类的`display()`方法中使用`super()`。从技术上讲，`LoggerMixin`继承自Python内置的`object`类，该类没有`display()`方法。那么，我们如何在这里调用`super().display()`呢？
- en: 'In a multiple inheritance situation, `super()` does something a little more
    complex than just standing in for the superclass. It looks up the chain of inheritance
    using something called the **Method Resolution Order** and determines the nearest
    class that defines the method we''re calling. Thus, when we call `MySubclass.display()`,
    a series of method resolutions occurs, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承的情况下，`super()`做的事情比仅仅代表超类要复杂一些。它使用一种叫做**方法解析顺序**的东西来查找继承链，并确定定义我们调用的方法的最近的类。因此，当我们调用`MySubclass.display()`时，会发生一系列的方法解析，如下所示：
- en: '`MySubClass.display()` is resolved to `LoggerMixin.display()`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MySubClass.display()`被解析为`LoggerMixin.display()`。'
- en: '`LoggerMixin.display()` calls `super().display()`, which is resolved to `Displayer.display()`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggerMixin.display()`调用`super().display()`，解析为`Displayer.display()`。'
- en: It also calls `self.log()`. Since `self`, in this case, is a `MySubClass` instance,
    it resolves to `MySubClass.log()`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还调用`self.log()`。在这种情况下，`self`是一个`MySubClass`实例，所以它解析为`MySubClass.log()`。
- en: '`MySubClass.log()` calls `super().log()`, which is resolved back to `LoggerMixin.log()`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MySubClass.log()`调用`super().log()`，解析回`LoggerMixin.log()`。'
- en: If this seems confusing, just remember that `self.method()` will look for `method()`
    in the current class first, then follow the list of inherited classes from left
    to right until the method is found. The `super().method()` will do the same, except
    that it skips the current class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来令人困惑，只需记住`self.method()`将首先在当前类中查找`method()`，然后按照从左到右的继承类列表查找方法。`super().method()`也会这样做，只是它会跳过当前类。
- en: The method resolution order of a class is stored in its `__mro__` property;
    you can inspect this method in a Python shell or debugger if you're having trouble
    with inherited methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类的方法解析顺序存储在它的`__mro__`属性中；如果你在Python shell或调试器中遇到继承方法的问题，你可以检查这个方法。
- en: 'Note that `LoggerMixin` is not usable on its own: it only works when combined
    with a class that has a `display()` method. This is why it''s a mixin class because
    it''s meant to be mixed in to enhance other classes.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`LoggerMixin`不能单独使用：它只在与具有`display()`方法的类结合时起作用。这就是为什么它是一个mixin类，因为它的目的是混合到其他类中以增强它们。
- en: A validating mixin class
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个验证mixin类
- en: 'Let''s apply our knowledge of multiple inheritance to build a mixin that will
    give us some boilerplate validation logic by performing the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用我们对多重继承的知识来构建一个mixin，通过执行以下步骤来给我们一些样板验证逻辑：
- en: 'Open `data_entry_app.py` and start the class before your `Application` class
    definition:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`data_entry_app.py`并在`Application`类定义之前开始这个类：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start this class as usual, though we're not subclassing anything this time.
    The constructor also has an extra argument called `error_var`. This will allow
    us to pass in a variable to use for the error message; if we don't, the class
    creates its own. The call to `super().__init__()` will cause the base class that
    we mix with to execute its constructor.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样开始这节课，尽管这次我们不会再继承任何东西。构造函数还有一个额外的参数叫做`error_var`。这将允许我们传入一个变量来用于错误消息；如果我们不这样做，类会创建自己的变量。调用`super().__init__()`将导致我们混合的基类执行它的构造函数。
- en: 'Next, we set up validation, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进行验证，如下所示：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We're setting up our `validate` and `invalid` methods here. We'll go ahead and
    pass in all the substitution codes (except `'%w'`, the widget name, since it's
    fairly useless inside a class context). We're running validation on all conditions,
    so we can capture both focus and keystroke events.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里设置了我们的`validate`和`invalid`方法。我们将继续传入所有的替换代码（除了`'%w'`，因为在类上下文中它几乎没有用）。我们对所有条件进行验证，所以我们可以捕获焦点和按键事件。
- en: 'Now, we''ll define our error condition handler:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义我们的错误条件处理程序：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will just change the text color to red if there''s an error, or black
    otherwise. We don''t set the error in this function, since we''ll want to set
    the actual error text in the validate method as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误，这将只是将文本颜色更改为红色，否则更改为黑色。我们不在这个函数中设置错误，因为我们将希望在验证方法中设置实际的错误文本，如下所示：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `_validate()` method just handles a few setup chores like toggling off the
    error and clearing the error message. Then, it runs an event-specific validate
    method, depending on the event type passed in. We only care about the `key` and
    `focusout` events right now, so any other event just returns `True`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`_validate()`方法只处理一些设置工作，比如关闭错误和清除错误消息。然后，它运行一个特定于事件的验证方法，取决于传入的事件类型。我们现在只关心`key`和`focusout`事件，所以任何其他事件都会返回`True`。
- en: Notice that we call the individual methods using keywords; when we create our
    subclasses, we'll be overriding these methods. By using keyword arguments, our
    overridden functions can just specify the needed keywords or extract individual
    arguments from `**kwargs`, rather than having to get all the arguments in the
    right order. Also notice that all the arguments are passed into `_key_validate()`,
    but only `event` is passed into `_focusout_validate()`. Focus events don't return
    anything useful for any of the other arguments, so there's no point in passing
    them along.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用关键字调用各个方法；当我们创建我们的子类时，我们将覆盖这些方法。通过使用关键字参数，我们覆盖的函数只需指定所需的关键字或从`**kwargs`中提取单个参数，而不必按正确的顺序获取所有参数。还要注意，所有参数都传递给`_key_validate()`，但只有`event`传递给`_focusout_validate()`。焦点事件对于其他参数都没有有用的返回值，所以将它们传递下去没有意义。
- en: 'The ultimate idea here is that our subclasses only need to override the validation
    method or methods we care about for that widget. If we don''t override them, they
    just return `True`, so validation passes. Now, we need to handle an invalid event:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的最终想法是，我们的子类只需要覆盖我们关心的小部件的验证方法或方法。如果我们不覆盖它们，它们就会返回`True`，所以验证通过。现在，我们需要处理一个无效的事件：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We take an identical approach to these methods. Unlike the validate methods,
    though, our invalid data handlers don't need to return anything. For invalid keys,
    we do nothing by default, and for invalid data on `focusout`, we toggle our error
    status on.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对这些方法采取相同的方法。不像验证方法，我们的无效数据处理程序不需要返回任何内容。对于无效的键，默认情况下我们什么也不做，对于`focusout`上的无效数据，我们切换错误状态。
- en: 'Keystroke validation only really makes sense in the context of entering keys,
    but there may be times when we want to manually run the `focusout` checks, since
    it effectively checks a completely entered value. For this reason, we''ll implement
    the following method:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按键验证只在输入键的情况下才有意义，但有时我们可能希望手动运行`focusout`检查，因为它有效地检查完全输入的值。因此，我们将实现以下方法：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''re just duplicating the logic that occurs when a `focusout` event happens:
    run the validation function, and if it fails, run the invalid handler. This is
    all we need for `ValidatedMixin`, so let''s start applying it to some of our widgets
    and see how it works.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只是复制了`focusout`事件发生时发生的逻辑：运行验证函数，如果失败，则运行无效处理程序。这就是我们对`ValidatedMixin`所需的全部内容，所以让我们开始将其应用于一些小部件，看看它是如何工作的。
- en: Building our widgets
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的小部件
- en: 'Let''s think through what classes we need to implement with our new `ValidatedMixin`
    class, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细考虑我们需要使用新的`ValidatedMixin`类实现哪些类，如下所示：
- en: All our fields except `Notes` are required, so we'll need a basic `Entry` widget
    that registers an error if there's no input.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`Notes`之外，我们所有的字段都是必需的，因此我们需要一个基本的`Entry`小部件，如果没有输入，则会注册错误。
- en: We have one `Date` field, so we need an `Entry` widget that enforces a valid
    date string.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个`Date`字段，因此我们需要一个强制有效日期字符串的`Entry`小部件。
- en: We have a number of the `Spinbox` widgets for decimal or integer input. We'll
    need to make sure these only accept valid number strings.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一些用于十进制或整数输入的`Spinbox`小部件。我们需要确保这些只接受有效的数字字符串。
- en: We have a few `Combobox` widgets that don't behave quite the way we want them
    to.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一些`Combobox`小部件的行为不太符合我们的期望。
- en: Let's get started!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Requiring data
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要数据
- en: 'All of our fields are required, so let''s start with a basic `Entry` widget
    that requires data. We can use these for fields: `Technician` and `Seed sample`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的字段都是必需的，所以让我们从一个需要数据的基本`Entry`小部件开始。我们可以将这些用于字段：`Technician`和`Seed sample`。
- en: 'Add the following code under the `ValidatedMixin` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ValidatedMixin`类下添加以下代码：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's no keystroke validation to do here, so we just need to create `_focusout_validate()`.
    If the entered value is empty, we just set an error string and return `False`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有按键验证要做，所以我们只需要创建`_focusout_validate()`。如果输入的值为空，我们只需设置一个错误字符串并返回`False`。
- en: That's all there is to it!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样了！
- en: A Date widget
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期小部件
- en: 'Now, let''s apply the mixin class to the `DateEntry` class we made before,
    keeping the same validation algorithm as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将mixin类应用于之前制作的`DateEntry`类，保持相同的验证算法如下：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, pretty simple, all we need to do is specify the validation logic. We've
    added the logic from our `RequiredEntry` class too, since the `Date` value is
    required.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，非常简单，我们只需要指定验证逻辑。我们还添加了来自我们的`RequiredEntry`类的逻辑，因为`Date`值是必需的。
- en: Let's move on to something a bit more intricate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行一些更复杂的工作。
- en: A better Combobox widget
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的Combobox小部件
- en: 'The drop-down widgets in different toolkits behave fairly consistently when
    it comes to mouse operation, but the response to keystrokes varies, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不同工具包中的下拉式小部件在鼠标操作时表现相当一致，但对按键的响应有所不同，如下所示：
- en: Some do nothing
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些什么都不做
- en: Some require the use of arrow keys to select items
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些需要使用箭头键来选择项目
- en: Some move to the first entry that begins with any key pressed, and cycle through
    entries beginning with that letter on subsequent presses
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些移动到按下任意键开始的第一个条目，并在后续按键开始的条目之间循环
- en: Some narrow down the list to entries that match what's typed
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些会缩小列表以匹配所键入的内容
- en: 'We need to think about what behavior our `Combobox` widget should have. Since
    our users are accustomed to doing data entry with the keyboard, and some have
    difficulty with the mouse, the widget needs to work with the keyboard. Making
    them use repeated keystrokes to select options is not very intuitive, either.
    After talking with the data entry staff, you decide on this behavior:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑我们的`Combobox`小部件应该具有什么行为。由于我们的用户习惯于使用键盘进行数据输入，有些人使用鼠标有困难，小部件需要与键盘配合使用。让他们重复按键来选择选项也不是很直观。与数据输入人员讨论后，您决定采用以下行为：
- en: If the proposed text matches no entries, it will be ignored
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果建议的文本与任何条目都不匹配，它将被忽略。
- en: When the proposed text matches a single entry, the widget is set to that value
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当建议的文本与单个条目匹配时，小部件将设置为该值
- en: A delete or backspace clears the entire box
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或退格会清除整个框
- en: 'Add this code under the `DateEntry` code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DateEntry`代码下添加此代码：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `_key_validate()` method starts out by setting up a `valid` flag and doing
    a quick check to see if this is a delete action. If it is, we set the value to
    a blank string and return `True`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`_key_validate()`方法首先设置一个`valid`标志，并快速检查是否是删除操作。如果是，我们将值设置为空字符串并返回`True`。'
- en: 'Now, we''ll add the logic to match the proposed text to our values:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加逻辑来匹配建议的文本与我们的值：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A copy of the widget's list of values is retrieved using its `.cget()` method.
    Then, we use list comprehension to reduce this list to only the entries that match
    the proposed text, calling `lower()` on both the values in the list item and the
    proposed text so that our match is case-insensitive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其`.cget()`方法检索小部件值列表的副本。然后，我们使用列表推导来将此列表减少到仅与建议的文本匹配的条目，对列表项和建议的文本的值调用`lower()`，以便我们的匹配不区分大小写。
- en: Every Tkinter widget supports the `.cget()` method. It can be used to retrieve
    any of the widget's configuration values by name.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Tkinter小部件都支持`.cget()`方法。它可以用来按名称检索小部件的任何配置值。
- en: 'If the length of the matching list is `0`, we reject the keystroke. If it''s
    `1`, we''ve found our match, so we''ll set the variable to that value. If it''s
    anything else, we need to let the user keep typing. As a final touch, we''ll send
    the cursor to the end of the field using the `.icursor()` method if a match is
    found. This isn''t strictly necessary, but it looks better than leaving the cursor
    in the middle of the text. Now, we''ll add the `focusout` validator, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配列表的长度为`0`，我们拒绝按键。如果为`1`，我们找到了匹配，所以我们将变量设置为该值。如果是其他任何值，我们需要让用户继续输入。作为最后的修饰，如果找到匹配，我们将使用`.icursor()`方法将光标发送到字段的末尾。这并不是严格必要的，但比将光标留在文本中间看起来更好。现在，我们将添加`focusout`验证器，如下所示：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We don't have to do much here, because the key validation method ensures that
    the only possible values are a blank field or an item in the values list, but
    since all fields are required to have a value, we'll copy the validation from
    `RequiredEntry`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们不需要做太多，因为关键验证方法确保唯一可能的值是空字段或值列表中的项目，但由于所有字段都需要有一个值，我们将从`RequiredEntry`复制验证。
- en: That takes care of our `Combobox` widget. Next, we'll deal with the `Spinbox` widget.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就处理了我们的`Combobox`小部件。接下来，我们将处理`Spinbox`小部件。
- en: A range-limited Spinbox widget
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围限制的Spinbox小部件
- en: A number entry seems like it shouldn't be too complicated to deal with, but
    there are a number of subtleties to work through to make it bulletproof. In addition
    to limiting the field to valid number values, you'll want to enforce the `from`,
    `to`, and `increment` arguments as the minimum, maximum, and precision of the
    input, respectively.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入似乎不应该太复杂，但有许多微妙之处需要解决，以使其牢固。除了将字段限制为有效的数字值之外，您还希望将`from`、`to`和`increment`参数分别强制为输入的最小、最大和精度。
- en: 'The algorithm needs to implement the following rules:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 算法需要实现以下规则：
- en: Deletion is always allowed
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除始终允许
- en: Digits are always allowed
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字始终允许
- en: If `from` is less than `0`, a minus is allowed as the first character
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`from`小于`0`，则允许减号作为第一个字符
- en: If `increment` has a decimal component, one dot is allowed
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`increment`有小数部分，则允许一个点
- en: If the proposed value is greater than the `to` value, ignore the keystroke
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果建议的值大于`to`值，则忽略按键
- en: If the proposed value requires more precision than `increment`, ignore the keystroke
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果建议的值需要比`increment`更高的精度，则忽略按键
- en: On `focusout`, make sure the value is a valid number string
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`focusout`时，确保值是有效的数字字符串
- en: Also on `focusout`, make sure the value is greater than the `from` value
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样在`focusout`时，确保值大于`from`值
- en: 'Take a look at the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下步骤：
- en: 'Here''s how we''ll code, regarding the preceding rules:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们将如何编码，关于前面的规则：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We'll start by overriding the `__init__()` method so that we can specify some
    defaults and grab the `increment` value from the constructor arguments for processing.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先重写`__init__()`方法，以便我们可以指定一些默认值，并从构造函数参数中获取`increment`值以进行处理。
- en: The `Spinbox` arguments can be passed in as floats, integers, or strings. Regardless
    of how you pass them in, Tkinter converts them to floats. Determining the precision
    of a float is problematic, because of floating-point error, so we want to convert
    it to a Python `Decimal` before it becomes a float.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Spinbox`参数可以作为浮点数、整数或字符串传递。无论如何传递，Tkinter都会将它们转换为浮点数。确定浮点数的精度是有问题的，因为浮点误差的原因，所以我们希望在它变成浮点数之前将其转换为Python
    `Decimal`。'
- en: Floats attempt to represent decimal numbers in binary form. Open a Python shell
    and enter `1.2 / .2`. You might be surprised to find the answer is `5.999999999999999`
    rather than `6`. This is known as a **floating-point error**, and it's a source
    of computation error in nearly every programming language. Python offers us the
    `Decimal` class, which takes a numeric string and stores it in a way that makes
    mathematical operations safe from floating-point errors.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数尝试以二进制形式表示十进制数。打开Python shell并输入`1.2 / .2`。您可能会惊讶地发现答案是`5.999999999999999`而不是`6`。这被称为**浮点误差**，几乎在每种编程语言中都是计算错误的来源。Python为我们提供了`Decimal`类，它接受一个数字字符串并以一种使数学运算免受浮点误差的方式存储它。
- en: 'Before we can use `Decimal`, we need to import it. Add the following code to
    your imports at the top of the file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们使用`Decimal`之前，我们需要导入它。在文件顶部的导入中添加以下代码：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`InvalidOperation` is an exception thrown when `Decimal` is given a string
    it cannot interpret. We''ll be using it later on.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InvalidOperation`是当`Decimal`得到一个它无法解释的字符串时抛出的异常。我们稍后会用到它。'
- en: Notice that we cast `increment` to `str` before passing it to `Decimal`. Ideally,
    we should pass `increment` in as a string to ensure it will be interpreted correctly,
    but in case we need to pass in a float for some reason, `str` will do some sensible
    rounding first.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在将其传递给`Decimal`之前，我们将`increment`转换为`str`。理想情况下，我们应该将`increment`作为字符串传递，以确保它将被正确解释，但以防我们因某种原因需要传递一个浮点数，`str`将首先进行一些明智的四舍五入。
- en: 'We also set defaults for `to` and `from_`: `-Infinity` and `Infinity`. Both
    `float` and `Decimal` will happily accept these values and treat them as you''d
    expect them to do. The default `to` and `from_` values for `Tkinter.Spinbox` are
    `0`; if they''re left there, Tkinter treats it as no limit, but this creates a
    problem if we specify one but not the other.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为`to`和`from_`设置了默认值：`-Infinity`和`Infinity`。`float`和`Decimal`都会愉快地接受这些值，并将它们视为您期望的那样处理。`Tkinter.Spinbox`的默认`to`和`from_`值为`0`；如果它们保留在那里，Tkinter会将其视为无限制，但如果我们指定一个而不是另一个，这就会产生问题。
- en: We extract `precision` of the `resolution` value as an exponent of the smallest
    valid decimal place. We'll use this value in the validation class.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提取`resolution`值的`precision`作为最小有效小数位的指数。我们将在验证类中使用这个值。
- en: 'Our constructor is settled, so let''s write the validate methods. The key validate
    method is a bit tricky, so we''ll walk through it chunk by chunk. First, we start
    the method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的构造函数已经确定，所以让我们编写验证方法。关键验证方法有点棘手，所以我们将一步一步地走过它。首先，我们开始这个方法：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To begin, we retrieve the `from` and `to` values, then assign flag variables
    to indicate if negatives and decimals should be allowed, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检索`from`和`to`值，然后分配标志变量以指示是否应允许负数和小数，如下所示：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deletion should always work, so if it's a deletion, return `True`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 删除应该总是有效的，所以如果是删除，返回`True`。
- en: We've broken our no multiple returns guideline here, because the same logic
    with only one `return` would be nested quite deeply. When trying to write readable,
    maintainable code, sometimes one has to pick the lesser of two evils.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里打破了不要多次返回的准则，因为只有一个`return`的相同逻辑会嵌套得非常深。在尝试编写可读性好、易于维护的代码时，有时不得不选择两害相权取其轻。
- en: 'Next, we test if the keystroke is a valid character, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试按键是否是有效字符，如下所示：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Valid characters are digits plus `-` and `.`. The minus sign is only valid at
    index `0`, and the dot can only appear once. Anything else returns `False`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有效字符是数字加上`-`和`.`。减号只在索引`0`处有效，点只能出现一次。其他任何字符都返回`False`。
- en: The built-in `any` function takes a list of expressions and returns `True` if
    any one of the expressions in the list are true. There's also an `all` function
    that returns `True` if all the expressions are true. These functions allow you
    to condense a long chain of boolean expressions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`any`函数接受一个表达式列表，并在列表中的任何一个表达式为真时返回`True`。还有一个`all`函数，如果所有表达式都为真，则返回`True`。这些函数允许您压缩一长串布尔表达式。
- en: We're almost guaranteed at this point to have a valid `Decimal` string, but
    not quite; we might have just `-`, `.`, or `-.` characters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们几乎可以保证有一个有效的`Decimal`字符串，但还不够；我们可能只有`-`、`.`或`-.`字符。
- en: 'The following are valid partial entries, so we just return `True` for them:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是有效的部分条目，因此我们只需为它们返回`True`：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, the proposed text can only be a valid `Decimal` string, so we''ll
    make a `Decimal` from it and do some more tests:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，建议的文本只能是有效的`Decimal`字符串，因此我们将从中制作一个`Decimal`并进行更多的测试：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our last two tests check to see if the proposed text is either greater than
    our maximum value, or has more precision than the `increment` that we specified
    (the reason we use a `<` operator here is because `precision` is given as a negative
    value for decimal places). In case nothing has been returned yet, we return the
    `valid` value as a safeguard. Our `focusout` validator is much simpler, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后两个测试检查建议的文本是否大于我们的最大值，或者比我们指定的“增量”具有更多的精度（我们在这里使用`<`运算符的原因是因为“精度”给出为小数位的负值）。如果还没有返回任何内容，我们将返回`valid`值作为保障。我们的`focusout`验证器要简单得多，如下所示：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the entire intended value, we only need to make sure it's a valid `Decimal`
    string and greater than the minimum value.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了整个预期值，我们只需要确保它是有效的`Decimal`字符串并且大于最小值。
- en: With that, our `ValidatedSpinbox` is ready to go.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的`ValidatedSpinbox`已经准备就绪。
- en: Dynamically adjusting the Spinbox range
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态调整Spinbox范围
- en: Our `ValidatedSpinbox` method seems adequate for most of our fields. But consider
    the `Height` fields for a moment. It would not make any sense for the `Mini height`
    value to be more than the `Max height` value, or for the `Median height` value
    not to be between them. Is there some way we can work this kind of interdependent
    behavior into our class?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ValidatedSpinbox`方法似乎对我们的大多数字段都足够了。但是考虑一下`Height`字段。`Mini height`值大于`Max
    height`值或`Median height`值不在它们之间是没有意义的。有没有办法将这种相互依赖的行为融入到我们的类中？
- en: We can! To do this, we'll rely on the **tracing** feature of Tkinter variables.
    A trace is essentially a hook into the `.get()` and `.set()` methods of variables
    that allows you to trigger any Python function or method when a variable is read
    or changed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以！为此，我们将依赖Tkinter变量的**跟踪**功能。跟踪本质上是对变量的`.get()`和`.set()`方法的钩子，允许您在读取或更改变量时触发任何Python函数或方法。
- en: 'The syntax is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first argument to `.trace()` indicates which event we want to trace. Here, `w`
    indicates a write (`.set()`), `r` indicates a read (`.get()`), and `u` indicates
    an undefined variable or deletion of the variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`.trace()`的第一个参数表示我们要跟踪的事件。这里，`w`表示写（`.set()`），`r`表示读（`.get()`），`u`表示未定义的变量或删除变量。'
- en: Our strategy will be to allow optional `min_var` and `max_var` variables into
    the `ValidatedSpinbox` method and set a trace on these variables to update the
    `ValidatedSpinbox` method's min or max value whenever this variable is changed.
    We'll also have a `focus_update_var` variable that will be updated with the `Spinbox` widget
    value at `focusout` time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略是允许可选的`min_var`和`max_var`变量进入`ValidatedSpinbox`方法，并在这些变量上设置一个跟踪，以便在更改此变量时更新`ValidatedSpinbox`方法的最小或最大值。我们还将有一个`focus_update_var`变量，它将在`focusout`时间更新为`Spinbox`小部件值。
- en: 'Let''s take a look at the following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'To start, we''ll update our `ValidatedSpinbox` constructor as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将更新我们的`ValidatedSpinbox`构造函数如下：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, note that we've added a line to store our variable in `self.variable`,
    and we create one if the program doesn't pass one in explicitly. Some of the code
    we need to write will depend on a text variable existing, so we'll force this,
    just in case.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请注意我们已经添加了一行来将变量存储在`self.variable`中，如果程序没有明确传入变量，我们将创建一个变量。我们需要编写的一些代码将取决于文本变量的存在，因此我们将强制执行这一点，以防万一。
- en: If we pass in either a `min_var` or `max_var` argument, the value is stored
    and a trace is configured. The `trace()` method points to an appropriately named
    method.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们传入`min_var`或`max_var`参数，该值将被存储，并配置一个跟踪。`trace()`方法指向一个适当命名的方法。
- en: We also store a reference to the `focus_update_var` argument and bind the `<FocusOut>`
    event to a method that will be used to update it.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还存储了对`focus_update_var`参数的引用，并将`<FocusOut>`事件绑定到一个方法，该方法将用于更新它。
- en: The `bind()` method can be called on any Tkinter widget, and it's used to connect
    widget events to a Python callable. Events can be keystrokes, mouse movements
    or clicks, focus events, window management events, and more.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`方法可以在任何Tkinter小部件上调用，它用于将小部件事件连接到Python可调用函数。事件可以是按键、鼠标移动或点击、焦点事件、窗口管理事件等等。'
- en: 'Now, we need to add the callback methods for our `trace()` and `bind()` commands.
    Start with `_set_focus_update_var()`, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的`trace()`和`bind()`命令添加回调方法。首先从`_set_focus_update_var()`开始，如下所示：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method simply gets the widget's current value and, if there is a `focus_update_var` argument
    present in the instance, sets it to the same value. Note that we don't set the
    value if there's an error currently present on the widget. It wouldn't make sense
    to update the value to something invalid.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是简单地获取小部件的当前值，并且如果实例中存在`focus_update_var`参数，则将其设置为相同的值。请注意，如果小部件当前存在错误，我们不会设置值。将值更新为无效值是没有意义的。
- en: When Tkinter calls a `bind` callback, it passes in an event object that contains
    information about the event that triggered the callback. Even if you aren't going
    to use this information, your function or method needs to be able to take this
    argument.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当Tkinter调用`bind`回调时，它传递一个包含有关触发回调的事件的信息的事件对象。即使您不打算使用这些信息，您的函数或方法也需要能够接受此参数。
- en: 'Now, let''s create the callback for setting the minimum, as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建设置最小值的回调，如下所示：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first thing we do is retrieve the current value. `Tkinter.Spinbox` has the
    slightly annoying behavior of correcting its value when the `to` or `from` values
    are changed, moving too-low values to the `from` value and too-high values to
    the `to` value. This kind of silent auto-correction might slip past the attention
    of our user and cause bad data to be saved. What we want is to leave the value
    out of range and mark it as an error; so to work around Tkinter, we're going to
    save the current value, change the configuration, and then put the original value
    back in the field.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是检索当前值。`Tkinter.Spinbox`在更改`to`或`from`值时有稍微让人讨厌的行为，将太低的值移动到`from`值，将太高的值移动到`to`值。这种悄悄的自动校正可能会逃过我们用户的注意，导致坏数据被保存。我们希望的是将值留在范围之外，并将其标记为错误；因此，为了解决Tkinter的问题，我们将保存当前值，更改配置，然后将原始值放回字段中。
- en: With the current value saved, we attempt to get the value of the `min_var` and
    set our widget's `from_` value from it. There are several things that could go
    wrong here, such as a blank or invalid value in whatever field controls our minimum
    and maximum variables, all of which should throw either a `tk.TclError` or a `ValueError`.
    In either case, we'll just do nothing.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前值后，我们尝试获取`min_var`的值，并从中设置我们的小部件的`from_`值。这里可能会出现几种问题，例如控制我们的最小和最大变量的字段中有空白或无效值，所有这些都应该引发`tk.TclError`或`ValueError`。在任何一种情况下，我们都不会做任何事情。
- en: It's generally a bad idea to just silence exceptions; however, in this case,
    there's nothing we can reasonably do if the variable is bad except ignore it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只是消除异常是一个坏主意；然而，在这种情况下，如果变量有问题，我们无法合理地做任何事情，除了忽略它。
- en: Now, we just need to write the current value that we saved back into the field.
    If it's empty, we just delete the field; otherwise, we set the input's variable. 
    The method ends with a call to the `trigger_focusout_validation()` method to re-check
    the value in the field against the new minimum.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要将我们保存的当前值写回字段。如果为空，我们只需删除字段；否则，我们设置输入的变量。该方法以调用`trigger_focusout_validation()`方法结束，以重新检查字段中的值与新最小值的匹配情况。
- en: The `_set_maximum()` method will be identical to this method, except that it
    will update the `to` value using `max_var` instead.  You can write it yourself,
    or see the sample code included with the book.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_set_maximum()`方法将与此方法相同，只是它将使用`max_var`来更新`to`值。您可以自己编写它，或者查看本书附带的示例代码。'
- en: There is one last change we need to make to our `ValidatedSpinbox` class. Since
    our maximum can potentially change after entry, and we're relying on our `focusout`
    validation to detect that, we'll need to add some conditions to check the maximum.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对我们的`ValidatedSpinbox`类进行最后一个更改。由于我们的最大值可能在输入后更改，并且我们依赖于我们的`focusout`验证来检测它，我们需要添加一些条件来检查最大值。
- en: 'We need to add this to the  `_focusout_validate()` method:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将这个添加到`_focusout_validate()`方法中：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add those lines just before the `return` statement to check the maximum value
    and set the error, as appropriate.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`return`语句之前添加这些行以检查最大值并根据需要设置错误。
- en: Updating our form
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的表单
- en: 'Now that our widgets are all made, it''s time to make the form use them by
    performing the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的小部件都已经制作好了，是时候通过执行以下步骤让表单使用它们了：
- en: 'Scroll down to the `DataRecordForm` class constructor, and we''ll start updating
    our widgets one row at a time. Line 1 is fairly straightforward:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动到`DataRecordForm`类构造函数，并且我们将逐行更新我们的小部件。第1行非常简单：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s as simple as swapping out the `input_class` value in each `LabelInput`
    for our new class. Go ahead and run your application and try out the widgets.
    Try some different valid and invalid dates, and see how the `Combobox` widget
    works (`RequiredEntry` won''t do much at this point, since the only visible indication
    is red text, and there''s no text to mark red if it''s empty; we''ll address that
    later on). Now, on to line 2, first add the `Lab` widget, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LabelInput`中的`input_class`值替换为我们的新类就像交换一样简单。继续运行你的应用程序并尝试小部件。尝试一些不同的有效和无效日期，并查看`Combobox`小部件的工作方式（`RequiredEntry`在这一点上不会有太多作用，因为唯一可见的指示是红色文本，如果为空，就没有文本标记为红色；我们稍后会解决这个问题）。现在，转到第2行，首先添加`Lab`小部件，如下所示：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, add the `Plot` widget, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`Plot`小部件，如下所示：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Fairly straightforward again, but if you run it, you'll find there's a problem
    with `Plot`. It turns out that our `ValidatedComobox` method doesn't work right
    when the values are integers since the characters the user types are always strings
    (even if they're digits); we can't compare strings and integers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次相当简单，但如果您运行它，您会发现`Plot`存在问题。事实证明，当值为整数时，我们的`ValidatedComobox`方法无法正常工作，因为用户键入的字符始终是字符串（即使它们是数字）；我们无法比较字符串和整数。
- en: 'If you think about it, `Plot` shouldn''t really be an integer value. Yes, the
    values are technically integers, but as we decided back in Chapter 3, *Creating
    Basic Forms with Tkinter and ttk Widgets,* they could as well be letters or symbols;
    you wouldn''t do maths on a plot number. So, we''ll change `Plot` to use a `StringVar` variable
    and make the values of the widget strings as well. Change the `Plot` widget creation,
    as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您考虑一下，`Plot`实际上不应该是一个整数值。是的，这些值在技术上是整数，但正如我们在第3章*使用Tkinter和ttk小部件创建基本表单*中决定的那样，它们也可以是字母或符号；您不会在一个图表号上进行数学运算。因此，我们将更改`Plot`以使用`StringVar`变量，并将小部件的值也更改为字符串。更改`Plot`小部件的创建如下所示：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we're just changing the `input_var` to a `StringVar` and using a list
    comprehension to cast every `values` item to a string. Now, `Plot` works as expected.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只是将`input_var`更改为`StringVar`，并使用列表推导将每个`values`项转换为字符串。现在，`Plot`的工作正常了。
- en: 'Continue through the form, replacing the default `ttk` widgets with your newly
    validated versions. For the `Spinbox` widget, make sure you''re passing in the
    `to`, `from_`, and `increment` values as strings rather than integers. For instance,
    the `Humidity` widget should be as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过表单，用新验证的版本替换默认的`ttk`小部件。对于`Spinbox`小部件，请确保将`to`、`from_`和`increment`值作为字符串而不是整数传递。例如，`Humidity`小部件应该如下所示：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we get to the `Height` boxes, it''s time to put our `min_var` and `max_var`
    features to the test. First, we need to set up variables to store the minimum
    and maximum height, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们到达`Height`框时，是时候测试我们的`min_var`和`max_var`功能了。首先，我们需要设置变量来存储最小和最大高度，如下所示：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We create two new `DoubleVar` objects to hold the current minimum and maximum
    heights, setting them to infinite values to begin with. This ensures there will
    be effectively no minimum or maximum height to start with.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建两个新的`DoubleVar`对象来保存当前的最小和最大高度，将它们设置为无限值。这确保一开始实际上没有最小或最大高度。
- en: Note that our widgets won't be affected by these values until they actually
    change, so they won't nullify the original `to` and `from_` values passed in.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的小部件直到它们实际更改才会受到这些值的影响，因此它们不会使传入的原始`to`和`from_`值无效。
- en: 'Now, we create the `Min Height` widget, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建`Min Height`小部件，如下所示：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll use `max_height_var` to set the maximum here, ensuring that our minimum
    will never go above the maximum value, and set the `focus_update_var` to `min_height_var` values
    so that it will be updated whenever this field is changed. Now, the `Max Height`
    widget is as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`max_height_var`在此处设置最大值，确保我们的最小值永远不会超过最大值，并将`focus_update_var`设置为`min_height_var`的值，以便在更改此字段时它将被更新。现在，`Max
    Height`小部件如下所示：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This time, we use our `min_height_var` variable to set the widget''s minimum
    value and update the `max_height_var` from the widget''s current value. Finally,
    the `Median Height` field is as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次，我们使用我们的`min_height_var`变量来设置小部件的最小值，并从小部件的当前值更新`max_height_var`。最后，`Median
    Height`字段如下所示：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we're setting the minimum and maximum values for the field from the `min_height_var`
    and `max_height_var` variables, respectively. We're not updating any variables
    from the `Median Height` field, although we could add additional variables and
    code here to make sure that `Min Height` couldn't go above it or `Max Height`
    below it. In most cases, it won't matter if the user is entering data in order
    since `Median Height` is last.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们分别从`min_height_var`和`max_height_var`变量设置字段的最小和最大值。我们不会更新任何来自`Median Height`字段的变量，尽管我们可以在这里添加额外的变量和代码，以确保`Min
    Height`不会超过它，或者`Max Height`不会低于它。在大多数情况下，如果用户按顺序输入数据，`Median Height`就不重要了。
- en: 'You might wonder why we don''t just use the `input_var` variables from `Min
    Height` and `Max Height` to hold these values instead. If you try this, you''ll
    discover the reason: the `input_var` updates as you type, which means your partial
    value instantly becomes the new maximum or minimum value. We''d rather wait until
    the user has committed the value to assign this, and thus we created a separate
    variable that is only updated on `focusout`.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们不直接使用`Min Height`和`Max Height`中的`input_var`变量来保存这些值。如果您尝试这样做，您会发现原因：`input_var`会随着您的输入而更新，这意味着您的部分值立即成为新的最大值或最小值。我们宁愿等到用户提交值后再分配这个值，因此我们创建了一个只在`focusout`时更新的单独变量。
- en: Displaying errors
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示错误
- en: 'If you run the application, you may notice that while fields with the `focusout`
    errors turn red, we don''t get to see the actual error. We need to fix this by
    performing the following steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您可能会注意到，虽然`focusout`错误的字段变红，但我们无法看到实际的错误。我们需要通过执行以下步骤来解决这个问题：
- en: 'Locate your `LabelInput` class, and add the following code to the end of the
    constructor method:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您的`LabelInput`类，并将以下代码添加到构造方法的末尾：
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we check to see if our input has an error variable, and if not, we create
    one. We save a reference to it as `self.error`, then create a `Label` with the
    error as `textvariable`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们检查我们的输入是否有错误变量，如果没有，我们就创建一个。我们将它保存为`self.error`的引用，然后创建一个带有错误的`textvariable`的`Label`。
- en: Finally, we place this under the input widget.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将这个放在输入小部件下面。
- en: Now, when you try the application, you should be able to see the field errors.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您尝试应用程序时，您应该能够看到字段错误。
- en: Preventing form submission on error
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止表单在出现错误时提交
- en: 'The final step in preventing errors from getting into our CSV file is to stop
    the application from saving if the form has known errors. Let''s perform the following
    steps to do this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止错误进入CSV文件的最后一步是，如果表单存在已知错误，则停止应用程序保存。让我们执行以下步骤来做到这一点：
- en: The first step in implementing this is to provide a way for the `Application`
    object (which handles saving the data) to retrieve the error status from the `DataRecordForm`
    object.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施这一步的第一步是为`Application`对象（负责保存数据）提供一种从`DataRecordForm`对象检索错误状态的方法。
- en: 'At the end of the `DataRecordForm` class, add the following method:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataRecordForm`类的末尾，添加以下方法：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Similar to how we handled getting the data, we just loop through the `LabelFrame`
    widgets. We look for inputs that have the `trigger_focusout_validation` method
    and call it, just to be sure that all values have been checked. Then, if the widget's
    `error` variable has any value, we add it to an `errors` dictionary. This way,
    we can retrieve a dictionary of field names and the errors on each field.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们处理数据的方式类似，我们只需循环遍历`LabelFrame`小部件。我们寻找具有`trigger_focusout_validation`方法的输入，并调用它，以确保所有值都已经被检查。然后，如果小部件的`error`变量有任何值，我们将其添加到一个`errors`字典中。这样，我们可以检索每个字段的字段名称和错误的字典。
- en: Now, we need to add this behavior to the `Application` class's save logic.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将此行为添加到`Application`类的保存逻辑中。
- en: 'Add the following code to the beginning of `on_save()`, under `docstring`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`on_save()`的开头添加以下代码，在`docstring`下面：
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This logic is straightforward: get the errors, if we find any, and alert the
    user in the status area and return from the function (thus not saving anything).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑很简单：获取错误，如果我们找到任何错误，就在状态区域警告用户并从函数返回（因此不保存任何内容）。
- en: Start the application and try it out by trying to save a blank form. You should
    get error messages in all fields and a message at the bottom telling you which
    fields have errors.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试保存一个空白表单。您应该在所有字段中收到错误消息，并在底部收到一个消息，告诉您哪些字段有错误。
- en: Automating input
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化输入
- en: Preventing users from entering bad data is one way to help users enter better
    data; another approach is to automate. Using our understanding of how the forms
    are likely to be filled out, we can insert values that are very likely to be correct
    for certain fields.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 防止用户输入错误数据是帮助用户输入更好数据的一种方式；另一种方法是自动化。利用我们对表单可能如何填写的理解，我们可以插入对于某些字段非常可能是正确的值。
- en: Remember from [Chapter 2](3ec510a4-0919-4f25-9c34-f7bbd4199912.xhtml), *Designing
    GUI Applications with Tkinter,* that the forms are nearly always recorded the
    same day that they're filled out, and that they're filled out one at a time from
    `Plot` 1 to `Plot` 20 in order. Also remember that the `Date`, `Lab`, and `Technician`
    values remain the same for each form which is filled in. Let's automate this for
    our users.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住[第2章](3ec510a4-0919-4f25-9c34-f7bbd4199912.xhtml)中提到的，*使用Tkinter设计GUI应用程序*，表单几乎总是在填写当天录入，并且按顺序从`Plot`
    1到`Plot` 20依次填写。还要记住，`Date`，`Lab`和`Technician`的值对每个填写的表单保持不变。让我们为我们的用户自动化这个过程。
- en: Inserting a date
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入日期
- en: Inserting the current date is an easy place to start. The place to do this is
    in the `DataRecordForm.reset()` method, which sets up the form for entering a
    new record.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 插入当前日期是一个简单的开始地方。这个地方是在`DataRecordForm.reset()`方法中，该方法设置了输入新记录的表单。
- en: 'Update that method as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新该方法：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Just as we do in the `Application.save()` method, we get the current date from
    `datetime.today()` and format it as an ISO date. Then, we set the `Date` widget's
    input to that value.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`Application.save()`方法中所做的那样，我们从`datetime.today()`获取当前日期并将其格式化为ISO日期。然后，我们将`Date`小部件的输入设置为该值。
- en: Automating Lab, Time, and Technician
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化Lab，Time和Technician
- en: 'Something which is slightly more complex is our handling of `Lab`, `Time`,
    and `Technician`. Let''s review the logic as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微复杂一些的是我们对`Lab`，`Time`和`Technician`的处理。让我们按照以下逻辑进行审查：
- en: Before clearing the data, save the `Lab`, `Time`, and `Technician` values.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清除数据之前，保存`Lab`，`Time`和`Technician`的值。
- en: If `Plot` is less than the last value (`20`), we'll put those values back after
    clearing all the fields, then increment to the next `Plot` value.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Plot`小于最后一个值（`20`），我们将在清除所有字段后将这些值放回，然后增加到下一个`Plot`值。
- en: 'If `Plot` is the last value or no value, leave those fields blank. The code
    is as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Plot`是最后一个值或没有值，则将这些字段留空。代码如下：
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because `Plot` looks like an integer, it might be tempting to increment it like
    one, but it's better to work with it as though it were not. We use the indexes
    of the values list instead.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Plot`看起来像一个整数，可能会诱人像增加一个整数一样增加它，但最好将其视为非整数。我们使用值列表的索引。
- en: 'One last tweak, the focus of the form always starts in the first field, but
    this means the user has to tab through fields that are already filled in. It would
    be nice if the next empty inputs were focused at the start instead. Tkinter inputs
    have a `focus()` method, which gives them keyboard focus. Depending on which fields
    we''ve filled in, this will either be `Time` or `Seed sample`. Under the line
    that sets the `Date` value, add the following code line:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个微调，表单的焦点始终从第一个字段开始，但这意味着用户必须通过已经填写的字段进行标签。如果下一个空输入从一开始就聚焦，那将是很好的。Tkinter输入有一个`focus()`方法，它可以给它们键盘焦点。根据我们填写的字段，这要么是`Time`，要么是`Seed
    sample`。在设置`Date`值的下一行下面，添加以下代码行：
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And under the line that sets the `Plot` value, inside the conditional block,
    add the following line of code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置`Plot`值的行下面，在条件块内，添加以下代码行：
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our form is now ready for a trial run with our users. It's definitely an improvement
    over the CSV entry at this point, and will help data entry to make quick work
    of those forms.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单现在已经准备好与用户进行试运行。在这一点上，它绝对比CSV输入有所改进，并将帮助数据输入快速完成这些表单。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The application has really come a long way. In this chapter, we learned about
    Tkinter validation, created a validation mixin class, and used it to create validated
    versions of the `Entry`, `Combobox`, and `Spinbox` widgets. We validated different
    kinds of data on keystrokes and focus events, and created fields that dynamically
    update their constraints based on the value of related fields.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经取得了长足的进步。在本章中，我们学习了Tkinter验证，创建了一个验证混合类，并用它来创建`Entry`，`Combobox`和`Spinbox`小部件的验证版本。我们在按键和焦点事件上验证了不同类型的数据，并创建了根据相关字段的值动态更新其约束的字段。
- en: In the next chapter, we're going to prepare our code base for expansion and
    learn how to organize a large application for easier maintenance. More specifically,
    we'll learn about the MVC pattern and how to structure our code in multiple files
    for simpler maintenance. We'll also learn more about RST and and version control
    software.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将准备我们的代码基础以便扩展，并学习如何组织一个大型应用程序以便更容易维护。更具体地说，我们将学习MVC模式以及如何将我们的代码结构化为多个文件，以便更简单地进行维护。我们还将更多地了解RST和版本控制软件。
