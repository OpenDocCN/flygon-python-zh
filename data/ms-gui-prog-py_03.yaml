- en: Building Forms with QtWidgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QtWidgets构建表单
- en: One of the first steps in application development is prototyping your app's
    GUI. With a wide range of ready-to-use widgets, PyQt makes this very easy. Best
    of all, we can move our prototype code directly into an actual application when
    we're done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发的第一步之一是原型设计应用程序的GUI。有了各种各样的现成小部件，PyQt使这变得非常容易。最重要的是，当我们完成后，我们可以直接将我们的原型代码移植到实际应用程序中。
- en: 'In this chapter, we''re going to get familiar with basic form design over the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将通过以下主题熟悉基本的表单设计：
- en: Creating basic QtWidgets widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的QtWidgets小部件
- en: Placing and arranging widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放置和排列小部件
- en: Validating widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证小部件
- en: Building a calendar application GUI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个日历应用程序的GUI
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you'll need everything from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, plus the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter02](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter02).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要从[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml) *PyQt入门*中获取所有内容，以及来自[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter02](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter02)的示例代码。
- en: Check out the following video to see the code in action: [http://bit.ly/2M2R26r](http://bit.ly/2M2R26r)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：[http://bit.ly/2M2R26r](http://bit.ly/2M2R26r)
- en: Creating basic QtWidgets widgets
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的QtWidgets小部件
- en: The `QtWidgets` module contains dozens of widgets, some simple and standard,
    others complex and unique. In this section, we're going to go through eight of
    the most common widgets and their basic usage.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtWidgets`模块包含数十个小部件，有些简单和标准，有些复杂和独特。在本节中，我们将介绍八种最常见的小部件及其基本用法。'
- en: Before starting this section, make a copy of your application template from
    [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started with
    PyQt*, and save it to a file called `widget_demo.py`. As we go through the examples,
    you can add them into your `MainWindow.__init__()` method to see how the objects
    work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，从[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml) *PyQt入门*中复制您的应用程序模板，并将其保存到名为`widget_demo.py`的文件中。当我们逐个示例进行时，您可以将它们添加到您的`MainWindow.__init__()`方法中，以查看这些对象的工作方式。
- en: QWidget
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QWidget
- en: '`QWidget` is the parent class of all other widgets, so any properties and methods
    it has will also be available in any other widget. By itself, a `QWidget` object
    can be useful as a container for other widgets, a filler to fill blank areas,
    or as a base class for top-level windows.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget`是所有其他小部件的父类，因此它拥有的任何属性和方法也将在任何其他小部件中可用。单独使用时，`QWidget`对象可以作为其他小部件的容器，填充空白区域，或作为顶层窗口的基类。'
- en: 'Creating a widget is as simple as this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建小部件就像这样简单：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice we've passed `self` as an argument. If we're creating a widget to be
    placed on or used inside another widget class, as we are here, it's a good idea
    to pass a reference to the parent widget as the first argument. Specifying a parent
    widget will ensure that the child widget is destroyed and cleaned up when the
    parent is, and limit its visibility to inside the parent widget.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们将`self`作为参数传递。如果我们正在创建一个小部件以放置在或在另一个小部件类中使用，就像我们在这里做的那样，将父小部件的引用作为第一个参数传递是一个好主意。指定父小部件将确保在父小部件被销毁和清理时，子小部件也被销毁，并限制其可见性在父小部件内部。
- en: As you learned in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, PyQt also allows us to specify values for any of the widget's
    properties.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中学到的，*PyQt入门*，PyQt也允许我们为任何小部件的属性指定值。
- en: 'For example, we can use the `toolTip` property to set the tooltip text (which
    will pop up when the widget has hovered with the mouse) for this widget:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`toolTip`属性来设置此小部件的工具提示文本（当鼠标悬停在小部件上时将弹出）：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Read the C++ documentation for `QWidget` (found at [https://doc.qt.io/qt-5/qwidget.html](https://doc.qt.io/qt-5/qwidget.html))
    and note the class's properties. Note that each property has a specified data
    type. In this case, `toolTip` requires `QString`. We can use a regular Unicode
    string whenever `QString` is required because PyQt translates it for us. For more
    esoteric data types, such as `QSize` or `QColor`, we would need to create the
    appropriate object. Be aware that these conversions are happening in the background,
    however, as Qt is not forgiving about data types.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读`QWidget`的C++文档（位于[https://doc.qt.io/qt-5/qwidget.html](https://doc.qt.io/qt-5/qwidget.html)）并注意类的属性。请注意，每个属性都有指定的数据类型。在这种情况下，`toolTip`需要`QString`。每当需要`QString`时，我们可以使用常规Unicode字符串，因为PyQt会为我们进行转换。然而，对于更奇特的数据类型，如`QSize`或`QColor`，我们需要创建适当的对象。请注意，这些转换是在后台进行的，因为Qt对数据类型并不宽容。
- en: 'For example, this code results in an error:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码会导致错误：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This would result in `TypeError` because PyQt won't convert a `bytes` object
    into `QString`. Because of this, make sure you check the data type required by
    a widget's properties or method calls and use a compatible type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`TypeError`，因为PyQt不会将`bytes`对象转换为`QString`。因此，请确保检查小部件属性或方法调用所需的数据类型，并使用兼容的类型。
- en: QWidget as a top-level window
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QWidget作为顶层窗口
- en: 'When a `QWidget` is created without a parent and its `show()` method is called,
    it becomes a top-level window. When we use it as a top-level window, such as we
    do with our `MainWindow` instance, there are some window-specific properties we
    can set. Some of these are shown in the following table:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个没有父级的`QWidget`并调用它的`show()`方法时，它就成为了一个顶层窗口。当我们将其用作顶层窗口时，例如我们在`MainWindow`实例中所做的那样，我们可以设置一些特定于窗口的属性。其中一些显示在下表中：
- en: '| Property | Argument type | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `windowTitle` | string | The title of the window. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `windowTitle` | 字符串 | 窗口的标题。 |'
- en: '| `windowIcon` | `QIcon` | The icon for the window. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `windowIcon` | `QIcon` | 窗口的图标。 |'
- en: '| `modal` | Boolean | Whether the window is modal. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `modal` | 布尔值 | 窗口是否为模态。 |'
- en: '| `cursor` | `Qt.CursorShape` | The cursor used when this widget has hovered.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `cursor` | `Qt.CursorShape` | 当小部件悬停时使用的光标。 |'
- en: '| `windowFlags` | `Qt.WindowFlags` | How the OS should treat the window (dialog,
    tooltip, popup). |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `windowFlags` | `Qt.WindowFlags` | 操作系统应如何处理窗口（对话框、工具提示、弹出窗口）。 |'
- en: The argument type for `cursor` is an example of an enum. An enum is simply a
    list of named values, and Qt defines enum anywhere that a property is limited
    to a set of descriptive values. The argument for `windowFlags` is an example of
    a flag. Flags are like enums, except that they can be combined (using the pipe
    operator, `|`) so that multiple flags can be passed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`cursor`的参数类型是枚举的一个例子。枚举只是一系列命名的值，Qt在属性受限于一组描述性值的任何地方定义枚举。`windowFlags`的参数是标志的一个例子。标志类似于枚举，不同之处在于它们可以组合（使用管道运算符`|`），以便传递多个标志。'
- en: In this case, both the enum and flag are part of the `Qt` namespace, found in
    the `QtCore` module. So, for example, to set the cursor to an arrow cursor when
    the widget is hovered over, you'd need to find the right constant in `Qt` that
    refers to the arrow cursor and set the widget's `cursor` property to that value.
    To set flags on the window indicating to the OS that it's a `sheet` and `popup` window,
    you'd need to find the constants in `Qt` that represent those window flags, combine
    them with the pipe, and pass it as the value for `windowFlags`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，枚举和标志都是`Qt`命名空间的一部分，位于`QtCore`模块中。因此，例如，要在小部件悬停时将光标设置为箭头光标，您需要找到`Qt`中引用箭头光标的正确常量，并将小部件的`cursor`属性设置为该值。要在窗口上设置标志，指示操作系统它是`sheet`和`popup`窗口，您需要找到`Qt`中表示这些窗口标志的常量，用管道组合它们，并将其作为`windowFlags`的值传递。
- en: 'Creating such a `QWidget` window might look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样一个`QWidget`窗口可能是这样的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We'll encounter many more flags and enums as we learn to configure Qt widgets
    throughout the rest of this book.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分学习配置Qt小部件时，我们将遇到更多的标志和枚举。
- en: QLabel
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QLabel
- en: '`QLabel` is a `QWidget` object configured to display simple text and images.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLabel`是一个配置为显示简单文本和图像的`QWidget`对象。'
- en: 'Creating one looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice this time that the parent widget is specified as the second argument,
    while the first argument is the text of the label.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次指定的父窗口小部件是第二个参数，而第一个参数是标签的文本。
- en: 'Some commonly used `QLabel` properties are shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了一些常用的`QLabel`属性：
- en: '| Property | Argument | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `text` | string | Text to display on the label. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `text` | string | 标签上显示的文本。 |'
- en: '| `margin` | integer | Space (in pixels) around the text. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `margin` | 整数 | 文本周围的空间（以像素为单位）。 |'
- en: '| `indent` | integer | Space (in pixels) to indent the text. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `indent` | 整数 | 文本缩进的空间（以像素为单位）。 |'
- en: '| `wordWrap` | Boolean | Whether to wrap long lines. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `wordWrap` | 布尔值 | 是否换行。 |'
- en: '| `textFormat` | `Qt.TextFormat` | Force plaintext or rich text, or auto-detect.
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `textFormat` | `Qt.TextFormat` | 强制纯文本或富文本，或自动检测。 |'
- en: '| `pixmap` | `QPixmap` | An image to display instead of the text. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `pixmap` | `QPixmap` | 要显示的图像而不是文本。 |'
- en: 'The label''s text is stored in its `text` property so it can be accessed or
    changed using the related accessor methods, like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的文本存储在其`text`属性中，因此可以使用相关的访问器方法来访问或更改，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`QLabel` can display plaintext, rich text, or an image. Rich text in Qt uses
    an HTML-like syntax; by default, the label will automatically detect whether your
    string contains any formatting tags and display the appropriate type of text accordingly.
    For example, if we wanted to make our label boldface and add a margin around the
    text, we could do so like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLabel`可以显示纯文本、富文本或图像。Qt中的富文本使用类似HTML的语法；默认情况下，标签将自动检测您的字符串是否包含任何格式标记，并相应地显示适当类型的文本。例如，如果我们想要使我们的标签加粗并在文本周围添加边距，我们可以这样做：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will learn more about using images, rich text, and fonts in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications,* and [Chapter 11](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml),
    *Creating Rich Text with QTextDocument*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml) *Qt应用程序样式*和[第11章](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml)
    *使用QTextDocument创建富文本*中学习更多关于使用图像、富文本和字体的知识。
- en: QLineEdit
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QLineEdit
- en: 'The `QLineEdit` class is a single-line text-entry widget that you might commonly
    use in a data-entry or login form. `QLineEdit` can be called with no arguments,
    with only a parent widget, or with a default string value as the first argument,
    like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLineEdit`类是一个单行文本输入小部件，您可能经常在数据输入或登录表单中使用。`QLineEdit`可以不带参数调用，只带有父窗口小部件，或者将默认字符串值作为第一个参数，如下所示：'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are also a number of properties we can pass in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多我们可以传递的属性：
- en: '| Property | Arguments | Description |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `text` | string | The contents of the box. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `text` | string | 盒子的内容。 |'
- en: '| `readOnly` | Boolean | Whether the field can be edited. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `readOnly` | 布尔值 | 字段是否可编辑。 |'
- en: '| `clearButtonEnabled` | Boolean | Whether a clear button is added. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `clearButtonEnabled` | 布尔值 | 是否添加清除按钮。 |'
- en: '| `placeholderText` | string | Text that will appear when the field is empty.
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `placeholderText` | string | 字段为空时显示的文本。 |'
- en: '| `maxLength` | integer | The maximum number of characters that can be entered.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `maxLength` | 整数 | 可输入的最大字符数。 |'
- en: '| `echoMode` | `QLineEdit.EchoMode` | Switches the way text is displayed as
    its entered (such as for password entry). |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `echoMode` | `QLineEdit.EchoMode` | 切换文本输入时显示方式（例如用于密码输入）。 |'
- en: 'Let''s add some properties to our line edit widget:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的行编辑小部件添加一些属性：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will populate the widget with a default text of `'default value'`. It will
    display a placeholder string of `'Type here'` when the field is empty or a small
    `X` button that clears the field when it has text in it. It also limits the number
    of characters that can be typed to `20`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用默认文本'默认值'填充小部件。当字段为空或有一个清除字段的小`X`按钮时，它将显示一个占位符字符串'在此输入'。它还限制了可以输入的字符数为`20`。
- en: QPushButton and other buttons
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QPushButton和其他按钮
- en: '`QPushButton` is a simple, clickable button widget. Like `QLabel` and `QLineEdit`,
    it can be called with a first argument that specifies the text on the button,
    like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPushButton`是一个简单的可点击按钮小部件。与`QLabel`和`QLineEdit`一样，它可以通过第一个参数调用，该参数指定按钮上的文本，如下所示：'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some of the more useful properties we can set on `QPushButton` include the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`QPushButton`上设置的一些更有用的属性包括以下内容：
- en: '| Property | Arguments | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `checkable` | Boolean | Whether the button stays on when pressed. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '`checkable` | 布尔值 | 按钮是否在按下时保持开启状态。'
- en: '| `checked` | Boolean | For `checkable` buttons, whether the button is checked.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '`checked` | 布尔值 | 对于`checkable`按钮，按钮是否被选中。'
- en: '| `icon` | `QIcon` | An icon image to display on the button. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '`icon` | `QIcon` | 要显示在按钮上的图标图像。'
- en: '| `shortcut` | `QKeySequence` | A keyboard shortcut that will activate the
    button. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '`shortcut` | `QKeySequence` | 一个激活按钮的键盘快捷键。'
- en: 'The `checkable` and `checked` properties allow us to use this button as a toggle
    button that reflects an on/off state, rather than just a click button that performs
    an action. All of these properties come from the `QPushButton` class''s parent
    class, `QAbstractButton`. This is also the parent class of several other button
    classes, listed here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkable`和`checked`属性允许我们将此按钮用作反映开/关状态的切换按钮，而不仅仅是执行操作的单击按钮。所有这些属性都来自`QPushButton`类的父类`QAbstractButton`。这也是其他几个按钮类的父类，列在这里：'
- en: '| Class | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: 类 | 描述
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `QCheckBox` | A checkbox can be Boolean for on/off or tristate for on/partially
    on/off. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '`QCheckBox` | 复选框可以是开/关的布尔值，也可以是开/部分开/关的三态值。'
- en: '| `QRadioButton` | Like checkbox, but only one button among those with the
    same parent can be checked. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`QRadioButton` | 类似复选框，但在具有相同父级的按钮中只能选中一个按钮。'
- en: '| `QToolButton` | Special button for use on toolbar widgets. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '`QToolButton` | 用于工具栏小部件的特殊按钮。'
- en: Though each has some unique features, for the core functionality, these buttons
    are the same in terms of how we create and configure them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个按钮都有一些独特的特性，但在核心功能方面，这些按钮在我们创建和配置它们的方式上是相同的。
- en: 'Let''s make our button checkable, check it by default, and give it a shortcut:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的按钮设置为可选中，默认选中，并给它一个快捷键：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `shortcut` option requires us to pass in a `QKeySequence`, which
    is part of the `QtGui` module. This is a good example of how property arguments
    often need to be wrapped in some kind of utility class. `QKeySequence` encapsulates
    a key combination, in this case, the *Ctrl* key (or *command* key, on macOS) and
    *P*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`shortcut`选项要求我们传入一个`QKeySequence`，它是`QtGui`模块的一部分。这是一个很好的例子，说明属性参数通常需要包装在某种实用类中。`QKeySequence`封装了一个键组合，这里是*Ctrl*键（或macOS上的*command*键）和*P*。
- en: Key sequences can be specified as a string, such as the preceding example, or
    by using enum values from the `QtCOre.Qt` module. For example, we could write
    the preceding as `QKeySequence(qtc.Qt.CTRL + qtc.Qt.Key_P)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 键序列可以指定为字符串，例如前面的示例，也可以使用`QtCOre.Qt`模块中的枚举值。例如，我们可以将前面的示例写为`QKeySequence(qtc.Qt.CTRL
    + qtc.Qt.Key_P)`。
- en: QComboBox
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QComboBox
- en: A **combobox**, also known as a dropdown or select widget, is a widget that
    presents a list of options when clicked on, one of which must be selected. `QCombobox`
    can optionally allow text input for custom answers by setting its `editable` property
    to `True`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**combobox**，也称为下拉或选择小部件，是一个在点击时呈现选项列表的小部件，其中必须选择一个选项。`QCombobox`可以通过将其`editable`属性设置为`True`来允许文本输入自定义答案。'
- en: 'Let''s create a `QCombobox` object like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`QCombobox`对象，如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Right now, our `combobox` has no items in its menu. `QCombobox` doesn''t provide
    a way to initialize the widget with options in the constructor; instead, we have
    to create the widget, then use the `addItem()` or `insertItem()` method to populate
    its menu with options, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`combobox`菜单中没有项目。`QCombobox`在构造函数中不提供使用选项初始化小部件的方法；相反，我们必须创建小部件，然后使用`addItem()`或`insertItem()`方法来填充其菜单选项，如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `addItem()` method takes a string for the label and a data value. As you
    can see, this value can be anything—an integer, a string, a Python class. This
    value can be retrieved for the currently selected item using the `QCombobox` object's
    `currentData()` method. It's typically a good idea—though not required—to make
    all the item values be of the same type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`addItem()`方法接受标签和数据值的字符串。正如你所看到的，这个值可以是任何东西——整数，字符串，Python类。可以使用`QCombobox`对象的`currentData()`方法检索当前选定项目的值。通常最好——尽管不是必需的——使所有项目的值都是相同类型的。'
- en: '`addItem()` will always append items to the end of the menu; to insert them
    earlier, use the `insertItem()` method. It works exactly the same, except that
    it takes an index (integer value) for the first argument. The item will be inserted
    at that index in the list. If we want to save time and don''t need a `data` property
    for our items, we can also use `addItems()` or `insertItems()` to pass in a list
    of options.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`addItem()`将始终将项目附加到菜单的末尾；要在之前插入它们，使用`insertItem()`方法。它的工作方式完全相同，只是它接受一个索引（整数值）作为第一个参数。项目将插入到列表中的该索引处。如果我们想节省时间，不需要为我们的项目设置`data`属性，我们也可以使用`addItems()`或`insertItems()`传递一个选项列表。'
- en: 'Some other important properties for `QComboBox` include the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`QComboBox`的一些其他重要属性包括以下内容：'
- en: '| Property | Arguments | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `currentData` | (anything) | The data object of the currently selected item.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '`currentData` | （任何） | 当前选定项目的数据对象。'
- en: '| `currentIndex` | integer | The index of the currently selected item. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '`currentIndex` | 整数 | 当前选定项目的索引。'
- en: '| `currentText` | string | The text of the currently selected item. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '`currentText` | string | 当前选定项目的文本。'
- en: '| `editable` | Boolean | Whether `combobox` allows text entry. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '`editable` | 布尔值 | `combobox`是否允许文本输入。'
- en: '| `insertPolicy` | `QComboBox.InsertPolicy` | Where entered items should be
    inserted in the list. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '`insertPolicy` | `QComboBox.InsertPolicy` | 输入的项目应该插入列表中的位置。'
- en: The data type for `currentData` is `QVariant`, a special Qt class that acts
    as a container for any kind of data. These are more useful in C++, as they provide
    a workaround for static typing in situations where multiple data types might be
    useful. PyQt automatically converts `QVariant` objects to the most appropriate
    Python type, so we rarely need to work directly with this type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentData`的数据类型是`QVariant`，这是Qt的一个特殊类，用作任何类型数据的容器。在C++中更有用，因为它们为多种数据类型可能有用的情况提供了一种绕过静态类型的方法。PyQt会自动将`QVariant`对象转换为最合适的Python类型，因此我们很少需要直接使用这种类型。'
- en: 'Let''s update our `combobox` so that we can add items to the top of the dropdown:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`combobox`，以便我们可以将项目添加到下拉列表的顶部：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now this `combobox` will allow any text to be typed in; the text will be added
    to the top of the list box. The `data` property for the new items will be `None`,
    so this is really only appropriate if we are working with the visible strings
    only.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个`combobox`将允许输入任何文本；文本将被添加到列表框的顶部。新项目的`data`属性将为`None`，因此这实际上只适用于我们仅使用可见字符串的情况。
- en: QSpinBox
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSpinBox
- en: In general, a spinbox is a text entry with arrow buttons designed to *spin*
    through a set of incremental values. `QSpinbox` is built specifically to handle
    either integers or discrete values (such as a combobox).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，旋转框是一个带有箭头按钮的文本输入，旨在*旋转*一组递增值。`QSpinbox`专门用于处理整数或离散值（例如下拉框）。
- en: 'Some useful `QSpinBox` properties include the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的`QSpinBox`属性包括以下内容：
- en: '| Property | Arguments | Description |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `value` | integer | The current spinbox value, as an integer. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `value` | 整数 | 当前旋转框值，作为整数。 |'
- en: '| `cleanText` | string | The current spinbox value, as a string (excludes the
    prefix and suffix). |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `cleanText` | string | 当前旋转框值，作为字符串（不包括前缀和后缀）。 |'
- en: '| `maximum` | integer | The maximum integer value of the box. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `maximum` | 整数 | 方框的最大整数值。 |'
- en: '| `minimum` | integer | The minimum value of the box. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `minimum` | 整数 | 方框的最小值。 |'
- en: '| `prefix` | string | A string to prepend to the displayed value. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `prefix` | string | 要添加到显示值的字符串。 |'
- en: '| `suffix` | string | A string to append to the displayed value. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `suffix` | string | 要附加到显示值的字符串。 |'
- en: '| `singleStep` | integer | How much to increment or decrement the value when
    the arrows are used. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `singleStep` | 整数 | 当使用箭头时增加或减少值的数量。 |'
- en: '| `wrapping` | Boolean | Whether to wrap from one end of the range to the other
    when the arrows are used. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `wrapping` | 布尔值 | 当使用箭头时是否从范围的一端包装到另一端。 |'
- en: 'Let''s create a `QSpinBox` object in our script, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在脚本中创建一个`QSpinBox`对象，就像这样：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This spinbox starts with a value of `12` and will allow entry of integers from
    `10` to `100`, displayed in the `$<value> + Tax` format. Note that the non-integer
    portion of the box is not editable. Also note that, while the increment and decrement
    arrows move by `5`, nothing prevents us from entering a value that is not a multiple
    of `5`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个旋转框从值`12`开始，并允许输入从`10`到`100`的整数，以`$<value> + Tax`的格式显示。请注意，框的非整数部分不可编辑。还要注意，虽然增量和减量箭头移动`5`，但我们可以输入不是`5`的倍数的值。
- en: '`QSpinBox` will automatically ignore keystrokes that are not numeric, or that
    would put the value outside the acceptable range. If a value is typed that is
    too low, it will be auto-corrected to a valid value when the focus moves from
    the `spinbox`; for example, if you typed `9` into the preceding box and clicked
    out of it, it would be auto-corrected to `90`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSpinBox`将自动忽略非数字的按键，或者会使值超出可接受范围。如果输入了一个太低的值，当焦点从`spinbox`移开时，它将被自动更正为有效值；例如，如果您在前面的框中输入了`9`并单击了它，它将被自动更正为`90`。'
- en: '`QDoubleSpinBox` is identical to `QSpinBox`, but designed for a decimal or
    floating-point numbers.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDoubleSpinBox`与`QSpinBox`相同，但设计用于十进制或浮点数。'
- en: To use `QSpinBox` for discrete text values instead of integers, you need to
    subclass it and override its validation methods. We'll do that later in the *Validating
    widgets* section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`QSpinBox`用于离散文本值而不是整数，您需要对其进行子类化并重写其验证方法。我们将在*验证小部件*部分中进行。
- en: QDateTimeEdit
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QDateTimeEdit
- en: A close relative of the spinbox is `QDateTimeEdit`, designed for entering date-time
    values. By default, it appears as a spinbox that allows the user to tab through
    each field in the date-time value and increment/decrement it using the arrows.
    The widget can also be configured to use a calendar popup.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转框的近亲是`QDateTimeEdit`，专门用于输入日期时间值。默认情况下，它显示为一个旋转框，允许用户通过每个日期时间值字段进行制表，并使用箭头递增/递减它。该小部件还可以配置为使用日历弹出窗口。
- en: 'The more useful properties include the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的属性包括以下内容：
- en: '| Property | Arguments | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `date` | `QDate` or `datetime.date` | The date value. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `date` | `QDate`或`datetime.date` | 日期值。 |'
- en: '| `time` | `QTime` or `datetime.time` | The time value. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `time` | `QTime`或`datetime.time` | 时间值。 |'
- en: '| `dateTime` | `QDateTime` or `datetime.datetime` | The combined date-time
    value. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `dateTime` | `QDateTime`或`datetime.datetime` | 组合的日期时间值。 |'
- en: '| `maximumDate`, `minimumDate` | `QDate` or `datetime.date` | The maximum and
    minimum date enterable. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `maximumDate`，`minimumDate` | `QDate`或`datetime.date` | 可输入的最大和最小日期。 |'
- en: '| `maximumTime`, `minimumTime` | `QTime` or `datetime.time` | The maximum and
    minimum time enterable. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `maximumTime`，`minimumTime` | `QTime`或`datetime.time` | 可输入的最大和最小时间。 |'
- en: '| `maximumDateTime`, `minimumDateTime` | `QDateTime` or `datetime.datetime`
    | The maximum and minimum date-time enterable. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `maximumDateTime`，`minimumDateTime` | `QDateTime`或`datetime.datetime` | 可输入的最大和最小日期时间。
    |'
- en: '| `calendarPopup` | Boolean | Whether to display the calendar popup or behave
    like a spinbox. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `calendarPopup` | 布尔值 | 是否显示日历弹出窗口或像旋转框一样行为。 |'
- en: '| `displayFormat` | string | How the date-time should be formatted. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `displayFormat` | string | 日期时间应如何格式化。 |'
- en: 'Let''s create our date-time box like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像这样创建我们的日期时间框：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This date-time widget will be created with the following attributes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日期时间小部件将使用以下属性创建：
- en: It will be set to 12:30 on the current date
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期将设置为12:30
- en: It will show the calendar popup when focused
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当焦点集中时，它将显示日历弹出窗口
- en: It will disallow dates after January 1st, 2030
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将禁止在2030年1月1日之后的日期
- en: It will disallow times after 17:00 (5 PM) on the maximum date
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将禁止在最大日期后的17:00（下午5点）之后的时间
- en: It will display date-times in the year-month-day hour-minutes format
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将以年-月-日小时-分钟的格式显示日期时间
- en: Note that `maximumTime` and `minimumTime` only impact the `maximumDate` and
    `minimumDate` values, respectively. So, even though we've specified a maximum
    time of 17:00, nothing prevents you from entering 18:00 as long as it's before
    January 1st, 2030\. The same concept applies to minimum dates and times.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`maximumTime`和`minimumTime`只影响`maximumDate`和`minimumDate`的值，分别。因此，即使我们指定了17:00的最大时间，只要在2030年1月1日之前，您也可以输入18:00。相同的概念也适用于最小日期和时间。
- en: 'The display format for the date-time is set using a string that contains specific
    substitution codes for each item. Some of the more common codes are listed here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 日期时间的显示格式是使用包含每个项目的特定替换代码的字符串设置的。这里列出了一些常见的代码：
- en: '| Code | Meaning |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 意义 |'
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d` | Day of the month. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 月份中的日期。 |'
- en: '| `M` | Month number. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 月份编号。 |'
- en: '| `yy` | Two-digit year. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `yy` | 两位数年份。 |'
- en: '| `yyyy` | Four-digit year. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `yyyy` | 四位数年份。 |'
- en: '| `h` | Hour. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 小时。 |'
- en: '| `m` | Minute. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 分钟。 |'
- en: '| `s` | Second. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 秒。 |'
- en: '| `A` | AM/PM, if used, hour will switch to 12-hour time. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 上午/下午，如果使用，小时将切换到12小时制。 |'
- en: Day, month, hour, minute, and second all default to omitting the leading zero.
    To get a leading zero, just double up the letter (for example, `dd` for a day
    with a leading zero). A complete list of the codes can be found at [https://doc.qt.io/qt-5/qdatetime.html](https://doc.qt.io/qt-5/qdatetime.html).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 日，月，小时，分钟和秒都默认省略前导零。要获得前导零，只需将字母加倍（例如，`dd`表示带有前导零的日期）。代码的完整列表可以在[https://doc.qt.io/qt-5/qdatetime.html](https://doc.qt.io/qt-5/qdatetime.html)找到。
- en: 'Note that all times, dates, and date-times can accept objects from the Python
    standard library''s `datetime` module as well as the Qt types. So, our box could
    just as well have been created like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有时间、日期和日期时间都可以接受来自Python标准库的`datetime`模块以及Qt类型的对象。因此，我们的框也可以这样创建：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Which one you choose to use is a matter of personal preference or situational
    requirements. For instance, if you are working with other Python modules, the `datetime` standard
    library objects are going to be more compatible. If you just need to set a default
    value for a widget, `QDateTime` may be more convenient, since you likely already
    have `QtCore` imported.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择使用哪一个取决于个人偏好或情境要求。例如，如果您正在使用其他Python模块，`datetime`标准库对象可能更兼容。如果您只需要为小部件设置默认值，`QDateTime`可能更方便，因为您可能已经导入了`QtCore`。
- en: If you need more control over the date and time entry, or just want to split
    these up, Qt has the `QTimeEdit` and `QDateEdit` widgets. They're just like this
    widget, except they only handle time and date, respectively.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多对日期和时间输入的控制，或者只是想将它们拆分开来，Qt有`QTimeEdit`和`QDateEdit`小部件。它们就像这个小部件一样，只是分别处理时间和日期。
- en: QTextEdit
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QTextEdit
- en: While `QLineEdit` exists for single-line strings, `QTextEdit` provides us with
    the capability to enter multi-line text. `QTextEdit` is much more than just a
    simple plaintext entry, though; it's a full-blown WYSIWYG editor that can be configured
    to support rich text and images.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`QLineEdit`用于单行字符串，但`QTextEdit`为我们提供了输入多行文本的能力。`QTextEdit`不仅仅是一个简单的纯文本输入，它是一个完整的所见即所得编辑器，可以配置为支持富文本和图像。
- en: 'Some of the more useful properties of `QTextEdit` are shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了`QTextEdit`的一些更有用的属性：
- en: '| Property | Arguments | Description |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `plainText` | string | The contents of the box, in plaintext. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `plainText` | 字符串 | 框的内容，纯文本格式。 |'
- en: '| `html` | string | The contents of the box, as rich text. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `html` | 字符串 | 框的内容，富文本格式。 |'
- en: '| `acceptRichText` | Boolean | Whether the box allows rich text. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `acceptRichText` | 布尔值 | 框是否允许富文本。 |'
- en: '| `lineWrapColumnOrWidth` | integer | The pixel or column at which the text
    will be wrapped. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `lineWrapColumnOrWidth` | 整数 | 文本将换行的像素或列。 |'
- en: '| `lineWrapMode` | `QTextEdit.LineWrapMode` | Whether the line wrap uses columns
    or pixels. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `lineWrapMode` | `QTextEdit.LineWrapMode` | 行换行模式使用列还是像素。 |'
- en: '| `overwriteMode` | Boolean | Whether overwrite is activated; `False` means
    insert mode. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `overwriteMode` | 布尔值 | 是否激活覆盖模式；`False`表示插入模式。 |'
- en: '| `placeholderText` | string | Text to display when the field is empty. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `placeholderText` | 字符串 | 字段为空时显示的文本。 |'
- en: '| `readOnly` | Boolean | Whether the field is read-only. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `readOnly` | 布尔值 | 字段是否只读。 |'
- en: 'Let''s create a text edit like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个文本编辑器，如下所示：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create a plaintext editor that only allows `25` characters to be typed
    per line, with the phrase `'Enter your text here'` displayed when it's empty.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个纯文本编辑器，每行只允许输入`25`个字符，当为空时显示短语`'在此输入您的文本'`。
- en: We'll dig in deeper to the `QTextEdit` and rich text documents in [Chapter 11](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml),
    *Creating Rich Text with QTextDocument*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml)中深入了解`QTextEdit`和富文本文档，*使用QTextDocument创建富文本*。
- en: Placing and arranging widgets
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放置和排列小部件
- en: So far, we've created a lot of widgets, but if you run the program you won't
    see any of them. Although our widgets all belong to the parent window, they haven't
    been placed on it yet. In this section, we'll learn how to arrange our widgets
    in the application window and set them to an appropriate size.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了许多小部件，但如果运行程序，您将看不到它们。虽然我们的小部件都属于父窗口，但它们还没有放置在上面。在本节中，我们将学习如何在应用程序窗口中排列我们的小部件，并将它们设置为适当的大小。
- en: Layout classes
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局类
- en: A layout object defines how child widgets are arranged on a parent widget. Qt
    offers a variety of layout classes, each of which has a layout strategy appropriate
    for different situations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 布局对象定义了子小部件在父小部件上的排列方式。Qt提供了各种布局类，每个类都有适合不同情况的布局策略。
- en: 'The workflow for using layout classes goes like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布局类的工作流程如下：
- en: Create a layout object from an appropriate layout class
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从适当的布局类创建布局对象
- en: Assign the layout object to the parent widget's `layout` property using the
    `setLayout()` method
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setLayout()`方法将布局对象分配给父小部件的`layout`属性
- en: Add widgets to the layout using the layout's `addWidget()` method
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用布局的`addWidget()`方法向布局添加小部件
- en: You can also add layouts to a layout using the `addLayout()` method to create
    more complex arrangements of widgets. Let's take a tour of a few of the basic
    layout classes offered by Qt.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`addLayout()`方法将布局添加到布局中，以创建更复杂的小部件排列。让我们来看看Qt提供的一些基本布局类。
- en: QHBoxLayout and QVBoxLayout
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QHBoxLayout和QVBoxLayout
- en: '`QHBoxLayout` and `QVBoxLayout` are both derived from `QBoxLayout`, a very
    basic layout engine that simply divides the parent into horizontal or vertical
    boxes and places widgets sequentially as they''re added. `QHBoxLayout` is oriented
    horizontally, and widgets are placed from left to right as added. `QVBoxLayout`
    is oriented vertically, and widgets are placed from top to bottom as added.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`QHBoxLayout`和`QVBoxLayout`都是从`QBoxLayout`派生出来的，这是一个非常基本的布局引擎，它简单地将父对象分成水平或垂直框，并按顺序放置小部件。`QHBoxLayout`是水平定向的，小部件按添加顺序从左到右放置。`QVBoxLayout`是垂直定向的，小部件按添加顺序从上到下放置。'
- en: 'Let''s try `QVBoxLayout` on our `MainWindow` widget:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`MainWindow`小部件上尝试`QVBoxLayout`：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the layout object exists, we can start adding our widgets to it using
    the `addWidget()` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦布局对象存在，我们可以使用`addWidget()`方法开始向其中添加小部件：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, if you run the program, the widgets are added one per line.
    If we wanted to add several widgets to a single line, we could nest a layout inside
    our layout, like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果运行程序，小部件将逐行添加。如果我们想要将多个小部件添加到一行中，我们可以像这样在布局中嵌套一个布局：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we've added a horizontal layout to the next cell of our main vertical
    layout and then inserted three more widgets to the sub-layout. These three widgets
    display side by side in a single line of the main layout. Most application layouts
    can be accomplished by simply nesting box layouts in this manner.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在主垂直布局的下一个单元格中添加了一个水平布局，然后在子布局中插入了三个更多的小部件。这三个小部件在主布局的一行中并排显示。大多数应用程序布局可以通过简单地嵌套框布局来完成。
- en: QGridLayout
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QGridLayout
- en: Nested box layouts cover a lot of ground, but in some situations, you might
    like to arrange widgets in uniform rows and columns. This is where `QGridLayout`
    comes in handy. As the name suggests, it allows you to place widgets in a table-like
    structure.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套框布局涵盖了很多内容，但在某些情况下，您可能希望以统一的行和列排列小部件。这就是`QGridLayout`派上用场的地方。顾名思义，它允许您以表格结构放置小部件。
- en: 'Create a grid layout object like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样创建一个网格布局对象：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Adding widgets to `QGridLayout` is similar to the method for the `QBoxLayout`
    classes, but also requires passing coordinates:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 向`QGridLayout`添加小部件类似于`QBoxLayout`类的方法，但还需要传递坐标：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here are the arguments for `QGridLayout.addWidget()`, in order:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`QGridLayout.addWidget()`的参数，顺序如下：
- en: The widget to add
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加的小部件
- en: The row number (vertical coordinate), starting from `0`
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行号（垂直坐标），从`0`开始
- en: The column number (horizontal coordinate), starting from `0`
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列号（水平坐标），从`0`开始
- en: The row span, or how many rows the widget will encompass (optional)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行跨度，或者小部件将包含的行数（可选）
- en: The column span, or how many columns the widget will encompass (optional)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列跨度，或者小部件将包含的列数（可选）
- en: Thus, our `spinbox` widget is placed at row `0`, column `0`, which is the top
    left; our `datetimebox` at row `0`, column `1`, which is the top right; and our
    `textedit` at row `1`, column `0`, and it spans two rows and two columns.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`spinbox`小部件放置在第`0`行，第`0`列，即左上角；我们的`datetimebox`放置在第`0`行，第`1`列，即右上角；我们的`textedit`放置在第`1`行，第`0`列，并且跨越了两行两列。
- en: Keep in mind that the grid layout keeps consistent widths on all columns and
    consistent heights on all rows. Thus, if you place a very wide widget in row `2`,
    column `1`, all widgets in all rows that happen to be in column `1` will be stretched
    accordingly. If you want each cell to stretch independently, use nested box layouts
    instead.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，网格布局保持所有列的宽度一致，所有行的高度一致。因此，如果您将一个非常宽的小部件放在第`2`行，第`1`列，所有行中位于第`1`列的小部件都会相应地被拉伸。如果希望每个单元格独立拉伸，请改用嵌套框布局。
- en: QFormLayout
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QFormLayout
- en: When creating data-entry forms, it's common to have labels next to the input
    widgets they label. Qt provides a convenient two-column grid layout for this situation
    called `QFormLayout`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据输入表单时，通常会在标签旁边放置标签。Qt为这种情况提供了一个方便的两列网格布局，称为`QFormLayout`。
- en: 'Let''s add a form layout to our GUI:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的GUI添加一个表单布局：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Adding widgets can be easily done with the `addRow()` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addRow()`方法可以轻松添加小部件：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This convenience method takes a string and a widget and automatically creates
    the `QLabel` widget for the string. If passed only a single widget (such as a
    `QLabel`), the widget spans both columns. This can be useful for headings or section
    labels.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方便的方法接受一个字符串和一个小部件，并自动为字符串创建`QLabel`小部件。如果只传递一个小部件（如`QLabel`），该小部件跨越两列。这对于标题或部分标签非常有用。
- en: '`QFormLayout` is not just a mere convenience over `QGridLayout`, it also automatically
    provides idiomatic behavior when used across different platforms. For example,
    when used on Windows, the labels are left-justified; when used on macOS, the labels
    are right-justified, keeping with the design guidelines of the platform. Additionally,
    when viewed on a narrow screen (such as a mobile device), the layout automatically
    collapses to a single column with the labels above the input. It''s definitely
    worthwhile to use this layout any time you have a two-column form.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFormLayout`不仅仅是对`QGridLayout`的方便，它还在跨不同平台使用时自动提供成语化的行为。例如，在Windows上使用时，标签是左对齐的；在macOS上使用时，标签是右对齐的，符合平台的设计指南。此外，当在窄屏幕上查看（如移动设备），布局会自动折叠为单列，标签位于输入框上方。在任何需要两列表单的情况下使用这种布局是非常值得的。'
- en: Controlling widget size
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制小部件大小
- en: 'If you run our demo as it currently is and expand it to fill your screen, you''ll
    notice that each cell of the main layout gets evenly stretched to fill the screen,
    as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照当前的设置运行我们的演示并将其扩展以填满屏幕，您会注意到主布局的每个单元格都会均匀拉伸以填满屏幕，如下所示：
- en: '![](assets/2b113c24-8f5f-4608-a786-8a0e4d6b40bd.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2b113c24-8f5f-4608-a786-8a0e4d6b40bd.png)'
- en: This isn't ideal. The label at the top really doesn't need to be expanded, and
    there is a lot of wasted space at the bottom. Presumably, if a user were to expand
    this window, they'd do so to get more space in input widgets like our `QTextEdit`.
    We need to give the GUI some guidance on how to size our widgets, and how to resize
    them in the event that the window is expanded or shrunk from its default size.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。顶部的标签实际上不需要扩展，并且底部有很多空间被浪费。据推测，如果用户要扩展此窗口，他们会这样做以获得更多的输入小部件空间，就像我们的`QTextEdit`。我们需要为GUI提供一些关于如何调整小部件的大小以及在窗口从其默认大小扩展或收缩时如何调整它们的指导。
- en: Controlling the size of widgets can be a bit perplexing in any toolkit, but
    Qt's approach can be especially confusing, so let's take it one step at a time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何工具包中，控制小部件的大小可能会有些令人困惑，但Qt的方法可能尤其令人困惑，因此让我们一步一步来。
- en: 'We can simply set a fixed size for any widget using its `setFixedSize()` method,
    like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用其`setFixedSize()`方法为任何小部件设置固定大小，就像这样：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`setFixedSize` accepts only pixel values, and a widget set to a fixed size
    cannot be altered from those pixel sizes under any circumstances. The problem
    with sizing a widget this way is that it doesn''t account for the possibility
    of different fonts, different text sizes, or changes to the size or layout of
    the application window, which might result in the widget being too small for its
    contents, or needlessly large. We can make it slightly more flexible by setting `minimumSize`
    and `maximumSize`, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFixedSize`仅接受像素值，并且设置为固定大小的小部件在任何情况下都不能改变这些像素大小。以这种方式调整小部件的大小的问题在于它没有考虑不同字体、不同文本大小或应用程序窗口的大小或布局发生变化的可能性，这可能导致小部件对其内容太小或过大。我们可以通过设置`minimumSize`和`maximumSize`使其稍微灵活一些，就像这样：'
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you run this code and resize the window, you'll notice `line_edit` has a
    bit more flexibility as the window expands and contracts. Note, however, that
    the widget won't shrink below its `minimumSize`, but it won't necessarily use
    its `maximumSize`, even if the room is available.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码并调整窗口大小，您会注意到`line_edit`在窗口扩展和收缩时具有更大的灵活性。但是，请注意，小部件不会收缩到其`minimumSize`以下，但即使有空间可用，它也不一定会使用其`maximumSize`。
- en: So, this is still far from ideal. Rather than concern ourselves with how many
    pixels each widget consumes, we'd prefer it be sized sensibly and fluidly with
    respect to its contents and role within the interface. Qt does just this using
    the concepts of *size hints* and *size polices*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这仍然远非理想。与其关心每个小部件消耗多少像素，我们更希望它根据其内容和在界面中的角色合理而灵活地调整大小。Qt正是使用*大小提示*和*大小策略*的概念来实现这一点。
- en: A size hint is a suggested size for a widget and is returned by the widget's
    `sizeHint()` method. This size may be based on a variety of dynamic factors; for
    example, the `QLabel` widget's `sizeHint()` value depends on the length and wrap
    of the text it contains. Because it's a method and not a property, setting a custom
    `sizeHint()` for a widget requires you to subclass the widget and reimplement
    the method. Fortunately, this isn't something we often need to do.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 大小提示是小部件的建议大小，并由小部件的`sizeHint()`方法返回。此大小可能基于各种动态因素；例如，`QLabel`小部件的`sizeHint()`值取决于其包含的文本的长度和换行。由于它是一个方法而不是属性，因此为小部件设置自定义`sizeHint()`需要您对小部件进行子类化并重新实现该方法。幸运的是，这并不是我们经常需要做的事情。
- en: 'A size policy defines how the widget responds to a resizing request with respect
    to its size hint. This is set as the `sizePolicy` property of a widget. Size policies
    are defined in the `QtWidgets.QSizePolicy.Policy` enum, and set separately for
    the horizontal and vertical dimensions of a widget using the `setSizePolicy` accessor
    method. The available policies are listed here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 大小策略定义了小部件在调整大小请求时如何响应其大小提示。这是作为小部件的`sizePolicy`属性设置的。大小策略在`QtWidgets.QSizePolicy.Policy`枚举中定义，并使用`setSizePolicy`访问器方法分别为小部件的水平和垂直尺寸设置。可用的策略在此处列出：
- en: '| Policy | Description |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 策略 | 描述 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Fixed | Never grow or shrink. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 固定 | 永远不要增长或缩小。 |'
- en: '| Minimum | Don''t get smaller than `sizeHint`. Expanding isn''t useful. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 最小 | 不要小于`sizeHint`。扩展并不有用。 |'
- en: '| Maximum | Don''t get larger than `sizeHint`, shrink if necessary. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 最大 | 不要大于`sizeHint`，如果有必要则缩小。 |'
- en: '| Preferred | Try to be `sizeHint`, but shrink if necessary. Expanding isn''t
    useful. This is the default. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 首选 | 尝试是`sizeHint`，但如果有必要则缩小。扩展并不有用。这是默认值。 |'
- en: '| Expanding | Try to be `sizeHint`, shrink if necessary, but expand if at all
    possible. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 扩展 | 尝试是`sizeHint`，如果有必要则缩小，但尽可能扩展。 |'
- en: '| MinimumExpanding | Don''t get smaller than `sizeHint`, but expand if at all
    possible. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 最小扩展 | 不要小于`sizeHint`，但尽可能扩展。 |'
- en: '| Ignored | Forget `sizeHint` altogether, just take up as much space as possible.
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 忽略 | 完全忘记`sizeHint`，尽可能占用更多空间。 |'
- en: 'So, for example, if we''d like the spinbox to stay at a fixed width so the
    widget next to it can expand, we would do this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们希望SpinBox保持固定宽度，以便旁边的小部件可以扩展，我们将这样做：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or, if we''d like our `textedit` widget to fill as much of the screen as possible,
    but never shrink below its `sizeHint()` value, we should set its policies like
    this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们希望我们的`textedit`小部件尽可能填满屏幕，但永远不要缩小到其`sizeHint()`值以下，我们应该像这样设置其策略：
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Sizing widgets can be somewhat unpredictable when you have deeply-nested layouts;
    sometimes it''s handy to be able to override `sizeHint()`. In Python, a quick
    way to do this is with Lambda functions, like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有深度嵌套的布局时，调整小部件的大小可能有些不可预测；有时覆盖`sizeHint()`会很方便。在Python中，可以使用Lambda函数快速实现这一点，就像这样：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that `sizeHint()` must return a `QtCore.QSize` object, not just an integer
    tuple.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sizeHint()`必须返回`QtCore.QSize`对象，而不仅仅是整数元组。
- en: A final way to control the size of widgets when using a box layout is to set
    a `stretch` factor when adding the widget to the layout. Stretch is an optional
    second parameter of `addWidget()` that defines the comparative stretch of each
    widget.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用框布局时，控制小部件大小的最后一种方法是在将小部件添加到布局时设置一个`stretch`因子。拉伸是`addWidget()`的可选第二个参数，它定义了每个小部件的比较拉伸。
- en: 'This example shows the use of the `stretch` factor:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`stretch`因子的使用：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`stretch` only works with the `QHBoxLayout` and `QVBoxLayout` classes.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch`只适用于`QHBoxLayout`和`QVBoxLayout`类。'
- en: In this example, we've added a line edit with a stretch factor of `1`, and a
    second with a stretch factor of `2`. When you run this, you'll find that the second
    line edit is about twice the length of the first.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了一个拉伸因子为`1`的行编辑，和一个拉伸因子为`2`的第二个。当你运行这个程序时，你会发现第二个行编辑的长度大约是第一个的两倍。
- en: Keep in mind that stretch doesn't override the size hint or size policies, so
    depending on those factors the stretch ratios may not be exactly as specified.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，拉伸不会覆盖大小提示或大小策略，因此根据这些因素，拉伸比例可能不会完全按照指定的方式进行。
- en: Container widgets
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器小部件
- en: We have seen that we can use `QWidget` as a container for other widgets. Qt
    also provides us with some special widgets that are specifically designed to contain
    other widgets. We'll look at two of these: `QTabWidget` and `QGroupBox`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以使用`QWidget`作为其他小部件的容器。Qt还为我们提供了一些专门设计用于包含其他小部件的特殊小部件。我们将看看其中的两个：`QTabWidget`和`QGroupBox`。
- en: QTabWidget
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QTabWidget
- en: '`QTabWidget`, sometimes known as a **notebook widget** in other toolkits, allows
    us to have multiple *pages* selectable by tabs. They''re very useful for breaking
    complex interfaces into smaller chunks that are easier for users to take in.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTabWidget`，有时在其他工具包中被称为**笔记本小部件**，允许我们通过选项卡选择多个*页面*。它们非常适用于将复杂的界面分解为更容易用户接受的较小块。'
- en: 'The workflow for using `QTabWidget` is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QTabWidget`的工作流程如下：
- en: Create the `QTabWidget` object
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`QTabWidget`对象
- en: Build a UI page on a `QWidget` or other widget class
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QWidget`或其他小部件类上构建一个UI页面
- en: Add the page to the tab widget using the `QTabWidget.addTab()` method
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QTabWidget.addTab()`方法将页面添加到选项卡小部件
- en: 'Let''s try that; first, create the tab widget:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧；首先，创建选项卡小部件：
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, let''s move the `grid_layout` we built under the *Placing and arranging
    widgets* section to a container widget:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们在*放置和排列小部件*部分下构建的`grid_layout`移动到一个容器小部件下：
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, let''s add our `container` widget to a new tab:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将我们的`container`小部件添加到一个新的选项卡中：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second argument to `addTab()` is the title text that will appear on the
    tab. Subsequent tabs can be added with more calls to `addTab()`, like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTab()`的第二个参数是选项卡上将显示的标题文本。可以通过多次调用`addTab()`来添加更多的选项卡，就像这样：'
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `insertTab()` method can also be used to add new tabs somewhere other than
    the end.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertTab()`方法也可以用于在末尾以外的其他位置添加新的选项卡。'
- en: '`QTabWidget` has a few properties we can customize, listed here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTabWidget`有一些我们可以自定义的属性，列在这里：'
- en: '| Property | Arguments | Description |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `movable` | Boolean | Whether the tabs can be reordered. The default is `False`.
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `movable` | 布尔值 | 选项卡是否可以重新排序。默认值为`False`。 |'
- en: '| `tabBarAutoHide` | Boolean | Whether the tab bar is hidden or shown when
    there is only one tab. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `tabBarAutoHide` | 布尔值 | 当只有一个选项卡时，选项卡栏是隐藏还是显示。 |'
- en: '| `tabPosition` | `QTabWidget.TabPosition` | Which side of the widget the tabs
    appear on. The default is North (top). |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `tabPosition` | `QTabWidget.TabPosition` | 选项卡出现在小部件的哪一侧。默认值为North（顶部）。 |'
- en: '| `tabShape` | `QTabWidget.TabShape` | The shape of the tabs. It can be rounded
    or triangular. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `tabShape` | `QTabWidget.TabShape` | 选项卡的形状。可以是圆角或三角形。 |'
- en: '| `tabsClosable` | Boolean | Whether to display a close button on the tabs.
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `tabsClosable` | 布尔值 | 是否在选项卡上显示一个关闭按钮。 |'
- en: '| `useScrollButtons` | Boolean | Whether to use scroll buttons when there are
    many tabs or to expand. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `useScrollButtons` | 布尔值 | 是否在有许多选项卡时使用滚动按钮或展开。 |'
- en: 'Let''s amend our `QTabWidget` to have movable, triangular tabs on the left
    side of the widget:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`QTabWidget`，使其在小部件的左侧具有可移动的三角形选项卡：
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`QStackedWidget` is similar to the tab widget, except that it contains no built-in
    mechanism for switching pages. You may find it useful if you want to build your
    own tab-switching mechanism.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStackedWidget`类似于选项卡小部件，只是它不包含用于切换页面的内置机制。如果您想要构建自己的选项卡切换机制，您可能会发现它很有用。'
- en: QGroupBox
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QGroupBox
- en: '`QGroupBox` provides a panel that is labeled and (depending on the platform
    style) bordered. It''s useful for grouping related input together on a form. We
    create the `QGroupBox` just as we would create a `QWidget` container, except that
    it can have a border and a title for the box, for example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGroupBox`提供了一个带有标签的面板，并且（取决于平台样式）有边框。它对于在表单上将相关的输入分组在一起非常有用。我们创建`QGroupBox`的方式与创建`QWidget`容器的方式相同，只是它可以有一个边框和一个框的标题，例如：'
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we create a group box with the `Buttons` title. We gave it a horizontal
    layout and added two button widgets.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有`Buttons`标题的分组框。我们给它一个水平布局，并添加了两个按钮小部件。
- en: Notice in this example, instead of giving the layout a handle of its own as
    we've been doing, we create an anonymous `QHBoxLayout` and then use the widget's
    `layout()` accessor method to retrieve a reference to it for adding widgets. You
    may prefer this approach in certain situations.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们没有像以前那样给布局一个自己的句柄，而是创建了一个匿名的`QHBoxLayout`，然后使用小部件的`layout()`访问器方法来检索一个引用，以便添加小部件。在某些情况下，您可能更喜欢这种方法。
- en: 'The group box is fairly simple, but it does have a few interesting properties:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 分组框相当简单，但它确实有一些有趣的属性：
- en: '| Property | Argument | Description |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 参数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `title` | string | The title text. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `title` | 字符串 | 标题文本。 |'
- en: '| `checkable` | Boolean | Whether the groupbox has a checkbox to enable/disable
    its contents. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `checkable` | 布尔值 | groupbox是否有一个复选框来启用/禁用它的内容。 |'
- en: '| `checked` | Boolean | Whether a checkable groupbox is checked (enabled).
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `checked` | 布尔值 | 一个可勾选的groupbox是否被勾选（启用）。 |'
- en: '| `alignment` | `QtCore.Qt.Alignment` | The alignment of the title text. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `alignment` | `QtCore.Qt.Alignment` | 标题文本的对齐方式。 |'
- en: '| `flat` | Boolean | Whether the box is flat or has a frame. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `flat` | 布尔值 | 盒子是平的还是有框架。 |'
- en: The `checkable` and `checked` properties are very useful for situations where
    you want a user to be able to disable entire sections of a form (for example,
    to disable the billing address part of an order form if it's the same as shipping
    address).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkable`和`checked`属性非常有用，用于希望用户能够禁用表单的整个部分的情况（例如，如果与运输地址相同，则禁用订单表单的帐单地址部分）。'
- en: 'Let''s reconfigure our `groupbox`, like so:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新配置我们的`groupbox`，如下所示：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that now the buttons can be disabled with a simple checkbox toggle, and
    the frame has a different look.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在按钮可以通过简单的复选框切换禁用，并且框架的外观不同。
- en: If you just want a bordered widget without a label or checkbox capabilities,
    the `QFrame` class might be a better alternative.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想要一个有边框的小部件，而没有标签或复选框功能，`QFrame`类可能是一个更好的选择。
- en: Validating widgets
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证小部件
- en: Although Qt provides a wide range of ready-made input widgets for things such
    as dates and numbers, we may find sometimes that we need a widget with very specific
    constraints on its input values. Such input constraints can be created using the
    `QValidator` class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Qt提供了各种现成的输入小部件，例如日期和数字，但有时我们可能会发现需要一个具有非常特定约束的小部件。这些输入约束可以使用`QValidator`类创建。
- en: 'The workflow is like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程如下：
- en: Create a custom validator class by subclassing `QtGui.QValidator`
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过子类化`QtGui.QValidator`创建自定义验证器类
- en: Override the `validate()` method with our validation logic
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们的验证逻辑覆盖`validate()`方法
- en: Assign an instance of our custom class to a widget's `validator` property
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们自定义类的一个实例分配给小部件的`validator`属性
- en: Once assigned to an editable widget, the `validate()` method will be called
    every time the user updates the value of the widget (for example, every keystroke
    in `QLineEdit`) and will determine whether the input is accepted.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配给可编辑小部件，`validate()`方法将在用户更新小部件的值时被调用（例如，在`QLineEdit`中的每次按键），并确定输入是否被接受。
- en: Creating an IPv4 entry widget
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建IPv4输入小部件
- en: To demonstrate widget validation, let's create a widget that validates **Internet
    Protocol version 4** (**IPv4**) addresses. An IPv4 address must be in the format
    of 4 integers, each between `0` and `255`, with a dot between each number.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示小部件验证，让我们创建一个验证**互联网协议版本4**（**IPv4**）地址的小部件。IPv4地址必须是4个整数，每个整数在`0`和`255`之间，并且每个数字之间有一个点。
- en: 'Let''s start by creating our validator class. Add this class just before the
    `MainWindow` class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的验证器类。在`MainWindow`类之前添加这个类：
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need to override this class''s `validate()` method. `validate()` receives
    two pieces of information: a string that contains the proposed input and the index
    at which the input occurred. It will have to return a value that indicates whether
    the input is `Acceptable`, `Intermediate`, or `Invalid`. If the input is acceptable
    or intermediate, it will be accepted. If it''s invalid, it will be rejected.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重写这个类的`validate()`方法。`validate()`接收两个信息：一个包含建议输入的字符串和输入发生的索引。它将返回一个指示输入是`可接受`、`中间`还是`无效`的值。如果输入是可接受或中间的，它将被接受。如果无效，它将被拒绝。
- en: The value used to indicate the input state is either `QtValidator.Acceptable`,
    `QtValidator.Intermediate`, or `QtValidator.Invalid`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指示输入状态的值是`QtValidator.Acceptable`、`QtValidator.Intermediate`或`QtValidator.Invalid`。
- en: In the Qt documentation, we're told that the validator class should only return
    the state constant. In PyQt, however, you actually need to return a tuple that
    contains the state, the string, and the position. This doesn't seem to be well-documented,
    unfortunately, and the error if you should forget this is not intuitive at all.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt文档中，我们被告知验证器类应该只返回状态常量。然而，在PyQt中，实际上需要返回一个包含状态、字符串和位置的元组。不幸的是，这似乎没有很好的记录，如果您忘记了这一点，错误就不直观。
- en: 'Let''s start building our IPv4 validation logic as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的IPv4验证逻辑如下：
- en: 'Split the string on the dot character:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点字符上拆分字符串：
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If there are more than `4` segments, the value is invalid:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有超过`4`个段，该值无效：
- en: '[PRE40]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If any populated segment is not a digit string, the value is invalid:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何填充的段不是数字字符串，则该值无效：
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If not every populated segment can be converted into an integer between 0 and
    255, the value is invalid:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是每个填充的段都可以转换为0到255之间的整数，则该值无效：
- en: '[PRE42]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we''ve made it this far into the checks, the value is either intermediate
    or valid. If there are fewer than four segments, it''s intermediate:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们已经进行了这些检查，该值要么是中间的，要么是有效的。如果段少于四个，它是中间的：
- en: '[PRE43]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If there are any empty segments, the value is intermediate:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何空段，该值是中间的：
- en: '[PRE44]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the value has passed all these tests, it''s acceptable. We can return our
    tuple:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值通过了所有这些测试，它是可接受的。我们可以返回我们的元组：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To use this validator, we just need to create an instance of it and assign
    it to a widget:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此验证器，我们只需要创建一个实例并将其分配给一个小部件：
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you run the demo now, you'll see that the line edit now constrains you to
    a valid IPv4 address.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行演示，您会看到行编辑现在限制您输入有效的IPv4地址。
- en: Using QSpinBox for discrete values
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QSpinBox进行离散值
- en: As you learned earlier under the *Creating basic QtWidgets widgets* section,
    `QSpinBox` can be used for discrete lists of string values, much like a combobox.
    `QSpinBox` has a built-in `validate()` method that works just like the `QValidator`
    class' method to constrain input to the widget. To make a spinbox use discrete
    string lists, we need to subclass `QSpinBox` and override `validate()` and two
    other methods, `valueFromText()` and `textFromValue()`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*创建基本QtWidgets小部件*部分中学到的，`QSpinBox`可以用于离散的字符串值列表，就像组合框一样。`QSpinBox`有一个内置的`validate()`方法，它的工作方式就像`QValidator`类的方法一样，用于限制小部件的输入。要使旋转框使用离散字符串列表，我们需要对`QSpinBox`进行子类化，并覆盖`validate()`和另外两个方法，`valueFromText()`和`textFromValue()`。
- en: 'Let''s create a custom spinbox class that can be used to choose items from
    a list; just before the `MainWindow` class, enter this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自定义的旋转框类，用于从列表中选择项目；在`MainWindow`类之前，输入以下内容：
- en: '[PRE47]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We're subclassing `qtw.QSpinBox` and overriding the constructor so that we can
    pass in a list or tuple of choices, storing it as `self.choices`. Then we call
    the `QSpinBox` constructor; note that we set the `maximum` and `minimum` so that
    they can't be set outside the bounds of our choices. We're also passing along
    any extra positional or keyword arguments so that we can take advantage of all
    the other `QSpinBox` property settings.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对`qtw.QSpinBox`进行子类化，并覆盖构造函数，以便我们可以传入一个选择列表或元组，将其存储为`self.choices`。然后我们调用`QSpinBox`构造函数；请注意，我们设置了`maximum`和`minimum`，以便它们不能设置在我们选择的范围之外。我们还传递了任何额外的位置或关键字参数，以便我们可以利用所有其他`QSpinBox`属性设置。
- en: 'Next, let''s reimplement `valueFromText()`, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新实现`valueFromText()`，如下所示：
- en: '[PRE48]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The purpose of this method is to be able to return an integer index value given
    a string that matches one of the displayed choices. We're simply returning the
    list index of whatever string is passed in.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的目的是能够返回一个整数索引值，给定一个与显示的选择项匹配的字符串。我们只是返回传入的任何字符串的列表索引。
- en: 'Next, we need to reimplement the complimentary method, `textFromValue()`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重新实现补充方法`textFromValue()`：
- en: '[PRE49]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The purpose of this method is to translate an integer index value into the text
    of the matching choice. In this case, we're just returning the string at the given
    index. If somehow the widget gets passed a value out of range, we're returning
    `!Error!` as a string. Since this method is used to determine what is displayed
    in the box when a particular value is set, this would clearly show an error condition
    if somehow the value were out of range.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的目的是将整数索引值转换为匹配选择的文本。在这种情况下，我们只是返回给定索引处的字符串。如果以某种方式小部件传递了超出范围的值，我们将返回`!Error!`作为字符串。由于此方法用于确定在设置特定值时框中显示的内容，如果以某种方式值超出范围，这将清楚地显示错误条件。
- en: Finally, we need to take care of `validate()`. Just as we did with our `QValidator`
    class, we need to create a method that takes the proposed input and edit index
    and returns a tuple that contains the validation state, string value, and index.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理`validate()`。就像我们的`QValidator`类一样，我们需要创建一个方法，该方法接受建议的输入和编辑索引，并返回一个包含验证状态、字符串值和索引的元组。
- en: 'We''ll code it like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样编写它：
- en: '[PRE50]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In our method, we're returning `Acceptable` if the input string is found in
    `self.choices`, `Intermediate` if any choice starts with the input string (this
    includes a blank string), or `Invalid` in any other case.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的方法中，如果输入字符串在`self.choices`中找到，我们将返回`Acceptable`，如果任何选择项以输入字符串开头（包括空字符串），我们将返回`Intermediate`，在任何其他情况下我们将返回`Invalid`。
- en: 'With this class created, we can create one of our widgets in our `MainWindow`
    class:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个类创建，我们可以在我们的`MainWindow`类中创建一个小部件：
- en: '[PRE51]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: An important difference between a `QComboBox` object and a `QSpinBox` object
    with text options is that the spinbox items lack a `data` property. Only the text
    or index can be returned. It's best used for things such as months, days of the
    week, or other sequential lists that translate meaningfully into integer values.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`QComboBox`对象和具有文本选项的`QSpinBox`对象之间的一个重要区别是，旋转框项目缺少`data`属性。只能返回文本或索引。最适合用于诸如月份、星期几或其他可转换为整数值的顺序列表。'
- en: Building a calendar application GUI
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个日历应用程序GUI
- en: 'It''s time to put what we''ve learned into action and actually build a simple,
    functional GUI. Our goal is to build a simple calendar application that looks
    like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们所学到的知识付诸实践，实际构建一个简单的功能性GUI。我们的目标是构建一个简单的日历应用程序，看起来像这样：
- en: '![](assets/e7ff923c-5442-4c41-ba36-c81f7435b740.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7ff923c-5442-4c41-ba36-c81f7435b740.png)'
- en: 'Our interface won''t be functional yet; for now, we''ll just focus on getting
    the components created and laid out as shown in the screenshot. We''ll do this
    two ways: once using code only, and a second time using Qt Designer.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的界面还不能正常工作；现在，我们只关注如何创建和布局组件，就像屏幕截图中显示的那样。我们将以两种方式实现这一点：一次只使用代码，第二次使用Qt Designer。
- en: Either of these methods is valid and work fine, though as you'll see, each has
    advantages and disadvantages.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是有效的，而且都可以正常工作，尽管您会看到，每种方法都有优点和缺点。
- en: Building the GUI in code
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中构建GUI
- en: Create a new file called `calendar_form.py` by copying the application template
    from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt*.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中的应用程序模板，创建一个名为`calendar_form.py`的新文件，*PyQt入门*。
- en: 'Then we''ll configure our main window; in the `MainWindow` constructor, begin
    with this code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将配置我们的主窗口；在`MainWindow`构造函数中，从这段代码开始：
- en: '[PRE52]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This code will set our window title to something appropriate and set a fixed
    size for our window of 800 x 600\. Note that this is just the initial size, and
    the user will be able to resize the form if they wish to.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将设置我们窗口的标题为适当的内容，并设置窗口的固定大小为800 x 600。请注意，这只是初始大小，用户可以调整窗体的大小。
- en: Creating the widgets
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建小部件
- en: 'Now, let''s create all of our widgets:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建所有的小部件：
- en: '[PRE53]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'These are all of the widgets we will be using in our GUI. Most of these we
    have covered already, but there are two new ones: `QCalendarWidget` and `QListWidget`.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们在GUI中将要使用的所有小部件。其中大部分我们已经介绍过了，但有两个新的：`QCalendarWidget`和`QListWidget`。
- en: '`QCalendarWidget` is exactly what you''d expect it to be: a fully interactive
    calendar that can be used to view and select dates. Although it has a number of
    properties that can be configured, for our needs the default configuration is
    fine. We''ll be using it to allow the user to select the date to be viewed and
    edited.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`QCalendarWidget`正是您所期望的：一个完全交互式的日历，可用于查看和选择日期。虽然它有许多可以配置的属性，但对于我们的需求，默认配置就可以了。我们将使用它来允许用户选择要查看和编辑的日期。'
- en: '`QListWidget` is for displaying, selecting, and editing items in a list. We''re
    going to use it to show a list of events saved on a particular day.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`QListWidget`用于显示、选择和编辑列表中的项目。我们将使用它来显示保存在特定日期的事件列表。'
- en: 'Before we move on, we need to configure our `event_category` combo box with
    some items to select. Here''s the plan for this box:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要使用一些项目配置我们的`event_category`组合框以进行选择。以下是此框的计划：
- en: Have it read `Select category…` as a placeholder when nothing is selected
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有选择时，将其读为“选择类别…”作为占位符
- en: Include an option called `New…` which might perhaps allow the user to enter
    a new category
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括一个名为`New…`的选项，也许允许用户输入新类别。
- en: Include some common categories by default, such as `Work`, `Meeting`, and `Doctor`
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下包括一些常见类别，例如`工作`、`会议`和`医生`
- en: 'To do this, add the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请添加以下内容：
- en: '[PRE54]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`QComboBox` doesn''t really have placeholder text, so we''re using a trick
    here to simulate it. We''ve added our combo box items using the `addItems()` method
    as usual. Next, we retrieve its data model using the `model()` method, which returns
    a `QStandardItemModel` instance. The data model holds a list of all the items
    in the combo box. We can use the model''s `item()` method to access the actual
    data item at a given index (in this case `0`) and use its `setEnabled()` method
    to disable it.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`QComboBox`实际上没有占位符文本，因此我们在这里使用了一个技巧来模拟它。我们像往常一样使用`addItems()`方法添加了我们的组合框项目。接下来，我们使用`model()`方法检索其数据模型，该方法返回一个`QStandardItemModel`实例。数据模型保存组合框中所有项目的列表。我们可以使用模型的`item()`方法来访问给定索引（在本例中为`0`）处的实际数据项，并使用其`setEnabled()`方法来禁用它。'
- en: In short, we've simulated placeholder text by disabling the first entry in the
    combo box.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们通过禁用组合框中的第一个条目来模拟占位符文本。
- en: We'll learn more about widget data models in [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml),
    *Creating Data Interfaces with Model-View Classes.*
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)中了解更多关于小部件数据模型的知识，*使用模型视图类创建数据接口*。
- en: Building the layout
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建布局
- en: 'Our form is going to require some nested layouts to get everything into position.
    Let''s break down our proposed design and determine how to create this layout:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单将需要一些嵌套布局才能将所有内容放置到正确的位置。让我们分解我们提议的设计，并确定如何创建此布局：
- en: The application is divided into a calendar on the left and a form on the right.
    This suggests using `QHBoxLayout` for the main layout.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序分为左侧的日历和右侧的表单。这表明主要布局使用`QHBoxLayout`。
- en: The form on the right is a vertical stack of components, suggesting we use `QVBoxLayout`
    to arrange things on the right.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的表单是一个垂直堆叠的组件，表明我们应该使用`QVBoxLayout`在右侧排列事物。
- en: The event form at the bottom right can be laid out roughly in a grid so we could
    use `QGridLayout` there.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右下角的事件表单可以大致布局在网格中，因此我们可以在那里使用`QGridLayout`。
- en: 'We''ll begin by creating the main layout and adding in the calendar:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建主布局，然后添加日历：
- en: '[PRE55]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We want the calendar widget to fill any extra space in the layout, so we''ll
    set its size policy accordingly:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望日历小部件填充布局中的任何额外空间，因此我们将根据需要设置其大小策略：
- en: '[PRE56]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s create the vertical layout on the right, and add the label and
    event list:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在右侧创建垂直布局，并添加标签和事件列表：
- en: '[PRE57]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the event that there''s more vertical space, we''d like the event list to
    fill all the available space. So, let''s set its size policy as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多的垂直空间，我们希望事件列表填满所有可用的空间。因此，让我们将其大小策略设置如下：
- en: '[PRE58]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The next part of our GUI is the event form and its label. We could use another
    label here, but the design suggests that these form fields are grouped together
    under this heading so `QGroupBox` would be more appropriate.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: GUI的下一部分是事件表单及其标签。我们可以在这里使用另一个标签，但设计建议这些表单字段在此标题下分组在一起，因此`QGroupBox`更合适。
- en: 'So, let''s create a group box with `QGridLayout` to hold our event form:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个带有`QGridLayout`的组框来容纳我们的事件表单：
- en: '[PRE59]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, we need to add in our remaining widgets into the grid layout:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将剩余的小部件添加到网格布局中：
- en: '[PRE60]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We're dividing our grid into three columns, and using the optional column-span
    argument to put our title and detail fields across all three columns.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将网格分为三列，并使用可选的列跨度参数将我们的标题和详细字段跨越所有三列。
- en: And now we're done! At this point, you can run the script and see your completed
    form. It doesn't do anything yet, of course, but that is a topic for our [Chapter
    3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling Events with Signals
    and Slots*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了！此时，您可以运行脚本并查看您完成的表单。当然，它目前还没有做任何事情，但这是我们[第3章](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml)的主题，*使用信号和槽处理事件*。
- en: Building the GUI in Qt Designer
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt Designer中构建GUI
- en: Let's try building the same GUI, but this time we'll build it using Qt Designer.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建相同的GUI，但这次我们将使用Qt Designer构建它。
- en: First steps
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步
- en: 'To begin, launch Qt Designer as described in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, then create a new form based on a widget, like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中描述的方式启动Qt Designer，然后基于小部件创建一个新表单，如下所示：
- en: '![](assets/eda1e482-5f33-4176-a699-f3da3c3f43a7.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eda1e482-5f33-4176-a699-f3da3c3f43a7.png)'
- en: 'Now, click on the Widget and we''ll configure its properties using the Properties
    panel on the right:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，单击小部件，我们将使用右侧的属性面板配置其属性：
- en: Change the object name to `MainWindow`
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象名称更改为`MainWindow`
- en: Under **Geometry**, change the Width to `800` and Height to `600`
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**几何**下，将宽度更改为`800`，高度更改为`600`
- en: Change the window title to `My Calendar App`
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口标题更改为`我的日历应用程序`
- en: 'Next, we''ll start adding in the widgets. Scroll through the widget box on
    the left to find the **Calendar Widget**, then drag it onto the main window. Select
    the calendar and edit its properties:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始添加小部件。在左侧的小部件框中滚动查找**日历小部件**，然后将其拖放到主窗口上。选择日历并编辑其属性：
- en: Change the name to `calendar`
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称更改为`calendar`
- en: Change the horizontal and vertical size policies to `Expanding`
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水平和垂直大小策略更改为`扩展`
- en: To set up our main layout, right-click the main window (not on the calendar)
    and select Layout | **Lay Out Horizontally**. This will add a `QHBoxLayout` to
    the main window widget. Note that you can't do this until at least one widget
    is on the main window, which is why we added the calendar widget first.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置我们的主要布局，右键单击主窗口（不是日历），然后选择布局|**水平布局**。这将在主窗口小部件中添加一个`QHBoxLayout`。请注意，直到至少有一个小部件放在主窗口上，您才能这样做，这就是为什么我们首先添加了日历小部件。
- en: Building the right panel
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建右侧面板
- en: 'Now, we''ll add the vertical layout for the right side of the form. Drag a
    Vertical Layout to the right of the calendar widget. Then drag a Label Widget
    into the vertical layout. Make sure the label is listed hierarchically as a child
    of the vertical layout, not a sibling:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为表单的右侧添加垂直布局。将一个垂直布局拖到日历小部件的右侧。然后将一个标签小部件拖到垂直布局中。确保标签在层次结构中列为垂直布局的子对象，而不是同级对象：
- en: '![](assets/ba44242d-5956-4cd8-9e1a-492662eec464.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba44242d-5956-4cd8-9e1a-492662eec464.png)'
- en: If you are having trouble dragging the widget onto the unexpanded layout, you
    can also drag it into the hierarchy in the **Object Inspector** panel.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在将小部件拖放到未展开的布局上遇到问题，您也可以将其拖放到**对象检查器**面板中的层次结构中。
- en: Double-click the text on the label and change it to say Events on Date.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 双击标签上的文本，将其更改为日期上的事件。
- en: Next, drag a List Widget onto the vertical layout so that it appears under the
    label. Rename it `event_list` and check its properties to make sure its size policies
    are set to `Expanding`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个列表小部件拖到垂直布局中，使其出现在标签下面。将其重命名为`event_list`，并检查其属性，确保其大小策略设置为`扩展`。
- en: Building the event form
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建事件表单
- en: Find the Group Box in the widget box and drag it under the list widget. Double-click
    the text and change it to `Event`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件框中找到组框，并将其拖到列表小部件下面。双击文本，并将其更改为`事件`。
- en: Drag a Line Edit onto the group box, making sure it shows up as a child of the
    group box in the Object Inspector. Change the object name to `event_title`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个行编辑器拖到组框上，确保它显示为组框对象检查器中的子对象。将对象名称更改为`event_title`。
- en: Now, right-click the group box and select Lay out, then select **Lay out in
    a Grid**. This will create a grid layout in the group box.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，右键单击组框，选择布局，然后选择**在网格中布局**。这将在组框中创建一个网格布局。
- en: Drag a Combo Box onto the next line. Drag a Time Edit to the right of it, then
    a Check Box to the right of that. Name them `event_category`, `event_time`, and
    `allday_check`, respectively. Double-click the checkbox text and change it to
    `All Day`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个组合框拖到下一行。将一个时间编辑器拖到其右侧，然后将一个复选框拖到其右侧。将它们分别命名为`event_category`，`event_time`和`allday_check`。双击复选框文本，并将其更改为`全天`。
- en: To add options to the combo box, right-click the box and select **Edit Items**.
    This will open a dialog where we can type in our items, so click the + button
    to add `Select Category…` like the first one, then `New…`, then a few random categories
    (such as `Work`, `Doctor`, `Meeting`).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要向组合框添加选项，右键单击框并选择**编辑项目**。这将打开一个对话框，我们可以在其中输入我们的项目，所以点击+按钮添加`选择类别…`，就像第一个一样，然后`新建…`，然后一些随机类别（如`工作`，`医生`，`会议`）。
- en: Unfortunately, we can't disable the first item using Qt Designer. We'll have
    to handle that when we use our form in an application, which we'll discuss in
    [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling Events with
    Signals and Slots*.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法在Qt Designer中禁用第一项。当我们在应用程序中使用我们的表单时，我们将在[第3章](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml)中讨论如何处理这个问题，*使用信号和槽处理事件*。
- en: Notice that adding those three widgets pushed the line edit over to the right.
    We need to fix the column span on that widget. Click the line edit, grab the handle
    on the right edge, and drag it right until it expands to the width of the group
    box.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，添加这三个小部件会将行编辑器推到右侧。我们需要修复该小部件的列跨度。单击行编辑器，抓住右边缘的手柄，将其向右拖动，直到它扩展到组框的宽度。
- en: Now, grab a Text Edit and drag it under the other widgets. Notice that it's
    squashed into the first column, so just as with the line edit, drag it right until
    it fills the whole width. Rename the text edit to `event_detail`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，抓住一个文本编辑器，将其拖到其他小部件下面。注意它被挤压到第一列，所以就像行编辑一样，将其向右拖动，直到填满整个宽度。将文本编辑器重命名为`event_detail`。
- en: Finally, drag two Push Button widgets to the bottom of the form. Make sure to
    drag them to the second and third columns, leaving the first column empty. Rename
    them `add_button` and `del_button`, changing the text to `Add/Update` and `Delete`,
    respectively.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将两个按钮小部件拖到表单底部。确保将它们拖到第二列和第三列，留下第一列为空。将它们重命名为`add_button`和`del_button`，将文本分别更改为`添加/更新`和`删除`。
- en: Previewing the form
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览表单
- en: Save the form as `calendar_form.ui`, then press *Ctrl* + *R* to preview it.
    You should see a fully functional form, just as shown in the original screenshot.
    To actually use this file, we'll have to transpile it to Python code and import
    it into an actual script. We'll cover this in [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling
    Events with Signals and Slots*, after we've made some additional modifications
    to the form.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 将表单保存为`calendar_form.ui`，然后按下*Ctrl* + *R*进行预览。您应该看到一个完全功能的表单，就像原始截图中显示的那样。要实际使用这个文件，我们需要将其转换为Python代码并将其导入到实际的脚本中。在我们对表单进行一些额外修改之后，我们将在[第3章](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml)中进行讨论，*使用信号和槽处理事件*。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a selection of the most popular widget classes in
    Qt. You learned how to create them, customize them, and add them to a form. We
    discussed various ways to control widget sizes and practiced building a simple
    application form in both Python code and the Qt Designer WYSIWYG application.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Qt中一些最受欢迎的小部件类。您学会了如何创建它们，自定义它们，并将它们添加到表单中。我们讨论了各种控制小部件大小的方法，并练习了在Python代码和Qt
    Designer所见即所得应用程序中构建简单应用程序表单的方法。
- en: In the next chapter, we'll learn how to make this form actually do something
    as we explore Qt's core communication and event-handling system. Keep your calendar
    form handy, as we'll modify it some more and make a functional application from
    it.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使这个表单真正做一些事情，同时探索Qt的核心通信和事件处理系统。保持你的日历表单方便，因为我们将对它进行更多修改，并从中制作一个功能应用程序。
- en: Questions
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你从本章学到的知识：
- en: How would you create a `QWidget` that is fullscreen, has no window frame, and
    uses the hourglass cursor?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何创建一个全屏、没有窗口框架，并使用沙漏光标的`QWidget`？
- en: 'You''re asked to design a data-entry form for a computer inventory database.
    Choose the best widget to use for each of the following fields:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被要求为计算机库存数据库设计一个数据输入表单。为以下字段选择最好的小部件使用：
- en: '**Computer make**: One of eight brands that your company purchases'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机制造商**：你公司购买的八个品牌之一'
- en: '**Processor Speed**: The CPU speed in GHz'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器速度**：CPU速度，以GHz为单位'
- en: '**Memory amount**: The amount of RAM, in whole MB'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存量**：内存量，以MB为单位'
- en: '**Host Name**: The computer''s hostname'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机名**：计算机的主机名'
- en: '**Video make**: Whether the video hardware is Nvidia, AMD, or Intel'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频制作**：视频硬件是Nvidia、AMD还是Intel'
- en: '**OEM License**: Whether the computer uses an **Original Equipment Manufacturer**
    (**OEM**) license'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OEM许可证**：计算机是否使用原始设备制造商（OEM）许可证'
- en: The data entry form includes an `inventory number` field that requires the `XX-999-9999X` format
    where `X` is an uppercase letter from `A` to `Z`, excluding `O` and `I`, and `9`
    is a number from `0` to `9`. Can you create a validator class to validate this
    input?
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据输入表单包括一个需要`XX-999-9999X`格式的`库存编号`字段，其中`X`是从`A`到`Z`的大写字母，不包括`O`和`I`，`9`是从`0`到`9`的数字。你能创建一个验证器类来验证这个输入吗？
- en: Check out the following calculator form—what layouts may have been used to create
    it?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看下面的计算器表单——可能使用了哪些布局来创建它？
- en: '![](assets/1b7c100d-6694-48e8-8bc0-e15dc8c0aba7.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1b7c100d-6694-48e8-8bc0-e15dc8c0aba7.png)'
- en: Referring to the preceding calculator form, how would you make the button grid
    take up any extra space when the form is resized?
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考前面的计算器表单，当表单被调整大小时，你会如何使按钮网格占用任何额外的空间？
- en: The topmost widget in the calculator form is a `QLCDNumber` widget. Can you
    find the Qt documentation on this widget? What unique properties does it have?
    When might you use it?
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算器表单中最顶层的小部件是一个`QLCDNumber`小部件。你能找到关于这个小部件的Qt文档吗？它有哪些独特的属性？你什么时候会使用它？
- en: Starting with your template code, build the calculator form in code.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的模板代码开始，在代码中构建计算器表单。
- en: Build the calculator form in Qt Designer.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Designer中构建计算器表单。
- en: Further reading
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Check out the following resources for more information on the topics covered
    in this chapter:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源，了解本章涉及的主题的更多信息：
- en: The `QWidget` properties documentation lists all the properties for `QWidget`,
    which are inherited by all its child classes, at [https://doc.qt.io/qt-5/qwidget.html#properties](https://doc.qt.io/qt-5/qwidget.html#properties)
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QWidget`属性文档列出了所有`QWidget`的属性，这些属性被所有子类继承，网址为[https://doc.qt.io/qt-5/qwidget.html#properties](https://doc.qt.io/qt-5/qwidget.html#properties)'
- en: The `Qt` namespace documentation lists many of the global enums used in Qt at [https://doc.qt.io/qt-5/qt.html#WindowState-enum](https://doc.qt.io/qt-5/qt.html#WindowState-enum)
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qt`命名空间文档列出了Qt中使用的许多全局枚举，网址为[https://doc.qt.io/qt-5/qt.html#WindowState-enum](https://doc.qt.io/qt-5/qt.html#WindowState-enum)'
- en: The Qt layout management tutorial provides detailed information on layouts and
    sizing at [https://doc.qt.io/qt-5/layout.html](https://doc.qt.io/qt-5/layout.html)
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt布局管理教程提供了有关布局和大小调整的详细信息，网址为[https://doc.qt.io/qt-5/layout.html](https://doc.qt.io/qt-5/layout.html)
- en: The `QDateTime` documentation provides more information about working with dates
    and times in Qt at [https://doc.qt.io/qt-5/qdatetime.html](https://doc.qt.io/qt-5/qdatetime.html)
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QDateTime`文档提供了有关在Qt中处理日期和时间的更多信息，网址为[https://doc.qt.io/qt-5/qdatetime.html](https://doc.qt.io/qt-5/qdatetime.html)'
- en: More information about `QCalendarWidget` can be found at [https://doc.qt.io/qt-5/qcalendarwidget.html](https://doc.qt.io/qt-5/qcalendarwidget.html)
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`QCalendarWidget`的更多信息可以在[https://doc.qt.io/qt-5/qcalendarwidget.html](https://doc.qt.io/qt-5/qcalendarwidget.html)找到。
