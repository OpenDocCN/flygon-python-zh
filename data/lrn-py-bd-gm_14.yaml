- en: Getting to Know PyOpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解PyOpenGL
- en: Geometrical shapes and figures play a vital role in game development. We tend
    to neglect their importance when it comes to the development of advanced graphics
    technologies. However, many popular games still use these shapes and figures to
    render game characters. Mathematical concepts such as transformations, vectored
    movements, and ZOOM IN and ZOOM OUT capabilities add weight when it comes to the
    manipulation of game objects. Python has several modules to support such manipulations.
    In this chapter, we are going to learn about one such powerful Python feature—the PyOpenGL
    module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几何形状和图形在游戏开发中起着至关重要的作用。当涉及到先进的图形技术的开发时，我们往往忽视它们的重要性。然而，许多流行的游戏仍然使用这些形状和图形来渲染游戏角色。数学概念，如变换、向量运动以及放大和缩小的能力，在操纵游戏对象时具有重要作用。Python有几个模块来支持这种操纵。在本章中，我们将学习一个强大的Python功能——PyOpenGL模块。
- en: While exploring PyOpenGL, we will learn how to create complex geometrical shapes
    using primitives (that is, vertices and edges). We will start by installing Python
    PyOpenGL and start drawing with it. We will make several objects, such as triangles
    and cubes, with it. We won't be using pygame to create such shapes; instead, we
    will use pure mathematical concepts for defining rectangular coordinate points
    for vertices and edges. We will also explore different PyOpenGL methods such as
    clipping and perspective. We will cover each of them to gain knowledge about how
    PyOpenGL can be used to create appealing game characters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索PyOpenGL时，我们将学习如何使用基本图形（即顶点和边）创建复杂的几何形状。我们将从安装Python PyOpenGL并开始用它绘图开始。我们将使用它制作几个对象，如三角形和立方体。我们不会使用pygame来创建这些形状；相反，我们将使用纯数学概念来定义顶点和边的直角坐标点。我们还将探索不同的PyOpenGL方法，如裁剪和透视。我们将涵盖每一个方法，以了解PyOpenGL如何用于创建吸引人的游戏角色。
- en: By the end of this chapter, you will be familiar with the traditional and mathematical
    ways of creating primitives. This way of creating shapes provides programmers
    and designers with the ability to manipulate their game objects and characters.
    You will also learn how to implement ZOOM-IN and ZOOM-OUT capabilities in the
    game, as well as how to use color properties by drawing geometric primitives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将熟悉创建基本图形的传统和数学方法。这种创建形状的方式为程序员和设计师提供了操纵他们的游戏对象和角色的能力。您还将学习如何在游戏中实现放大和缩小的功能，以及如何通过绘制几何基本图形来使用颜色属性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding PyOpenGL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解PyOpenGL
- en: Making objects with PyOpenGL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyOpenGL制作对象
- en: Understanding PyOpenGL methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解PyOpenGL方法
- en: Understanding color properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解颜色属性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following list of requirements to complete this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下要求清单才能完成本章：
- en: Pygame editor (IDLE) version 3.5+ is recommended.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用Pygame编辑器（IDLE）版本3.5+。
- en: You will need the Pycharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将需要Pycharm IDE（参考[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python-设置Python和编辑器*，了解安装过程）。
- en: The code assets for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter14](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter14)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码资产可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter14](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter14)
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2oJMfLM](http://bit.ly/2oJMfLM)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oJMfLM](http://bit.ly/2oJMfLM)'
- en: Understanding PyOpenGL
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解PyOpenGL
- en: In the past, graphical programs containing three-dimensional scenes that had
    been processed with 3D-accelerated hardware was something every game programmer
    wanted. Even though this is normal by today's standards, the hardware is not the
    same as it was years ago. Most of the game's graphics had to be rendered with
    the software that resided in the low-processing devices. Hence, apart from creating
    such scenes, rendering would also take quite a bit of time and would ultimately
    make the game slow. The advent of gaming interfaces, also known as graphics cards,
    created a revolution in the gaming industry; programmers were now only bound to
    making interfaces, animation, and autonomous gaming logic rather than concerning
    themselves with processing power. Hence, games that have been created post-90s
    have richer gameplay and a touch of artificial intelligence (multiplayer games).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，包含经过3D加速硬件处理的三维场景的图形程序是每个游戏程序员都想要的东西。尽管按照今天的标准来看这是正常的，但硬件与多年前并不相同。大部分游戏的图形必须使用低处理设备中的软件进行渲染。因此，除了创建这样的场景，渲染也需要相当长的时间，最终会使游戏变慢。游戏界面的出现，也被称为图形卡，为游戏行业带来了革命；程序员现在只需要关注界面、动画和自主游戏逻辑，而不必关心处理能力。因此，90年代后创建的游戏具有更丰富的游戏性和一丝人工智能（多人游戏）。
- en: It is well-known that graphics cards can handle three-dimensional capabilities
    such as rendering and optimizing scenes. However, to use such features, we need
    a programming interface that communicates between our project and such interfaces.
    The **A****pplication Programming Interface** (**API**) we are going to use in
    this chapter is OpenGL. OpenGL is a cross-platform (the program runs on any machine)
    API that is generally used to render 2D and 3D graphics. The API is analogous
    to libraries that are used to facilitate interaction with a graphics processing
    unit, and it accelerates the graphics rendering method by using hardware-accelerated
    rendering. It comes pre-installed on most machines as part of a graphics driver,
    though you can check its version by using the *GL view* *utility*. Before we start
    writing programs so that we can draw geometrical shapes and figures using PyOpenGL,
    we need to install it on our machine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，图形卡可以处理渲染和优化场景等三维功能。但是，要使用这些功能，我们需要一个在我们的项目和这些接口之间进行通信的编程接口。我们在本章中要使用的**应用程序编程接口**（**API**）是OpenGL。OpenGL是一个跨平台（程序可以在任何机器上运行）的API，通常用于渲染2D和3D图形。该API类似于用于促进与图形处理单元的交互的库，并且通过使用硬件加速渲染来加速图形渲染方法。它作为图形驱动程序的一部分预装在大多数机器上，尽管您可以使用*GL视图*
    *实用程序*来检查其版本。在我们开始编写程序以便使用PyOpenGL绘制几何形状和图形之前，我们需要在我们的机器上安装它。
- en: Installing PyOpenGL
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装PyOpenGL
- en: 'Even if OpenGL is already present on your system, you need to install the PyOpenGL
    module separately so that the required OpenGL drivers and Python frameworks can
    communicate with each other. The Pycharm IDE provides a service that can locate
    Python interpreters and install PyOpenGL, which removes the overhead of installing
    it manually. Follow these steps to install PyOpenGL in the Pycharm IDE:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使OpenGL已经存在于您的系统上，您仍然需要单独安装PyOpenGL模块，以便所需的OpenGL驱动程序和Python框架可以相互通信。Pycharm
    IDE提供了一个服务，可以定位Python解释器并安装PyOpenGL，从而消除了手动安装的开销。按照以下步骤在Pycharm IDE中安装PyOpenGL：
- en: Click on File from the top navigation bar and then Settings. Then, hover over
    the left-hand side navigation window and select the project:interpreter option.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击顶部导航栏中的“文件”，然后单击“设置”。然后，将鼠标悬停在左侧导航窗口上，并选择项目：解释器选项。
- en: Select the current project Python interpreter, that is, Python 3.8+ (followed
    by your project name), and press the to add (+) button from the menu screen next
    to the Interpreter drop-down menu.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前项目的Python解释器，即Python 3.8+（后跟您的项目名称），并从解释器下拉菜单旁边的菜单屏幕上按下添加（+）按钮。
- en: Search for PyOpenGL in the search bar and press the Install package button.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索栏中搜索PyOpenGL，然后按“安装包”按钮。
- en: Alternatively, if you want to install PyOpenGL externally, you can download
    it as a Python egg file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想要外部安装PyOpenGL，您可以将其下载为Python蛋文件。
- en: A *Python egg* is a logical structure embodying the release of a specific version
    of a Python project, comprising its code, resources, and metadata. There are multiple
    formats that can be used to physically encode a Python egg, and others can be
    developed. However, a key principle of Python eggs is that they should be discoverable
    and importable. That is, it should be possible for a Python application to easily
    and efficiently find out what eggs are present on a system and ensure that the
    desired eggs' contents are importable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python蛋*是一个逻辑结构，包含了Python项目特定版本的发布，包括其代码、资源和元数据。有多种格式可用于物理编码Python蛋，也可以开发其他格式。但是，Python蛋的一个关键原则是它们应该是可发现和可导入的。也就是说，Python应用程序应该能够轻松高效地找出系统上存在哪些蛋，并确保所需蛋的内容是可导入的。'
- en: 'These types of files are bundled together to create Python modules that can
    be downloaded from the **Python Enterprise Application Kit** (**PEAK**) with the
    help of an easy install procedure. To download a Python egg file, you have to
    download the Python `easy_install` module. Go to [http://peak.telecommunity.com/DevCenter/EasyInstall](http://peak.telecommunity.com/DevCenter/EasyInstall)
    and then download and run the `ez_setup.py` file. After successfully installing
    easy install, run the following command in your command shell/Terminal to install
    PyOpenGL:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的文件被捆绑在一起，以创建可以通过简单的安装过程从**Python企业应用套件**（**PEAK**）下载的Python模块。要下载Python蛋文件，您必须下载Python
    `easy_install`模块。转到[http://peak.telecommunity.com/DevCenter/EasyInstall](http://peak.telecommunity.com/DevCenter/EasyInstall)，然后下载并运行`ez_setup.py`文件。成功安装easy
    install后，在命令行/终端中运行以下命令以安装PyOpenGL：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Easy install is not only used for installing PyOpenGL—you can download or upgrade
    a large range of Python modules with its help. For example, the `easy_install`
    SQLObject is used to install SQL PyPi packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Easy install不仅用于安装PyOpenGL，还可以借助它下载或升级大量的Python模块。例如，`easy_install` SQLObject用于安装SQL
    PyPi包。
- en: 'As usual, when we need to use packages, we need to import them into our project.
    In this case, you can make a demo project (`demo.py`) to start testing the OpenGL
    project. So that we can use features such as code maintainability and debugging,
    we will make a PyOpenGL project using the Pycharm IDE rather than using Python''s
    built-in IDE. Open any new project and follow these steps to check whether PyOpenGL
    is running or not:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们需要使用包时，我们需要将它们导入到我们的项目中。在这种情况下，您可以创建一个演示项目（`demo.py`）来开始测试OpenGL项目。这样我们就可以使用诸如代码可维护性和调试之类的功能，我们将使用Pycharm
    IDE制作PyOpenGL项目，而不是使用Python的内置IDE。打开任何新项目，并按照以下步骤检查PyOpenGL是否正在运行：
- en: 'Start by importing every class of PyOpenGL with the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令导入PyOpenGL的每个类：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, import the required OpenGL functions using the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令导入所需的OpenGL函数：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, you should import `pygame` into your project:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您应该将`pygame`导入到您的项目中：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Initialize the display for your project with the `pygame` command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pygame`命令为您的项目初始化显示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run your project and analyze the result. If a new screen appears, you can continue
    making projects. However, if the prompt says PyOpenGL is not installed, make sure
    to follow the preceding installation procedure.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的项目并分析结果。如果出现新屏幕，您可以继续制作项目。但是，如果提示说PyOpenGL未安装，请确保按照前面的安装过程进行操作。
- en: The preceding four lines are easy to follow. Let's discuss them one by one.
    The first step was quite simple—it tells the interpreter to import PyOpenGL along
    with its multiple classes, which can be used for different functions. Importing
    in such a way reduces the effort of importing each class of PyOpenGL one by one.
    The first import is mandatory as this line imports different OpenGL functions
    that begin with the `gl` keyword. For example, we can use a command such as `glVertex3fv()`,
    which can be used to draw different 3D shapes (we'll cover this later).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的四行很容易理解。让我们逐一讨论它们。第一步非常简单-它告诉解释器导入PyOpenGL以及其多个类，这些类可用于不同的功能。以这种方式导入可以减少逐个导入PyOpenGL的每个类的工作量。第一个导入是强制性的，因为这一行导入以`gl`关键字开头的不同OpenGL函数。例如，我们可以使用诸如`glVertex3fv()`之类的命令，用于绘制不同的3D形状（我们稍后会介绍这个）。
- en: The next line of the import statement, that is, `from OpenGL.GLU import *`,
    is used so that we can use commands that start with `glu`, for example, `gluPerspective()`.
    These types of commands are useful in making changes to the view of the display
    screen, along with the objects it rendered. For example, we can make conversions
    such as cropping and clipping using such `glu` commands.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句的下一行，即`from OpenGL.GLU import *`，是为了我们可以使用以`glu`开头的命令，例如`gluPerspective()`。这些类型的命令对于更改显示屏的视图以及渲染的对象非常有用。例如，我们可以使用这样的`glu`命令进行裁剪和剪裁等转换。
- en: 'Similar to the PyOpenGL GL library, GLU is a Python library that is used to
    explore the relationships within or between related datasets. They are mostly
    used to make changes on the display screen while affecting the shapes and dimensions
    of the rendered objects. To learn more about the internals of GLU, check out its
    official documentation page: [http://pyopengl.sourceforge.net/pydoc/OpenGL.GLU.html](http://pyopengl.sourceforge.net/pydoc/OpenGL.GLU.html).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于PyOpenGL GL库，GLU是一个Python库，用于探索相关数据集内部或之间的关系。它们主要用于在影响渲染对象的形状和尺寸的同时对显示屏进行更改。要了解有关GLU内部的更多信息，请查看其官方文档页面：[http://pyopengl.sourceforge.net/pydoc/OpenGL.GLU.html](http://pyopengl.sourceforge.net/pydoc/OpenGL.GLU.html)。
- en: The next line simply imports `pygame` into our project. While the surface that
    was created using OpenGL is 3D, it needs the `pygame` module to render it. Before
    using any commands from the `gl` or `glu` modules, we need to call the `pygame`
    module to create a display using the `set_mode()` function (feel the power of
    the `pygame` module). The display that's created by the `pygame` module will be
    3D rather than 2D while using the `set_mode` function with the OpenGL library.
    After this, we are telling the Python interpreter to create an OpenGL surface
    and return it as a `window_screen` object. The tuple (`height`, `width`) that's
    passed inside the `set_mode` function represents the surface size.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行只是将`pygame`导入到我们的项目中。使用OpenGL创建的表面是3D的，它需要`pygame`模块来渲染它。在使用`gl`或`glu`模块的任何命令之前，我们需要调用`pygame`模块使用`set_mode()`函数创建一个显示（感受`pygame`模块的强大）。由`pygame`模块创建的显示将是3D而不是2D，同时使用OpenGL库的`set_mode`函数。之后，我们告诉Python解释器创建一个OpenGL表面并将其作为`window_screen`对象返回。传递给`set_mode`函数的元组（高度，宽度）表示表面大小。
- en: 'In the final step, I want you to focus on the optional parameters, which are
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我希望您关注以下可选参数：
- en: '`HWSURFACE`: It creates the surface in the hardware. It is primarily used for
    creating an accelerated 3D display screen, but it is only used in FULL SCREEN.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HWSURFACE`：它在硬件中创建表面。主要用于创建加速的3D显示屏，但仅在全屏模式下使用。'
- en: '`OPENGL`: It makes a suggestion to pygame regarding the creation of an OpenGL
    rendered surface.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPENGL`：它向pygame建议创建一个OpenGL渲染表面。'
- en: '`DOUBLEBUF`: It stands for double buffering, and is recommended for `HWSURFACE`
    and `OPENGL` by pygame. It reduces the flickering (the phenomena of burning and
    shining colors in the screen unsteadily).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOUBLEBUF`：它代表双缓冲，pygame建议对`HWSURFACE`和`OPENGL`使用。它减少了屏幕上颜色闪烁的现象。'
- en: 'There are a few more optional parameters, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他可选参数，如下：
- en: '`FULLSCREEN`: This will make the display of the screen rendered to a  fullscreen
    view.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FULLSCREEN`：这将使屏幕显示渲染为全屏视图。'
- en: '`RESIZABLE`: This allows us to resize the window screen.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESIZABLE`：这允许我们调整窗口屏幕的大小。'
- en: '`NOFRAME`: This will make the window screen borderless, controlless, and so
    on. For more information regarding pygame optional parameters, please go to [https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode](https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOFRAME`：这将使窗口屏幕无边框，无控件等。有关pygame可选参数的更多信息，请访问[https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode](https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode)。'
- en: Now that we have started installing PyOpenGL on our machine and set a window
    for screen objects, we can start drawing objects and primitives.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的机器上安装了PyOpenGL并为屏幕对象设置了一个窗口，我们可以开始绘制对象和基本图形。
- en: Making objects with PyOpenGL
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyOpenGL制作对象
- en: OpenGL is primarily known for drawing different geometrical shapes or primitives,
    all of which can be used in the creation of scenes for a 3D canvas. We can make
    multiple-sided shapes (polygons), such as a triangle, quadrilateral, or hexagon.
    Several pieces of information, such as vertex and edges, should be given to the
    primitives so that PyOpenGL can render them accordingly. Since the information
    that's related to the vertex and edges is different for each shape, we have different
    functions to create different primitives. This is different compared to pygame's
    2D function (`pygame.draw`), which was used to create multiple shapes using the
    same single function. For example, a triangle has three vertices and three sides,
    whereas a quadrilateral has four vertices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL主要用于绘制不同的几何形状或基元，所有这些都可以用于创建3D画布的场景。我们可以制作多边形（多边形）形状，如三角形、四边形或六边形。应该向基元提供多个信息，如顶点和边，以便PyOpenGL可以相应地渲染它们。由于与顶点和边相关的信息对于每个形状都是不同的，因此我们有不同的函数来创建不同的基元。这与pygame的2D函数（`pygame.draw`）不同，后者用于使用相同的单个函数创建多个形状。例如，三角形有三个顶点和三条边，而四边形有四个顶点。
- en: 'If you have a mathematical background, knowledge of vertices and edges will
    be a piece of cake for you. But for those of you who are not, the vertices of
    any geometrical shapes are the corners or points in which two or more lines meet.
    For example, a triangle has three vertices. In the following illustration, **A**,
    **B**, and **C** are vertices of the triangle ABC. Similarly, edges are the line
    segments on the boundary joining one vertex to another. In the following triangle,
    AB, BC, and AC are edges of the triangle ABC:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您具有数学背景，对顶点和边的了解对您来说将是小菜一碟。但对于那些不了解的人来说，任何几何形状的顶点都是两条或两条以上线相交的角或点。例如，三角形有三个顶点。在下图中，**A**、**B**和**C**是三角形ABC的顶点。同样，边是连接一个顶点到另一个顶点的线段。在下面的三角形中，AB、BC和AC是三角形ABC的边：
- en: '![](Images/26d029c3-1800-45d8-aedd-b1a92e547f8a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26d029c3-1800-45d8-aedd-b1a92e547f8a.png)'
- en: 'To draw such geometrical shapes with PyOpenGL, we need to start by invoking
    some basic OpenGL primitives, which are listed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PyOpenGL绘制这样的几何形状，我们需要首先调用一些基本的OpenGL基元，这些基元列在下面：
- en: First of all, call the `glBegin()` function with any of the primitives you want
    to draw. For example, `glBegin(GL_TRIANGLES)` should be invoked to inform the
    interpreter about the triangular shapes we are going to draw.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用要绘制的任何基元调用`glBegin()`函数。例如，应调用`glBegin(GL_TRIANGLES)`来通知解释器我们将要绘制的三角形形状。
- en: The next piece of information regarding the vertices (A, B, C) is critical for
    drawing shapes. We send information regarding the vertices using the `glVertex()`
    function.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于顶点（A、B、C）的下一个重要信息对于绘制形状至关重要。我们使用`glVertex()`函数发送有关顶点的信息。
- en: Apart from information about vertices and edges, you can provide additional
    information, such as the color of the shapes, using the `glColor()` function.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了有关顶点和边的信息之外，您还可以使用`glColor()`函数提供有关形状颜色的其他信息。
- en: After providing enough essential information, you can invoke the `glEnd()` method
    to inform OpenGL that enough information has been provided. Then, it can start
    drawing the specified shapes, as indicated by the constants that are provided
    by the `glBegin` method.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供足够的基本信息之后，您可以调用`glEnd()`方法通知OpenGL已经提供了足够的信息。然后，它可以开始绘制指定的形状，如`glBegin`方法提供的常量所示。
- en: 'The following code is the pseudocode for drawing triangular shapes using PyOpenGL
    (reference the preceding illustration to understand the operation of PyOpenGL
    functions):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用PyOpenGL绘制三角形形状的伪代码（参考前面的插图以了解PyOpenGL函数的操作）：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following illustration shows the normal of the triangle. A normal is a
    mathematical term that means a unit vector (has a magnitude of 1 and has a direction—please refer
    to [Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml), *Upgrading the Snake
    Game with Turtle*, to find out more about vectors). This piece of information
    (normal) is essential because it tells PyOpenGL where each vertex resides. For
    example, `glVertex3f(0, 1, 0)` will put a vertex on the *y*-axis. Therefore, (*x*,
    *y*, *z*) represents the magnitude in the *x*-axis, *y*-axis, and *z*-axis, like
    so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了三角形的法线。法线是一个数学术语，表示单位向量（具有1的大小和方向，请参考[第10章](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml)，*使用海龟升级蛇游戏*，了解更多关于向量的信息）。这个信息（法线）很重要，因为它告诉PyOpenGL每个顶点的位置。例如，`glVertex3f(0,
    1, 0)`会在*y*轴上放置一个顶点。因此，(*x*, *y*, *z*)表示*x*轴、*y*轴和*z*轴上的大小，如下所示：
- en: '![](Images/cfe2348d-185f-47f9-b2b2-73ed7cdd6841.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cfe2348d-185f-47f9-b2b2-73ed7cdd6841.png)'
- en: 'Now that we know how to create basic triangular primitives, let''s take a look
    at the following table to understand the other different types of primitives that
    can be drawn using PyOpenGL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建基本的三角形基元，让我们看一下以下表格，了解可以使用PyOpenGL绘制的其他不同类型的基元：
- en: '| **Constants keywords** | **Shapes** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **常量关键字** | **形状** |'
- en: '| `GL_POINTS` | Draws dots or points to the screen |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `GL_POINTS` | 将点或点绘制到屏幕上 |'
- en: '| `GL_LINES` | Draws lines (individual ones) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `GL_LINES` | 绘制线条（单独的线条） |'
- en: '| `GL_TRIANGLES` | Draws triangles |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `GL_TRIANGLES` | 绘制三角形 |'
- en: '| `GL_QUADS` | Draws quadrilaterals (four-sided polygons) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `GL_QUADS` | 绘制四边形（四边形） |'
- en: '| `GL_POLYGON` | Draws polygons (any edges or vertices) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `GL_POLYGON` | 绘制多边形（任何边或顶点） |'
- en: 'We are now capable of drawing any primitives using primitive constants, provided
    that we have information about their vertices. Let''s create the following quadrilateral:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用基元常量绘制任何基元，前提是我们有关于它们顶点的信息。让我们创建以下四边形：
- en: '![](Images/3ae798eb-a9ce-4cdf-804d-e163c4c08409.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3ae798eb-a9ce-4cdf-804d-e163c4c08409.png)'
- en: 'The following is the pseudocode for drawing the preceding cube primitive:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是绘制前述立方体基元的伪代码：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding line of code, we started by defining the `GL_QUADS` constants
    to inform PyOpenGL about the name of the primitives we are drawing. Then, we added
    the color attributes with the `glColor` method. Similarly, we defined the four
    primary vertices of the cube using the `glVertex` method. The coordinates that
    were passed as an argument to the `glVertex` method represent the *x*, *y,* and
    *z*-axes in the plane.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们首先定义了`GL_QUADS`常量，以通知PyOpenGL我们正在绘制的基本图元的名称。然后，我们使用`glColor`方法添加了颜色属性。同样，我们使用`glVertex`方法定义了立方体的四个主要顶点。作为`glVertex`方法的参数传递的坐标代表了平面上的*x*、*y*和*z*轴。
- en: Now that we are able to draw different geometrical shapes using PyOpenGL, let's
    learn about the different rendering functions/premiers of PyOpenGL so that we
    can make other complex structures.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够使用PyOpenGL绘制不同的几何形状，让我们了解PyOpenGL的不同渲染函数/基本图元，以便我们可以制作其他复杂的结构。
- en: Understanding PyOpenGL methods
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解PyOpenGL方法
- en: 'It is well-known that a computer screen has a two-dimensional view (its height
    and width). In order to display the three-dimensional scene created by OpenGL,
    the scene must go through several matrix transformations, which are commonly known
    as projections. This allows the 3D scene to be rendered in a 2D view. Among the
    various transformation methods, two are commonly used for projections (clipping
    and normalization). These matrix transformations are applied to the 3D coordinate
    system and reduced to a 2D coordinate system. The `GL_PROJECTION` matrix is frequently
    used for performing the transformation associated with projections. The mathematical
    deduction of projection transformation is another story and we are never going
    to use those, but understanding how it works is important for any game programmer.
    Let''s go over how `GL_PROJECTION` works:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，计算机屏幕具有二维视图（高度和宽度）。为了显示由OpenGL创建的三维场景，场景必须经过几次矩阵变换，通常称为投影。这允许将3D场景呈现为2D视图。在各种变换方法中，常用于投影的有两种（裁剪和归一化）。这些矩阵变换应用于3D坐标系，并缩减为2D坐标系。`GL_PROJECTION`矩阵经常用于执行与投影相关的变换。投影变换的数学推导是另一回事，我们永远不会使用它们，但理解它的工作原理对于任何游戏程序员来说都是重要的。让我们来看看`GL_PROJECTION`的工作原理：
- en: '**Clipping**:This transforms the coordinates of the vertex of the scene to
    the clip coordinates of the scene. Clipping is a process that resizes the length
    of the scene so that some parts are clipped from `viewport` (a window display).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**裁剪**：这将把场景的顶点坐标转换为场景的裁剪坐标。裁剪是一个调整场景长度的过程，以便从`视口`（窗口显示）中裁剪掉一些部分。'
- en: '**Normalization**:This process is known as **Normalized Device Coordinates** (**NDC**),
    which transforms the clip coordinates into device coordinates by dividing by the
    `w` components of the clipping coordinates. For instance, the clip coordinates
    x[c], y[c], and z[c] are tested by comparing with w[c]. Vertices that does not
    lie in the range of -w[c] to +w[c] are discarded. Here the subscript *c* represents
    the clipping coordinate system.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归一化**：这个过程被称为**标准化设备坐标**（**NDC**），它通过将裁剪坐标除以裁剪坐标的`w`分量来将裁剪坐标转换为设备坐标。例如，裁剪坐标x[c]、y[c]和z[c]通过与w[c]进行比较。不在-w[c]到+w[c]范围内的顶点被丢弃。这里的下标*c*表示裁剪坐标系。'
- en: 'Hence, it is easier to infer that the process of matrix transformation, including
    `GL_PROJECTION`, includes two steps: clipping, which is immediately followed by
    normalization to device coordinates. The following diagram illustrates how clipping
    is done:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更容易推断矩阵变换的过程，包括`GL_PROJECTION`，包括两个步骤：裁剪，紧接着是归一化到设备坐标。以下图示了裁剪的过程：
- en: '![](Images/4af7b0fe-7069-405c-9ba1-131b483d844d.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4af7b0fe-7069-405c-9ba1-131b483d844d.png)'
- en: We can clearly observe that the process of clipping (sometimes called culling)
    is only performed in the clipping coordinates, which are defined by the size of
    the 2D viewport. To find out which clip coordinates have been discarded, we need
    to look at an example. Let's assume that *x*, *y*, and *z* are clipping coordinates
    and that their values are compared with the coordinates of *w *(*x*, *y*), which
    decides whether any vertex (or part of shapes) remains in the screen or discarded.
    If any of the coordinates lie below the value of -w[c] and above the value of
    +w[c], that vertex is discarded. In the preceding diagram, vertex A lies above
    +w[c] while vertices B and C lie below -w[c], and so both vertices are discarded.
    Moreover, vertices D and E lie within the value of (-w[c], +w[c]), and so they
    remain in the view. The value of w[c] is determined by the width of the viewport.
    Hence, the projection matrix of OpenGL (`GL_PROJECTION`) takes the 3D coordinates
    and performs projection, which converts it into 2D coordinates that can be rendered
    into the 2D computer display screen. Although some information might be lost,
    it is considered one of the most effective methods of rendering 3D scenes into
    a 2D screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地观察到裁剪（有时称为剔除）的过程只在裁剪坐标中执行，这些坐标由2D视口的大小定义。要找出哪些裁剪坐标已被丢弃，我们需要看一个例子。假设*x*、*y*和*z*是裁剪坐标，它们的值与*w*（*x*、*y*）的坐标进行比较，决定任何顶点（或形状的一部分）是否保留在屏幕上或被丢弃。如果任何坐标位于-w[c]的值以下和+w[c]的值以上，那个顶点就被丢弃。在上图中，顶点A位于+w[c]之上，而顶点B和C位于-w[c]之下，因此两个顶点都被丢弃。此外，顶点D和E位于(-w[c]，+w[c])的值范围内，因此它们保留在视图中。w[c]的值由视口的宽度确定。因此，OpenGL的投影矩阵（`GL_PROJECTION`）接受3D坐标并执行投影，将其转换为可以呈现在2D计算机显示屏上的2D坐标。尽管可能会丢失一些信息，但它被认为是将3D场景渲染到2D屏幕上的最有效方法之一。
- en: We are not done yet, though—after projection is performed, we have to convert
    the 3D scene into 2D, which requires the use of another OpenGL matrix transformation
    known as `GL_MODELVIEW`. The step of this transformation is, however, quite different.
    Firstly, matrix transformation is done, which multiplies the coordinate system
    by *view distance*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完成——在投影完成后，我们必须将3D场景转换为2D，这需要使用另一个OpenGL矩阵变换，称为`GL_MODELVIEW`。然而，这种转换的步骤是相当不同的。首先进行矩阵变换，将坐标系乘以*视距*。
- en: 'To convert them into 2D components, *z*-components is provided for each of
    them. To understand the model-view matrix, we have to understand the two matrices
    that are a part of its composition: the model matrix and the view matrix. The
    model matrix performs several transformations such as rotation, scaling, and translations
    in the model world, whereas the view matrix adjusts the scene that''s relative
    to the camera''s position. The view matrix takes care of what the object looks
    like to the player who is watching the scene, something like the first player
    character screen/viewpoint.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将它们转换为2D组件，为每个*z*分量提供了。要理解模型视图矩阵，我们必须理解构成其组成部分的两个矩阵：模型矩阵和视图矩阵。模型矩阵在模型世界中执行多个转换，如旋转、缩放和平移，而视图矩阵调整相对于摄像机位置的场景。视图矩阵负责处理对象在玩家观看场景时的外观，类似于第一人称角色的屏幕/视点。
- en: 'Now that we are aware of the transformation matrices of OpenGL, let''s make
    a simple program (`resize.py`) that can resize the display accordingly:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了OpenGL的变换矩阵，让我们制作一个简单的程序（`resize.py`），可以相应地调整显示屏的大小：
- en: 'Start by importing OpenGL:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入OpenGL。
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make a simple function, `change_View()`, that takes the size of the display
    screen, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个简单的函数`change_View()`，以显示屏的大小为参数，如下所示：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code that''s stated in from *Step 3* to *Step 6* should be added inside
    the `change_View()` function. Add a function call to `ViewPort`, which takes the
    initial values and size of the display as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤3*到*步骤6*中的代码应该添加到`change_View()`函数中。添加一个对`ViewPort`的函数调用，它以初始值和显示大小为参数，如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, it''s time to add a projection matrix. To add `GL_PROJECTION`, we have
    to call the `glMatrixMode()` method, which checks the mode of matrices being called,
    as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加投影矩阵了。要添加`GL_PROJECTION`，我们必须调用`glMatrixMode()`方法，检查被调用的矩阵的模式，如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Immediately after applying the projection matrix, two important methods should
    be invoked, that is, `glLoadIdentity()` and `gluPerspective()`, which set the
    "touchstone" for the projection matrix:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用投影矩阵后，应调用两个重要的方法，即`glLoadIdentity()`和`gluPerspective()`，它们为投影矩阵设置了“基准”：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After setting up the projection matrix, the next step is to set the model-view
    matrix. The model view matrix mode can be activated by calling the `GL_MODELVIEW` transformation
    matrix with the `glMatrixMode()` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置投影矩阵后，下一步是设置模型视图矩阵。可以通过调用`glMatrixMode()`方法激活模型视图矩阵模式：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding six steps show us how we can resize the display screen in which
    a 3D scene is displayed in a 2D display screen. *Step 1* and *Step 2* are focused
    on importing openGL. In *Step 3*, we called the `glViewport()` method and passed
    an argument that ranges from (`0`, `0`) to (`width`, `height`), which informs
    OpenGL that we want to use the entire screen to display the scene. The next step
    calls the `glMatrixMode()` method, which tells OpenGL that every matrix transformation
    will apply the projection matrix in every successive function call.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的六个步骤向我们展示了如何调整显示屏，将3D场景显示在2D显示屏中。*步骤1*和*步骤2*专注于导入OpenGL。在*步骤3*中，我们调用了`glViewport()`方法，并传递了一个参数，范围从(`0`,
    `0`)到(`width`, `height`)，这告诉OpenGL我们要使用整个屏幕来显示场景。下一步调用了`glMatrixMode()`方法，告诉OpenGL每次函数调用都将应用投影矩阵。
- en: '*Step 5* calls two new methods which, as the `glLoadIdentity()` signature states,
    are used to make the projection matrix identity, which means that all of the coordinates
    of the projection matrix should be changed to `1`. Eventually, we call another
    method, `gluPerspective()`, which sets the categorical/standard projection matrix.
    You may have noticed that the `gluPerspective()` method starts with `glu` and
    not `gl`; hence, this function is called from the GLU library. Four float arguments
    are passed with the `gluPerspective` method, that is, the field perspective of
    the camera viewpoint, the aspect ratio, and two clipping plane points (near and
    farther). Hence, clipping is done via the `gluPerspective` function. To observe
    how clipping is done, refer to the example of star geometrical shape that we discussed
    at the beginning of this topic.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤5*调用了两个新方法，正如`glLoadIdentity()`的签名所述，用于使投影矩阵成为单位矩阵，这意味着投影矩阵的所有坐标都应该更改为`1`。最后，我们调用另一个方法`gluPerspective()`，它设置了分类/标准投影矩阵。您可能已经注意到`gluPerspective()`方法以`glu`开头而不是`gl`，因此，此函数是从GLU库中调用的。`gluPerspective`方法传递了四个浮点参数，即相机视点的视场角，宽高比和两个裁剪平面点（近和远）。因此，裁剪是通过`gluPerspective`函数完成的。要了解裁剪是如何完成的，请参考我们在本主题开头讨论的星形几何形状的示例。'
- en: Now, it's time to put what we've learned to the test by making a program that
    interacts with PyOpenGL structures. We will also define another attribute that
    will make objects more appealing. This is known as *c**olor properties*. We will
    define a cube, along with mathematical information regarding vertices and edges.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将我们学到的知识付诸实践，制作一个与PyOpenGL结构交互的程序。我们还将定义另一个属性，使对象更具吸引力。这被称为*颜色属性*。我们将定义一个立方体，以及关于顶点和边的数学信息。
- en: Understanding color properties
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解颜色属性
- en: 'In real-world scenarios, there are profuse amounts of colors associated with
    objects, but computer devices are not intelligent or capable enough to distinguish
    and capture all of them. Hence, to accommodate every possible color in digital
    form is nearly impossible. Due to this, scientists have provided us with a way
    to represent different colors: the *RGB* pattern. This is a combination of three
    major color components: red, green, and blue. Combining these components, we can
    create almost every color possible. The value of each component ranges from 0
    to 255; changes to each component''s code results in a new color.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，与物体相关联的颜色有很多，但是计算机设备并不足够智能或者能力强大到可以区分和捕捉所有这些颜色。因此，几乎不可能在数字形式中容纳每一种可能的颜色。因此，科学家们为我们提供了一种表示不同颜色的方法：*RGB*模式。这是三种主要颜色组件的组合：红色、绿色和蓝色。通过组合这些组件，我们可以创建几乎所有可能的颜色。每个组件的值范围从0到255；对每个组件的代码的更改会导致新的颜色。
- en: The color properties that are used in OpenGL are quite similar to the real-world
    color reflection property. The color of the object that we observe is not actually
    its color; rather, it is the color that's reflected by the object. The object
    can have some properties of a wavelength, in which the object can absorb a certain
    color and might reflect a different one. For example, trees absorb sunlight except
    for green. We perceive and assume that it is green, but actually objects have
    no color. This concept of light reflection is fairly applied in OpenGL—we usually
    define a light source that might have a definite color code. Furthermore, we will
    also define the object's color code and then multiply it with the light source.
    The resultant color code or light is the result of reflection from the object,
    which is considered the color of the object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL中使用的颜色属性与现实世界的颜色反射属性非常相似。我们观察到的物体的颜色实际上并不是它的颜色；相反，它是物体反射的颜色。物体可能具有某种波长的属性，物体可以吸收某种颜色并反射出另一种颜色。例如，树木吸收阳光除了绿色。我们感知并假设它是绿色的，但实际上物体没有颜色。这种光反射的概念在OpenGL中得到了很好的应用——通常我们定义一个可能具有明确颜色代码的光源。此外，我们还将定义物体的颜色代码，然后将其与光源相乘。结果的颜色代码或光是从物体反射出来的结果，被认为是物体的颜色。
- en: In the case of OpenGL, color is given in the form of a tuple containing four
    components in which three are red, green, and blue. The fourth component represents
    alpha information, which indicates the level of transparency of the object. Instead
    of providing values of 0 to 255 for RGB components, we provide a value ranging
    from 0 to 1 in the case of OpenGL. For example, yellow is a combination of red
    and green, and so its alpha information is (1, 1, 0). Refer to [https://community.khronos.org/t/color-tables/22518](https://community.khronos.org/t/color-tables/22518)
    to find out more about OpenGL's color code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，颜色以包含四个组件的元组形式给出，其中三个是红色、绿色和蓝色。第四个组件代表alpha信息，表示物体的透明级别。在OpenGL中，与RGB组件的值为0到255不同，我们提供的值范围是0到1。例如，黄色是红色和绿色的组合，因此它的alpha信息是(1,
    1, 0)。请参考[https://community.khronos.org/t/color-tables/22518](https://community.khronos.org/t/color-tables/22518)了解更多关于OpenGL颜色代码的信息。
- en: 'The following functions/features are available in OpenGL''s color properties:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数/特性在OpenGL的颜色属性中可用：
- en: '`glClearColor()`: This function sets a clear color, which means that it fills
    the color on a part of the area that hasn''t been drawn. The value of the color
    code can be given as a tuple containing a value ranging from 0 to 1\. For example,
    `glClearColor(1.0, 1.0, 1.0, 0.0)` represents filling with white.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glClearColor()`: 这个函数设置一个清晰的颜色，这意味着它填充在尚未绘制的区域上的颜色。颜色代码的值可以作为一个元组给出，范围从0到1。例如，`glClearColor(1.0,
    1.0, 1.0, 0.0)`表示用白色填充。'
- en: '`glShadeModel()`: This function enables the lightening features of OpenGL.
    Usually, the argument that''s passed to `glShadeModel` is `GL_FLAT`, which is
    used for shading the faces or edges of shapes such as cubes and pyramids. If you
    want to shade curved objects rather than faceted ones, you can use `GL_SMOOTH`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glShadeModel()`: 这个函数启用了OpenGL的光照特性。通常传递给`glShadeModel`的参数是`GL_FLAT`，用于给形状的面或边缘上色，比如立方体和金字塔。如果你想给曲面对象上色而不是给面体对象上色，你可以使用`GL_SMOOTH`。'
- en: '`glEnable()`: This is not actually a method related to color properties, but
    it is used to enable them. For instance, `glEnable(GL_COLOR_MATERIAL)` will enable *materials*,
    which allows us to interact with the surface and light source. Furthermore, by
    adjusting the settings, the properties of the materials are mostly used to make
    any object lighter and sharper.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glEnable()`: 这实际上不是与颜色属性相关的方法，但是用于启用它们。例如，`glEnable(GL_COLOR_MATERIAL)`将启用*材料*，这允许我们与表面和光源进行交互。此外，通过调整设置，材料的属性主要用于使任何物体更轻和更锐利。'
- en: Now that we are familiar with the concepts of color properties and ways of creating
    color attributes, let's make a simple program that will draw a cube using the
    color properties of PyOpenGL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了颜色属性的概念和创建颜色属性的方法，让我们编写一个简单的程序，使用PyOpenGL的颜色属性来绘制一个立方体。
- en: Brainstorming grids
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头脑风暴网格
- en: Before we start to code, it's always good practice to brainstorm a little bit
    and acquire the necessary information so that we can create a program. Since we
    are going to create a program that will render a cube—a surface that has eight
    vertices, 12 edges, and six faces—we need to define such information explicitly.
    We can define each of these attributes as nested tuples—tuples inside a single
    tuple.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，头脑风暴一下并获取必要的信息总是一个好习惯，这样我们才能创建一个程序。因为我们将创建一个渲染立方体的程序——一个有八个顶点、12条边和六个面的表面——我们需要明确定义这样的信息。我们可以将这些属性定义为嵌套元组——单个元组内的元组。
- en: 'Taking one vertex as a reference, we can simultaneously get the positions of
    other vertices. Let''s assume that a cube has one vertex at (`1`, `-1`, `-1`).
    Now, assuming that all of the edges of a cube have a length of 1 unit, we can
    get the coordinates of the vertices. The following code shows a list of the vertices
    of the cube:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个顶点作为参考，我们可以同时获取其他顶点的位置。假设一个立方体有一个顶点在（`1`，`-1`，`-1`）。现在，假设立方体的所有边都是1个单位长，我们可以得到顶点的坐标。以下代码显示了立方体的顶点列表：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, there are 12 edges (edges are the lines that are drawn from one
    vertex to another). Since there are eight vertices ( 0 to 7), let''s write some
    code that defines the 12 edges using eight vertices. The identifiers that are
    passed as tuples in the following code represent the edges or sides that are drawn
    from one vertex to another. For example, tuple (`0`, `1`) indicates the edge that
    was drawn from vertex 0 to vertex 1:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有12条边（边是从一个顶点到另一个顶点画出的线）。由于有八个顶点（0到7），让我们编写一些代码，使用八个顶点定义12条边。在以下代码中，作为元组传递的标识符表示从一个顶点到另一个顶点画出的边或面。例如，元组（`0`，`1`）表示从顶点0到顶点1画出的边：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, the last piece of information that must be provided is about surfaces.
    A cube has six faces, each of which contains four vertices and four edges. We
    can provide this information like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须提供的最后一部分信息是关于表面的。一个立方体有六个面，每个面包含四个顶点和四条边。我们可以这样提供这些信息：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the order in which the vertices, edges, and surface are provided matters.
    For example, in the `cube_Surfaces` data structure, if you swapped the second
    item of the tuple with the first one, the shape of the cube will deteriorate.
    This is because each piece of information is linked with vertex information, that
    is, surface (`0`, `1`, `2`, `3`) contains the first, second, third, and fourth
    vertices.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意提供顶点、边和表面的顺序很重要。例如，在`cube_Surfaces`数据结构中，如果你交换了元组的第二个项目和第一个项目，立方体的形状将会恶化。这是因为每个信息都与顶点信息相关联，也就是说，表面（`0`，`1`，`2`，`3`）包含了第一个、第二个、第三个和第四个顶点。
- en: Now that we've finished brainstorming and gathered some useful information about
    the shape we are going to draw, it's time to start rendering the cube using PyOpenGL
    and its library, which is often referred to as the *GLU library*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了头脑风暴，并收集了关于我们要绘制的形状的一些有用信息，是时候开始使用PyOpenGL及其库来渲染立方体了，这个库通常被称为*GLU库*。
- en: Understanding the GLU library
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GLU库
- en: 'Now that we''ve collected information about the edges, sides, and vertices
    of our shape, we can start coding the model. We have already studied how we can
    draw shapes with OpenGL using methods such as `glBegin()` and `glVertex3fv()`.
    Let''s use them and create a function that can draw a cube structure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了关于我们形状的边、面和顶点的信息，我们可以开始编写模型了。我们已经学习了如何使用`glBegin()`和`glVertex3fv()`等方法使用OpenGL绘制形状。让我们使用它们，并创建一个可以绘制立方体结构的函数：
- en: 'Start by importing OpenGL and the GLU library. Right after importing the library,
    add the information we acquired regarding the vertices, edges, and surfaces that
    we defined while brainstorming to the same file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入OpenGL和GLU库。在导入库之后，将我们在头脑风暴中定义的有关顶点、边和表面的信息添加到同一个文件中：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, define the function and fetch the surfaces and vertex. This process is
    quite simple; we will start by drawing the surfaces for the cube. We should use
    the `GL_QUADS` property to draw four-sided surfaces (confused? Refer to the *Making
    objects with OpenGL* section of this chapter for more information):'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义函数并获取表面和顶点。这个过程非常简单；我们将从绘制立方体的表面开始。我们应该使用`GL_QUADS`属性来绘制四面体表面（困惑吗？请参考本章的*使用OpenGL制作对象*部分获取更多信息）：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, inside the `renderCube()` method, write some code that can draw a
    line segment. The `GL_LINES` parameter is used to draw a line segment:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`renderCube()`方法中，编写一些可以绘制线段的代码。使用`GL_LINES`参数来绘制线段：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This three-line procedure is enough to create even complex geometrical shapes.
    Now, you can perform multiple operations on these cubes. For example, you can
    perform operations such as the rotation of objects by using mouse trackpads. As
    we know, handling such user events requires a `pygame` module. Hence, let''s define
    a function that will take care of event handling, along with some of the characteristics
    of PyOpenGL. Begin your code with the `import pygame` statement and add the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个三行的过程足以创建复杂的几何形状。现在，你可以对这些立方体执行多个操作。例如，你可以使用鼠标触控板旋转物体。正如我们所知，处理这样的用户事件需要一个`pygame`模块。因此，让我们定义一个函数，来处理事件，并使用PyOpenGL的一些特性。从`import
    pygame`语句开始你的代码，并添加以下代码：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code snippet is quite simple to understand since we have been
    doing this from the beginning of this chapter. Here, we've used the `pygame` module,
    which sets the game screen with an OpenGL scene or interface. We have added a
    transformation matrix, which performs clipping using the `gluPerspective()` function.
    Finally, we added the initial position of the cube before actual rotation (where
    we might be at the beginning).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段非常容易理解，因为我们从本章的开始就一直在做这个。在这里，我们使用了`pygame`模块，它使用OpenGL场景或接口设置游戏屏幕。我们添加了一个变换矩阵，它使用`gluPerspective()`函数执行裁剪。最后，我们在实际旋转之前添加了立方体的初始位置（在开始时可能在哪里）。
- en: 'Now that we have addressed the basic primers of OpenGL, let''s use pygame''s
    event handling method to manipulate the structure of the cube, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了OpenGL的基本知识，让我们使用pygame的事件处理方法来操纵立方体的结构，就像这样：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After handling the events that are based on mouse button navigation, let''s
    use some of the methods provided by PyOpenGL to render the cube. We will use methods
    such as `glRotatef()`, which will perform matrix transformation. Write the following
    code just after where we handled the events:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理基于鼠标按钮导航的事件之后，让我们使用PyOpenGL提供的一些方法来渲染立方体。我们将使用`glRotatef()`等方法来执行矩阵变换。在处理事件的地方之后，写入以下代码：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The highlighted part of the preceding code denotes a resize transformation,
    which ultimately leads to the ZOOM-UP and ZOOM-DOWN features being used. Now,
    you can run the program and observe the cube being rendered at the center of the
    pygame screen, in yellow. Try using an external mouse and using the navigation
    buttons (buttons 4 and 5) to zoom in and zoom out. You can also observe how clipping
    is used in the project: whenever we make a cube so big that it exceeds the clipping
    plane, some parts of the cube are removed from the viewport.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的突出部分表示调整大小的变换，最终导致了使用ZOOM-UP和ZOOM-DOWN功能。现在，您可以运行程序，观察立方体在pygame屏幕中心以黄色渲染。尝试使用外部鼠标和导航按钮（按钮4和5）进行放大和缩小。您还可以观察项目中如何使用裁剪：每当我们使一个立方体变得如此之大以至于超出裁剪平面时，立方体的一些部分将从视口中移除。
- en: In this way, we can combine two powerful Python gaming modules, that is, *pygame*
    and *PyOpenGL*, to make 3D scenes and interfaces. We have only skimmed the ways
    of creating some shapes and how to transform them. Now, it's up to you to discover
    more about PyOpenGL and try to make a game that's much more user-friendly and
    attractive by providing rich textures and content.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以结合两个强大的Python游戏模块，即*pygame*和*PyOpenGL*，制作3D场景和界面。我们只是简单地介绍了创建一些形状和如何变换它们的方法。现在，轮到您去发现更多关于PyOpenGL的知识，并尝试制作一个更加用户友好和吸引人的游戏，提供丰富的纹理和内容。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered many interesting topics in this chapter, mostly regarding surfaces
    and geometrical shapes. Although we used the term *matrix* in this chapter, we
    didn't bother performing matrix computation using a mathematical approach because
    Python has everything built-in to perform such operations. Still, we should remember
    the old adage, *game programmers don't need to have a PhD in mathematics*, since
    knowing a basic level of math is enough if we want to make games. Here, we only
    learned about translation, scaling, and rotation, which are enough if we want
    to make a 3D scene. We didn't get bogged down by learning about the concepts of
    translations or scaling using the mathematical approach—instead, we learned about
    using the programming approach.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多有趣的主题，主要涉及表面和几何形状。虽然在本章中我们使用了术语*矩阵*，但我们并没有使用数学方法进行矩阵计算，因为Python内置了执行此类操作的一切。尽管如此，我们应该记住这句古老的格言，*游戏程序员不需要拥有数学博士学位*，因为只要我们想制作游戏，基本的数学水平就足够了。在这里，我们只学习了平移、缩放和旋转，如果我们想制作一个3D场景，这已经足够了。我们没有陷入使用数学方法进行平移或缩放的概念中——相反，我们学习了使用编程方法。
- en: We started off by learning how to set up the OpenGL display screen by using
    pygame's `setting` method. Since OpenGL is a vast and profound field of study,
    covering everything in a single chapter was impossible. Hence, we only covered
    how to load/store three-dimensional models and how to apply them to the OpenGL
    rendering surface by applying clipping, rotate, and resize transformations. We
    also studied color properties and used them with PyOpenGL and pygame. The main
    goal of this chapter was to make it easier for you to understand how to create
    3D shapes using OpenGL 3D scenes while providing critical geometrical information
    such as vertices, edges, and surfaces. You will now be able to work with OpenGL
    to create 3D shapes, figures, and visuals. You now also know how to distinguish
    the color property of OpenGL from any other coloring patterns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了如何使用pygame的`setting`方法设置OpenGL显示屏。由于OpenGL是一个广阔而深奥的研究领域，无法在单一章节中涵盖所有内容。因此，我们只涵盖了如何加载/存储三维模型以及如何通过应用裁剪、旋转和调整大小变换将它们应用到OpenGL渲染表面上。我们还研究了颜色属性，并将它们与PyOpenGL和pygame一起使用。本章的主要目标是让您更容易理解如何使用OpenGL创建3D形状，同时提供关键的几何信息，如顶点、边和表面。现在您将能够使用OpenGL创建3D形状、图形和可视化。您现在也知道如何将OpenGL的颜色属性与其他着色模式区分开来。
- en: In the next chapter, we will learn about another important module, which goes
    by the name of *Pymunk*. This is a very powerful physics library that adds physics
    capabilities for game characters. We will learn about the different terms that
    are used when we need to talk about real-world environments, such as velocity
    and acceleration, which are used to handle collisions and the movement of game
    characters. While learning about these concepts, we will also be making an Angry
    Bird game, which we will deploy across various platforms.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个重要的模块，名为*Pymunk*。这是一个非常强大的物理库，为游戏角色增加了物理能力。我们将学习在需要讨论真实世界环境时使用的不同术语，如速度和加速度，这些术语用于处理碰撞和游戏角色的移动。在学习这些概念的同时，我们还将制作一个愤怒的小鸟游戏，并将其部署到各种平台上。
