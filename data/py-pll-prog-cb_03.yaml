- en: Process-Based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于进程的并行处理
- en: In the previous chapter, we learned how to use threads to implement concurrent
    applications. This chapter will examine the process-based approach that we introduced
    in [Chapter 1](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml), *Getting Started with
    Parallel Computing and Python*. In particular, the focus of the chapter is on
    the Python `multiprocessing` module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用线程来实现并发应用程序。本章将讨论我们在[第1章](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml)中介绍的基于进程的方法，*使用并行计算和Python入门*。特别是，本章的重点是Python的`multiprocessing`模块。
- en: The Python `multiprocessing` module, which is a part of the standard library
    of the language, implements the shared memory programming paradigm, that is, the
    programming of a system that consists of *one or more processors* that have access
    to a shared memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`multiprocessing`模块是语言标准库的一部分，实现了共享内存编程范式，即一个或多个处理器可以访问共享内存的系统的编程。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding Python's `multiprocessing` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Python的`multiprocessing`模块
- en: Spawning a process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个进程
- en: Naming a process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给进程命名
- en: Running processes in the background
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台运行进程
- en: Killing a process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杀死进程
- en: Defining a process in a subclass
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子类中定义一个进程
- en: Using a queue to exchange objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列交换对象
- en: Using pipes to exchange objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道交换对象
- en: Synchronizing processes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步进程
- en: Managing a state between processes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理进程之间的状态
- en: Using a process pool
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用进程池
- en: Understanding Python's multiprocessing module
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Python的多进程模块
- en: The introduction of the Python `multiprocessing` documentation ([https://docs.python.org/2.7/library/multiprocessing.html#introduction](https://docs.python.org/2.7/library/multiprocessing.html#introduction))
    clearly mentions that all the functionality within this package requires the `main`
    module to be importable to the children ([https://docs.python.org/3.3/library/multiprocessing.html](https://docs.python.org/3.3/library/multiprocessing.html)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`multiprocessing`文档（[https://docs.python.org/2.7/library/multiprocessing.html#introduction](https://docs.python.org/2.7/library/multiprocessing.html#introduction)）清楚地提到，这个包中的所有功能都需要`main`模块对子模块可导入（[https://docs.python.org/3.3/library/multiprocessing.html](https://docs.python.org/3.3/library/multiprocessing.html)）。
- en: 'The `__main__` module is not importable to the children in IDLE, even if you
    run the script as a file with IDLE. To get the correct result, we will run all
    the examples from Command Prompt:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__`模块在IDLE中对子模块不可导入，即使你在IDLE中以文件形式运行脚本。为了得到正确的结果，我们将从命令提示符中运行所有的例子：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `multiprocessing_example.py` is the script's name.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`multiprocessing_example.py`是脚本的名称。
- en: Spawning a process
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个进程
- en: Spawning a process is the creation of a *child process* from a *parent process.*
    The latter continues its execution asynchronously or waits until the child process
    ends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成进程是从*父进程*创建*子进程*。后者会异步地继续执行或等待子进程结束。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The `multiprocessing` library allows spawning processes by following these
    steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库允许通过以下步骤生成进程：'
- en: '*Define* the `process` object.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*定义*`process`对象。'
- en: '*Call* the `start()` method of the process to run it.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*调用*进程的`start()`方法来运行它。'
- en: '*Call* the `join()` method of the process. It waits until the process has completed
    the job and then exits.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*调用*进程的`join()`方法。它会等待直到进程完成工作然后退出。'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s have a look at the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'To create a process, we need to import the `multiprocessing` module with the
    following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个进程，我们需要使用以下命令导入`multiprocessing`模块：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each process is associated with the `myFunc(i)` function. This function outputs
    the numbers from `0` to `i`, where `i` is the ID associated with the process number:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '每个进程都与`myFunc(i)`函数相关联。这个函数输出从`0`到`i`的数字，其中`i`是与进程编号相关联的ID： '
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we define the `process` object with `myFunc` as the`target` function:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用`myFunc`作为`target`函数定义`process`对象：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we call the `start` and `join` methods on the process created:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在创建的进程上调用`start`和`join`方法：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Without the `join` method, child processes do not end and must be killed manually.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`join`方法，子进程不会结束，必须手动杀死。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this section, we have therefore seen how it is possible to create processes
    by starting from a parent process. This feature is called *spawning a process*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何从父进程开始创建进程。这个特性被称为*生成进程*。
- en: 'Python''s `multiprocessing` library allows easy process management by following
    three simple steps. The first step is the process definition through the `multiprocessing`
    class method,`Process`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`multiprocessing`库通过以下三个简单步骤轻松管理进程。第一步是通过`multiprocessing`类方法`Process`定义进程：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Process` method has as an argument of the function to spawn, `myFunc`,
    and any arguments of the function itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process`方法有一个要生成的函数`myFunc`和函数本身的任何参数作为参数。'
- en: 'The following two steps are necessary to execute and exit the process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个步骤是执行和退出进程所必需的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run the process and display the results, let''s open Command Prompt, preferably
    in the same folder containing the example file (`spawning_processes.py`), and
    then type the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行进程并显示结果，让我们打开命令提示符，最好是在包含示例文件（`spawning_processes.py`）的相同文件夹中，然后输入以下命令：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each process created (there are six in all), the output of the target function
    is shown. Remember that this is a simple counter from `0` up to the index of the
    process ID:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个创建的进程（总共有六个），显示目标函数的输出。记住这只是一个从`0`到进程ID的索引的简单计数器：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This reminds us once again of the importance of instantiating the `Process`
    object within the main section: this is because the child process created imports
    the script file where the `target` function is contained. Then, by instantiating
    the `process` object within this block, we prevent an infinite recursive call
    of such instantiations.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次提醒我们在主要部分内实例化`Process`对象的重要性：这是因为创建的子进程导入包含`target`函数的脚本文件。然后，通过在此块内实例化`process`对象，我们防止了这种实例化的无限递归调用。
- en: 'A valid workaround is used to define the `target` function in a different script,
    namely `myFunc.py`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效的解决方法在不同的脚本中定义`target`函数，即`myFunc.py`：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `main` program containing the process instance is defined in a second file
    (`spawning_processes_namespace.py`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 包含进程实例的`main`程序在第二个文件（`spawning_processes_namespace.py`）中定义：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To run this example, type the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请输入以下命令：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output is the same as the previous example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与上一个示例相同。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official guide for the `multiprocessing` library can be found at[https://docs.python.org/3/](https://docs.python.org/3/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库的官方指南可以在[https://docs.python.org/3/](https://docs.python.org/3/)找到。'
- en: Naming a process
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给进程命名
- en: In the previous example, we identified the processes and how to pass a variable
    to the target function. However, it is very useful to associate a name to the
    processes as debugging an application requires the processes to be well marked
    and identifiable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们确定了进程以及如何将变量传递给目标函数。然而，将进程与名称关联起来非常有用，因为调试应用程序需要对进程进行良好标记和识别。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: At some point in your code, it may be crucial to know what process is currently being
    executed. For this purpose, the `multiprocessing` library provides the `current_process()`
    method, which uses the `name` attribute to identify which process is currently
    running. In the following section, we'll learn about this topic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的某个时刻，了解当前正在执行的进程可能是至关重要的。为此，`multiprocessing`库提供了`current_process()`方法，该方法使用`name`属性来标识当前正在运行的进程。在接下来的部分中，我们将学习这个主题。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'The `target` function for both the processes is the`myFunc` function. It outputs
    the process name by evaluating the `multiprocessing.current_process().name` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个进程的`target`函数都是`myFunc`函数。它通过评估`multiprocessing.current_process().name`方法输出进程名称：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we create `process_with_name`simply by instantiating the `name` parameter
    and`process_with_default_name`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过实例化`name`参数和`process_with_default_name`来创建`process_with_name`：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the processes are started and then joined:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动进程，然后加入：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` program, the processes are created using the same target function,`myFunc`.
    This function simply prints the process name.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，使用相同的目标函数`myFunc`创建进程。这个函数只是简单地打印进程名称。
- en: 'To run the example, open Command Prompt and type the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请打开命令提示符并输入以下命令：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The main Python process is `multiprocessing.process._MainProcess`, while child
    processes are `multiprocessing.process.Process`. It can be tested by simply typing
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 主Python进程是`multiprocessing.process._MainProcess`，而子进程是`multiprocessing.process.Process`。可以通过简单地输入以下内容进行测试：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More on this topic can be found at [https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/](https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请访问[https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/](https://doughellmann.com/blog/2012/04/30/determining-the-name-of-a-process-from-python/)。
- en: Running processes in the background
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台运行进程
- en: Running in the background is a mode of execution that is typical of some programs
    that do not require the presence or intervention of the user, and which may be
    concurrent to the execution of other programs (and therefore, it is only possible
    in multitasking systems), resulting in the user being unaware about it. Background
    programs typically perform long or time-consuming tasks such as peer-to-peer filesharing
    programs or defragmentation of filesystems. Many OS processes also run in the
    background.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台运行是一种典型的执行模式，适用于一些不需要用户存在或干预的程序，并且可能与其他程序的执行同时进行（因此，只有在多任务系统中才可能），导致用户对此毫不知情。后台程序通常执行长时间或耗时的任务，如点对点文件共享程序或文件系统的碎片整理。许多操作系统进程也在后台运行。
- en: In Windows, programs in this mode (scanning antiviruses or OS updates) often
    place an icon in the system tray (the area of the desktop next to the system clock)
    in order to signal their activity and adopt behaviors that reduce the use of resources
    so as to not interfere with the user's interactive activities, such as slowing
    down or causing interruptions. In Unix and Unix-like systems, processes that run
    in the background are called **daemons**. Using a task manager can highlight all
    running programs including those in the background.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，以这种模式运行的程序（如扫描防病毒软件或操作系统更新）通常会在系统托盘（桌面旁边的系统时钟区域）放置一个图标，以便通知它们的活动，并采取减少资源使用的行为，以免干扰用户的交互活动，如减慢或引起中断。在Unix和类Unix系统中，运行在后台的进程称为**守护进程**。使用任务管理器可以突出显示所有运行的程序，包括后台程序。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The `multiprocessing` module allows—through the daemonic option—to run background
    processes. In the following example, two processes are defined:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块允许通过守护选项运行后台进程。在以下示例中，定义了两个进程：'
- en: '`background_process` with their`daemon` parameter set to `True`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background_process`，其`daemon`参数设置为`True`'
- en: '`NO_background_process` with their`daemon` parameter set to `False`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_background_process`，其`daemon`参数设置为`False`'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following example, we implement a target function, namely `foo`, which
    displays the digits from `0` to `4` **if** the child process is in the**background**;
    otherwise, it prints the digits from `5` to `9`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们实现了一个目标函数，即`foo`，它显示从`0`到`4`的数字**如果**子进程在**后台**；否则，它打印从`5`到`9`的数字：
- en: 'Let''s import the relevant libraries:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关的库：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we define the `foo()` function. As previously specified, the printed
    digits depend on the value of the `name` parameter:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`foo()`函数。如前所述，打印的数字取决于`name`参数的值：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we define the following processes: `background_process` and `NO_background_process`.
    Notice that the `daemon` parameter is set for the two processes:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义以下进程：`background_process`和`NO_background_process`。注意，`daemon`参数设置为这两个进程：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Note that only the `daemon` parameter of the process defines whether the process
    should run in the background or not. To run this example, type the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，进程的`daemon`参数定义了进程是否应该在后台运行。要运行这个例子，输入以下命令：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output clearly reports only the `NO_background_process` output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地只报告了`NO_background_process`的输出：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output changes the setting of the `daemon` parameter for `background_process`
    to `False`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`background_process`的`daemon`参数设置为`False`：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To run this example, type the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个例子，输入以下内容：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output reports the execution of both the `background_process` and `NO_background_process` processes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出报告了`background_process`和`NO_background_process`进程的执行：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A code snippet on how to run a Python script in the background in Linux can
    be found at [https://janakiev.com/til/python-background/](https://janakiev.com/til/python-background/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://janakiev.com/til/python-background/](https://janakiev.com/til/python-background/)找到有关如何在Linux中后台运行Python脚本的代码片段。
- en: Killing a process
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程
- en: There is no perfect software and even in the best applications, you can nest
    a bug that leads to blocking the application, which is why modern OSes have developed
    several methods to terminate the processes of applications in order to free the
    system resources and allow the user to use them for other operations as soon as
    possible. This section will show you how to kill a process in your multiprocessing
    application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完美的软件，即使在最好的应用程序中，也可能存在导致阻塞应用程序的错误，这就是为什么现代操作系统开发了几种方法来终止应用程序的进程，以释放系统资源并允许用户尽快将其用于其他操作。本节将向您展示如何在多进程应用程序中终止进程。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's possible to kill a process immediately by using the `terminate` method.
    Also, we use the `is_alive` method to keep track of whether the process is alive
    or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`terminate`方法立即终止一个进程。此外，我们使用`is_alive`方法来跟踪进程是否存活。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps allow us to perform the recipe:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤允许我们执行该过程：
- en: 'Let''s import the relevant libraries:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入相关的库：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, a simple `target` function is implemented. In this example, the `target`
    function, `foo()`, prints the first `10` digits:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现一个简单的`target`函数。在这个例子中，`target`函数`foo()`打印前`10`个数字：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `main` program, we create a process monitoring its lifetime by the `is_alive`
    method; then, we finish it with a call to `terminate`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们创建一个进程，通过`is_alive`方法监视其生命周期；然后，我们通过调用`terminate`结束它：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we verify the status code when the process is finished and read the attribute
    of the `ExitCode` process:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当进程完成时，我们验证状态码并读取`ExitCode`进程的属性：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The possible values of `ExitCode` are as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExitCode`的可能值如下：'
- en: '`== 0`: No error was produced.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`== 0`：没有产生错误。'
- en: '`> 0`: The process had an error and exited that code.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`> 0`：进程出现错误并退出该代码。'
- en: '`< 0`: The process was killed with a signal of `-1 * ExitCode`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< 0`：进程被`-1 * ExitCode`的信号终止。'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The sample code consists of a target function, `foo()`, whose task is to print
    out the first `10` integer numbers on the screen. In the `main`program, the process
    is executed and then killed by the `terminate` instruction. The process is then
    joined and `ExitCode` is determined.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码由一个目标函数`foo()`组成，其任务是在屏幕上打印出前`10`个整数。在`main`程序中，执行该进程，然后通过`terminate`指令终止它。然后加入该进程并确定`ExitCode`。
- en: 'To run the code, type the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，请输入以下命令：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到了以下输出：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that the output value of the `ExitCode` code is equal to `**-**15`. The
    negative value of `-15` indicates that the child was terminated by an interrupt
    signal, which is identified by the number `15`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ExitCode`代码的输出值等于`**-**15`。`-15`的负值表示子进程被中断信号终止，该信号由数字`15`标识。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: On a Linux machine, a Python process can be identified and then killed simply
    by following the tutorial at [http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html](http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上，可以通过以下教程简单地识别并终止Python进程：[http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html](http://www.cagrimmett.com/til/2016/05/06/killing-rogue-python-processes.html)。
- en: Defining processes in a subclass
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在子类中定义进程
- en: The `multiprocessing` module provides access to process management functionalities.
    In this section, we'll learn about how to define a process in a subclass of the
    `multiprocessing.Process` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块提供了对进程管理功能的访问。在本节中，我们将学习如何在`multiprocessing.Process`类的子类中定义一个进程。'
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To implement a multiprocessing custom subclass, we need to do the following
    things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个多进程的自定义子类，我们需要做以下几件事：
- en: '*Define* a subclass of the `multiprocessing.Process` class, redefining the
    `run()` method.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义*`multiprocessing.Process`类的子类，重新定义`run()`方法。'
- en: '*Override* the `_init__(self [,args])` method to add additional arguments,
    if needed.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖*`_init__(self [,args])`方法以添加额外的参数，如果需要的话。'
- en: '*Override* the `run(self [,args])` method to implement what `Process` should
    do when it is started.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*覆盖*`run(self [,args])`方法来实现`Process`在启动时应该做什么。'
- en: Once you have created the new `Process` subclass, you can create an instance
    of it and then start by invoking the `start` method, which will, in turn, call
    the `run` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了新的`Process`子类，你可以创建它的一个实例，然后通过调用`start`方法来启动，这将依次调用`run`方法。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Just consider a very simple example, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只需考虑一个非常简单的例子，如下所示：
- en: 'Import the relevant library first:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入相关的库：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, define a subclass, `MyProcess`, overriding only the `run` method, which
    returns the process'' name:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个子类`MyProcess`，只覆盖`run`方法，该方法返回进程的名称：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `main` program, we define a subclass of `10` processes:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们定义了`10`个进程的子类：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Each process subclass is represented by a class that extends the `Process`
    class and overrides the`run()` method. This method is the starting point of `Process`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过程子类由扩展`Process`类并覆盖`run()`方法的类表示。这个方法是`Process`的起点：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `main` program, we create several objects of the`MyProcess()` type.The
    execution of the thread begins when the `start()` method is called:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们创建了`MyProcess()`类型的几个对象。当调用`start()`方法时，线程的执行就开始了：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `join()` command just handles the termination of processes. To run the
    script from Command Prompt, type the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`命令只处理进程的终止。要从命令提示符运行脚本，请输入以下命令：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In object-oriented programming, a subclass is a class that inherits all properties
    from a superclass, whether they are objects or methods. An alternative name to
    subclass is *derived class*. *Inheritance* is the specific term that indicates
    this process by which the daughter or derived classes inherit the properties of
    parent classes or superclasses.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，子类是继承自超类的所有属性的类，无论它们是对象还是方法。子类的另一个名称是*派生类*。*继承*是指示子类或派生类继承父类或超类属性的特定术语。
- en: You can think of a subclass as a particular genre of its superclass; in fact,
    it can use methods and/or attributes, as well as redefine them through *overriding*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把子类看作是其超类的一个特定类型；事实上，它可以使用方法和/或属性，并通过*覆盖*重新定义它们。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on class definition techniques can be found at [http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html](http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类定义技术的更多信息可以在[http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html](http://buildingskills.itmaybeahack.com/book/python-2.6/html/p03/p03c02_adv_class.html)找到。
- en: Using a queue to exchange data
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列交换数据
- en: A *queue* is a data structure of the**First-In, First-Out** (**FIFO**) type (the
    first input is the first to exit). A practical example is the queues to get a
    service, how to pay at the supermarket, or get your hair cut at the hairdresser.
    Ideally, you are served in the same order as you were presented to. This is exactly
    how a FIFO queue works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列*是一种**先进先出**（**FIFO**）类型的数据结构（第一个输入是第一个退出）。一个实际的例子是排队等待服务，如在超市付款，或者在理发店理发。理想情况下，你会按照你的出现顺序被服务。这正是FIFO队列的工作原理。'
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this section, we show you how to use a queue for a *producer-consumer* problem,
    thatis a classic example of *process synchronization*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何使用队列解决*生产者-消费者*问题，这是*进程同步*的一个经典例子。
- en: 'The **producer-consumer** problem describes two *processes*: one is the *producer*
    and the other is a *consumer*, sharing a **common** **buffer** of a **fixed**
    **size**.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产者-消费者**问题描述了两个*进程*：一个是*生产者*，另一个是*消费者*，它们共享一个**固定大小**的**公共缓冲区**。'
- en: The task of the *producer* is to generate data and to deposit it in the buffer
    continuously. At the same time, the *consumer* will use the data produced, removing
    it from the buffer from time to time. The problem is to ensure that the producer
    does not process new data if the buffer is full and that the consumer does not
    look for data if the buffer is empty. The solution for the producer is to suspend
    its execution if the buffer is full.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*生产者*的任务是不断生成数据并将其存入缓冲区。与此同时，*消费者*将使用生成的数据，不时地从缓冲区中移除。问题在于确保如果缓冲区已满，生产者不会处理新数据，如果缓冲区为空，消费者不会寻找数据。生产者的解决方案是在缓冲区已满时暂停执行。'
- en: As soon as the consumer has taken an item from the buffer, the producer wakes
    up and starts to fill the buffer again. Similarly, the consumer will suspend if
    the buffer is empty. As soon as the producer has downloaded the data into the
    buffer, the consumer wakes up.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消费者从缓冲区中取出一个项目，生产者就会醒来并开始重新填充缓冲区。同样，如果缓冲区为空，消费者将暂停。一旦生产者将数据下载到缓冲区中，消费者就会醒来。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This solution can be implemented by means of communication strategies between
    processes, shared memory, or message passing. An incorrect solution could result
    in a deadlock, in which both processes wait to be awakened:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案可以通过进程之间的通信策略、共享内存或消息传递来实现。一个不正确的解决方案可能导致死锁，即两个进程都在等待被唤醒：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s perform the steps as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤执行：
- en: 'The `producer` class is responsible for entering `10` items in the queue by
    using the `put` method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`producer`类负责使用`put`方法在队列中输入`10`个项目：'
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `consumer` class has the task of removing the items from the queue (using
    the `get` method) and verifying that the queue is not empty. If this happens,
    then the flow inside the `while` loop ends with a `break` statement:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`consumer`类的任务是从队列中移除项目（使用`get`方法）并验证队列不为空。如果发生这种情况，那么`while`循环内的流程将以`break`语句结束：'
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `multiprocessing` class has its `queue` object instantiated in the `main` program:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`multiprocessing`类在`main`程序中实例化了它的`queue`对象：'
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Within the `main` program, we define the queue using the `multiprocessing.Queue`object.
    Then, it is passed as an argument to the `producer ` and`consumer` processes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们使用`multiprocessing.Queue`对象定义队列。然后，将其作为参数传递给`producer`和`consumer`进程：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the `producer`class, the `queue.put` method is used to append new items
    to the queue:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`producer`类中，使用`queue.put`方法将新项目附加到队列中：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'While in the `consumer` class, the `queue.get` method is used to po*p* out
    the items:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`consumer`类中，使用`queue.get`方法弹出项目：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Execute the code by typing the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行代码：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following output reports the interaction between the producer and the consumer:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出报告了生产者和消费者之间的交互：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A queue has the `JoinableQueue` subclass. This provides the following methods:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 队列有`JoinableQueue`子类。这提供了以下方法：
- en: '`task_done()`: This method indicates that a task is complete, for example,
    after using the `get()` method to fetch items from the queue. So `task_done()`
    must be used only by queue consumers.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_done()`: 此方法表示任务已完成，例如，在使用`get()`方法从队列中获取项目后。因此，`task_done()`只能由队列消费者使用。'
- en: '`join()`: This method blocks the processes until all the items in the queue
    have been completed and processed.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`: 此方法阻塞进程，直到队列中的所有项目都已完成并被处理。'
- en: See also
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A good tutorial on how to use a queue is available at [https://www.pythoncentral.io/use-queue-beginners-guide/](https://www.pythoncentral.io/use-queue-beginners-guide/).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于如何使用队列的好教程，可以在[https://www.pythoncentral.io/use-queue-beginners-guide/](https://www.pythoncentral.io/use-queue-beginners-guide/)找到。
- en: Using pipes to exchange objects
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道交换对象
- en: 'A *pipe* does the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*管道*执行以下操作：'
- en: It returns a pair of connection objects connected by a pipe.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一对由管道连接的连接对象。
- en: Every connection object has to send/receive methods to communicate between processes.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个连接对象都必须有发送/接收方法来在进程之间进行通信。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `multiprocessing` library allows you to implement a pipe data structure
    using the`multiprocessing.Pipe (duplex)` function. This returns a pair of objects, `(conn1,
    conn2)`, which represent the end of the pipe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库允许您使用`multiprocessing.Pipe(duplex)`函数实现管道数据结构。这将返回一对对象，`(conn1,
    conn2)`，它们代表管道的端点。'
- en: The `duplex` parameter determines whether the pipe for the last case is bidirectional
    (that is,`duplex = True`), or unidirectional (that is, `duplex = False`). `conn1`
    can only be used for receiving messages, and `conn2` can only be used for sending
    messages.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`duplex`参数确定了最后一种情况的管道是双向的（即`duplex = True`）还是单向的（即`duplex = False`）。`conn1`只能用于接收消息，`conn2`只能用于发送消息。'
- en: Now, let's see how to exchange objects using pipes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用管道交换对象。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here is a simple example of pipes. We have one process pipe that outputs numbers
    from `0` to `9`, and a second process pipe that takes the numbers and squares
    them:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个管道的简单示例。我们有一个进程管道，输出从`0`到`9`的数字，还有一个进程管道，接收这些数字并对其进行平方处理：
- en: 'Let''s import the `multiprocessing` library:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入`multiprocessing`库：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `pipe` function returns a pair of connection objects connected by a *two-way*
    pipe. In the example, `out_pipe` contains the numbers from `0` to `9`, which were
    generated by the `target` function of`create_items`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pipe`函数返回一对由*双向*管道连接的连接对象。在示例中，`out_pipe`包含了由`create_items`的`target`函数生成的从`0`到`9`的数字：'
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `multiply_items` function is based on two pipes, `pipe_1` and `pipe_2`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`multiply_items`函数基于两个管道`pipe_1`和`pipe_2`：'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This function returns the product of the elements of each pipe:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数返回每个管道元素的乘积：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `main` program,`pipe_1`, and `pipe_2` are defined:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，定义了`pipe_1`和`pipe_2`：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, process `pipe_1` with numbers from `0` to `9`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，处理从`0`到`9`的数字的`pipe_1`：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, process `pipe_2`, which picks up the numbers from `pipe_1` and squares
    them:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，处理`pipe_2`，它从`pipe_1`中取出数字并对其进行平方处理：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Close the processes:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭进程：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Print out the results:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出结果：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Essentially, the two pipes, `pipe_1` and `pipe_2`, are created by the `multiprocessing.Pipe(True)`
    statement:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，两个管道`pipe_1`和`pipe_2`是由`multiprocessing.Pipe(True)`语句创建的：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first pipe, `pipe_1`, simply created a list of integers from `0` to `9`,
    while the second pipe, `pipe_2`, processed each element of the list created by
    `pipe_1`, calculating the squared value of each element:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管道`pipe_1`只是创建了一个从`0`到`9`的整数列表，而第二个管道`pipe_2`则处理了`pipe_1`创建的列表的每个元素，计算了每个元素的平方值：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Therefore, both processes are closed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，两个进程都已关闭：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And the final result is printed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果被打印出来：
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Execute the code by typing the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行代码：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following result shows the square of the first `9` digits:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果显示了前`9`个数字的平方：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you need more than two points to communicate, then use a `Queue()` method.
    However, if you need absolute performance, then a `Pipe()` method is much faster
    because `Queue()` is built on top of `Pipe()`**.**
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要超过两个点进行通信，则使用`Queue()`方法。但是，如果您需要绝对的性能，则`Pipe()`方法要快得多，因为`Queue()`是建立在`Pipe()`之上的**。**
- en: See also
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on Python and pipes can be found at [https://www.python-course.eu/pipes.php](https://www.python-course.eu/pipes.php%0d).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python和管道的更多信息，请访问[https://www.python-course.eu/pipes.php](https://www.python-course.eu/pipes.php%0d)。
- en: Synchronizing processes
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步进程
- en: Multiple processes can work together to perform a given task. Usually, they
    share data. It is important that access to shared data by various processes does
    not produce inconsistent data. Processes that cooperate by sharing data must,
    therefore, act in an orderly manner in order for that data to be accessible. Synchronization
    primitives are quite like those encountered for the library and threading.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 多个进程可以共同执行给定的任务。通常，它们共享数据。重要的是，各个进程对共享数据的访问不会产生不一致的数据。因此，通过共享数据合作的进程必须以有序的方式行事，以便该数据可被访问。同步原语与库和线程中遇到的非常相似。
- en: 'Synchronization primitives are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 同步原语如下：
- en: '**Lock**: This object can be in either the locked or unlocked state. A locked
    object has two methods, `acquire()` and `release()`, to manage access to a shared
    resource.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁**：此对象可以处于锁定或解锁状态。锁定对象有两种方法，`acquire()`和`release()`，用于管理对共享资源的访问。'
- en: '**Event**: This object realizes simple communication between processes; one
    process signals an event and the other processes wait for it. An event object
    has two methods, `set()` and `clear()`, to manage its own internal flag.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：此对象实现进程之间的简单通信；一个进程发出信号，其他进程等待它。事件对象有两种方法，`set()`和`clear()`，用于管理自己的内部标志。'
- en: '**Condition**: This object is used to synchronize parts of a workflow, in sequential
    or parallel processes. It has two basic methods: `wait()` is used to wait for
    a condition and `notify_all()` is used to communicate the condition that was applied.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：此对象用于在顺序或并行进程中同步工作流的部分。它有两种基本方法：`wait()`用于等待条件，`notify_all()`用于通知应用的条件。'
- en: '**Semaphore**: This is used to share a common resource, for example, to support
    a fixed number of simultaneous connections.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：用于共享公共资源，例如支持固定数量的同时连接。'
- en: '**RLock**: This defines the *recursive lock* object. The methods and functionality
    of RLock are the same as the `threading` module.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RLock**：这定义了*递归锁*对象。RLock的方法和功能与`threading`模块相同。'
- en: '**Barrier**: This divides a program into phases as it requires all processes
    to reach the barrier before any of the proceeds. Code that is executed after a
    barrier cannot be concurrent with the code that was executed before the barrier.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Barrier**：这将程序分为阶段，因为它要求所有进程在继续之前都要到达屏障。在屏障之后执行的代码不能与屏障之前执行的代码并发。'
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '*Barrier* objects in Python are used to wait for the execution of a fixed number
    of threads to complete before a given thread can proceed with the execution of
    the program.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的*Barrier*对象用于等待固定数量的线程执行完毕，然后给定线程才能继续执行程序。
- en: The following example shows how to synchronize simultaneous tasks with a `barrier()` object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用`barrier()`对象同步同时进行的任务。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's consider four processes, wherein process `p1` and process `p2` are managed
    by a barrier statement*,* while process `p3` and process `p4` have *no synchronization*
    directives.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑四个进程，其中进程`p1`和进程`p2`由一个屏障语句管理，而进程`p3`和进程`p4`没有同步指令。
- en: 'To do this, perform the following steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请执行以下步骤：
- en: 'Import the relevant libraries:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关库：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `test_with_barrier` function executes the barrier''s **`wait()`** method:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test_with_barrier`函数执行屏障的**`wait()`**方法：'
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When the two processes have called the `wait()` method, they are released simultaneously:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个进程调用`wait()`方法时，它们会同时被释放：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `main` program, we created four processes. However, we also need a barrier
    and lock primitive. The `2`parameter in the `Barrier` statement stands for the
    total number of processes to manage:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们创建了四个进程。但是，我们还需要一个屏障和锁原语。`Barrier`语句中的`2`参数代表要管理的进程总数：
- en: '[PRE66]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Barrier` object provides one of the Python synchronization techniques with
    which single or multiple threads wait until a point in a set of activities and
    make progress together.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Barrier`对象提供了Python同步技术之一，单个或多个线程在一组活动中等待，然后一起取得进展。'
- en: 'In the `main` program, the `Barrier` object (that is,`synchronizer`) is defined
    through the following statement:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，通过以下语句定义了`Barrier`对象（即`synchronizer`）：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that the number `2` within the parentheses represents the number of processes
    that the barrier should wait upon.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，括号内的数字`2`表示屏障应该等待的进程数。
- en: 'Then, we implement a set of four processes, but only for the `p1` and `p2`processes.
    Note that `synchronizer` is passed as an argument:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了一组四个进程，但只针对`p1`和`p2`进程。请注意，`synchronizer`作为参数传递：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Indeed, in the body of the `test_with_barrier` function, the barrier''s `wait()` method is
    used in order to synchronize the processes:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在`test_with_barrier`函数的主体中，使用了屏障的`wait()`方法来同步进程：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'By running the script, we can see that the `p1` and `p2` processes print out
    the same timestamps as expected:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行脚本，我们可以看到`p1`和`p2`进程按预期打印出相同的时间戳：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There's more...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The following diagram shows you how a barrier works with the two processes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了屏障如何与两个进程一起工作：
- en: '![](assets/f9077bdf-036b-4f0e-90ea-0ddfd80fc58f.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9077bdf-036b-4f0e-90ea-0ddfd80fc58f.png)'
- en: Process management with a barrier
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用屏障进行进程管理
- en: See also
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Please read [https://pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)
    for more examples of process synchronization.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读[https://pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)以获取更多进程同步示例。
- en: Using a process pool
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用进程池
- en: The process pool mechanism allows the execution of a function across multiple
    input values to be parallelized, distributing *the* input data between processes. The
    process pool, therefore, allows implementing the so-called **data parallelism**
    that is based on the distribution of data through the different processes that
    operate on data in parallel.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 进程池机制允许在多个输入值上执行函数，实现并行化，将输入数据在进程之间分发。因此，进程池允许实现所谓的**数据并行性**，即基于在并行处理数据的不同进程之间分发数据。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `multiprocessing` library provides the `Pool` class for simple parallel
    processing tasks.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`库提供了`Pool`类来进行简单的并行处理任务。'
- en: 'The `Pool` class has the following methods:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool`类有以下方法：'
- en: '`apply()`: This blocks until the result is ready.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply()`: 这会阻塞，直到结果准备就绪。'
- en: '`apply_async()`: This is a variant of the `apply()` ([https://docs.python.org/2/library/functions.html#apply](https://docs.python.org/2/library/functions.html#apply))
    method, which returns a result object. It is an asynchronous operation that will
    not lock the main thread until all the child classes are executed.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_async()`: 这是`apply()`方法的变体，返回一个结果对象。这是一个异步操作，直到所有子类都执行完毕才会锁定主线程。'
- en: '`map()`: This is the parallel equivalent of the built-in `map()` ([https://docs.python.org/2/library/functions.html#map](https://docs.python.org/2/library/functions.html#map))
    function. This blocks until the result is ready, and it chops the iterable data
    in a number of chunks that are submitted to the process pool as separate tasks.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`: 这是内置`map()`的并行等价物（[https://docs.python.org/2/library/functions.html#map](https://docs.python.org/2/library/functions.html#map)）。这会阻塞，直到结果准备好，并且它会将可迭代数据分成多个块，作为单独的任务提交给进程池。'
- en: '`map_async()`: This is a variant of the `map()` ([https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map](https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map))
    method, which returns a `result` object. If a callback is specified, then it should
    be callable, which accepts a single argument. When the result becomes ready, a
    callback is applied to it (unless the call fails). A callback should be completed
    immediately; otherwise, the thread that handles the results will get blocked.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_async()`: 这是`map()`的一个变体（[https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map](https://docs.python.org/2/library/multiprocessing.html?highlight=pool%20class#multiprocessing.pool.multiprocessing.Pool.map)），它返回一个`result`对象。如果指定了回调函数，则应该是可调用的，接受一个参数。当结果准备好时，将应用回调函数（除非调用失败）。回调函数应立即完成；否则，处理结果的线程将被阻塞。'
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This example shows you how to implement a process pool to perform a parallel
    application. We create a pool of four processes and then we use the pool''s `map`
    method to perform a simple function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向你展示了如何实现一个进程池来执行并行应用。我们创建了一个包含四个进程的进程池，然后使用进程池的`map`方法执行一个简单的函数：
- en: 'Import the `multiprocessing` library:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`multiprocessing`库：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Pool` method applies `function_square` to the input element to perform
    a simple calculation:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pool`方法将`function_square`应用于输入元素以执行简单的计算：'
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The parameter inputs are a list of integers from `0` to `100`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数输入是一个从`0`到`100`的整数列表：
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The total number of parallel processes is `4`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行进程的总数为`4`：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `pool.map` method submits to the process pool as separate tasks:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pool.map`方法将作为单独的任务提交给进程池：'
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The result of the calculation is stored in `pool_outputs`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算结果存储在`pool_outputs`中：
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It is important to note that the result of the `pool.map()` method is equivalent
    to Python's built-in`map()` function, except that the processes run in parallel.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`pool.map()`方法的结果等同于Python内置的`map()`函数，只是进程是并行运行的。
- en: How it works…
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Here, we have created a pool of four processes using the following statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用以下语句创建了一个包含四个进程的进程池：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Each process has a list of integers as input. Here, `pool.map` works in the
    same way as the map, but uses multiple processes, whose number, four, was previously defined
    during pool creation:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个整数列表作为输入。在这里，`pool.map`的工作方式与map相同，但使用了多个进程，其数量为四，在创建pool时事先定义好了：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To terminate the computation of the pool, the usual `close` and `join` functions are
    used:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要终止进程池的计算，通常使用`close`和`join`函数：
- en: '[PRE79]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To execute this, type the following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请输入以下命令：
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is the result that we get after completing the calculation:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在完成计算后得到的结果：
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In the previous example, we saw that `Pool` also provides the `map` method,
    which allows us to apply a function to a different set of data. In particular,
    the scenario in which the same operation is performed in parallel on the elements
    of the input is referred to as*data parallelism*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到`Pool`还提供了`map`方法，它允许我们将函数应用于不同的数据集。特别是，在输入的元素上并行执行相同操作的情况被称为*数据并行*。
- en: 'In the following example, in which we use `Pool` and `map`, we create `pool`
    with`5`workers and, through the `map` method,a function of `f` is applied to a
    list of `10` elements:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用`Pool`和`map`，创建了一个有`5`个工作进程的`pool`，并通过`map`方法，将一个函数`f`应用于一个包含`10`个元素的列表：
- en: '[PRE82]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE83]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'To learn more information about process pools, usethe following link: [https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm](https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于进程池的信息，请使用以下链接：[https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm](https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_processes.htm)。
