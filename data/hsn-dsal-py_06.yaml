- en: Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度
- en: A **tree** is a hierarchical form of data structure. In the case of other data
    structures such as lists, queues, and stacks that we have discussed till now,
    the items are stored in a sequential way. However, in the case of a tree data
    structure, there is a *parent-child* relationship between the items. The top of
    the tree's data structure is known as a **root node**. This is the ancestor of
    all other nodes in the tree.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**树**是一种分层的数据结构。在其他数据结构（如列表、队列和栈）中，我们已经讨论过的项目是以顺序方式存储的。然而，在树数据结构的情况下，项目之间存在*父子*关系。树数据结构的顶部称为**根节点**。这是树中所有其他节点的祖先。'
- en: Tree data structures are very important owing to their use in various important
    applications. Trees are used for a number of things, such as parsing expressions,
    searches, storing data, manipulating data, sorting, priority queues, and so on.
    Certain document types, such as XML and HTML, can also be represented in a tree
    form. We shall look at some of the uses of trees in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 树数据结构非常重要，因为它们在各种重要应用中使用。树被用于许多事情，如解析表达式、搜索、存储数据、操作数据、排序、优先队列等。某些文档类型，如XML和HTML，也可以以树形式表示。我们将在本章中看一些树的用途。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Terms and definitions of trees
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的术语和定义
- en: Binary trees and binary search trees
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树和二叉搜索树
- en: Tree traversal
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的遍历
- en: Ternary search tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三叉搜索树
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the source code discussed in this chapter is provided in the GitHub repository
    for this book at [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有源代码都在本书的GitHub存储库中提供，网址为[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06)。
- en: Terminology
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Let's consider some terminology associated with tree data structures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑与树数据结构相关的一些术语。
- en: 'To understand trees, we need to first understand the basic concepts related
    to them. A tree is a data structure in which data is organized in a hierarchical
    form. The following diagram contains a typical tree consisting of character nodes
    lettered **A** through to **M**:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解树，我们首先需要了解与其相关的基本概念。树是一种数据结构，其中数据以分层形式组织。以下图表包含一个典型的树，由字符节点A到M标记：
- en: '![](Images/ad37d16c-654b-46f2-bc31-a4dc5536795a.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ad37d16c-654b-46f2-bc31-a4dc5536795a.png)'
- en: 'Here is a list of terms associated with a tree:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与树相关的术语列表：
- en: '**Node**: Each circled letter in the preceding diagram represents a node. A
    node is any data structure that actually stores the data.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：在前面的图表中，每个圈起来的字母代表一个节点。节点是实际存储数据的任何数据结构。'
- en: '**Root node**: The root node is the first node from which all other nodes in
    the tree are attached. In every tree, there is always one unique root node. The
    root node in our example tree is node A.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**：根节点是树中所有其他节点都连接到的第一个节点。在每棵树中，始终存在一个唯一的根节点。我们示例树中的根节点是节点A。'
- en: '**Sub-tree**: A sub-tree of a tree is a tree with its nodes being a descendant
    of some other tree. For example, nodes F, K, and L form a sub-tree of the original
    tree consisting of all the nodes.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子树**：树的子树是具有其节点作为其他树的后代的树。例如，节点F、K和L形成原始树的子树，其中包含所有节点。'
- en: '**Degree**: The total number of children of the given node is called the **degree
    of that node**. A tree consisting of only one node has a degree of 0\. The degree
    of node A in the preceding diagram is 2, the degree of node B is 3, the degree
    of node C is 3, and similarly, the degree of node G is 1.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定节点的子节点总数称为**该节点的度**。只包含一个节点的树的度为0。在前面的图表中，节点A的度为2，节点B的度为3，节点C的度为3，同样，节点G的度为1。
- en: '**Leaf node**: The leaf node does not have any children, and is the terminal
    node of the given tree. The degree of the leaf node is always 0\. In the preceding
    diagram, the nodes J, E, K, L, H, M, and I are all leaf nodes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**：叶节点没有任何子节点，是给定树的终端节点。叶节点的度始终为0。在前面的图表中，节点J、E、K、L、H、M和I都是叶节点。'
- en: '**Edge**: The connection among any given two nodes in the tree is called an **edge**.
    The total number of edges in a given tree will be a maximum of one less than the
    total nodes in the tree. An example edge is shown in the preceding sample tree
    structure.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：树中任意两个节点之间的连接称为**边**。给定树中边的总数将最多比树中的总节点数少一个。前面示例树结构中显示了一个边的示例。'
- en: '**Parent**: A node in the tree which has a further sub-tree is the parent node
    of that sub-tree. For example, node B is the parent of nodes D, E, and F, and
    node F is the parent of nodes K and L.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**：树中具有进一步子树的节点是该子树的父节点。例如，节点B是节点D、E和F的父节点，节点F是节点K和L的父节点。'
- en: '**Child**: This is a node connected to its parent, and it is the node that
    is a descendant of that node. For example, nodes B and C are children of node
    A, while the nodes H, G, and I are the children of node C.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**：这是连接到其父节点的节点，是该节点的后代节点。例如，节点B和C是节点A的子节点，而节点H、G和I是节点C的子节点。'
- en: '**Sibling**: All nodes with the same parent are siblings. For example, nodes
    B and C are siblings, and, similarly, nodes D, E, and F are also siblings.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟节点**：具有相同父节点的所有节点是兄弟节点。例如，节点B和C是兄弟节点，同样，节点D、E和F也是兄弟节点。'
- en: '**Level**: The root node of the tree is considered to be at level 0\. The children
    of the root node are considered at level 1, and the children of the nodes at level
    1 are considered at level 2, and so on. For example, the root node is at level
    0, nodes B and C are at level 1, and nodes D, E, F, H, G, and I are at level 2.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层级**：树的根节点被认为是在第0级。根节点的子节点被认为在第1级，第1级节点的子节点被认为在第2级，依此类推。例如，根节点在第0级，节点B和C在第1级，节点D、E、F、H、G和I在第2级。'
- en: '**Height of a tree**: The total number of the nodes in the longest path of
    the tree is the height of a tree. For example, in the preceding example tree,
    the height of the tree is 4 as the longest paths, `A-B-D-J` or `A-C-G-M` or `A-B-F-K`,
    all have a total number of 4 nodes each.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的高度：树中最长路径上的节点总数是树的高度。例如，在前面的树示例中，树的高度为4，因为最长路径`A-B-D-J`或`A-C-G-M`或`A-B-F-K`都有4个节点。
- en: '**Depth**: The depth of a node is the number of edges from the root of the
    tree to that node. In the preceding tree example, the depth of node H is 2.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**：节点的深度是从树的根到该节点的边的数量。在前面的树示例中，节点H的深度为2。'
- en: We shall begin our treatment of trees by considering the node in a tree and
    abstracting a class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过考虑树中的节点并抽象出一个类来开始处理树。
- en: Tree nodes
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树节点
- en: In linear data structures, data items are stored in a sequential order, one
    after another, whereas nonlinear data structures store data items in a non-linear
    order, where a data item can be connected to more than one data item. All of the
    data items in the linear data structures can be traversed in one pass, whereas
    this is not possible in the case of a non-linear data structure. The trees are
    the non-linear data structure; they store the data differently from other linear
    data structures such as *arrays*, *lists,* *stacks,* and *queues.*
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性数据结构中，数据项按顺序依次存储，而非线性数据结构将数据项以非线性顺序存储，其中一个数据项可以连接到多个数据项。线性数据结构中的所有数据项可以在一次遍历中遍历，而在非线性数据结构中这是不可能的。树是非线性数据结构；它们以与*数组*、*列表*、*栈*和*队列*等其他线性数据结构不同的方式存储数据。
- en: In the tree data structure, the nodes are arranged in a *parent-child* relationship.
    There should not be any cycle among the nodes in trees. The tree structure has
    nodes to form a hierarchy, and a tree that has no node is called an **empty tree**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在树数据结构中，节点按照*父-子*关系排列。树中的节点之间不应该有循环。树结构有节点形成层次结构，没有节点的树称为空树。
- en: 'First, we will discuss one of most important and special kinds of trees available,
    that is, the *binary tree.* A binary tree is a collection of nodes, where the
    nodes in the tree can have zero, 1, or 2 child nodes. A simple binary tree has
    a maximum of two children, that is, the left child and the right child. For example,
    in the following binary tree example, there is a root node that has two children
    (left child, right child):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论一种最重要和特殊的树，即*二叉树*。二叉树是节点的集合，树中的节点可以有零个、1个或2个子节点。简单的二叉树最多有两个子节点，即左子节点和右子节点。例如，在下面的二叉树示例中，有一个根节点，它有两个子节点（左子节点、右子节点）：
- en: '![](Images/17ebd6df-f607-4b65-8032-03d8be1cd394.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/17ebd6df-f607-4b65-8032-03d8be1cd394.png)'
- en: A tree is called a **full** **binary tree** if all the nodes of a binary tree
    have either zero or two children, and if there is no node that has `1` child. A
    binary tree is called a **complete binary tree** if it is completely filled, with
    a possible exception at the bottom level, which is filled from left to right.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二叉树的所有节点都有零个或两个子节点，并且没有一个节点有1个子节点，则称树为**满二叉树**。如果二叉树完全填满，底层可能有一个例外，从左到右填充，则称为**完全二叉树**。
- en: 'Just like in our previous implementations, a node is a container for data and
    holds references to other nodes. In a binary tree node, these references are to
    the left and the right children. Let''s look at the following code for building
    a binary tree `node` class in Python:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的实现一样，节点是数据的容器，并且持有对其他节点的引用。在二叉树节点中，这些引用是指左右子节点。让我们看一下下面的Python代码，构建一个二叉树`node`类：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To test this class, we must first create four nodes—`n1`, `n2`, `n3`, and `n4`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，我们首先要创建四个节点——`n1`、`n2`、`n3`和`n4`：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we connect the nodes to each other according to the property of a binary
    tree. We let `n1` be the root node, with `n2` and `n3` as its children. Finally,
    we take `n4` as the left child to `n2`. Take a look at the following diagram to
    see how we connect these nodes to each other:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们根据二叉树的属性将节点连接起来。我们让`n1`成为根节点，`n2`和`n3`成为它的子节点。最后，我们将`n4`作为`n2`的左子节点。看一下下面的图表，看看我们如何将这些节点连接起来：
- en: '![](Images/9775f219-4ae9-4ffb-a41b-391cb5ed7c2f.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9775f219-4ae9-4ffb-a41b-391cb5ed7c2f.png)'
- en: 'The next code snippet should be following in order to connect the nodes to
    each other according to the preceding diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码片段应该按照前面的图表连接节点：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we have set a very simple tree structure of four nodes. The first important
    operation that we would like to perform on trees is traversal. To understand traversing,
    let''s traverse the left sub-tree of this binary tree. We will start from the
    root node, print out the node, and move down the tree to the next left node. We
    keep doing this until we have reached the end of the left sub-tree, like so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个非常简单的四个节点的树结构。我们想要在树上执行的第一个重要操作是遍历。为了理解遍历，让我们遍历这棵二叉树的左子树。我们将从根节点开始，打印出节点，并向下移动到下一个左节点。我们一直这样做，直到我们到达左子树的末端，就像这样：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of traversing the preceding code block is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历上述代码块的输出如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tree traversal
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的遍历
- en: The method to visit all the nodes in a tree is called **tree traversal**. This
    can be done either **depth-first** **search** (**DFS**) or **breadth-first search** (**BFS**).
    We will discuss these two methods in the subsequent subsections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 访问树中所有节点的方法称为**树的遍历**。这可以通过**深度优先搜索**（**DFS**）或**广度优先搜索**（**BFS**）来完成。我们将在接下来的小节中讨论这两种方法。
- en: Depth-first traversal
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先遍历
- en: In depth-first traversal, we traverse the tree, starting from the root, and
    go deeper into the tree as much as possible on each child, and then continue to
    traverse to the next sibling. We use the recursive approach for tree traversal. There
    are three forms of depth-first traversal, namely, in-order, pre-order, and post-order.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度优先遍历中，我们从根开始遍历树，并尽可能深入每个子节点，然后继续遍历到下一个兄弟节点。我们使用递归方法进行树遍历。深度优先遍历有三种形式，即中序、前序和后序。
- en: In-order traversal and infix notation
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中序遍历和中缀表示法
- en: 'In-order tree traversal works as follows. First of all, we check if the current
    node is null or empty. If it is not empty, we traverse the tree. In in-order tree
    traversal, we follow these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 中序树遍历的工作方式如下。首先，我们检查当前节点是否为空或空。如果不为空，我们遍历树。在中序树遍历中，我们按照以下步骤进行：
- en: We start traversing the left sub-tree and call the `inorder` function recursively
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始遍历左子树，并递归调用“中序”函数
- en: Next, we visit the root node
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们访问根节点
- en: Finally, we traverse the right sub-tree and call the `inorder` function recursively
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遍历右子树，并递归调用“中序”函数
- en: So, in a nutshell, in in-order tree traversal, we visit the nodes in the tree
    in the order of (left sub-tree, root, right sub-tree).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在“中序”树遍历中，我们按照（左子树、根、右子树）的顺序访问树中的节点。
- en: 'Let''s consider an example to understand in-order tree traversal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例来理解中序树遍历：
- en: '![](Images/489c693f-15f5-4762-b70c-9ca81bbe5bb8.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/489c693f-15f5-4762-b70c-9ca81bbe5bb8.png)'
- en: In the example binary tree for in-order traversal, first, we recursively visit
    the left sub-tree of the root node **A**. The left sub-tree of node **A** has
    node **B** as root, so we again go to the left sub-tree of the root node **B**,
    that is, node **D**. We recursively go to the left sub-tree of root node **D **so
    that we get the left child with root node **D**. So, first, we visit the left
    child, that is, **G**, then visit the root node, **D**, and then visit the right
    child, **H**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在“中序”遍历的示例二叉树中，首先，我们递归访问根节点A的左子树。节点A的左子树以节点B为根，所以我们再次转到节点B的左子树，即节点D。我们递归地转到节点D的左子树，以便我们得到根节点D的左子树。因此，我们首先访问左子节点，即G，然后访问根节点D，然后访问右子节点H。
- en: Next, we visit node **B** and then visit node **E**. In this manner, we have
    visited the left sub-tree with the root node **A**. So, next, we visit the root
    node **A**. After that, we will visit the right sub-tree with root node **A**.
    Here, we go to the left sub-tree with root node **C**, which is null, so next
    we visit node **C**, and then we visit the right child of node **C**, that is,
    node **F**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问节点B，然后访问节点E。这样，我们已经访问了根节点A的左子树。所以下一步，我们访问根节点A。之后，我们将访问根节点A的右子树。在这里，我们转到根节点C的左子树，它是空的，所以下一步我们访问节点C，然后访问节点C的右子节点，即节点F。
- en: Therefore, the in-order traversal for this example tree is `G–D-H-B-E-A-C-F`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个示例树的中序遍历是“G-D-H-B-E-A-C-F”。
- en: 'The Python implementation of a recursive function to return an `inorder` listing
    of nodes in a tree is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 树的递归函数的Python实现，以返回树中节点的“中序”列表如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We visit the node by printing the visited node. In this case, we first recursively
    call the `inorder` function with `current.left_child`, then we visit the root
    node, and finally we recursively call the `inorder` function with `current.right_child` once
    more.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印访问的节点来访问节点。在这种情况下，我们首先递归调用“中序”函数与“current.left_child”，然后访问根节点，最后我们再次递归调用“中序”函数与“current.right_child”。
- en: The **infix** notation (also known as reverse Polish notation) is a commonly
    used notation to express arithmetic expressions where the operators are placed
    in-between the operands. It is common to use this way of representing an arithmetic expression since
    this is the way we are normally taught in schools. For example, the operator is
    inserted (infixed) between the operands, as in `3 + 4`. When necessary, parentheses
    can be used to build a more complex expression, such as `(4 + 5) * (5 - 3)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中缀表示法（也称为逆波兰表示法）是一种常用的表示算术表达式的表示法，其中操作符放置在操作数之间。通常使用这种方式来表示算术表达式，因为这是我们在学校通常学到的方式。例如，操作符被插入（插入）在操作数之间，如“3
    + 4”。必要时，可以使用括号来构建更复杂的表达式，例如“(4 + 5) * (5 - 3)”。
- en: 'An expression tree is a special kind of **binary tree** that can be used to
    represent arithmetic expressions. This in-order traversal of an expression tree
    produce the infix notation. For example, consider the following expression tree:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树是一种特殊的二叉树，可用于表示算术表达式。表达式树的中序遍历产生中缀表示法。例如，考虑以下表达式树：
- en: '![](Images/d46a0ed5-4f9f-406d-8028-c5bf7b0c17ed.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d46a0ed5-4f9f-406d-8028-c5bf7b0c17ed.png)'
- en: The in-order traversal of the preceding expression tree gives us the infix notation,
    that is, `(5 + 3)`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式树的中序遍历给出了中缀表示法，即“(5 + 3)”。
- en: Pre-order traversal and prefix notation
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前序遍历和前缀表示法
- en: 'Pre-order tree traversal works as follows. First of all, we check if the current
    node is null or empty. If it is not empty, we traverse the tree. The pre-order tree
    traversal works as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前序树遍历的工作方式如下。首先，我们检查当前节点是否为空或空。如果不为空，我们遍历树。前序树遍历的工作方式如下：
- en: We start traversing with the root node
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从根节点开始遍历
- en: Next, we traverse the left sub-tree and call the `preorder` function with the
    left sub-tree recursively
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历左子树，并递归调用“前序”函数与左子树
- en: Next, we visit the right sub-tree and call the `preorder` function with the
    right sub-tree recursively
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历右子树，并递归调用“前序”函数与右子树
- en: So, to traverse a tree in pre-order mode, we visit the tree in the order of
    root node, the left sub-tree, and the right sub-tree node.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要以前序方式遍历树，我们按照根节点、左子树和右子树节点的顺序访问树。
- en: 'Consider the following example tree to understand pre-order traversal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例树以了解前序遍历：
- en: '![](Images/f20499f8-7a4a-48f8-afc8-4269b864006d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f20499f8-7a4a-48f8-afc8-4269b864006d.png)'
- en: In the preceding example of a binary tree, first, we visit root node **A**.
    Next, we go to the left sub-tree of root node **A**. The left sub-tree of node
    **A** has node **B** as the root, so we visit this root node and the go to the
    left sub-tree of root node **B**, that is, node **D**. We then visit node **D** and
    go to the left sub-tree of root node **D**, and then we visit the left child, **G**,
    which is the sub-tree of root node **D**. Next, we visit the right child of the
    sub-tree with root node **D**, that is, node **H**. Next, we visit the right child
    of the sub-tree with root node **B**, that is, node **E**. So, in this manner,
    we have visited root node **A** and the left sub-tree with root node **A**. Now,
    we will visit the right sub-tree of root node **A**. Here, we visit the root node
    **C**, and then we go to the left sub-tree with root node **C**, which is null,
    so next, we visit the right child of node **C**, that is, node **F**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的二叉树示例中，首先我们访问根节点**A**。接下来，我们转到根节点**A**的左子树。节点**A**的左子树以节点**B**为根，因此我们访问这个根节点，然后转到根节点**B**的左子树，即节点**D**。然后我们访问节点**D**，并转到根节点**D**的左子树，然后我们访问左子节点**G**，它是根节点**D**的子树。接下来，我们访问根节点**D**的右子节点，即节点**H**。接着，我们访问根节点**B**的右子树的右子节点，即节点**E**。因此，以这种方式，我们已经访问了根节点**A**和以根节点**A**为根的左子树。现在，我们将访问根节点**A**的右子树。在这里，我们访问根节点**C**，然后我们转到根节点**C**的左子树，它为空，所以下一步，我们访问节点**C**的右子节点，即节点**F**。
- en: The pre-order traversal for this example tree would be `A-B-D-G-H-E-C-F`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例树的前序遍历将是`A-B-D-G-H-E-C-F`。
- en: 'The recursive function for `pre-order` tree traversal is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`pre-order`树遍历的递归函数如下：'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Prefix notation is commonly referred to as Polish notation. In this notation,
    the operator comes before its operands. Prefix notation is well known to LISP
    programmers. For example, the arithmetic expression to add two numbers, 3 and
    4, would be shown as `+ 3 4`. Since there is no ambiguity of precedence, parentheses
    are not required: `* + 4 5 - 5 3`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀表示法通常被称为波兰表示法。在这种表示法中，运算符位于其操作数之前。前缀表示法是LISP程序员熟知的。例如，要添加两个数字3和4的算术表达式将显示为`+
    3 4`。由于没有运算符优先级的歧义，因此不需要括号：`* + 4 5 - 5 3`。
- en: Let's consider another example, that is, the `(3 +4) * 5 `. This can also be
    represented as `* (+ 3 4) 5` in prefix notation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，即`(3 +4) * 5`。这也可以用前缀表示法表示为`* (+ 3 4) 5`。
- en: 'The pre-order traversal of an expression tree results in the prefix notation
    of the arithmetic expression. For example, consider the following expression tree:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树的前序遍历将得到算术表达式的前缀表示法。例如，考虑以下表达式树：
- en: '![](Images/08f7ec34-8fde-4a49-86ae-6fbcaac63487.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08f7ec34-8fde-4a49-86ae-6fbcaac63487.png)'
- en: The preorder traversal of the preceding tree will give the expression in prefix
    notation as `+- 8 3 3`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述树的前序遍历将以前缀表示法给出表达式为`+- 8 3 3`。
- en: Post-order traversal and postfix notation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后序遍历和后缀表示法
- en: '`Post-order` tree traversal works as follows. First of all, we check if the
    current node is null or empty. If it is not empty, we traverse the tree. `Post-order` tree
    traversal works as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`post-order`树遍历的工作方式如下。首先，我们检查当前节点是否为空。如果不为空，我们遍历树。`post-order`树遍历的工作方式如下：'
- en: We start traversing the left sub-tree and call the `postorder` function recursively
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始遍历左子树并递归调用`postorder`函数
- en: Next, we traverse the right sub-tree and call the postorder function recursively
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历右子树并递归调用`postorder`函数
- en: Finally, we visit the root node
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们访问根节点
- en: So. in a nutshell, regarding `post-order` tree traversal, we visit the nodes
    in the tree in the order of left sub-tree, right sub-tree, and finally the root
    node.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，关于`post-order`树遍历，我们按照左子树、右子树和最后根节点的顺序访问树中的节点。
- en: 'Consider the following example tree to understand post-order tree traversal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例树以理解后序树遍历：
- en: '![](Images/690334be-b950-44af-bf9d-ce1599bdefd8.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/690334be-b950-44af-bf9d-ce1599bdefd8.png)'
- en: In the preceding diagram, we first visit the left sub-tree of root node **A**
    recursively. We get to the last left subtree, that is, root node D, and then we
    visit the left node of it, which is node **G**. Then, we visit the right child,
    H, and then we visit the root node D. Following the same rule, we next visit the
    right child of node **B**, that is, node **E**. Then, we visit node **B**. Following
    on from this, we traverse the right sub-tree of node **A**. Here, we first reach
    the last right sub-tree and visit node **F**, and then we visit node **C**. Finally,
    we visit root node **A**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们首先递归访问根节点**A**的左子树。我们到达最后的左子树，也就是根节点D，然后我们访问它的左节点，即节点**G**。然后，我们访问右子节点H，然后我们访问根节点D。按照相同的规则，我们接下来访问节点**B**的右子节点，即节点**E**。然后，我们访问节点**B**。接着，我们遍历节点**A**的右子树。在这里，我们首先到达最后的右子树并访问节点**F**，然后我们访问节点**C**。最后，我们访问根节点**A**。
- en: The postorder traversal for this example tree would be `G-H-D-E-B-F-C-A`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例树的后序遍历将是`G-H-D-E-B-F-C-A`。
- en: 'The implementation of the `post-order` method for tree traversal is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 树遍历的`post-order`方法的实现如下：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Postfix or **reverse Polish notation** (**RPN**) places the operator after its
    operands, as in `3 4 +`. As is the case with Polish notation, there is no further
    confusion over the precedence of operators, so parentheses are never needed: `4
    5 + 5 3 - *`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀或**逆波兰表示法**（**RPN**）将运算符放在其操作数之后，如`3 4 +`。与波兰表示法一样，运算符的优先级不会引起混淆，因此永远不需要括号：`4
    5 + 5 3 - *`。
- en: 'The post-order traversal of the following expression tree will give the postfix
    notation of the arithmetic expression:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表达式树的后序遍历将给出算术表达式的后缀表示法：
- en: '![](Images/d133d129-c15f-41b9-bf01-a200e247e709.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d133d129-c15f-41b9-bf01-a200e247e709.png)'
- en: The postfix notation for the preceding expression tree is `8 3 -3 +`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式树的后缀表示法是`8 3 -3 +`。
- en: Breadth-first traversal
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: Breadth-first traversal starts from the root of the tree and then visits every
    node on the next level of the tree. Then, we move to the next level in the tree,
    and so on. This kind of tree traversal is breadth-first as it broadens the tree
    by traversing all the nodes in a level before going deep into the tree.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先遍历从树的根开始，然后访问树的下一级上的每个节点。然后，我们移动到树的下一级，依此类推。这种树遍历方式是广度优先的，因为它在深入树之前通过遍历一个级别上的所有节点来扩展树。
- en: 'Let''s consider the following example tree and traverse it by using the breadth-first
    traversal method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例树，并使用广度优先遍历方法遍历它：
- en: '![](Images/8d106753-e386-4549-9027-1709e4845e18.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8d106753-e386-4549-9027-1709e4845e18.png)'
- en: In the preceding diagram, we start by visiting the root node at **level 0**,
    that is, the node with a value of **4**. We visit this node by printing out its
    value. Next, we move to **level 1** and visit all the nodes on this level, which
    are the nodes with the values **2** and **8**. Finally, we move to the next level
    in the tree, that is, **level 3**, and we visit all the nodes at this level. The
    nodes at this level are **1**, **3**, **5**, and **10**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们首先访问**level 0**的根节点，即值为**4**的节点。我们通过打印出它的值来访问这个节点。接下来，我们移动到**level
    1**并访问该级别上的所有节点，即值为**2**和**8**的节点。最后，我们移动到树的下一级，即**level 3**，并访问该级别上的所有节点。该级别上的节点是**1**，**3**，**5**和**10**。
- en: Thus, the breadth-first tree traversal for this tree is as follows—**4**, **2**,
    **8**, **1**, **3**, **5**, and **10**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该树的广度优先遍历如下：**4**，**2**，**8**，**1**，**3**，**5**和**10**。
- en: This mode of traversal is implemented using a queue data structure. Starting
    with the root node, we push it into a queue. The node at the front of the queue
    is accessed (dequeued) and either printed or stored for later use. The left node
    is added to the queue followed by the right node. Since the queue is not empty,
    we repeat this process.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历模式是使用队列数据结构实现的。从根节点开始，我们将其推入队列。访问队列前面的节点（出队）并打印或存储以供以后使用。左节点被添加到队列，然后是右节点。由于队列不为空，我们重复这个过程。
- en: The Python implementation of this algorithm will enqueue the root node **4**,
    dequeue it, and visit the node. Next, nodes **2** and **8** are enqueued as they
    are the left and right nodes at the next level, respectively. Node **2** is dequeued
    so that it can be visited. Next, its left and right nodes, that is, nodes **1**
    and **3**, are enqueued. At this point, the node at the front of the queue is
    **8**. We dequeue and visit node **8**, after which we enqueue its left and right
    nodes. This process continues until the queue is empty.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的Python实现将根节点**4**入队，出队并访问该节点。接下来，节点**2**和**8**入队，因为它们分别是下一级的左节点和右节点。节点**2**出队以便访问。接下来，它的左节点和右节点，即节点**1**和**3**，入队。此时队列前面的节点是**8**。我们出队并访问节点**8**，然后将其左节点和右节点入队。这个过程一直持续到队列为空。
- en: 'The Python implementation of breadth-first traversal is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先遍历的Python实现如下：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We enqueue the root node and keep a list of the visited nodes in the `list_of_nodes` list.
    The `dequeue` class is used to maintain a queue:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根节点入队，并在`list_of_nodes`列表中保留访问过的节点的列表。使用`dequeue`类来维护队列：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the number of elements in `traversal_queue` is greater than zero, the body
    of the loop is executed. The node at the front of the queue is popped off and
    appended to the `list_of_nodes` list. The first `if` statement will `enqueue` the
    left child node if the `node` provided with a left node exists. The second `if` statement
    does the same for the right child node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`traversal_queue`中的元素数量大于零，则执行循环体。队列前面的节点被弹出并附加到`list_of_nodes`列表中。第一个`if`语句将左子节点入队，如果提供了左节点则存在。第二个`if`语句对右子节点执行相同的操作。
- en: The `list_of_nodes` list is returned in the last statement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of_nodes`列表在最后一个语句中返回。'
- en: Binary trees
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: A binary tree is one in which each node has a maximum of two children. The nodes
    in the binary tree are organized in the form of left sub-tree and right sub-tree.
    If the tree has a root, R, and two sub-trees, that is, left sub-tree `T1`, and
    right sub-tree `T2`, then their roots are called `left successor` and `right successor`, respectively.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是每个节点最多有两个子节点的树。二叉树中的节点以左子树和右子树的形式组织。如果树有一个根R和两个子树，即左子树`T1`和右子树`T2`，那么它们的根分别称为左继和右继。
- en: 'The following diagram is an example of a binary tree with five nodes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是一个具有五个节点的二叉树的示例：
- en: '![](Images/6519f2a2-5a73-4a88-81c8-c30ca11ba492.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6519f2a2-5a73-4a88-81c8-c30ca11ba492.png)'
- en: 'Here are the following observations that we have made regarding the preceding
    diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们对前面图表的观察：
- en: Each node holds a reference to a right and left node if the nodes do not exist
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点都保存对右节点和左节点的引用，如果节点不存在
- en: The root node is denoted with **5**
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点用**5**表示
- en: The root node has two sub-trees, where the left sub-tree has one node, that
    is, a node with a value of **3**, and the right sub-tree has three nodes with
    the values **7**, **6**, and **9**
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点有两个子树，左子树有一个节点，即值为**3**的节点，右子树有三个节点，值分别为**7**，**6**和**9**。
- en: The node with a value of **3** is a left successor node, whereas the node with
    a value of **7** is the right successor
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为**3**的节点是左继节点，而值为**7**的节点是右继节点
- en: A regular binary tree has no other rules as to how elements are arranged in
    the tree. It should only satisfy the condition that each node should have a maximum
    of two children.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的二叉树在树中排列元素方面没有其他规则。它只需满足每个节点最多有两个子节点的条件。
- en: Binary search trees
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: A **binary search tree** (**BST**) is a special kind of binary tree. It is one
    of the most important and commonly used data structures in computer science applications.
    A binary search tree is a tree that is structurally a binary tree, and stores
    data in its nodes very efficiently. It provides very fast search operations, and
    other operations such as insertion and deletion are also very easy and convenient.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树**（BST）是一种特殊的二叉树。它是计算机科学应用中最重要和最常用的数据结构之一。二叉搜索树是一棵结构上是二叉树的树，并且非常有效地在其节点中存储数据。它提供非常快速的搜索操作，插入和删除等操作也非常简单和方便。'
- en: 'A binary tree is called a binary search tree if the value at any node in the
    tree is greater than the values in all the nodes of its left sub-tree, and less
    than or equal to the values of all the nodes of the right sub-tree. For example,
    if **K1**, **K2**, and **K3** are key values in a tree of three nodes (as shown
    in the following diagram), then it should satisfy the following conditions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树中任意节点的值大于其左子树中所有节点的值，并且小于或等于其右子树中所有节点的值，则称二叉树为二叉搜索树。例如，如果**K1**、**K2**和**K3**是三个节点树中的关键值（如下图所示），则应满足以下条件：
- en: The key values of *K2<=K1*
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*K2<=K1*的关键值'
- en: The key values *K3>K1*
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键值*K3>K1*
- en: 'The following diagram depicts this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了这一点：
- en: '![](Images/4ad947ef-1686-45c9-ae03-cb7620cb4aec.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4ad947ef-1686-45c9-ae03-cb7620cb4aec.png)'
- en: 'Let''s consider another example so that we have a better understanding of binary
    search trees. Consider the following tree:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，以便更好地理解二叉搜索树。考虑以下树：
- en: '![](Images/8d71ac43-cacf-4faf-91c6-338483487b3f.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8d71ac43-cacf-4faf-91c6-338483487b3f.png)'
- en: This is an example of a BST. In this tree, all of the nodes in the left sub-tree are
    less than or equal to the value of that node. Also, all of the nodes in the right
    sub-tree of this node are greater than that of the parent node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是BST的一个例子。在这棵树中，左子树中的所有节点都小于或等于该节点的值。同样，该节点的右子树中的所有节点都大于父节点的值。
- en: Testing our tree for the properties of a BST, we notice that all of the nodes
    in the left sub-tree of the root node have a value less than 5\. Likewise, all
    the nodes in the right sub-tree have a value that is greater than 5\. This property
    applies to all the nodes in a BST, with no exceptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的树是否具有BST的属性时，我们注意到根节点左子树中的所有节点的值都小于5。同样，右子树中的所有节点的值都大于5。这个属性适用于BST中的所有节点，没有例外。
- en: 'Considering another example of a binary tree, let''s see if it is a binary
    search tree or not. Despite the fact that the following diagram looks similar
    to the previous diagram, it does not qualify as a BST as node **7** is greater
    than the root node **5**; however, it is located to the left of the root node.
    Node **4** is to the right sub-tree of its parent node **7**, which is incorrect.
    Thus, the following diagram is not a binary search tree:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个二叉树的例子，让我们看看它是否是二叉搜索树。尽管以下图表看起来与前一个图表相似，但它并不符合BST的条件，因为节点**7**大于根节点**5**；然而，它位于根节点的左侧。节点**4**位于其父节点**7**的右子树中，这是不正确的。因此，以下图表不是二叉搜索树：
- en: '![](Images/13e662dd-8b8f-445e-afec-59e6fc6dfad9.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13e662dd-8b8f-445e-afec-59e6fc6dfad9.png)'
- en: Binary search tree implementation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树实现
- en: 'Let''s begin the implementation of a BST in Python. We need to keep track of
    the root node of the tree, so we start by creating a `Tree` class that holds a
    reference to the root node:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在Python中实现BST。我们需要跟踪树的根节点，因此我们首先创建一个`Tree`类，其中包含对根节点的引用：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's all that is needed to maintain the state of a tree. Let's examine the
    main operations on the tree in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是维护树状态所需的全部内容。让我们在下一节中研究树上的主要操作。
- en: Binary search tree operations
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树操作
- en: The operations that can be performed on a binary search tree are `insert`, `delete`,
    `finding min`, `finding max`, `searching`, and so on. We will discuss them in
    subsequent subsections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树上可以执行的操作包括`插入`、`删除`、`查找最小值`、`查找最大值`、`搜索`等。我们将在后续小节中讨论它们。
- en: Finding the minimum and maximum nodes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找最小和最大节点
- en: The structure of the binary search tree makes searching a node that has a maximum
    or a minimum value very easy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的结构使得查找具有最大或最小值的节点非常容易。
- en: To find a node that has the smallest value in the tree, we start traversal from
    the root of the tree and visit the left node each time until we reach the end
    of the tree. Similarly, we traverse the right sub-tree recursively until we reach
    the end to find the node with the biggest value in the tree.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到树中具有最小值的节点，我们从树的根开始遍历，并每次访问左节点，直到到达树的末端。类似地，我们递归遍历右子树，直到到达末端，以找到树中具有最大值的节点。
- en: 'For example, consider the following diagram; we move down from node **6** to
    **3** and then from node **3** to **1** to find the node with the smallest value.
    Similarly, to find the maximum value node from the tree, we go down from the root
    to the right-hand side of the tree, then go from node **6** to node **8** and
    then node **8** to node **10** to find the node with the largest value. Here is
    an example BST tree:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下图表；我们从节点**6**向下移动到**3**，然后从节点**3**移动到**1**，以找到具有最小值的节点。类似地，要找到树中具有最大值的节点，我们从根向树的右侧移动，然后从节点**6**移动到节点**8**，然后从节点**8**移动到节点**10**以找到具有最大值的节点。以下是一个BST树的例子：
- en: '![](Images/4b26eee0-da90-49ec-bcc6-bb7ab38cd8d1.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4b26eee0-da90-49ec-bcc6-bb7ab38cd8d1.png)'
- en: This concept of finding the minimum and maximum nodes applies to sub-trees,
    too. Thus, the minimum node in the sub-tree with root node **8** is node **7**.
    Similarly, the node that has the maximum value within that sub-tree is **10**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最小和最大节点的概念也适用于子树。因此，根节点为**8**的子树中的最小节点是节点**7**。同样，该子树中具有最大值的节点是**10**。
- en: 'The Python implementation of the method that returns the minimum node is as
    follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回最小节点的Python实现如下：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `while` loop continues to get the left node and visits it until the last
    left node points to `None`. It is a very simple method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环继续获取左节点并访问它，直到最后一个左节点指向`None`。这是一个非常简单的方法。'
- en: 'Similarly, the following is the code of the method that returns the maximum
    node:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下是返回最大节点的方法的代码：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The running time complexity to find the minimum or maximum value in a BST is O(*h*),
    where `h` is the height of the tree.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在BST中查找最小值或最大值的运行时间复杂度为O(*h*)，其中`h`是树的高度。
- en: There are essentially two other operations, that is, `insert` and `delete`,
    and they are very important for BST. It is important to ensure that we maintain
    the property of the BST tree while applying these operations on the tree.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上还有两个其他操作，即`insert`和`delete`，它们对BST非常重要。在对树应用这些操作时，确保我们保持BST树的属性是很重要的。
- en: Inserting nodes
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入节点
- en: One of the most important operations to implement on a binary search tree is
    to insert data items in the tree. As we have already discussed, regarding the
    properties of the binary search tree, for each node in the tree, the left child
    nodes should contain the data less than their own value and the right child nodes
    should have data greater than their value. So, we have to ensure that the property
    of the binary search tree satisfies whenever we insert an item in the tree.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树上实现的最重要的操作之一是在树中插入数据项。正如我们已经讨论过的，关于二叉搜索树的属性，对于树中的每个节点，左子节点应该包含小于其自身值的数据，右子节点应该包含大于其值的数据。因此，我们必须确保每当我们在树中插入一个项目时，二叉搜索树的属性都得到满足。
- en: 'For example, let''s create a binary search tree by inserting data items **5**,
    **3**, **7**, and **1** in the tree. Consider the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过在树中插入数据项**5**、**3**、**7**和**1**来创建一个二叉搜索树。考虑以下内容：
- en: '**Insert 5:** We start with the first data item, **5**. To do this, we will
    create a node with its data attribute set to **5**, since it is the first node.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入5：**我们从第一个数据项**5**开始。为此，我们将创建一个数据属性设置为**5**的节点，因为它是第一个节点。'
- en: '**Insert 3:** Now, we want to add the second node with value **3** so that
    data value **3** is compared with the existing node value, **5**, of the root
    node:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入3：**现在，我们想添加值为**3**的第二个节点，以便将数据值**3**与根节点**5**的现有节点值进行比较：'
- en: 'Since the node value **3** is less than **5**, it will be placed in the left
    sub-tree of node **5**. Our BST will look as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于节点值**3**小于**5**，它将被放置在节点**5**的左子树中。我们的BST将如下所示：
- en: '![](Images/5cc8c9f2-30ef-4a54-8ccf-034a25fc7b6e.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5cc8c9f2-30ef-4a54-8ccf-034a25fc7b6e.png)'
- en: The tree satisfies the BST rule, where all the nodes in the left sub-tree are
    less than the parent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 树满足BST规则，即左子树中的所有节点都小于父节点。
- en: '**Insert 7:** To add another node of value **7** to the tree, we start from
    the root node with value **5** and make a comparison:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入7：**要向树中添加值为**7**的另一个节点，我们从值为**5**的根节点开始比较：'
- en: '![](Images/825b1134-b2e5-4422-a074-0a9edd9500d3.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/825b1134-b2e5-4422-a074-0a9edd9500d3.png)'
- en: Since **7** is greater than **5**, the node with value **7** is placed to the
    right of this root.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**7**大于**5**，值为**7**的节点被放置在此根节点的右侧。
- en: '**Insert 1:** Let''s add another node with value **1**. Starting from the root
    of the tree, we make a comparison between **1** and **5**:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插入1：**让我们添加另一个值为**1**的节点。从树的根开始，我们比较**1**和**5**：'
- en: '![](Images/77b2a9ae-1353-4526-bce0-0d0071fa2db9.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/77b2a9ae-1353-4526-bce0-0d0071fa2db9.png)'
- en: 'This comparison shows that **1** is less than **5**, so we go to the left node
    of **5**, which is the node with a value of **3**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较表明**1**小于**5**，所以我们转到**5**的左节点，即值为**3**的节点：
- en: '![](Images/cc62c702-3223-4bfc-817b-b4c688f3a41a.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cc62c702-3223-4bfc-817b-b4c688f3a41a.png)'
- en: 'When we compare **1** with **3**, since **1** is less than **3**, we move a
    level below node **3** and to its left. However, there is no node there. Therefore,
    we create a node with the value **1** and associate it with the left pointer of
    node **3** to obtain the following structure. Here, we have the final binary search
    tree of **4** nodes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将**1**与**3**进行比较时，由于**1**小于**3**，我们向下移动到节点**3**的下一级并向左移动。然而，那里没有节点。因此，我们创建一个值为**1**的节点，并将其与节点**3**的左指针关联，以获得以下结构。在这里，我们有**4**个节点的最终二叉搜索树：
- en: '![](Images/026ebb91-6c6b-43df-815f-0a4e2e2ff30a.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/026ebb91-6c6b-43df-815f-0a4e2e2ff30a.png)'
- en: We can see that this example contains only integers or numbers. So, if we need
    to store the string data in the binary search tree, in this case strings would
    be compared alphabetically. And, if we want to store our own custom data types
    inside a BST, we will have to make sure that our class supports ordering.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个例子只包含整数或数字。因此，如果我们需要在二叉搜索树中存储字符串数据，在这种情况下字符串将按字母顺序进行比较。如果我们想在BST中存储自定义数据类型，我们必须确保我们的类支持排序。
- en: 'The Python implementation of the `insert` method to add the nodes in the BST
    is given as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了在BST中添加节点的`insert`方法的Python实现如下：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s understand each of the instructions of this `insert` function,
    step by step. We will begin with a function declaration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步理解`insert`函数的每条指令。我们将从函数声明开始：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By now, you will be used to the fact that we encapsulate the data in a node.
    This way, we hide away the `node` class from the client code, who only needs to
    deal with the tree:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经习惯了我们将数据封装在节点中的事实。这样，我们将`node`类隐藏在客户端代码中，客户端只需要处理树：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A first check will be done to find out whether we have a root node. If we don''t,
    the new node becomes the root node (we cannot have a tree without a root node):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将进行检查，以找出是否有根节点。如果没有，新节点将成为根节点（没有根节点的树是不允许的）：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we walk down the tree, we need to keep track of the current node we are
    working on, as well as its parent. The `current` variable is always used for this
    purpose:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们沿着树向下走时，我们需要跟踪我们正在处理的当前节点以及其父节点。`current`变量总是用于此目的：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we must perform a comparison. If the data held in the new node is less
    than the data held in the current node, then we check whether the current node
    has a left child node. If it doesn''t, this is where we insert the new node. Otherwise,
    we keep traversing:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须进行比较。如果新节点中保存的数据小于当前节点中保存的数据，那么我们检查当前节点是否有左子节点。如果没有，这就是我们插入新节点的地方。否则，我们继续遍历：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we need to take care of the greater than or equal case. If the current
    node doesn''t have a right child node, then the new node is inserted as the right
    child node. Otherwise, we move down and continue looking for an insertion point:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理大于或等于的情况。如果当前节点没有右子节点，那么新节点将被插入为右子节点。否则，我们向下移动并继续寻找插入点：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Insertion of a node in a BST takes `O(h)`, where `h` is the height of the tree.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在BST中插入一个节点需要`O(h)`的时间，其中`h`是树的高度。
- en: Deleting nodes
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: 'Another important operation on a BST is the `deletion` or `removal` of nodes.
    There are three scenarios that we need to cater for during this process. The node
    that we want to remove might have the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: BST上的另一个重要操作是节点的`删除`或`移除`。在这个过程中，我们需要考虑三种情况。我们要删除的节点可能有以下情况：
- en: '**No children**: If there is no leaf node, directly remove the node'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有子节点**：如果没有叶节点，直接删除节点'
- en: '**One child**: In this case, we swap the value of that node with its child,
    and then delete the node'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个子节点**：在这种情况下，我们交换该节点的值与其子节点的值，然后删除该节点'
- en: '**Two children**: In this case, we first find the in-order successor or predecessor,
    swap the value with it, and then delete that node'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两个子节点**：在这种情况下，我们首先找到中序后继或前驱，与其交换值，然后删除该节点'
- en: 'The first scenario is the easiest to handle. If the node about to be removed
    has no children, we simply remove it from its parent:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是最容易处理的。如果要删除的节点没有子节点，我们只需将其从其父节点中删除：
- en: '![](Images/9a0542ba-4bd8-473e-9a43-23bfcd1b5bf2.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9a0542ba-4bd8-473e-9a43-23bfcd1b5bf2.png)'
- en: In the preceding example, node **A** has no children, so we will simply delete
    it from its parent, that is, node **Z**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，节点**A**没有子节点，所以我们将它从其父节点，即节点**Z**中删除。
- en: 'On the other hand, when the node we want to remove has one child, the parent
    of that node is made to point to the child of that particular node. Let''s take
    a look at the following diagram, where we want to delete node **6** who has one
    child, that is, node **5**:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们要删除的节点只有一个子节点时，该节点的父节点被指向该节点的子节点。让我们看一下下面的图表，我们要删除节点**6**，它只有一个子节点，即节点**5**：
- en: '![](Images/31d35eef-0bc8-40a2-981d-aea941d428a2.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/31d35eef-0bc8-40a2-981d-aea941d428a2.png)'
- en: In order to delete node **6**, which has node **5** as its only child, we point
    the left pointer of node **9** to node **5**. Here, we need to ensure that the
    child and parent relationship follows the properties of a binary search tree.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除只有一个子节点的节点**6**，我们将节点**9**的左指针指向节点**5**。在这里，我们需要确保子节点和父节点的关系遵循二叉搜索树的属性。
- en: 'A more complex scenario arises when the node we want to delete has two children.
    Consider the following example tree, where we want to delete node **9**, which
    has two children:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要删除的节点有两个子节点时，会出现更复杂的情况。考虑以下示例树，我们要删除节点**9**，它有两个子节点：
- en: '![](Images/038348fb-2f25-4010-96a1-1e817fa197ab.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/038348fb-2f25-4010-96a1-1e817fa197ab.png)'
- en: We cannot simply replace node **9** with either node **6** or **13**. What we
    need to do is find the next biggest descendant of node **9**. This is node **12**.
    To get to node **12**, we move to the right node of node **9**. Then, we move
    left to find the leftmost node. Node **12** is called the in-order successor of
    node **9**. The second step resembles the move to find the maximum node in a sub-tree.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地用节点**6**或**13**替换节点**9**。我们需要找到节点**9**的下一个最大的后代。这是节点**12**。要到达节点**12**，我们移动到节点**9**的右节点，然后向左移动以找到最左边的节点。节点**12**被称为节点**9**的中序后继。第二步类似于查找子树中的最大节点。
- en: We replace the value of node **9** with the value **12** and remove node **12**.
    Upon removing node **12**, we end up with a simpler form of node removal that
    was addressed previously. Node 12 has no children, so we apply the rule for removing
    nodes without children accordingly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用节点**9**的值替换节点**9**的值，并删除节点**12**。删除节点**12**后，我们得到了一个更简单的节点删除形式，这是之前讨论过的。节点12没有子节点，所以我们相应地应用了删除没有子节点的节点的规则。
- en: 'Our `node` class does not have a reference to a parent. As such, we need to
    use a helper method to `search` and return the node with its parent node. This
    method is similar to the `search` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`node`类没有父节点的引用。因此，我们需要使用一个辅助方法来`搜索`并返回带有其父节点的节点。这个方法类似于`搜索`方法：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only difference is that before we update the current variable inside the
    loop, we store its parent with `parent = current`. The method to do the actual
    removal of a node begins with this search:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是在更新循环内的当前变量之前，我们用`parent = current`存储它的父节点。实际删除节点的方法始于这个搜索：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We pass the parent and the found nodes to `parent` and `node`, respectively
    with the `parent, node = self.get_node_with_parent(data)` line. It is important
    to know the number of children that the node has that we want to delete, and we
    do so in the `if` statement.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将父节点和找到的节点分别传递给`parent`和`node`，使用`parent, node = self.get_node_with_parent(data)`。了解要删除的节点有多少个子节点是很重要的，我们在`if`语句中这样做。
- en: 'After we know the number of children a node has that we want to delete, we
    need to handle various conditions in which a node can be deleted. The first part
    of the `if` statement handles the case where the node has no children:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们知道要删除的节点有多少个子节点之后，我们需要处理节点可以被删除的各种情况。`if`语句的第一部分处理了节点没有子节点的情况：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In cases where the node to be deleted has only one child, the `elif` part of
    the `if` statement does the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在要删除的节点只有一个子节点的情况下，`if`语句的`elif`部分执行以下操作：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `next_node` is used to keep track of that single node. which is the child
    of the node that is to be deleted. We then connect `parent.left_child` or `parent.right_child`
    to `next_node`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_node`用于跟踪单个节点，该节点是要删除的节点的子节点。然后，我们将`parent.left_child`或`parent.right_child`连接到`next_node`。'
- en: 'Lastly, we handle the condition where the node we want to delete has two children:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理了要删除的节点有两个子节点的情况：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In finding the in-order successor, we move to the right node with `leftmost_node
    = node.right_child`. As long as a left node exists, `leftmost_node.left_child`
    will evaluate to `True` and the `while` loop will run. When we get to the leftmost
    node, it will either be a leaf node (meaning that it will have no child node)
    or have a right child.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找中序后继时，我们移动到右节点，使用`leftmost_node = node.right_child`。只要左节点存在，`leftmost_node.left_child`将计算为`True`，并且`while`循环将运行。当我们到达最左边的节点时，它要么是叶节点（意味着它将没有子节点），要么有一个右子节点。
- en: 'We update the node that''s about to be removed with the value of the in-order
    successor with `node.data = leftmost_node.data`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`node.data = leftmost_node.data`来更新即将被删除的节点的值为中序后继的值：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding statement allows us to properly attach the parent of the leftmost
    node with any child node. Observe how the right-hand side of the equals sign stays
    unchanged. This is because the in-order successor can only have a right child
    as its only child.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句允许我们正确地将左子树节点的父节点与任何子节点连接起来。请注意等号右侧保持不变。这是因为中序后继只能有一个右子节点作为其唯一子节点。
- en: The `remove` operation takes `O(*h*)`, where `h` is the height of the tree.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`操作的时间复杂度为`O(*h*)`，其中`h`是树的高度。'
- en: Searching the tree
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索树
- en: 'A binary search tree is a tree data structure in which all the nodes follow
    the property that all the nodes in the left sub-tree of a node have lower key
    values, and have greater key values in its right sub-tree. Thus, searching for
    an element with a given key value is quite easy. Let''s consider an example binary
    search tree that has nodes **1**, **2**, **3**, **4**, **8**, **5**, and **10**,
    as shown in the following diagram:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树是一种树形数据结构，其中所有节点都遵循这样的属性：节点的左子树中的所有节点具有较低的键值，在其右子树中具有较大的键值。因此，搜索具有给定键值的元素非常容易。让我们考虑一个示例二叉搜索树，其中的节点为**1**、**2**、**3**、**4**、**8**、**5**和**10**，如下图所示：
- en: '![](Images/5c287e15-284f-4eab-99f3-7efe3b2b34c5.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5c287e15-284f-4eab-99f3-7efe3b2b34c5.png)'
- en: In the preceding tree, if we wish to search for a node with a value of **5**,
    then we start from the root node and compare it with the root. As node **5** is
    a greater value compared to root node value **4**, we move to the right sub-tree.
    In the right sub-tree, we have node **8** as the root node; we compare node **5**
    with node **8**. As the node to be searched has a smaller value than node **8**,
    we move to the left sub-tree. When we move to the left sub-tree, we compare the
    left sub-tree node **5** with the required node with value **5**. This is a match,
    so we return `"item found"`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述树中，如果我们想要搜索值为**5**的节点，则我们从根节点开始，并将其与根节点进行比较。由于节点**5**的值大于根节点值**4**，我们移动到右子树。在右子树中，我们有节点**8**作为根节点；我们将节点**5**与节点**8**进行比较。由于要搜索的节点的值小于节点**8**，我们移动到左子树。当我们移动到左子树时，我们将左子树节点**5**与值为**5**的所需节点进行比较。这是一个匹配，所以我们返回“找到项目”。
- en: 'Here is the implementation of the `searching` method in a binary search tree:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是二叉搜索树中`searching`方法的实现：
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we will return the data if it was found, or `None` if
    the data wasn't found. We start searching from the root node. Next, if the data
    item to be searched for doesn't exist in the tree, we return `None` to the client
    code. We might also have found the data—in that case, we return the data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，如果找到数据，我们将返回数据，如果未找到数据，则返回`None`。我们从根节点开始搜索。接下来，如果要搜索的数据项不存在于树中，则我们将返回`None`给客户端代码。我们也可能已经找到了数据，如果是这种情况，我们将返回数据。
- en: If the data we are searching for is less than that of the current node, we go
    down the tree to the left. Furthermore, in the `else` part of the code, we check
    if the data we are looking for is greater than the data held in the current node,
    which means that we go down the tree to the right.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要搜索的数据小于当前节点的数据，则我们向树的左侧移动。此外，在代码的`else`部分中，我们检查我们要查找的数据是否大于当前节点中保存的数据，这意味着我们向树的右侧移动。
- en: 'Finally, we can write some client code to test how the BST works. We must create
    a tree and insert a few numbers between `1` and `10`. Then, we search for all
    the numbers in that range. The ones that exist in the tree get printed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写一些客户端代码来测试BST的工作原理。我们必须创建一棵树，并在“1”和“10”之间插入一些数字。然后，我们搜索该范围内的所有数字。存在于树中的数字将被打印出来：
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Benefits of a binary search tree
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树的好处
- en: A binary search tree is a better choice compared to arrays and linked lists.
    A BST is fast for most operations such as searching, insertion, and deletion,
    whereas arrays provide fast searching, but are comparatively slow in insertion
    and deletion operations. In a similar fashion, linked lists are efficient in performing
    insertion and deletion operations, but are slower when performing the search operation.
    The `best-case` running time complexity for searching an element from a binary
    search tree is `O(log n)`, and the `worst-case` time complexity is `O(n)`, whereas
    both `best-case` and `worst-case` time complexity for searching in lists is `O(n)`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树与数组和链表相比是更好的选择。对于大多数操作，如搜索、插入和删除，BST都很快，而数组提供了快速的搜索，但在插入和删除操作上相对较慢。同样，链表在执行插入和删除操作时效率很高，但在执行搜索操作时速度较慢。在二叉搜索树中搜索元素的“最佳情况”运行时间复杂度为“O(log
    n)”，而“最坏情况”时间复杂度为“O(n)”，而在列表中搜索的“最佳情况”和“最坏情况”时间复杂度均为“O(n)”。
- en: 'The following table provides a comparison of the array, linked list, and binary
    search tree data structures:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了数组、链表和二叉搜索树数据结构的比较：
- en: '| **Properties** | **Array** | **Linked list** | **BST** |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **数组** | **链表** | **BST** |'
- en: '| **Data structure** | Linear. | Linear. | Non-linear. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **数据结构** | 线性。 | 线性。 | 非线性。 |'
- en: '| **Ease of use** | Easy to create and use. Average-case complexity for search,
    insert, and delete is `O(n)`. | Insertion and deletion is fast, especially with
    the doubly linked list. | Access of elements, insertion, and deletion is fast
    with the average-case complexity of `O(log n)`. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **易用性** | 创建和使用都很容易。搜索、插入和删除的平均情况复杂度为`O(n)`。 | 插入和删除很快，特别是使用双向链表。 | 元素访问、插入和删除都很快，平均情况复杂度为`O(log
    n)`。 |'
- en: '| **Access Complexity** | Easy to access elements. Complexity is `O(1)`. |
    Only sequential access is possible, so slow. Average and worst-case complexity
    is `O(n)`. | Access is fast, but slow when the tree is unbalanced, with the worst-case
    complexity of `O(n)`. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **访问复杂度** | 访问元素容易。复杂度为`O(1)`。 | 只能进行顺序访问，所以很慢。平均和最坏情况下的复杂度是`O(n)`。 | 访问很快，但当树不平衡时很慢，最坏情况下的复杂度为`O(n)`。
    |'
- en: '| **Search complexity** | Average and worst-case complexity is `O(n)`. | It
    is slow due to sequential searching. Average and worst-case complexity is `O(n)`.
    | Worst-case complexity for searching is `O(n)`. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **搜索复杂度** | 平均和最坏情况下的复杂度是`O(n)`。 | 由于顺序搜索，所以很慢。平均和最坏情况下的复杂度是`O(n)`。 | 搜索的最坏情况复杂度是`O(n)`。
    |'
- en: '| **Insertion complexity** | Insertion is slow. Average and worst-case complexity
    is `O(n)`. | Average and worst-case complexity is `O(1)`. | The worst-case complexity
    for insertion is `O(n)`. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **插入复杂度** | 插入很慢。平均和最坏情况下的复杂度是`O(n)`。 | 平均和最坏情况下的复杂度是`O(1)`。 | 插入的最坏情况复杂度是`O(n)`。
    |'
- en: '| **Deletion complexity** | Deletion is slow. Average and worst-case complexity
    is `O(n)`. | Average and worst-case complexity is `O(1)`. | The worst-case complexity
    for deletion is `O(n)`. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **删除复杂度** | 删除很慢。平均和最坏情况下的复杂度是`O(n)`。 | 平均和最坏情况下的复杂度是`O(1)`。 | 删除的最坏情况复杂度是`O(n)`。
    |'
- en: 'Let''s consider an example to understand when the binary search tree is a good
    choice to store the data. Let''s assume that we have the following data nodes—**5**,
    **3**, **7**, **1**, **4****,** **6**, and **9**. If we use a list to store this
    data, the worst-case scenario will require us to search through the entire list
    of seven elements for finding the item. So, it will require seven comparisons
    to search for item **9** in this data node:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来理解何时使用二叉搜索树来存储数据是一个好选择。假设我们有以下数据节点——**5**，**3**，**7**，**1**，**4**，**6**和**9**。如果我们使用列表来存储这些数据，最坏的情况将需要我们搜索整个包含七个元素的列表来找到这个项目。因此，在这个数据节点中，需要七次比较来搜索项目**9**：
- en: '![](Images/2ebb36ce-b7e3-4149-833f-fe26f1d5e61e.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2ebb36ce-b7e3-4149-833f-fe26f1d5e61e.png)'
- en: 'However, if we use a binary search tree to store these values, as shown in
    the following diagram, in the worst-case scenario, we would require three comparisons
    to search for item **9**:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用二叉搜索树来存储这些值，如下图所示，在最坏的情况下，我们需要三次比较来搜索项目**9**：
- en: '![](Images/9232922d-cb33-4d9f-8f58-3c09482b5e0c.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9232922d-cb33-4d9f-8f58-3c09482b5e0c.png)'
- en: 'However, it is important to note that the efficiency of searching also depends
    on how we built the binary search tree. If the tree hasn''t been constructed properly,
    it can be slow. For example, if we had inserted the elements into the tree in
    the order {**1**, **3**, **4**, **5**, **6**, **7**,**9**}, as shown in the following
    diagram, then the tree would not be more efficient than the list:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意搜索效率也取决于我们如何构建二叉搜索树。如果树没有被正确构建，它可能会很慢。例如，如果我们按照{**1**，**3**，**4**，**5**，**6**，**7**，**9**}的顺序将元素插入到树中，如下图所示，那么树将不会比列表更有效：
- en: '![](Images/72619b66-237f-4771-a7bc-0211b8e82bee.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/72619b66-237f-4771-a7bc-0211b8e82bee.png)'
- en: Thus, choosing a self-balancing tree helps to improve the `search` operation.
    Here, we should note that the binary search tree is a better choice in most of
    the cases; however, we should try to balance the tree.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择自平衡树有助于改善`搜索`操作。在这里，我们应该注意，二叉搜索树在大多数情况下是更好的选择；然而，我们应该尝试平衡树。
- en: Balancing trees
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡树
- en: We have seen in the previous section that if nodes are inserted into a tree
    in a sequential order, it becomes slow and behaves more or less like a list; that
    is, each node has exactly one child node. To improve the performance of the tree
    data structure, we generally like to reduce the height of the tree as much as
    possible to balance the tree by filling up each row in the tree. This process
    is called **balancing the tree**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前一节中看到，如果节点按顺序插入到树中，它会变得很慢，行为上更像一个列表；也就是说，每个节点恰好有一个子节点。为了提高树数据结构的性能，我们通常希望尽可能减少树的高度，通过填充树中的每一行来平衡树。这个过程称为**平衡树**。
- en: There are different types of self-balancing trees, such as red-black trees,
    AA trees, and scapegoat trees. These balance the tree during each operation that
    modifies the tree, such as insert or delete. There are also external algorithms
    that balance a tree. The benefits of these are that you don't need to balance
    the tree on every single operation and can leave balancing to the point where
    you need it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的自平衡树，如红黑树、AA树和替罪羊树。这些树在修改树的每个操作期间平衡树，比如插入或删除。还有一些外部算法来平衡树。这些方法的好处是你不需要在每次操作中都平衡树，可以在需要时再进行平衡。
- en: Expression trees
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达树
- en: An arithmetic expression is represented by a combination of operators and operands
    where the operators can be unary or binary. An arithmetic expression can also
    be represented using a **binary tree**, which is called an expression tree. This
    tree structure can also be used to parse arithmetic and boolean expressions. In
    an expression tree, all the leaf nodes contain the operands and non-leaf nodes
    contain the operators. We should also note that the expression tree will have
    one of its sub-trees (right sub-tree or left sub-tree) empty in the case of a
    unary operator.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式由操作数和运算符的组合表示，其中运算符可以是一元或二元。算术表达式也可以使用**二叉树**表示，称为表达式树。这种树结构也可以用于解析算术和布尔表达式。在表达式树中，所有叶节点包含操作数，非叶节点包含运算符。我们还应该注意，表达式树的子树（右子树或左子树）在一元运算符的情况下将为空。
- en: 'For example, the expression tree for `3 + 4` would look as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`3 + 4`的表达式树如下所示：
- en: '![](Images/8286c09a-c33a-4d43-907e-8955d357ad4b.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8286c09a-c33a-4d43-907e-8955d357ad4b.png)'
- en: 'For a slightly more complex expression, `(4 + 5) * (5-3)`, we would get the
    following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于稍微复杂的表达式`(4 + 5) * (5-3)`，我们将得到以下结果：
- en: '![](Images/cf45c4ca-4483-4c7e-81dd-cab97ec9ba5f.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cf45c4ca-4483-4c7e-81dd-cab97ec9ba5f.png)'
- en: The arithmetic expression can be expressed using three notations (that is, infix,
    postfix, and prefix), as discussed in the previous section on tree traversal. Due
    to this, it becomes easy to evaluate an expression tree for the given arithmetic
    expression. The reverse Polish notation provides faster calculations. We will
    show you how to construct the expression tree for the given postfix notation in
    the following subsection.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式可以用三种符号表示（即中缀、后缀和前缀），如前一节中关于树遍历的讨论所述。因此，对于给定的算术表达式，评估表达式树变得容易。逆波兰符号提供更快的计算。我们将在以下小节中向您展示如何构建给定后缀符号的表达式树。
- en: Parsing a reverse Polish expression
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析逆波兰表达式
- en: 'Now, we are going to build up a tree for an expression written in postfix notation.
    Then, we will calculate the result. We will use a simple tree implementation.
    To keep it simple, since we are going to grow the tree by merging smaller trees,
    we only need a tree node implementation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为后缀表示法中的表达式构建树。然后，我们将计算结果。我们将使用一个简单的树实现。为了保持简单，因为我们将通过合并较小的树来增加树，我们只需要一个树节点实现：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to build the tree, we are going to enlist the items with the help
    of a stack. Let''s just create an arithmetic expression and set up our stack:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建树，我们将使用堆栈列出项目。让我们创建一个算术表达式并设置我们的堆栈：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since Python is a language that tries hard to have sensible defaults, its `split()`
    method splits on whitespace by default. (If you think about it, this is most likely
    what you would expect.) The result is going to be that `expr` is a list with the
    values `4`, `5`, `+`, `5`, `3`, `-`, and `*`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是一种试图具有合理默认值的语言，其`split()`方法默认在空格上拆分。（如果您考虑一下，这很可能是您所期望的。）结果将是`expr`是一个包含值`4`、`5`、`+`、`5`、`3`、`-`和`*`的列表。
- en: Each element of the `expr` list is going to be either an operator or an operand.
    If we get an operand, then we embed it in a tree node and push it onto the stack.
    If we get an operator, on the other hand, then we embed the operator into a tree
    node and pop its two operands into the node's left and right children. Here, we
    have to take care to ensure that the first pop goes into the right child; otherwise,
    we will have problems with subtraction and division.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr`列表的每个元素将是运算符或操作数。如果我们得到一个操作数，那么我们将其嵌入树节点并将其推送到堆栈上。另一方面，如果我们得到一个运算符，那么我们将运算符嵌入树节点，并将其两个操作数弹出到节点的左右子节点中。在这里，我们必须确保第一个弹出进入右子节点；否则，我们将在减法和除法中出现问题。'
- en: 'Here is the code to build the tree:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建树的代码：
- en: '[PRE30]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we perform a conversion from `string` to `int` in the case of an
    operand. You could use `float()` instead, if you wish to support floating point
    operands.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在操作数的情况下，我们执行了从`string`到`int`的转换。如果您希望支持浮点操作数，可以使用`float()`。
- en: 'At the end of this operation, we should have one single element in the stack,
    and that holds the full tree. If we want to evaluate the expression, we would
    build the following little function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作结束时，我们应该在堆栈中有一个单一元素，并且该元素包含完整的树。如果我们想要评估表达式，我们将构建以下小函数：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we pass in a node to the function. If the node contains
    an operand, then we simply return that value. If we get an operator, then we perform
    the operation that the operator represents on the node's two children. However,
    since one or more of the children could also contain either operators or operands,
    we call the `calc()` function recursively on the two child nodes (bearing in mind
    that all the children of every node are also nodes).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将一个节点传递给函数。如果节点包含操作数，那么我们只需返回该值。如果我们得到一个运算符，那么我们将在节点的两个子节点上执行运算符表示的操作。然而，由于一个或多个子节点也可能包含运算符或操作数，我们在两个子节点上递归调用`calc()`函数（要记住每个节点的所有子节点也都是节点）。
- en: 'Now, we just need to pop the root node off the stack and pass it into the `calc()`
    function. Then, we should have the result of the calculation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要从堆栈中弹出根节点并将其传递给`calc()`函数。然后，我们应该得到计算的结果：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Running this program should yield the result `18`, which is the result of `(4
    + 5) * (5 - 3)`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序应该产生结果`18`，这是`(4 + 5) * (5 - 3)`的结果。
- en: Heaps
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: A heap data structure is a specialization of a tree in which the nodes are ordered
    in a specific way. Heaps are divided into `max` heaps and `min` heaps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 堆数据结构是树的一种特殊形式，其中节点以特定方式排序。堆分为`max`堆和`min`堆。
- en: 'In a `max` heap, each parent node value must always be greater than or equal
    to its children. It follows that the root node must be the greatest value in the
    tree. Consider the following diagram for the max heap, where all the nodes have
    greater values compared to their children:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`max`堆中，每个父节点的值必须始终大于或等于其子节点。由此可知，根节点必须是树中最大的值。考虑以下最大堆的图表，其中所有节点的值都大于其子节点的值：
- en: '![](Images/d0bd32c7-21a2-4f0b-a2a9-908d904f5933.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d0bd32c7-21a2-4f0b-a2a9-908d904f5933.png)'
- en: 'In a min heap, each parent node must be less than or equal to both its children.
    As a consequence, the root node holds the lowest value. Consider the following
    diagram for the min heap, where all the nodes have smaller values compared to
    their children:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`min`堆中，每个父节点必须小于或等于其两个子节点。因此，根节点包含最小值。考虑以下最小堆的图表，其中所有节点的值都小于其子节点的值：
- en: '![](Images/5bc4330e-b3b1-4dad-bace-f5ee12e66be2.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5bc4330e-b3b1-4dad-bace-f5ee12e66be2.png)'
- en: Heaps are used for a number of different things. For one, they are used to implement
    priority queues. There is also a very efficient sorting algorithm, called **heap
    sort**, that uses heaps. We are going to study these in depth in subsequent chapters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 堆用于许多不同的事情。首先，它们用于实现优先级队列。还有一种非常高效的排序算法，称为**堆排序**，它使用堆。我们将在后续章节中深入研究这些内容。
- en: Ternary search tree
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三元搜索树
- en: A ternary tree is a data structure where each node of the tree can contain up
    to `3` children. It is different compared to the binary search tree in the sense
    that a node in a binary tree can have a maximum of `2` children, whereas a node
    in the ternary tree can have a maximum of `3` children. The ternary tree data
    structure is also considered a special case of the trie data structure. In trie
    data structure, each node contains 26 pointers to its children when we use trie
    data structure to store strings in contrast to the ternary search tree data structure,
    where we have 3 pointers to its children.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 三元树是一种数据结构，树的每个节点最多可以包含`3`个子节点。与二叉搜索树相比，它不同之处在于二叉树中的节点最多可以有`2`个子节点，而三元树中的节点最多可以有`3`个子节点。三元树数据结构也被认为是字典树数据结构的特殊情况。在字典树数据结构中，当我们使用字典树数据结构存储字符串时，每个节点包含26个指向其子节点的指针，而在三元搜索树数据结构中，我们有3个指向其子节点的指针。
- en: 'The ternary search tree can be represented as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 三元搜索树可以表示如下：
- en: Each node stores a character in it
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点都存储一个字符
- en: It has the equal pointer that points to a node that stores a value equal to
    the current node
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有指向存储与当前节点相等值的节点的等指针
- en: It has the left pointer that points to a node that stores a value smaller than
    the current node
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有指向存储小于当前节点值的节点的左指针
- en: It has the right pointer that points to a node that stores a value greater than
    the current node
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有指向存储大于当前节点值的节点的右指针
- en: Each node has a flag variable that keeps track of whether that node is the end
    of a string or not
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点都有一个标志变量，用于跟踪该节点是否是字符串的结尾
- en: 'To better understand the ternary search tree data structure, we will demonstrate
    it through an example where we insert the strings **PUT**, **CAT**, **SIT**, **SING**,
    and **PUSH** to an empty ternary tree, as shown in the following diagram:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解三元搜索树数据结构，我们将通过一个示例来演示，其中我们将字符串**PUT**，**CAT**，**SIT**，**SING**和**PUSH**插入到一个空的三元树中，如下图所示：
- en: '![](Images/0f216d85-eb1f-46d4-b73f-6f5234881607.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0f216d85-eb1f-46d4-b73f-6f5234881607.png)'
- en: 'Inserting a value into a ternary search tree is quite similar to how we do
    it in a binary search tree. In the ternary search tree, we follow these steps
    to insert a string in the ternary search tree:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将值插入三元搜索树与在二叉搜索树中进行的方式非常相似。在三元搜索树中，我们遵循以下步骤将字符串插入三元搜索树：
- en: Since the tree is empty initially, we start by creating the root node with the
    first character, **P**, and then we create another node for the character **U**,
    and finally the character **T**.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于树最初为空，我们首先创建根节点，其中包含第一个字符**P**，然后我们为字符**U**创建另一个节点，最后是字符**T**。
- en: Next, we wish to add the word **CAT**. First, we compare the first character **C** with
    the root node character, **P**. Since it does not match, and it is smaller than
    the root node, we create a new node for the character **C** on the left-hand side
    of the root node. Furthermore, we create the nodes for characters **A** and **T**.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望添加单词**CAT**。首先，我们将第一个字符**C**与根节点字符**P**进行比较。由于不匹配，并且它小于根节点，我们在根节点的左侧为字符**C**创建一个新节点。此外，我们创建了字符**A**和**T**的节点。
- en: Next, we add a new word, **SIT**. First, we compare the first character, **S**,
    with the root node character, **P**. Since it does not match, and character **S**
    is greater than character **P**, we create a new node on the right-hand side for
    the character **S**. Furthermore, we create nodes for characters **I** and **T**.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个新单词**SIT**。首先，我们将第一个字符**S**与根节点字符**P**进行比较。由于不匹配，并且字符**S**大于字符**P**，我们在右侧为字符**S**创建一个新节点。此外，我们创建了字符**I**和**T**的节点。
- en: Next, we insert a new word, **SING**, into the ternary search tree. We start
    by comparing the first character, **S**, to the root node. Since it does not match,
    and the character **S** is greater than the root node **P**, we look at the next
    character to the right-hand side, that is, **S**. Here, the character matches,
    so we compare the next character, which is **I**; this also matches. Next, we
    compare the character **N**, to the character **T** in the tree. Here, the characters
    do not match, so we move to the left-hand side of node **T**. Here, we create
    a new node for the character **N**. Furthermore, we create another new node for
    the character **G**.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将单词**SING**插入到三叉搜索树中。我们首先将第一个字符**S**与根节点进行比较。由于不匹配，并且字符**S**大于根节点**P**，我们查看右侧的下一个字符，即**S**。这里，字符匹配，因此我们比较下一个字符**I**；这也匹配。接下来，我们将字符**N**与树中的字符**T**进行比较。这里，字符不匹配，因此我们移动到节点**T**的左侧。在这里，我们为字符**N**创建一个新节点。此外，我们为字符**G**创建另一个新节点。
- en: Then, we add a new node, **PUSH**, in the ternary search tree. First, we compare
    the first character of the word, that is, **P**, to the root node. Since it matches,
    we look at the next character in the ternary tree. Here, the character **U** also
    matches with the next character of the word. So, we look at the next character
    of the word, that is, **S**. It doesn't match with the next character in the tree,
    which is **T**. Therefore, we create a new node for the character **S** to the
    left-hand side of node **T** since character **S** is smaller than **T**. Next,
    we create another node for the next character, **H**.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在三叉搜索树中添加一个新节点**PUSH**。首先，我们比较单词的第一个字符，即**P**，与根节点。由于匹配，我们查看三叉树中的下一个字符。这里，字符**U**也与单词的下一个字符匹配。因此，我们查看单词的下一个字符，即**S**。它与树中的下一个字符**T**不匹配。因此，我们在节点**T**的左侧为字符**S**创建一个新节点，因为字符**S**小于**T**。接下来，我们为下一个字符**H**创建另一个节点。
- en: Take note that each node in the ternary tree keeps track of which node is the
    leaf node or non-leaf node via the use of a flag variable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，三叉树中的每个节点都通过使用标志变量来跟踪哪个节点是叶节点或非叶节点。
- en: Ternary search trees are very efficient for strings searching for related applications
    such as when we wish to search all of the strings that start with a given prefix,
    or when we wish to search for a phone number that starts with given specific numbers,
    spell checks, and so on.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 三叉搜索树非常适用于字符串搜索相关的应用，比如当我们希望搜索所有以特定前缀开头的字符串，或者当我们希望搜索以特定数字开头的电话号码，拼写检查等等。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at tree data structures and their uses. We studied
    binary trees in particular, which is a subtype of tree where each node has two
    children at most. We also looked at how a binary tree can be used as a searchable
    data structure with a BST. The breadth-first and depth-first search traversal
    modes were also implemented in Python by using queue recursion.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了树数据结构及其用途。特别是我们研究了二叉树，这是树的一个子类型，其中每个节点最多有两个子节点。我们还看了二叉树如何作为可搜索的数据结构与BST一起使用。广度优先和深度优先搜索遍历模式也通过使用队列递归在Python中实现。
- en: We also looked at how a binary tree can be used to represent an arithmetic or
    a Boolean expression. We then built an expression tree to represent an arithmetic
    expression. Afterward, we showed you how to use a stack to parse an expression
    written in RPN, build up the expression tree, and finally traverse it to get the
    result of the arithmetic expression.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了二叉树如何用来表示算术或布尔表达式。然后，我们构建了一个表达式树来表示算术表达式。之后，我们向您展示了如何使用栈来解析以逆波兰表示法编写的表达式，构建表达式树，并最终遍历它以获得算术表达式的结果。
- en: Finally, we mentioned heaps, a specialization of a tree structure. We have tried
    to at least lay down the theoretical foundation for the heap in this chapter so
    that we can go on to implement heaps for different purposes in upcoming chapters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了堆，这是树结构的一种特殊形式。我们在本章至少尝试奠定了堆的理论基础，以便在接下来的章节中为不同的目的实现堆。
- en: In the next chapter, we will be discussing the details of hash tables and symbol
    tables.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论哈希表和符号表的细节。
