- en: 2\. Python's Main Tools for Statistics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. Python统计的主要工具
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter presents a practical introduction to the main libraries that most
    statistics practitioners use in Python. It will cover some of the most important
    and useful concepts, functions, and **Application Programming Interfaces** (**APIs**)
    of each of the key libraries. Almost all of the computational tools that will
    be needed for the rest of this book will be introduced in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了大多数统计从业者在Python中使用的主要库的实际介绍。它将涵盖一些最重要和有用的概念、函数和每个关键库的**应用程序编程接口**（**API**）。几乎本书其余部分所需的所有计算工具都将在本章介绍。
- en: 'By the end of this chapter, you will understand the idea behind array vectorization
    of the NumPy library and be able to use its sampling functionalities. You''ll
    be able to initialize pandas DataFrames to represent tabular data and manipulate
    their content. You''ll also understand the importance of data visualization in
    data analysis and be able to utilize Python''s two most popular visualization
    libraries: Matplotlib and Seaborn.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解NumPy库的数组矢量化背后的思想，并能够使用其抽样功能。您将能够初始化pandas数据框架以表示表格数据并操纵其内容。您还将了解数据分析中数据可视化的重要性，并能够利用Python的两个最流行的可视化库：Matplotlib和Seaborn。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'After going through a refresher on the Python language in the previous chapter,
    we are now ready to tackle the main topics of this book: mathematics and statistics.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中对Python语言进行了复习之后，我们现在准备着手处理本书的主要主题：数学和统计。
- en: 'Among others, the general fields of computational mathematics and statistics
    can be broken up into three main tool-centric components: representation and engineering;
    analysis and computation; and finally, visualization. In the ecosystem of the
    Python programming language, specific libraries are dedicated to each of these
    components (namely, pandas, NumPy, Matplotlib, and Seaborn), making the process
    modular.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他外，计算数学和统计的一般领域可以分为三个主要的工具中心组件：表示和工程；分析和计算；最后是可视化。在Python编程语言的生态系统中，专门的库专门用于这些组件中的每一个（即pandas、NumPy、Matplotlib和Seaborn），使整个过程变得模块化。
- en: While there might be other similar packages and tools, the libraries that we
    will be discussing have been proven to possess a wide range of functionalities
    and support powerful options in terms of computation, data processing, and visualization,
    making them some of a Python programmer's preferred tools over the years.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能存在其他类似的软件包和工具，但我们将讨论的库已被证明具有广泛的功能和支持强大的计算、数据处理和可视化选项，使它们成为多年来Python程序员首选的工具之一。
- en: In this chapter, we will be introduced to each of these libraries and learn
    about their main API. Using a hands-on approach, we will see how these tools allow
    great freedom and flexibility in terms of creating, manipulating, analyzing, and
    visualizing data in Python. Knowing how to use these tools will also equip us
    for more complicated topics in the later chapters of this workshop.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍这些库的每一个，并了解它们的主要API。通过实践方法，我们将看到这些工具如何在Python中创建、操纵、分析和可视化数据方面提供了极大的自由和灵活性。了解如何使用这些工具也将使我们能够更好地应对本研讨会后面章节中的更复杂的主题。
- en: Scientific Computing and NumPy Basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 科学计算和NumPy基础知识
- en: The term **scientific computing** has been used several times in this workshop
    so far; in the broadest sense of the term, it denotes the process of using computer
    programs (or anything with computing capabilities) to model and solve a specific
    problem in mathematics, engineering, or science. Examples may include mathematical
    models to look for and analyze patterns and trends in biological and social data,
    or machine learning models to make future predictions using economic data. As
    you may have already noticed, this definition has a significant overlap with the
    general fields of data science, and sometimes the terms are even used interchangeably.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本研讨会中已经多次使用了术语**科学计算**；在该术语的最广泛意义上，它表示使用计算机程序（或任何具有计算能力的东西）来模拟和解决数学、工程或科学中的特定问题的过程。示例可能包括数学模型来查找和分析生物和社会数据中的模式和趋势，或者使用经济数据进行未来预测的机器学习模型。正如您可能已经注意到的那样，这个定义与数据科学的一般领域有重要的重叠，有时甚至可以互换使用这些术语。
- en: The main workhorse of many (if not most) scientific computing projects in Python
    is the NumPy library. Since NumPy is an external library that does not come preinstalled
    with Python, we need to download and install it. As you may already know, installing
    external libraries and packages in Python can be done easily using package managers
    such as pip or Anaconda.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中许多（如果不是大多数）科学计算项目的主要工具是NumPy库。由于NumPy是一个外部库，不会预先安装在Python中，我们需要下载并安装它。正如您可能已经知道的那样，在Python中安装外部库和软件包可以使用包管理器（如pip或Anaconda）轻松完成。
- en: 'From your Terminal, run the following command to use pip to install NumPy in
    your Python environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的终端运行以下命令，使用pip在您的Python环境中安装NumPy：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are currently in an Anaconda environment, you can run the following
    command instead:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您目前在Anaconda环境中，您可以运行以下命令：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With these simple commands, all the necessary steps in the installation process
    are taken care of for us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的命令，我们已经完成了安装过程中的所有必要步骤。
- en: Some of NumPy's most powerful capabilities include vectorized, multi-dimensional
    array representations of objects; implementation of a wide range of linear algebraic
    functions and transformations; and random sampling. We will cover all of these
    topics in this section, starting with the general concept of arrays.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的一些最强大的功能包括对象的矢量化、多维数组表示；实现广泛的线性代数函数和变换；以及随机抽样。我们将在本节中涵盖所有这些主题，从数组的一般概念开始。
- en: NumPy Arrays
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy数组
- en: 'We have actually already come across the concept of an array in the previous
    chapter, when we discussed Python lists. In general, an array is also a sequence
    of different elements that can be accessed individually or manipulated as a whole.
    As such, NumPy arrays are very similar to Python lists; in fact, the most common
    way to declare a NumPy array is to pass a Python list to the `numpy.array()` method,
    as illustrated here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在上一章中，当我们讨论Python列表时，我们已经接触到了数组的概念。一般来说，数组也是一系列不同元素，可以单独访问或作为整体进行操作。因此，NumPy数组与Python列表非常相似；事实上，声明NumPy数组的最常见方式是将Python列表传递给`numpy.array()`方法，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The biggest difference we need to keep in mind is that elements in a NumPy
    array need to be of the same type. For example, here, we are trying to create
    an array with two numbers and a string, which causes NumPy to forcibly convert
    all elements in the array into strings (the `<U21` data type denotes the Unicode
    strings with fewer than 21 characters):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要牢记的最大区别是，NumPy数组中的元素需要是相同类型的。例如，在这里，我们试图创建一个包含两个数字和一个字符串的数组，这导致NumPy强制将数组中的所有元素转换为字符串（`<U21`数据类型表示少于21个字符的Unicode字符串）：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similar to the way we can create multi-dimensional Python lists, NumPy arrays
    support the same option:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们可以创建多维Python列表的方式类似，NumPy数组也支持相同的选项：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While working with NumPy, we often refer to multi-dimensional arrays as matrices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用NumPy时，我们经常将多维数组称为矩阵。
- en: 'Apart from initialization from Python lists, we can create NumPy arrays that
    are in a specific form. In particular, a matrix full of zeros or ones can be initialized
    using `np.zeros()` and `np.ones()`, respectively, with a given dimension and data
    type. Let''s have a look at an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Python列表进行初始化外，我们还可以创建特定形式的NumPy数组。特别是，可以使用`np.zeros()`和`np.ones()`分别初始化全零或全一的矩阵，指定维度和数据类型。让我们看一个例子：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the tuple `(2, 2)` specifies that the array (or matrix) being initialized
    should have a two-by-two dimension. As we can see by the dots after the zeros,
    the default data type of a NumPy array is a float and can be further specified
    using the `dtype` argument:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，元组`(2, 2)`指定正在初始化的数组（或矩阵）应具有二乘二的维度。正如我们在零后面看到的点所示，NumPy数组的默认数据类型是浮点数，并且可以使用`dtype`参数进一步指定：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'All-zero or all-one matrices are common objects in mathematics and statistics,
    so these API calls will prove to be quite useful later on. Now, let''s look at
    a common matrix object whose elements are all random numbers. Using `np.random.rand()`,
    we can create a matrix of a given shape, whose elements are uniformly sampled
    between 0 (inclusive) and 1 (exclusive):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 全零或全一矩阵是数学和统计学中常见的对象，因此这些API调用在以后将被证明非常有用。现在，让我们看一个常见的矩阵对象，其元素都是随机数。使用`np.random.rand()`，我们可以创建一个给定形状的矩阵，其元素在0（包括）和1（不包括）之间均匀抽样：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice here that we are not passing the desired shape of our matrix as a tuple
    anymore, but as individual parameters of the `np.random.rand()` function instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们不再将所需矩阵的形状作为元组传递，而是作为`np.random.rand()`函数的单独参数传递。
- en: If you are not familiar with the concept of randomness and random sampling from
    various distributions, don't worry, as we will cover that topic later on in this
    chapter as well. For now, let's move forward with our discussion about NumPy arrays,
    particularly about indexing and slicing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对随机性的概念和从各种分布中进行随机抽样不熟悉，不用担心，因为我们将在本章后面涵盖这个主题。现在，让我们继续讨论NumPy数组，特别是关于索引和切片。
- en: 'You will recall that in order to access individual elements in a Python list,
    we pass its index inside square brackets next to the list variable; the same goes
    for one-dimensional NumPy arrays:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得，为了访问Python列表中的单个元素，我们将其索引传递到列表变量旁边的方括号中；对于一维NumPy数组也是如此：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, when an array is multi-dimensional, instead of using multiple square
    brackets to access subarrays, we simply need to separate the individual indices
    using commas. For example, we access the element in the second row and the second
    column of a three-by-three matrix as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当数组是多维的时，我们不再使用多个方括号来访问子数组，而是只需使用逗号来分隔各个索引。例如，我们可以按如下方式访问三乘三矩阵中第二行第二列的元素：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Slicing NumPy arrays can be done in the same way: using commas. This syntax
    is very useful in terms of helping us access submatrices with more than one dimension
    in a matrix:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 切片NumPy数组可以以相同的方式进行：使用逗号。这种语法在帮助我们访问矩阵中具有多个维度的子矩阵方面非常有用：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding example, `a[1, 0: 2, 1:]` helps us to access the numbers in
    the original matrix, `a`; that is, in the second element in the first axis (corresponding
    to index `1`), the first two elements in the second axis (corresponding to `0:
    2`), and the last three elements in the third axis (corresponding to `1:`). This
    option is one reason why NumPy arrays are more powerful and flexible than Python
    lists, which do not support multi-dimensional indexing and slicing, as we have
    demonstrated.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的例子中，`a[1, 0: 2, 1:]`帮助我们访问原始矩阵`a`中的数字；即在第一个轴（对应索引`1`）中的第二个元素，第二个轴（对应`0:
    2`）中的前两个元素，以及第三个轴（对应`1:`）中的最后三个元素。这个选项是NumPy数组比Python列表更强大和灵活的一个原因，因为Python列表不支持多维索引和切片，正如我们所演示的。'
- en: 'Finally, another important syntax to manipulate NumPy arrays is the `np.reshape()`
    function, which, as its name suggests, changes the shape of a given NumPy array.
    The need for this functionality can arise on multiple occasions: when we need
    to display an array in a certain way for better readability, or when we need to
    pass an array to a built-in function that only takes in arrays of a certain shape.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一个重要的用于操作NumPy数组的语法是`np.reshape()`函数，正如其名称所示，它可以改变给定NumPy数组的形状。需要这种功能的情况可能会多次出现：当我们需要以某种方式显示数组以便更好地阅读时，或者当我们需要将数组传递给只接受特定形状数组的内置函数时。
- en: 'We can explore the effect of this function in the following code snippet:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码片段中探索这个函数的效果：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the `np.reshape()` function does not mutate the array that is passed
    in-place; instead, it returns a copy of the original array with the new shape
    without modifying the original. We can also assign this returned value to a variable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`np.reshape()`函数不会就地改变传入的数组；相反，它会返回原始数组的副本，新形状的数组而不修改原始数组。我们也可以将这个返回值赋给一个变量。
- en: 'Additionally, notice that while the original shape of the array is `(2, 3,
    4)`, we changed it to `(3, 2, 4)`. This can only be done when the total numbers
    of elements resulting from the two shapes are the same *(2 x 3 x 4 = 3 x 2 x 4
    = 24)*. An error will be raised if the new shape does not correspond to the original
    shape of an array in this way, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，虽然数组的原始形状是`(2, 3, 4)`，但我们将其改为`(3, 2, 4)`。只有当两个形状产生的元素总数相同时才能这样做*(2 x
    3 x 4 = 3 x 2 x 4 = 24)*。如果新形状与数组的原始形状不对应，将会引发错误，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Speaking of reshaping a NumPy array, transposing a matrix is a special form
    of reshaping that *flips* the elements in the matrix along its diagonal. Computing
    the transpose of a matrix is a common task in mathematics and machine learning.
    The transpose of a NumPy array can be computed using the `[array].T` syntax. For
    example, when we run `a.T` in the Terminal, we get the transpose of matrix `a`,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 说到重塑NumPy数组，转置矩阵是重塑的一种特殊形式，它*翻转*了矩阵中的元素沿着其对角线。计算矩阵的转置是数学和机器学习中的常见任务。可以使用`[array].T`语法计算NumPy数组的转置。例如，当我们在终端中运行`a.T`时，我们得到矩阵`a`的转置，如下所示：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And with that, we can conclude our introduction to NumPy arrays. In the next
    section, we will learn about another concept that goes hand in hand with NumPy
    arrays: vectorization.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以结束我们对NumPy数组的介绍。在下一节中，我们将学习与NumPy数组紧密相关的另一个概念：矢量化。
- en: Vectorization
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矢量化
- en: In the broadest sense, the term **vectorization** in computer science denotes
    the process of applying a mathematical operation to an array (in a general sense)
    element by element. For example, an add operation where every element in an array
    is added to the same term is a vectorized operation; the same goes for vectorized
    multiplication, where all elements in an array are multiplied by the same term.
    In general, vectorization is achieved when all array elements are put through
    the same function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学的最广泛意义上，**矢量化**一词表示将数学运算应用于数组（在一般意义上）的过程，逐个元素。例如，一个加法运算，其中数组中的每个元素都加上相同的项，就是一个矢量化操作；同样，对于矢量化乘法，数组中的所有元素都乘以相同的项。一般来说，当所有数组元素都经过相同的函数处理时，就实现了矢量化。
- en: Vectorization is done by default when an applicable operation is performed on
    a NumPy array (or multiple arrays). This includes binary functions such as addition,
    subtraction, multiplication, division, power, and mod, as well as several unary
    built-in functions in NumPy, such as absolute value, square root, trigonometric
    functions, logarithmic functions, and exponential functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当在NumPy数组（或多个数组）上执行适用的操作时，默认情况下会进行矢量化。这包括二进制函数，如加法、减法、乘法、除法、幂和取模，以及NumPy中的几个一元内置函数，如绝对值、平方根、三角函数、对数函数和指数函数。
- en: Before we see vectorization in NumPy in action, it is worth discussing the importance
    of vectorization and its role in NumPy. As we mentioned previously, vectorization
    is generally the application of a common operation on the elements in an array.
    Due to the repeatability of the process, a vectorized operation can be optimized
    to be more efficient than its alternative implementation in, say, a `for` loop.
    However, the trade-off for this capability is that the elements in the array would
    need to be of the same data type—this is also a requirement for any NumPy array.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到NumPy中的矢量化操作之前，值得讨论矢量化的重要性及其在NumPy中的作用。正如我们之前提到的，矢量化通常是在数组中的元素上应用常见操作。由于该过程的可重复性，矢量化操作可以被优化为比其在`for`循环中的替代实现更有效。然而，这种能力的权衡是数组中的元素需要是相同的数据类型——这也是任何NumPy数组的要求。
- en: With that, let's move on to the following exercise, where we will see this effect
    in action.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们继续进行下一个练习，我们将在这个练习中看到这种效果。
- en: 'Exercise 2.01: Timing Vectorized Operations in NumPy'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：计时NumPy中的矢量化操作
- en: 'In this exercise, we will calculate the speedup achieved by implementing various
    vectorized operations such as addition, multiplication, and square root calculation
    with NumPy arrays compared to a pure Python alternative without vectorization.
    To do this, perform the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将计算通过使用NumPy数组实现各种矢量化操作（如加法，乘法和平方根计算）与不使用矢量化的纯Python替代方案相比所实现的加速。为此，请执行以下步骤：
- en: 'In the first cell of a new Jupyter notebook, import the NumPy package and the
    `Timer` class from the `timeit` library. The latter will be used to implement
    our timing functionality:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Jupyter笔记本的第一个单元格中，导入NumPy包和`timeit`库中的`Timer`类。后者将用于实现我们的计时功能：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In a new cell, initialize a Python list containing numbers ranging from 0 (inclusive)
    to 1,000,000 (exclusive) using the `range()` function, as well as its NumPy array
    counterpart using the `np.array()` function:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的单元格中，使用`range()`函数初始化一个包含从0（包括）到1,000,000（不包括）的数字的Python列表，以及使用`np.array()`函数的NumPy数组对应项：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will now apply mathematical operations to this list and array in the following
    steps. In a new cell, write a function named `for_add()` that returns a list whose
    elements are the elements in the `my_list` variable with `1` added to each (we
    will use list comprehension for this). Write another function named `vec_add()`
    that returns the NumPy array version of the same data, which is simply `my_array
    + 1`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在以下步骤中对这个列表和数组应用数学运算。在一个新的单元格中，编写一个名为`for_add()`的函数，它返回一个列表，其中的元素是`my_list`变量中的元素加上`1`（我们将使用列表推导式）。再编写一个名为`vec_add()`的函数，它返回相同数据的NumPy数组版本，即`my_array
    + 1`：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next code cell, initialize two `Timer` objects while passing in each
    of the preceding two functions. These objects contain the interface that we will
    use to keep track of the speed of the functions.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，初始化两个`Timer`对象，同时传入前面两个函数。这些对象包含我们将用于跟踪函数速度的接口。
- en: 'Call the `repeat()` function on each of the objects with the arguments 10 and
    10—in essence, we are repeating the timing experiment by 100 times. Finally, as
    the `repeat()` function returns a list of numbers representing how much time passed
    in each experiment for a given function we are recording, we print out the minimum
    of this list. In short, we want the time of the fastest run of each of the functions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个对象调用`repeat()`函数，并使用参数10和10——实质上，我们重复了100次的定时实验。最后，由于`repeat()`函数返回表示每个函数的每次实验中经过的时间的数字列表，我们打印出此列表的最小值。简而言之，我们希望每个函数的最快运行时间：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output that this program produced:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序产生的输出如下：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While yours might be different, the relationship between the two numbers should
    be clear: the speed of the `for` loop addition function should be many times lower
    than that of the vectorized addition function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你的可能不同，但两个数字之间的关系应该是清楚的：`for`循环加法函数的速度应该比向量化加法函数的速度低得多。
- en: 'In the next code cell, implement the same comparison of speed where we multiply
    the numbers by `2`. For the NumPy array, simply return `my_array * 2`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，实现相同的速度比较，我们将数字乘以`2`。对于NumPy数组，只需返回`my_array * 2`：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify from the output that the vectorized multiplication function is also
    faster than the `for` loop version. The output after running this code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中验证，向量化的乘法函数也比`for`循环版本更快。运行此代码后的输出如下：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the next code cell, implement the same comparison where we compute the square
    root of the numbers. For the Python list, import and use the `math.sqrt()` function
    on each element in the list comprehension. For the NumPy array, return the expression
    `np.sqrt(my_array)`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，实现相同的比较，计算数字的平方根。对于Python列表，导入并在列表推导式中使用`math.sqrt()`函数。对于NumPy数组，返回表达式`np.sqrt(my_array)`：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Verify from the output that the vectorized square root function is once again
    faster than its `for` loop counterpart:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中验证，向量化的平方根函数再次比其`for`循环对应函数更快：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Also, notice that the `np.sqrt()` function is implemented to be vectorized,
    which is why we were able to pass the whole array to the function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`np.sqrt()`函数被实现为向量化，这就是为什么我们能够将整个数组传递给该函数。
- en: This exercise introduced a few vectorized operations for NumPy arrays and demonstrated
    how much faster they are compared to their pure Python loop counterparts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习介绍了一些NumPy数组的向量化操作，并演示了它们与纯Python循环对应函数相比有多快。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38l3Nk7.](https://packt.live/38l3Nk7
    )
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/38l3Nk7.](https://packt.live/38l3Nk7 )
- en: You can also run this example online at [https://packt.live/2ZtBSdY.](https://packt.live/2ZtBSdY
    )
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2ZtBSdY.](https://packt.live/2ZtBSdY )上在线运行此示例。
- en: 'That concludes the topic of vectorization in NumPy. In the next and final section
    on NumPy, we''ll discuss another powerful feature that the package offers: random
    sampling.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了NumPy中的向量化主题。在下一个也是最后一个关于NumPy的部分中，我们将讨论该软件包提供的另一个强大功能：随机抽样。
- en: Random Sampling
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机抽样
- en: In the previous chapter, we saw an example of how to implement randomization
    in Python using the `random` library. However, the randomization in most of the
    methods implemented in that library is uniform, and in scientific computing and
    data science projects, sometimes, we need to draw samples from distributions other
    than the uniform one. This area is where NumPy once again offers a wide range
    of options.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用`random`库在Python中实现随机化的示例。然而，在该库中实现的大多数方法中，随机化是均匀的，在科学计算和数据科学项目中，有时我们需要从除均匀分布以外的分布中抽取样本。NumPy再次提供了广泛的选择。
- en: Generally speaking, random sampling from a probability distribution is the process
    of selecting an instance from that probability distribution, where elements having
    a higher probability are more likely to be selected (or drawn). This concept is
    closely tied to the concept of a random variable in statistics. A random variable
    is typically used to model some unknown quantity in a statistical analysis, and
    it usually follows a given distribution, depending on what type of data it models.
    For example, the ages of members of a population are typically modeled using the
    normal distribution (also known as the bell curve or the Gaussian distribution),
    while the arrivals of customers to, say, a bank are often modeled using the Poisson
    distribution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，从概率分布中进行随机抽样是从该概率分布中选择一个实例的过程，具有更高概率的元素更有可能被选择（或抽取）。这个概念与统计学中的随机变量的概念密切相关。随机变量通常用于模拟统计分析中的某些未知数量，它通常遵循给定的分布，具体取决于它所模拟的数据类型。例如，人口成员的年龄通常使用正态分布（也称为钟形曲线或高斯分布）来建模，而到达银行的客户通常使用泊松分布来建模。
- en: By randomly sampling a given distribution that is associated with a random variable,
    we can obtain an actual realization of the variable, from which we can perform
    various computations to obtain insights and inferences about the random variable
    in question.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过随机抽样给定与随机变量相关的分布，我们可以获得该变量的实际实现，从而可以执行各种计算，以获得有关所讨论的随机变量的见解和推断。
- en: 'We will revisit the concept and usage of probability distributions later in
    this book. For now, let''s simply focus on the task at hand: how to draw samples
    from these distributions. This is done using the `np.random` package, which includes
    the interface that allows us to draw from various distributions.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面重新访问概率分布的概念和用法。现在，让我们简单地专注于手头的任务：如何从这些分布中抽取样本。这是通过`np.random`包来实现的，该包包括了允许我们从各种分布中抽取的接口。
- en: 'For example, the following code snippet initializes a sample from the normal
    distribution (note that your output might be different from the following due
    to randomness):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段初始化了一个从正态分布中抽取的样本（请注意，由于随机性，您的输出可能与以下内容不同）：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You might be aware of the fact that the normal distribution is specified by
    two statistics: a mean and a standard deviation. These can be specified using
    the `loc` (whose default value is `0.0`) and `scale` (whose default value is `1.0`)
    arguments, respectively, in the `np.random.normal()` function, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到正态分布由两个统计数据来指定：均值和标准差。这些可以分别在`np.random.normal()`函数中使用`loc`（默认值为`0.0`）和`scale`（默认值为`1.0`）参数来指定，如下所示：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is also possible to draw multiple samples, as opposed to just a single sample,
    at once as a NumPy array. To do this, we specify the `size` argument of the `np.random.normal()`
    function with the desired shape of the output array. For example, here, we are
    creating a 2 x 3 matrix of samples drawn from the same normal distribution:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以一次性以NumPy数组的形式抽取多个样本，而不仅仅是单个样本。为此，我们可以在`np.random.normal()`函数的`size`参数中指定所需的输出数组形状。例如，在这里，我们正在创建一个从相同正态分布中抽取的2
    x 3矩阵样本：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This option allows us to take the output array and potentially apply other NumPy-specific
    operations to it (such as vectorization). The alternative is to sequentially draw
    individual samples into a list and convert it into a NumPy array afterward.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项允许我们取得输出数组，并可能对其应用其他NumPy特定的操作（如矢量化）。另一种方法是顺序地将单个样本抽取到列表中，然后将其转换为NumPy数组。
- en: 'It is important to note that each probability distribution has its own statistic(s)
    that define it. The normal distribution, as we have seen, has a mean and a standard
    deviation, while the aforementioned Poisson distribution is defined with a λ (lambda)
    parameter, which is interpreted as the expectation of interval. Let''s see this
    in an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，每个概率分布都有自己定义它的统计数据。正态分布，正如我们所见，有一个均值和一个标准差，而前面提到的泊松分布则是用λ（lambda）参数来定义的，它被解释为区间的期望。让我们通过一个例子来看一下：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Generally, before drawing a sample from a probability distribution in NumPy,
    you should always look up the corresponding documentation to see what arguments
    are available for that specific distribution and what their default values are.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在NumPy中从概率分布中抽取样本之前，您应该始终查阅相应的文档，以了解该特定分布可用的参数以及它们的默认值是什么。
- en: Aside from probability distribution, NumPy also offers other randomness-related
    functionalities that can be found in the `random` module. For example, the `np.random.randint()`
    function returns a random integer between two given numbers; `np.random.choice()`
    randomly draws a sample from a given one-dimensional array; `np.random.shuffle()`,
    on the other hand, randomly shuffles a given sequence in-place.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了概率分布，NumPy还提供了其他与随机性相关的功能，这些功能可以在`random`模块中找到。例如，`np.random.randint()`函数返回两个给定数字之间的随机整数；`np.random.choice()`从给定的一维数组中随机抽取样本；而`np.random.shuffle()`则在原地随机打乱给定的序列。
- en: 'These functionalities, which are demonstrated in the following code snippet,
    offer a significant degree of flexibility in terms of working with randomness
    in Python in general, and specifically in scientific computing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在以下代码片段中展示，提供了在Python中处理随机性方面的重要灵活性，特别是在科学计算中：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A final important topic that we need to discuss whenever there is randomness
    involved in programming is reproducibility. This term denotes the ability to obtain
    the same result from a program in a different run, especially when there are randomness-related
    elements in that program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每当编程中涉及随机性时，我们需要讨论的最后一个重要主题就是可重现性。这个术语表示在不同运行中从程序中获得相同的结果的能力，特别是当程序中存在与随机性相关的元素时。
- en: Reproducibility is essential when a bug exists in a program but only manifests
    itself in certain random cases. By forcing the program to generate the same random
    numbers every time it executes, we have another way to narrow down and identify
    this kind of bug aside from unit testing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中存在错误但只在某些随机情况下才显现时，可重现性是至关重要的。通过强制程序每次执行时生成相同的随机数，我们有另一种方法来缩小并识别这种类型的错误，除了单元测试之外。
- en: In data science and statistics, reproducibility is of the utmost importance.
    Without a program being reproducible, it is possible for one researcher to find
    a statistically significant result while another is unable to, even when the two
    have the same code and methods. This is why many practitioners have begun placing
    heavy emphasis on reproducibility in the fields of data science and machine learning.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学和统计学中，可重现性是至关重要的。如果一个程序不可重现，那么一个研究人员可能会发现一个统计上显著的结果，而另一个研究人员却无法做到，即使两者使用相同的代码和方法。这就是为什么许多从业者已经开始在数据科学和机器学习领域非常重视可重现性的原因。
- en: The most common method to implement reproducibility (which is also the easiest
    to program) is to simply fix the seed of the program (specifically its libraries)
    that utilizes randomness. Fixing the seed of a randomness-related library ensures
    that the same random numbers will be generated across different runs of the same
    program. In other words, this allows for the same result to be produced, even
    if a program is run multiple times on different machines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可重现性的最常见方法（也是最容易编程的方法）是简单地固定程序（特别是其库）的种子，这些程序利用随机性。固定与随机性相关的库的种子可以确保在同一程序的不同运行中生成相同的随机数。换句话说，这允许产生相同的结果，即使程序在不同的机器上运行多次。
- en: 'To do this, we can simply pass an integer to the appropriate seed function
    of the library/package that produces randomness for our programs. For example,
    to fix the seed for the `random` library, we can write the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以简单地将一个整数传递给产生我们程序随机性的库/包的适当种子函数。例如，要为`random`库设置种子，我们可以写如下代码：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For the random package in NumPy, we can write the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NumPy中的随机包，我们可以写如下代码：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Setting the seed for these libraries/packages is generally a good practice when
    you are contributing to a group or an open source project; again, it ensures that
    all members of the team are able to achieve the same result and eliminates miscommunication.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些库/包的种子通常是一个很好的做法，当你为一个团队或一个开源项目做贡献时；再次，它确保团队的所有成员能够达到相同的结果，并消除了误解。
- en: 'This topic also concludes our discussion of the NumPy library. Next, we will
    move on to another integral part of the data science and scientific computing
    ecosystem in Python: the pandas library.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题也结束了我们对NumPy库的讨论。接下来，我们将转向Python中数据科学和科学计算生态系统的另一个重要部分：pandas库。
- en: Working with Tabular Data in pandas
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在pandas中处理表格数据
- en: 'If NumPy is used on matrix data and linear algebraic operations, pandas is
    designed to work with data in the form of tables. Just like NumPy, pandas can
    be installed in your Python environment using the pip package manager:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NumPy用于矩阵数据和线性代数运算，pandas则设计用于处理表格形式的数据。就像NumPy一样，pandas可以使用pip包管理器在Python环境中安装：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you are using Anaconda, you can download it using the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Anaconda，你可以使用以下命令下载它：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the installation process completes, fire off a Python interpreter and
    try importing the library:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，启动Python解释器并尝试导入该库：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If this command runs without any error message, then you have successfully
    installed pandas. With that, let''s move on with our discussions, beginning with
    the most commonly used data structure in pandas, `DataFrame`, which can represent
    table data: two-dimensional data with row and column labels. This is to be contrasted
    with NumPy arrays, which can take on any dimension but do not support labeling.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个命令没有出现任何错误消息，那么你已经成功安装了pandas。有了这个，让我们继续我们的讨论，从pandas中最常用的数据结构开始，`DataFrame`，它可以表示表格数据：具有行和列标签的二维数据。这与NumPy数组形成对比，NumPy数组可以具有任何维度，但不支持标记。
- en: Initializing a DataFrame Object
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化DataFrame对象
- en: There are multiple ways to initialize a `DataFrame` object. First, we can manually
    create one by passing in a Python dictionary, where each key should be the name
    of a column, and the value for that key should be the data included for that column,
    in the form of a list or a NumPy array.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以初始化`DataFrame`对象。首先，我们可以通过传递一个Python字典来手动创建一个，其中每个键应该是列的名称，该键的值应该是该列包含的数据，以列表或NumPy数组的形式。
- en: 'For example, in the following code, we are creating a table with two rows and
    three columns. The first column contains the numbers 1 and 2 in order, the second
    contains 3 and 4, and the third 5 and 6:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码中，我们正在创建一个包含两行三列的表格。第一列按顺序包含数字1和2，第二列包含3和4，第三列包含5和6：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first thing to note about `DataFrame` objects is that, as you can see from
    the preceding code snippet, when one is printed out, the output is automatically
    formatted by the backend of pandas. The tabular format makes the data represented
    in that object more readable. Additionally, when a `DataFrame` object is printed
    out in a Jupyter notebook, similar formatting is utilized for the same purpose
    of readability, as illustrated in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`DataFrame`对象的第一件事是，正如你从前面的代码片段中看到的那样，当一个被打印出来时，输出会自动由pandas的后端格式化。表格格式使得该对象中表示的数据更易读。此外，当在Jupyter笔记本中打印出`DataFrame`对象时，也会使用类似的格式化以实现可读性，如下面的截图所示：
- en: '![Figure 2.1: Printed DataFrame objects in Jupyter Notebooks'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：在Jupyter笔记本中打印的DataFrame对象'
- en: '](image/B15968_02_01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_01.jpg)'
- en: 'Figure 2.1: Printed DataFrame objects in Jupyter Notebooks'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：在Jupyter笔记本中打印的DataFrame对象
- en: 'Another common way to initialize a `DataFrame` object is that when we already
    have its data represented by a 2D NumPy array, we can directly pass that array
    to the `DataFrame` class. For example, we can initialize the same DataFrame we
    looked at previously with the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`DataFrame`对象的另一种常见方法是，当我们已经用2D NumPy数组表示其数据时，我们可以直接将该数组传递给`DataFrame`类。例如，我们可以使用以下代码初始化我们之前看过的相同DataFrame：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That said, the most common way in which a `DataFrame` object is initialized
    is through the `pd.read_csv()` function, which, as the name suggests, reads in
    a CSV file (or any text file formatted in the same way but with a different separating
    special character) and renders it as a `DataFrame` object. We will see this function
    in action in the next section, where we will understand the working of more functionalities
    from the pandas library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，初始化`DataFrame`对象的最常见方式是通过`pd.read_csv()`函数，这个函数读取CSV文件（或任何以不同分隔特殊字符格式化的文本文件）并将其呈现为`DataFrame`对象。我们将在下一节中看到这个函数的运行，我们将了解pandas库中更多功能的工作方式。
- en: Accessing Rows and Columns
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问行和列
- en: Once we already have a table of data represented in a `DataFrame` object, there
    are numerous options we can use to interact with and manipulate this table. For
    example, the first thing we might care about is accessing the data of certain
    rows and columns. Luckily, pandas offers intuitive Python syntax for this task.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们已经有了用`DataFrame`对象表示的数据表，我们可以使用多种选项与该表进行交互和操作。例如，我们可能关心的第一件事是访问某些行和列的数据。幸运的是，pandas为这项任务提供了直观的Python语法。
- en: 'To access a group of rows or columns, we can take advantage of the `loc` method,
    which takes in the labels of the rows/columns we are interested in. Syntactically,
    this method is used with square brackets (to simulate the indexing syntax in Python).
    For example, using the same table from our previous section, we can pass in the
    name of a row (for example, `0`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一组行或列，我们可以利用`loc`方法，该方法接受我们感兴趣的行/列的标签。从语法上讲，这个方法与方括号一起使用（以模拟Python中的索引语法）。例如，使用我们上一节中相同的表，我们可以传入一行的名称（例如`0`）：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that the object returned previously contains the information we want
    (the first row, and the numbers 1, 3, and 5), but it is formatted in an unfamiliar
    way. This is because it is returned as a `Series` object. `Series` objects are
    a special case of `DataFrame` objects that only contain 1D data. We don't need
    to pay too much attention to this data structure as its interface is very similar
    to that of `DataFrame`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到先前返回的对象包含我们想要的信息（第一行和数字1、3和5），但它的格式是陌生的。这是因为它作为`Series`对象返回。`Series`对象是`DataFrame`对象的特例，只包含1D数据。我们不需要太关注这种数据结构，因为它的接口与`DataFrame`的接口非常相似。
- en: 'Still considering the `loc` method, we can pass in a list of row labels to
    access multiple rows. The following code returns both rows in our example table:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然考虑`loc`方法，我们可以传入一个行标签列表来访问多个行。以下代码返回我们示例表中的两行：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Say you want to access the data in our table column-wise. The `loc` method
    offers that option via the indexing syntax that we are familiar with in NumPy
    arrays (row indices separated by column indices by a comma). Accessing the data
    in the first row and the second and third columns:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想按列访问我们表中的数据。`loc`方法通过我们在NumPy数组中熟悉的索引语法（用逗号分隔的行索引和列索引）提供了这个选项。访问第一行和第二列和第三列中的数据：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that if you''d like to return a whole column in a `DataFrame` object,
    you can use the special character colon, `:`, in the row index to indicate that
    all the rows should be returned. For example, to access the `''col3''` column
    in our `DataFrame` object, we can say `df.loc[:, ''col3'']`. However, in this
    special case of accessing a whole column, there is another simple syntax: just
    using the square brackets without the `loc` method, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您想要返回`DataFrame`对象中的整列，可以在行索引中使用特殊字符冒号`:`，表示应返回所有行。例如，要访问我们的`DataFrame`对象中的`'col3'`列，我们可以说`df.loc[:,
    'col3']`。然而，在访问整列的特殊情况下，还有另一种简单的语法：只使用方括号而不使用`loc`方法，如下所示：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Earlier, we said that when accessing individual rows or columns in a `DataFrame`,
    `Series` objects are returned. These objects can be iterated using, for example,
    a `for` loop:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们说在访问`DataFrame`中的单个行或列时，将返回`Series`对象。这些对象可以使用，例如，`for`循环进行迭代：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In terms of changing values in a `DataFrame` object, we can use the preceding
    syntax to assign new values to rows and columns:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改`DataFrame`对象中的值方面，我们可以使用前面的语法为行和列分配新值：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Additionally, we can use the same syntax to declare new rows and columns:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用相同的语法声明新的行和列：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, even though it is more common to access rows and columns in a `DataFrame`
    object by specifying their actual indices in the `loc` method, it is also possible
    to achieve the same effect using an array of Boolean values (`True` and `False`)
    to indicate which items should be returned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使在`loc`方法中通常通过指定它们的实际索引来访问`DataFrame`对象中的行和列，也可以使用布尔值（`True`和`False`）数组来实现相同的效果。
- en: 'For example, we can access the items in the second row and the second and fourth
    columns in our current table by writing the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过编写以下内容访问我们当前表中的第二行和第二和第四列中的项目：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the Boolean index list for the rows `[False, True, False]` indicates that
    only the second element (that is, the second row) should be returned, while the
    Boolean index list for the columns, similarly, specifies that the second and fourth
    columns are to be returned.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，行的布尔索引列表`[False, True, False]`表示只返回第二个元素（即第二行），而列的布尔索引列表类似地指定要返回第二和第四列。
- en: 'While this method of accessing elements in a `DataFrame` object might seem
    strange, it is highly valuable for filtering and replacing tasks. Specifically,
    instead of passing in lists of Boolean values as indices, we can simply use a
    conditional inside the `loc` method. For example, to display our current table,
    just with the columns whose values in their first row are larger than `5` (which
    should be the third and fourth columns), we can write the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种访问`DataFrame`对象中元素的方法可能看起来很奇怪，但它对于过滤和替换任务非常有价值。具体来说，我们可以在`loc`方法中使用条件，而不是传入布尔值列表作为索引。例如，要显示我们当前的表，只显示第一行中值大于`5`的列（应该是第三和第四列），我们可以编写以下内容：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Again, this syntax is specifically useful in terms of filtering out the rows
    or columns in a `DataFrame` object that satisfy some condition and potentially
    assign new values to them. A special case of this functionality is find-and-replace
    tasks (which we will go through in the next section).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这种语法在过滤出满足某些条件的`DataFrame`对象中的行或列并可能为它们分配新值方面特别有用。这种功能的一个特殊情况是查找和替换任务（我们将在下一节中介绍）。
- en: Manipulating DataFrames
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作DataFrame
- en: 'In this section, we will try out a number of methods and functions for `DataFrame`
    objects that are used to manipulate the data within those objects. Of course,
    there are numerous other methods that are available (which you can find in the
    official documentation: [https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html)).
    However, the methods given in the following table are among the most commonly
    used and offer great power and flexibility in terms of helping us to create, maintain,
    and mutate our data tables:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试一些用于操作`DataFrame`对象的方法和函数，以便操作这些对象中的数据。当然，还有许多其他可用的方法（可以在官方文档中找到：[https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html)）。然而，下表中给出的方法是最常用的，可以在帮助我们创建、维护和改变数据表方面提供强大的功能和灵活性：
- en: '![Figure 2.2: Methods used to manipulate pandas data'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：用于操作pandas数据的方法'
- en: '](image/B15968_02_02.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_02.jpg)'
- en: 'Figure 2.2: Methods used to manipulate pandas data'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：用于操作pandas数据的方法
- en: The following exercise will demonstrate the effects of the preceding methods
    for better understanding.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的练习将演示前面方法的效果，以便更好地理解。
- en: 'Exercise 2.02: Data Table Manipulation'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：数据表操作
- en: In this hands-on exercise, we will go through the functions and methods included
    in the preceding section. Our goal is to see the effects of those methods, and
    to perform common data manipulation techniques such as renaming columns, filling
    in missing values, sorting values, or writing a data table to file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实践练习中，我们将学习前面部分包含的函数和方法。我们的目标是看到这些方法的效果，并执行常见的数据操作技术，比如重命名列、填充缺失值、排序数值，或者将数据表写入文件。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'From the GitHub repository of this workshop, copy the `Exercise2.02/dataset.csv`
    file within the `Chapter02` folder to a new directory. The content of the file
    is as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个研讨会的GitHub存储库中，将`Exercise2.02/dataset.csv`文件复制到`Chapter02`文件夹中的新目录中。文件的内容如下：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Inside that new directory, create a new Jupyter notebook. Make sure that this
    notebook and the CSV file are in the same location.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中创建一个新的Jupyter笔记本。确保这个笔记本和CSV文件在同一个位置。
- en: 'In the first cell of this notebook, import both pandas and NumPy, and then
    read in the `dataset.csv` file using the `pd.read_csv()` function. Specify the
    `index_col` argument of this function to be `''id''`, which is the name of the
    first column in our sample dataset:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个笔记本的第一个单元格中，导入pandas和NumPy，然后使用`pd.read_csv()`函数读取`dataset.csv`文件。指定这个函数的`index_col`参数为`'id'`，这是我们样本数据集中的第一列的名称：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we print this newly created `DataFrame` object out, we can see that its
    values correspond directly to our original input file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们打印这个新创建的`DataFrame`对象时，我们可以看到它的值直接对应于我们原始的输入文件：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice the `NaN` (**Not a Number**) values here; `NaN` is the default value
    that will be filled in empty cells of a `DataFrame` object upon initialization.
    Since our original dataset was purposefully designed to contain two empty cells,
    those cells were appropriately filled in with `NaN`, as we can see here.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的`NaN`（**不是一个数字**）值；`NaN`是`DataFrame`对象在初始化时将填充空单元格的默认值。由于我们的原始数据集被设计为包含两个空单元格，这些单元格被适当地填充为`NaN`，正如我们在这里所看到的。
- en: Additionally, `NaN` values are registered as floats in Python, which is why
    the data type of the two columns containing them are converted into floats accordingly
    (indicated by the decimal points in the values).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`NaN`值在Python中被注册为浮点数，这就是为什么包含它们的两列的数据类型相应地转换为浮点数（值中的小数点表示）。
- en: 'In the next cell, rename the current columns to `''col_x''`, `''col_y''`, and
    `''col_z''` with the `rename()` method. Here, the `columns` argument should be
    specified with a Python dictionary mapping each old column name to its new name:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，使用`rename()`方法将当前列重命名为`'col_x'`、`'col_y'`和`'col_z'`。在这里，`columns`参数应该使用Python字典指定每个旧列名到它的新名字的映射：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This change can be observed when `df` is printed out after the line of code
    is run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行代码行后，可以观察到`df`打印出的变化：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the next cell, use the `fillna()` function to replace the `NaN` values with
    zeros. After this, convert all the data in our table into integers using `astype(int)`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，使用`fillna()`函数将`NaN`值替换为零。之后，使用`astype(int)`将表格中的所有数据转换为整数：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The resulting `DataFrame` object now looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`DataFrame`对象现在如下所示：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the next cell, remove the second, fourth, and fifth rows from the dataset
    by passing the `[1, 3, 4]` list to the `drop` method:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，通过将`[1, 3, 4]`列表传递给`drop`方法，从数据集中删除第二、第四和第五行：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the `axis=0` argument specifies that the labels we are passing to
    the method specify rows, not columns, of the dataset. Similarly, to drop specific
    columns, you can use a list of column labels while specifying `axis=1`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`axis=0`参数指定我们传递给方法的标签指定数据集的行，而不是列。类似地，要删除特定列，可以使用列标签的列表，同时指定`axis=1`。
- en: 'The resulting table now looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表现如下：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the next cell, create an all-zero, 2 x 3 `DataFrame` object with the corresponding
    column labels as the current `df` variable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，创建一个全零的2 x 3 `DataFrame`对象，并使用相应的列标签作为当前`df`变量：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the next code cell, use the `pd.concat()` function to concatenate the two
    `DataFrame` objects together (specify `axis=0` so that the two tables are concatenated
    vertically, instead of horizontally):'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，使用`pd.concat()`函数将两个`DataFrame`对象连接在一起（指定`axis=0`，以便垂直连接两个表，而不是水平连接）：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our current `df` variable now prints out the following (notice the two newly
    concatenated rows at the bottom of the table):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`df`变量现在打印出以下内容（注意表格底部新增的两行）：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the next cell, sort our current table in increasing order by the data in
    the `col_x` column:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，按`col_x`列中的数据按升序对我们当前的表进行排序：
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The resulting dataset now looks like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据集现在如下所示：
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, in another code cell, convert our table into the integer data type
    (the same way as before) and use the `to_csv()` method to write this table to
    a file. Pass in `''output.csv''` as the name of the output file and specify `index=False`
    so that the row labels are not included in the output:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在另一个代码单元中，将我们的表转换为整数数据类型（与之前的方式相同），并使用`to_csv()`方法将此表写入文件。将`'output.csv'`作为输出文件的名称传递，并指定`index=False`，以便输出中不包括行标签：
- en: '[PRE59]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The written output should look as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 书面输出应如下所示：
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And that is the end of this exercise. Overall, this exercise simulated a simplified
    workflow of working with a tabular dataset: reading in the data, manipulating
    it in some way, and finally writing it to file.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本练习的结束。总的来说，这个练习模拟了使用表格数据集的简化工作流程：读取数据，以某种方式操纵数据，最后将数据写入文件。
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38ldQ8O.](https://packt.live/38ldQ8O
    )
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/38ldQ8O](https://packt.live/38ldQ8O)。
- en: You can also run this example online at [https://packt.live/3dTzkL6.](https://packt.live/3dTzkL6
    )
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3dTzkL6](https://packt.live/3dTzkL6)上在线运行此示例。
- en: In the next and final section on pandas, we will consider a number of more advanced
    functionalities offered by the library.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个也是最后一个关于pandas的部分中，我们将考虑库提供的一些更高级的功能。
- en: Advanced Pandas Functionalities
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级Pandas功能
- en: Accessing and changing the values in the rows and columns of a `DataFrame` object
    are among the simplest ways to work with tabular data using the pandas library.
    In this section, we will go through three other options that are more complicated
    but also offer powerful options for us to manipulate our `DataFrame` objects.
    The first is the `apply()` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和更改`DataFrame`对象的行和列中的值是使用pandas库处理表格数据的最简单的方法之一。在本节中，我们将介绍另外三种更复杂但也提供了强大选项来操作我们的`DataFrame`对象的选项。第一个是`apply()`方法。
- en: If you are already familiar with the concept of this method for other data structures,
    the same goes for this method, which is implemented for `DataFrame` objects. In
    a general sense, this method is used to apply a function to all elements within
    a `DataFrame` object. Similar to the concept of vectorization that we discussed
    earlier, the resulting `DataFrame` object, after the `apply()` method, will have
    its elements as the result of the specified function when each element of the
    original data is fed to it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉了其他数据结构的这种方法的概念，那么对于为`DataFrame`对象实现的这种方法也是一样的。从一般意义上讲，此方法用于将函数应用于`DataFrame`对象中的所有元素。与我们之前讨论的矢量化概念类似，`apply()`方法之后的结果`DataFrame`对象的元素将是原始数据的每个元素被馈送到指定函数时的结果。
- en: 'For example, say we have the following `DataFrame` object:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下`DataFrame`对象：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, say we''d like to create another column whose entries are the entries
    in the `x_squared` column. We can then use the `apply()` method, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想创建另一列，其条目是`x_squared`列中的条目。然后，我们可以使用`apply()`方法，如下所示：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The term `lambda x: x ** 2` here is simply a quick way to declare a function
    without a name. From the printed output, we see that the `''x_squared''` column
    was created correctly. Additionally, note that with simple functions such as the
    square function, we can actually take advantage of the simple syntax of NumPy
    arrays that we are already familiar with. For example, the following code will
    have the same effect as the one we just considered:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的术语`lambda x: x ** 2`只是一种快速声明无名称函数的方法。从打印输出中，我们看到`''x_squared''`列已正确创建。另外，请注意，对于诸如平方函数之类的简单函数，我们实际上可以利用我们已经熟悉的NumPy数组的简单语法。例如，以下代码将产生与我们刚才考虑的代码相同的效果：'
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: However, with a function that is more complex and cannot be vectorized easily,
    it is better to fully write it out and then pass it to the `apply()` method. For
    example, let's say we'd like to create a column, each cell of which should contain
    the string `'even'` if the element in the `x` column in the same row is even,
    and the string `'odd'` otherwise.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更复杂且不容易矢量化的函数，最好是完全编写它，然后将其传递给`apply()`方法。例如，假设我们想创建一个列，如果同一行中`x`列中的元素是偶数，则每个单元格应包含字符串`'even'`，否则包含字符串`'odd'`。
- en: 'Here, we can create a separate function called `parity_str()` that takes in
    a number and returns the corresponding string. This function can then be used
    with the `apply()` method on `df[''x'']`, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以创建一个名为`parity_str()`的单独函数，该函数接受一个数字并返回相应的字符串。然后，可以将此函数与`df['x']`上的`apply()`方法一起使用，如下所示：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Another commonly used functionality in pandas that is slightly more advanced
    is the `pd.get_dummies()` function. This function implements the technique called
    one-hot encoding, which is to be used on a categorical attribute (or column) in
    a dataset.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas中另一个常用的略微高级的功能是`pd.get_dummies()`函数。该函数实现了一种称为独热编码的技术，用于数据集中的分类属性（或列）。
- en: We will discuss the concept of categorical attributes, along with other types
    of data, in more detail in the next chapter. For now, we simply need to keep in
    mind that plain categorical data sometimes cannot be interpreted by statistical
    and machine learning models. Instead, we would like to have a way to translate
    the categorical characteristic of the data into a numerical form while ensuring
    that no information is lost.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地讨论分类属性的概念，以及其他类型的数据。现在，我们只需要记住，有时统计和机器学习模型无法解释纯分类数据。相反，我们希望有一种方法将数据的分类特征转换为数字形式，同时确保不丢失任何信息。
- en: One-hot encoding is one such method; it works by generating a new column/attribute
    for each unique value and populating the cells in the new column with Boolean
    data, indicating the values from the original categorical attribute.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 独热编码就是这样一种方法；它通过为每个唯一值生成一个新的列/属性，并用布尔数据填充新列中的单元格，指示原始分类属性的值。
- en: 'This method is easier to understand via examples, so let''s consider the new
    `''x_parity''` column we created in the preceding example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过示例更容易理解，所以让我们考虑前面例子中创建的新的`'x_parity'`列：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This column is considered a categorical attribute since its values belong to
    a specific set of categories (in this case, the categories are `odd` and `even`).
    Now, by calling `pd.get_dummies()` on the column, we obtain the following `DataFrame`
    object:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这一列被认为是一个分类属性，因为它的值属于一组特定的类别（在这种情况下，类别是`odd`和`even`）。现在，通过在该列上调用`pd.get_dummies()`，我们得到以下的`DataFrame`对象：
- en: '[PRE66]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we can observe from the printed output, the `DataFrame` object includes two
    columns that correspond to the unique values in the original categorical data
    (the `'x_parity'` column). For each row, the column that corresponds to the value
    in the original data is set to `1` and the other column(s) is/are set to `0`.
    For example, the first row originally contained `odd` in the `'x_parity'` column,
    so its new `odd` column is set to `1`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从打印输出中所观察到的，`DataFrame`对象包括两列，对应于原始分类数据中的唯一值（`'x_parity'`列）。对于每一行，对应于原始数据中的值的列被设置为`1`，而其他列被设置为`0`。例如，第一行原始包含`odd`在`'x_parity'`列中，所以它的新`odd`列被设置为`1`。
- en: We can see that with one-hot encoding, we can convert any categorical attribute
    into a new set of binary attributes, making the data readably numerical for statistical
    and machine learning models. However, a big drawback of this method is the increase
    in dimensionality, as it creates a number of new columns that are equal to the
    number of unique values in the original categorical attribute. As such, this method
    can cause our table to greatly increase in size if the categorical data contains
    many different values. Depending on your computing power and resources, the recommended
    limit for the number of unique categorical values for the method is 50.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用独热编码，我们可以将任何分类属性转换为一组新的二进制属性，使数据对于统计和机器学习模型来说是可读的数字。然而，这种方法的一个很大的缺点是维度的增加，因为它创建了与原始分类属性中的唯一值数量相等的新列。因此，如果分类数据包含许多不同的值，这种方法可能会导致我们的表格大大增加。根据您的计算能力和资源，该方法的推荐唯一分类值的数量限制为50。
- en: The `value_counts()` method is another valuable tool in pandas that you should
    have in your toolkit. This method, to be called on a column of a `DataFrame` object,
    returns a list of unique values in that column and their respective counts. This
    method is thus only applicable to categorical or discrete data, whose values belong
    to a given, predetermined set of possible values.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`value_counts()`方法是pandas中另一个有价值的工具，你应该掌握。这个方法，要调用在`DataFrame`对象的一列上，返回该列中的唯一值及其相应的计数的列表。因此，这个方法只适用于分类或离散数据，其值属于给定的、预先确定的可能值集合。'
- en: 'For example, still considering the `''x_parity''` attribute of our sample dataset,
    we''ll inspect the effect of the `value_counts()` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，仍然考虑我们样本数据集的`'x_parity'`属性，我们将检查`value_counts()`方法的效果：
- en: '[PRE67]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can see that in the `'x_parity'` column, we indeed have two entries (or rows)
    whose values are `odd` and one entry for `even`. Overall, this method is quite
    useful in determining the distribution of values in, again, categorical and discrete
    data types.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在`'x_parity'`列中，我们确实有两个条目（或行）的值为`odd`，一个条目为`even`。总的来说，这种方法在确定值的分布方面非常有用，再次，特别是对于分类和离散数据类型。
- en: The next and last advanced functionality of pandas that we will discuss is the
    `groupby` operation. This operation allows us to separate a `DataFrame` object
    into subgroups, where the rows in a group all share a value in a categorical attribute.
    From these separate groups, we can then compute descriptive statistics (a concept
    we will delve into in the next chapter) to explore our dataset further.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的下一个也是最后一个pandas的高级功能是`groupby`操作。这个操作允许我们将`DataFrame`对象分成子组，其中组中的行都共享一个分类属性中的值。从这些单独的组中，我们可以计算描述性统计（这是我们将在下一章中深入探讨的概念），以进一步探索我们的数据集。
- en: We will see this in action in our next exercise, where we'll explore a sample
    student dataset.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中看到这一点，我们将探索一个样本学生数据集。
- en: 'Exercise 2.03: The Student Dataset'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：学生数据集
- en: By considering a sample of what can be a real-life dataset, we will put our
    knowledge of pandas' most common functions to use, including what we have been
    discussing, as well as the new `groupby` operation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过考虑一个真实数据集的样本，我们将运用我们对pandas最常见函数的知识，包括我们一直在讨论的内容，以及新的`groupby`操作。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个练习：
- en: 'Create a new Jupyter notebook and, in its first cell, run the following code
    to generate our sample dataset:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Jupyter笔记本，在它的第一个单元格中运行以下代码以生成我们的样本数据集：
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This code will produce the following output, which displays our sample dataset
    in tabular form:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将产生以下输出，以表格形式显示我们的样本数据集：
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Most of the attributes in our dataset are self-explanatory: in each row (which
    represents a student), `name` contains the name of the student, `gender` indicates
    whether the student is male or female, `class` is a categorical attribute that
    can take four unique values (`FY` for first-year, `SO` for sophomore, `JR` for
    junior, and `SR` for senior), `gpa` denotes the cumulative score of the student,
    and finally, `num_classes` holds the information of how many classes the student
    is currently taking.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据集中的大多数属性都是不言自明的：在每一行（代表一个学生）中，`name`包含学生的姓名，`gender`表示学生是男性还是女性，`class`是一个可以取四个唯一值的分类属性（`FY`代表大一，`SO`代表大二，`JR`代表大三，`SR`代表大四），`gpa`表示学生的累积分数，最后，`num_classes`保存学生目前正在上多少门课的信息。
- en: In a new code cell, create a new attribute named `'female_flag'` whose individual
    cells should hold the Boolean value `True` if the corresponding student is female,
    and `False` otherwise.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的代码单元格中，创建一个名为`'female_flag'`的新属性，其各个单元格应该包含布尔值`True`，如果对应的学生是女性，则为`True`，否则为`False`。
- en: 'Here, we can see that we can take advantage of the `apply()` method while passing
    in a lambda object, like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们可以利用`apply()`方法，同时传入一个lambda对象，如下所示：
- en: '[PRE70]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'However, we can also simply declare the new attribute using the `student_df[''gender'']
    == ''female''` expression, which evaluates the conditionals sequentially in order:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以简单地使用`student_df['gender'] == 'female'`表达式声明新属性，该表达式按顺序评估条件：
- en: '[PRE71]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This newly created attribute contains all the information included in the old
    `gender` column, so we will remove the latter from our dataset using the `drop()`
    method (note that we need to specify the `axis=1` argument since we are dropping
    a column):'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个新创建的属性包含了旧的`gender`列中包含的所有信息，因此我们将使用`drop()`方法从数据集中删除后者（请注意，我们需要指定`axis=1`参数，因为我们正在删除一列）：
- en: '[PRE72]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Our current `DataFrame` object should look as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`DataFrame`对象应该如下所示：
- en: '[PRE73]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In a new code cell, write an expression to apply one-hot encoding to the categorical
    attribute, `class`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的代码单元格中，编写一个表达式，对分类属性`class`应用独热编码：
- en: '[PRE74]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the same code cell, take this expression and include it in a `pd.concat()`
    function to concatenate this newly created `DataFrame` object to our old one,
    while simultaneously dropping the `class` column (as we now have an alternative
    for the information in this attribute):'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个代码单元格中，将这个表达式包含在`pd.concat()`函数中，将这个新创建的`DataFrame`对象与我们的旧对象连接起来，同时删除`class`列（因为我们现在有了这个属性信息的替代）：
- en: '[PRE75]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The current dataset should now look as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当前数据集现在应该如下所示：
- en: '[PRE76]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the next cell, call the `groupby()` method on `student_df` with the `female_flag`
    argument and assign the returned value to a variable named `gender_group`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，对`student_df`调用`groupby()`方法，并使用`female_flag`参数将返回的值赋给一个名为`gender_group`的变量：
- en: '[PRE77]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you might have guessed, here, we are grouping the students of the same gender
    into groups, so male students will be grouped together, and female students will
    also be grouped together but separate from the first group.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这里我们将相同性别的学生分组，因此男性学生将被分在一起，女性学生也将被分在一起，但与第一组分开。
- en: 'It is important to note that when we attempt to print out this `GroupBy` object
    stored in the `gender_group` variable, we only obtain a generic, memory-based
    string representation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当我们尝试打印存储在`gender_group`变量中的这个`GroupBy`对象时，我们只会得到一个通用的基于内存的字符串表示：
- en: '[PRE78]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we''d like to compute the average GPA of each group in the preceding grouping.
    To do that, we can use the following simple syntax:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想计算前面分组中每个组的平均GPA。为此，我们可以使用以下简单的语法：
- en: '[PRE79]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output will be as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE80]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Our command on the `gender_group` variable is quite intuitive: we''d like to
    compute the average of a specific attribute, so we access that attribute using
    square brackets, `['' gpa '']`, and then call the `mean()` method on it.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`gender_group`变量的命令非常直观：我们想要计算特定属性的平均值，因此我们使用方括号`['gpa']`访问该属性，然后对其调用`mean()`方法。
- en: 'Similarly, we can compute the total number of classes taking male students,
    as well as that number for the female students, with the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用以下代码计算男性学生和女性学生的总课程数：
- en: '[PRE81]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE82]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Throughout this exercise, we have reminded ourselves of some of the important
    methods available in pandas, and seen the effects of the `groupby` operation in
    action via a sample real-life dataset. This exercise also concludes our discussion
    on the pandas library, the premier tool for working with tabular data in Python.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个练习中，我们提醒自己一些pandas中重要的方法，并通过一个真实数据集的示例看到了`groupby`操作的效果。这个练习也结束了我们关于pandas库的讨论，这是Python中处理表格数据的首选工具。
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NOe5jt.](https://packt.live/2NOe5jt
    )
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2NOe5jt](https://packt.live/2NOe5jt)。
- en: You can also run this example online at [https://packt.live/3io2gP2.](https://packt.live/3io2gP2
    )
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3io2gP2](https://packt.live/3io2gP2)上在线运行此示例。
- en: 'In the final section of this chapter, we will talk about the final piece of
    a typical data science/scientific computing pipeline: data visualization.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将讨论典型数据科学/科学计算流水线的最后一部分：数据可视化。
- en: Data Visualization with Matplotlib and Seaborn
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Matplotlib和Seaborn进行数据可视化
- en: Data visualization is undoubtedly an integral part of any data pipeline. Good
    visualizations can not only help scientists and researchers find unique insights
    about their data, but also help convey complex, advanced ideas in an intuitive,
    easy to understand way. In Python, the backend of most of the data visualization
    tools is connected to the Matplotlib library, which offers an incredibly wide
    range of options and functionalities, as we will see in this upcoming discussion.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化无疑是任何数据流水线的重要组成部分。良好的可视化不仅可以帮助科学家和研究人员发现有关其数据的独特见解，还可以以直观、易于理解的方式传达复杂、高级的想法。在Python中，大多数数据可视化工具的后端都连接到Matplotlib库，该库提供了非常广泛的选项和功能，我们将在接下来的讨论中看到。
- en: 'First, to install Matplotlib, simply run either of the following commands,
    depending on which one is your Python package manager:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要安装Matplotlib，只需运行以下命令之一，取决于您的Python包管理器是哪一个：
- en: '[PRE83]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The convention in Python is to import the `pyplot` package from the Matplotlib
    library, like so:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的惯例是从Matplotlib库中导入`pyplot`包，如下所示：
- en: '[PRE84]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This `pyplot` package, whose alias is now `plt`, is the main workhorse for any
    visualization functionality in Python and will therefore be used extensively.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pyplot`包，现在的别名是`plt`，是Python中任何可视化功能的主要工具，因此将被广泛使用。
- en: Overall, instead of learning about the theoretical background of the library,
    in this section, we will take a more hands-on approach and go through a number
    of different visualization options that Matplotlib offers. In the end, we will
    obtain practical takeaways that will be beneficial for your own projects in the
    future.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '总的来说，与其学习库的理论背景，本节我们将采取更加实践的方法，并介绍Matplotlib提供的许多不同的可视化选项。最终，我们将获得实用的经验，这将有益于您将来的项目。 '
- en: Scatter Plots
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散点图
- en: 'One of the most fundamental visualization methods is a scatter plot – plotting
    a list of points on a plane (or other higher-dimensional spaces). This is simply
    done by means of the `plt.scatter()` function. As an example, say we have a list
    of five points, whose x- and y-coordinates are stored in the following two lists,
    respectively:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图是最基本的可视化方法之一-在平面（或其他高维空间）上绘制一系列点的列表。这只需通过`plt.scatter()`函数完成。例如，假设我们有一个包含五个点的列表，其x和y坐标分别存储在以下两个列表中：
- en: '[PRE85]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we can use the `plt.scatter()` function to create a scatter plot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`plt.scatter()`函数创建散点图：
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The preceding code will generate the following plot, which corresponds exactly
    to the data in the two lists that we fed into the `plt.scatter()` function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下图表，该图表与我们输入`plt.scatter()`函数的两个列表中的数据完全对应：
- en: '![Figure 2.3: Scatter plot using Matplotlib'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：使用Matplotlib的散点图'
- en: '](image/B15968_02_03.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_03.jpg)'
- en: 'Figure 2.3: Scatter plot using Matplotlib'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：使用Matplotlib的散点图
- en: Note the `plt.show()` command at the end of the code snippet. This function
    is responsible for displaying the plot that is customized by the preceding code,
    and it should be placed at the very end of a block of visualization-related code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意代码片段末尾的`plt.show()`命令。该函数负责显示由上述代码定制的图表，并且应放置在与可视化相关的代码块的末尾。
- en: 'As for the `plt.scatter()` function, there are arguments that we can specify
    to customize our plots further. For example, we can customize the size of the
    individual points, as well as their respective colors:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`plt.scatter()`函数，我们可以指定参数进一步定制我们的图表。例如，我们可以定制各个点的大小，以及它们各自的颜色：
- en: '[PRE87]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The preceding code produces the following output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '![Figure 2.4: Scatter plots with size and color customization'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：带有大小和颜色自定义的散点图'
- en: '](image/B15968_02_04.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_04.jpg)'
- en: 'Figure 2.4: Scatter plots with size and color customization'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：带有大小和颜色自定义的散点图
- en: This functionality is useful when the points you'd like to visualize in a scatter
    plot belong to different groups of data, in which case you can assign a color
    to each group. In many cases, clusters formed by different groups of data are
    discovered using this method.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望在散点图中可视化的点属于不同的数据组时，此功能非常有用，这种情况下，您可以为每个组分配一个颜色。在许多情况下，使用此方法发现了不同数据组形成的聚类。
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To see a complete documentation of Matplotlib colors and their usage, you can
    consult the following web page: [https://matplotlib.org/2.0.2/api/colors_api.html.](https://matplotlib.org/2.0.2/api/colors_api.html
    )'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Matplotlib颜色及其用法的完整文档，请参阅以下网页：[https://matplotlib.org/2.0.2/api/colors_api.html.](https://matplotlib.org/2.0.2/api/colors_api.html
    )
- en: Overall, scatter plots are used when we'd like to visualize the spatial distribution
    of the data that we are interested in. A potential goal of using a scatter plot
    is to reveal any clustering existing within our data, which can offer us further
    insights regarding the relationship between the attributes of our dataset.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，散点图用于可视化我们感兴趣的数据的空间分布。使用散点图的一个潜在目标是揭示数据中存在的任何聚类，这可以为我们提供关于数据集属性之间关系的进一步见解。
- en: Next, let's consider line graphs.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑折线图。
- en: Line Graphs
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折线图
- en: 'Line graphs are another of the most fundamental visualization methods, where
    points are plotted along a curve, as opposed to individually scattered. This is
    done via the simple `plt.plot()` function. As an example, we are plotting out
    the sine wave (from 0 to 10) in the following code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 折线图是另一种最基本的可视化方法，其中点沿着曲线绘制，而不是分散绘制。这是通过简单的`plt.plot()`函数完成的。例如，我们在以下代码中绘制正弦波（从0到10）：
- en: '[PRE88]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that here, the `np.linspace()` function returns an array of evenly spaced
    numbers between two endpoints. In our case, we obtain 1,000 evenly spaced numbers
    between 0 and 10\. The goal here is to take the sine function on these numbers
    and plot them out. Since the points are extremely close to one another, it will
    create the effect that a true smooth function is being plotted.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的`np.linspace()`函数返回两个端点之间均匀间隔的数字数组。在我们的例子中，我们获得了0到10之间的1,000个均匀间隔的数字。这里的目标是对这些数字进行正弦函数并将其绘制出来。由于点非常接近彼此，它将产生真正平滑函数被绘制的效果。
- en: 'This will result in the following graph:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下图表：
- en: '![Figure 2.5: Line graphs using Matplotlib'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：使用Matplotlib的折线图'
- en: '](image/B15968_02_05.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_05.jpg)'
- en: 'Figure 2.5: Line graphs using Matplotlib'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：使用Matplotlib的折线图
- en: 'Similar to the options for scatter plots, here, we can customize various elements
    for our line graphs, specifically the colors and styles of the lines. The following
    code, which is plotting three separate curves (the *y = x* graph, the natural
    logarithm function, and the sine wave), provides an example of this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与散点图的选项类似，这里我们可以定制线图的各种元素，特别是线条的颜色和样式。以下代码绘制了三条单独的曲线（*y = x*图，自然对数函数和正弦波），提供了一个示例：
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The following output is produced by the preceding code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '![Figure 2.6: Line graphs with style customization'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：带有样式自定义的折线图'
- en: '](image/B15968_02_06.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_06.jpg)'
- en: 'Figure 2.6: Line graphs with style customization'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：带有样式自定义的折线图
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete list of line styles can be found in Matplotlib''s official documentation,
    specifically at the following page: [https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html.](https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html
    )'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Matplotlib的官方文档中找到完整的线型列表，具体在以下页面：[https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html.](https://matplotlib.org/3.1.0/gallery/lines_bars_and_markers/linestyles.html
    )
- en: Generally, line graphs are used to visualize the trend of a specific function,
    which is represented by a list of points sequenced in order. As such, this method
    is highly applicable to data with some sequential elements, such as a time series
    dataset.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线图用于可视化特定函数的趋势，该函数由按顺序排列的点列表表示。因此，这种方法非常适用于具有一些顺序元素的数据，例如时间序列数据集。
- en: Next, we will consider the available options for bar graphs in Matplotlib.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑Matplotlib中条形图的可用选项。
- en: Bar Graphs
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条形图
- en: 'Bar graphs are typically used to represent the counts of unique values in a
    dataset via the height of individual bars. In terms of implementation in Matplotlib,
    this is done using the `plt.bar()` function, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 条形图通常用于通过各个条的高度表示数据集中唯一值的计数。在Matplotlib中，这是使用`plt.bar()`函数来实现的，如下所示：
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The first argument that the `plt.bar()` function takes in (the `labels` variable,
    in this case) specifies what the labels for the individual bars will be, while
    the second argument (`counts`, in this case) specifies the height of the bars.
    With this code, the following graph is produced:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.bar()`函数接受的第一个参数（在本例中为`labels`变量）指定了各个条的标签，而第二个参数（在本例中为`counts`）指定了条的高度。使用这段代码，将生成以下图形：'
- en: '![Figure 2.7: Bar graphs using Matplotlib'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：使用Matplotlib的条形图
- en: '](image/B15968_02_07.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_07.jpg)'
- en: 'Figure 2.7: Bar graphs using Matplotlib'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：使用Matplotlib的条形图
- en: As always, you can specify the colors of individual bars using the `c` argument.
    What is more interesting to us is the ability to create more complex bar graphs
    with stacked or grouped bars. Instead of simply comparing the counts of different
    data, stacked or grouped bars are used to visualize the composition of each bar
    in smaller subgroups.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，您可以使用`c`参数指定各个条的颜色。对我们来说更有趣的是能够使用堆叠或分组条来创建更复杂的条形图。与其简单地比较不同数据的计数，堆叠或分组条用于可视化每个条在较小子组中的组成。
- en: 'For example, let''s say within each group of `Type 1`, `Type 2`, and `Type
    3`, as in the previous example, we have two subgroups, `Type A` and `Type B`,
    as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在`Type 1`、`Type 2`和`Type 3`的每个组中，如前面的例子中，我们有两个子组，`Type A`和`Type B`，如下所示：
- en: '[PRE91]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In essence, the total counts for `Type 1`, `Type 2`, and `Type 3` are still
    the same, but now each can be further broken up into two subgroups, represented
    by the 2D list `counts`. In general, the types here can be anything; our goal
    is to simply visualize this composition of the subgroups within each large type
    using a stacked or grouped bar graph.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，`Type 1`、`Type 2`和`Type 3`的总计仍然相同，但现在每个都可以进一步分为两个子组，由2D列表`counts`表示。一般来说，这里的类型可以是任何东西；我们的目标只是简单地使用堆叠或分组条形图来可视化每个大类型中子组的组成。
- en: 'First, we aim to create a grouped bar graph; our goal is the following visualization:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的目标是创建分组条形图；我们的目标是以下可视化效果：
- en: '![Figure 2.8: Grouped bar graphs'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：分组条形图
- en: '](image/B15968_02_08.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_08.jpg)'
- en: 'Figure 2.8: Grouped bar graphs'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：分组条形图
- en: 'This is a more advanced visualization, and the process of creating the graph
    is thus more involved. First, we need to specify the individual locations of the
    grouped bars and their width:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更高级的可视化，因此创建图形的过程更加复杂。首先，我们需要指定分组条的各个位置及其宽度：
- en: '[PRE92]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then, we call the `plt.bar()` function on the appropriate data: once on the
    `Type A` numbers (`[my_type[0] for my_type in counts]`, using list comprehension)
    and once on the `Type B` numbers (`[my_type[1] for my_type in counts]`):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在适当的数据上调用`plt.bar()`函数：一次在`Type A`数字上（`[my_type[0] for my_type in counts]`，使用列表推导），一次在`Type
    B`数字上（`[my_type[1] for my_type in counts]`）：
- en: '[PRE93]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The terms `locations - width / 2` and `locations + width / 2` specify the exact
    locations of the `Type A` bars and the `Type B` bars, respectively. It is important
    that we reuse this `width` variable in the `width` argument of the `plt.bar()`
    function so that the two bars of each group are right next to each other.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`locations - width / 2`和`locations + width / 2`指定了`Type A`条和`Type B`条的确切位置。重要的是，我们在`plt.bar()`函数的`width`参数中重用这个`width`变量，以便每组的两个条紧挨在一起。
- en: 'Next, we''d like to customize the labels for each group of bars. Additionally,
    note that we are also assigning the returned values of the calls to `plt.bar()`
    to two variables, `bars_a` and `bars_b`, which will then be used to generate the
    legend for our graph:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要自定义每组条的标签。另外，请注意，我们还将`plt.bar()`的返回值分配给两个变量`bars_a`和`bars_b`，然后将用于生成图例：
- en: '[PRE94]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Finally, as we call `plt.show()`, the desired graph will be displayed.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们调用`plt.show()`时，所需的图形将被显示。
- en: So, that is the process of creating a grouped bar graph, where individual bars
    belonging to a group are placed next to one another. On the other hand, a stacked
    bar graph places the bars on top of each other. These two types of graphs are
    mostly used to convey the same information, but with stacked bars, the total counts
    of each group are easier to visually inspect and compare.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是创建分组条形图的过程，其中属于一组的单个条放在一起。另一方面，堆叠条形图将条形放在彼此之上。这两种类型的图表大多用于传达相同的信息，但使用堆叠条形图，每个组的总计更容易进行视觉检查和比较。
- en: 'To create a stacked bar graph, we take advantage of the `bottom` argument of
    the `plt.bar()` function while declaring the non-first groups. Specifically, we
    do the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建堆叠条形图，我们利用`plt.bar()`函数在声明非第一组时使用`bottom`参数。具体来说，我们这样做：
- en: '[PRE95]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The preceding code will create the following visualization:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建以下可视化效果：
- en: '![Figure 2.9: Stacked bar graphs'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：堆叠条形图
- en: '](image/B15968_02_09.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_09.jpg)'
- en: 'Figure 2.9: Stacked bar graphs'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：堆叠条形图
- en: And that concludes our introduction to bar graphs in Matplotlib. Generally,
    these types of graph are used to visualize the counts or percentages of different
    groups of values in a categorical attribute. As we have observed, Matplotlib offers
    extendable APIs that can help generate these graphs in a flexible way.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们在Matplotlib中对条形图的介绍。通常，这些类型的图表用于可视化分类属性中不同值组的计数或百分比。正如我们所观察到的，Matplotlib提供了可扩展的API，可以以灵活的方式生成这些图表。
- en: 'Now, let''s move on to our next visualization technique: histograms.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们下一个可视化技术：直方图。
- en: Histograms
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直方图
- en: A histogram is a visualization that places multiple bars together, but its connection
    to bar graphs ends there. Histograms are usually used to represent the distribution
    of values within an attribute (a numerical attribute, to be more precise). Taking
    in an array of numbers, a histogram should consist of multiple bars, each spanning
    across a specific range to denote the amount of numbers belonging to that range.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是一种将多个条放在一起的可视化，但它与条形图的联系就到此为止了。直方图通常用于表示属性内的值的分布（更准确地说是数值属性）。接受一个数字数组，直方图应包含多个条，每个条跨越特定范围，表示属于该范围的数字的数量。
- en: 'Say we have an attribute in our dataset that contains the sample data stored
    in `x`. We can call `plt.hist()` on `x` to plot the distribution of the values
    in the attribute like so:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据集中有一个包含存储在`x`中的样本数据的属性。我们可以在`x`上调用`plt.hist()`来绘制属性值的分布，如下所示：
- en: '[PRE96]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The preceding code produces a visualization similar to the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生了类似以下的可视化：
- en: '![Figure 2.10: Histogram using Matplotlib'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10：使用Matplotlib的直方图'
- en: '](image/B15968_02_10.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_10.jpg)'
- en: 'Figure 2.10: Histogram using Matplotlib'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：使用Matplotlib的直方图
- en: Note
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Your output might somewhat differ from what we have here, but the general shape
    of the histogram should be the same—a bell curve.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出可能与我们这里有些不同，但直方图的一般形状应该是一样的——钟形曲线。
- en: It is possible to specify the `bins` argument in the `plt.hist()` function (whose
    default value is 10) to customize the number of bars that should be generated.
    Roughly speaking, increasing the number of bins decreases the width of the range
    each bin spans across, thereby improving the granularity of the histogram.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`plt.hist()`函数中指定`bins`参数（默认值为10）来自定义应生成的条形的数量。粗略地说，增加箱子的数量会减少每个箱子跨越的范围的宽度，从而提高直方图的粒度。
- en: 'However, it is also possible to use too many bins in a histogram and achieve
    a bad visualization. For example, using the same variable, `x`, we can do the
    following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，直方图中也可能使用太多的箱子而导致糟糕的可视化效果。例如，使用相同的变量`x`，我们可以这样做：
- en: '[PRE97]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The preceding code will produce the following graph:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下图表：
- en: '![Figure 2.11: Using too many bins in a histogram'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11：直方图中使用太多的箱子'
- en: '](image/B15968_02_11.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_11.jpg)'
- en: 'Figure 2.11: Using too many bins in a histogram'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：直方图中使用太多的箱子
- en: This visualization is arguably worse than the previous example as it causes
    our histogram to become fragmented and non-continuous. The easiest way to address
    this problem is to increase the ratio between the size of the input data and the
    number of bins, either by having more input data or using fewer bins.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化可能比前面的例子更糟糕，因为它导致我们的直方图变得分散和不连续。解决这个问题的最简单方法是增加输入数据和箱子数量之间的比率，要么增加输入数据，要么使用更少的箱子。
- en: 'Histograms are also quite useful in terms of helping us to compare the distributions
    of more than one attribute. For example, by adjusting the `alpha` argument (which
    specifies the opaqueness of a histogram), we can overlay multiple histograms in
    one graph so that their differences are highlighted. This is demonstrated by the
    following code and visualization:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图在帮助我们比较多个属性的分布方面也非常有用。例如，通过调整`alpha`参数（指定直方图的不透明度），我们可以在一个图表中叠加多个直方图，以突出它们的差异。以下代码和可视化演示了这一点：
- en: '[PRE98]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output will be as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 2.12: Overlaid histograms'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12：叠加直方图'
- en: '](image/B15968_02_12.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_12.jpg)'
- en: 'Figure 2.12: Overlaid histograms'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：叠加直方图
- en: Here, we can see that while the two distributions have roughly similar shapes,
    one is to the right of the other, indicating that its values are generally greater
    than the values of the attribute on the left.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，虽然两个分布的形状大致相似，但一个在另一个的右侧，表明它的值通常大于左侧属性的值。
- en: 'One useful fact for us to note here is that when we simply call the `plt.hist()`
    function, a tuple containing two arrays of numbers is returned, denoting the locations
    and heights of individual bars in the corresponding histogram, as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的一个有用的事实是，当我们简单地调用`plt.hist()`函数时，会返回一个包含两个数字数组的元组，表示相应直方图中各个条的位置和高度，如下所示：
- en: '[PRE99]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The two arrays include all the histogram-related information about the input
    data, processed by Matplotlib. This data can then be used to plot out the histogram,
    but in some cases, we can even store the arrays in new variables and use these
    statistics to perform further analysis on our data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数组包括了由Matplotlib处理的输入数据的所有直方图相关信息。然后可以使用这些数据来绘制直方图，但在某些情况下，甚至可以将数组存储在新变量中，并使用这些统计数据对数据进行进一步分析。
- en: 'In the next section, we will move on to the final type of visualization we
    will be discussing in this chapter: heatmaps.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续讨论本章中将要讨论的最后一种可视化类型：热力图。
- en: Heatmaps
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热力图
- en: 'A heatmap is generated with a 2D array of numbers, where numbers with high
    values correspond to hot colors, and low-valued numbers correspond to cold colors.
    With Matplotlib, a heatmap is created with the `plt.imshow()` function. Let''s
    say we have the following code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 热力图是使用二维数组生成的，其中具有高值的数字对应于热色，低值的数字对应于冷色。使用Matplotlib，可以使用`plt.imshow()`函数创建热力图。假设我们有以下代码：
- en: '[PRE100]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The preceding code will produce the following visualization:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下可视化：
- en: '![Figure 2.13: Heatmap using Matplotlib'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：使用Matplotlib的热图'
- en: '](image/B15968_02_13.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_13.jpg)'
- en: 'Figure 2.13: Heatmap using Matplotlib'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：使用Matplotlib的热图
- en: Notice that with this representation, any group structure in the input 2D array
    (for example, if there is a block of cells whose values are significantly greater
    than the rest) will be effectively visualized.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过这种表示，输入的2D数组中的任何分组结构（例如，如果有一组单元格的值明显大于其余部分）将被有效地可视化。
- en: An important use of heatmaps is when we consider the correlation matrix of a
    dataset (which is a 2D array containing a correlation between any given pair of
    attributes within the dataset). A heatmap will be able to help us pinpoint any
    and all attributes that are highly correlated to one another.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 热图的一个重要用途是当我们考虑数据集的相关矩阵时（这是一个包含数据集内任意属性对之间相关性的2D数组）。热图将能够帮助我们找出任何高度相关的属性。
- en: This concludes our final topic of discussion in this section regarding the visualization
    library, Matplotlib. The next exercise will help us consolidate the knowledge
    that we have gained by means of a hands-on example.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们在本节中关于可视化库Matplotlib的最后一个讨论主题。下一个练习将通过一个实际示例帮助我们巩固所学到的知识。
- en: 'Exercise 2.04: Visualization of Probability Distributions'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：概率分布的可视化
- en: As we briefly mentioned when we talked about sampling, probability distributions
    are mathematical objects widely used in statistics and machine learning to model
    real-life data. While a number of probability distributions can prove abstract
    and complicated to work with, being able to effectively visualize their characteristics
    is the first step to understanding their usage.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论抽样时，我们简要提到概率分布是统计学和机器学习中广泛使用的数学对象，用于对现实生活数据进行建模。虽然许多概率分布可能抽象且复杂，但能够有效地可视化它们的特征是理解它们的用途的第一步。
- en: In this exercise, we will apply some visualization techniques (histogram and
    line plot) to compare the sampling functions from NumPy against their true probability
    distributions. For a given probability distribution, the **probability density
    function** (also known as the **PDF**) defines the probability of any real number
    according to that distribution. The goal here is to verify that with a large enough
    sample size, NumPy's sampling function gives us the true shape of the corresponding
    PDF for a given probability distribution.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将应用一些可视化技术（直方图和折线图）来比较NumPy中的抽样函数与它们真实的概率分布。对于给定的概率分布，**概率密度函数**（也称为**PDF**）定义了根据该分布的任何实数的概率。这里的目标是验证，通过足够大的样本量，NumPy的抽样函数是否给出了给定概率分布的真实PDF的真实形状。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'From your Terminal, that is, in your Python environment (if you are using one),
    install the SciPy package. You can install it, as always, using pip:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端，也就是您的Python环境中（如果您正在使用），安装SciPy包。您可以像往常一样使用pip进行安装：
- en: '[PRE101]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To install SciPy using Anaconda, use the following command:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Anaconda安装SciPy，请使用以下命令：
- en: '[PRE102]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: SciPy is another popular statistical computing tool in Python. It contains a
    simple API for PDFs of various probability distributions that we will be using.
    We will revisit this library in the next chapter.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy是Python中另一个流行的统计计算工具。它包含了各种概率分布的简单API，我们将在这里使用。我们将在下一章中重新讨论这个库。
- en: 'In the first code cell of a Jupyter notebook, import NumPy, the `stats` package
    of SciPy, and Matplotlib, as follows:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本的第一个代码单元中，导入NumPy、SciPy的`stats`包和Matplotlib，如下所示：
- en: '[PRE103]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the next cell, draw 1,000 samples from the normal distribution with a mean
    of `0` and a standard deviation of `1` using NumPy:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个单元格中，使用NumPy从均值为`0`，标准差为`1`的正态分布中抽取1,000个样本：
- en: '[PRE104]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we will create a `np.linspace` array between the minimum and the maximum
    of the samples that we have drawn, and finally call the true PDF on the numbers
    in the array. We''re doing this so that we can plot these points in a graph in
    the next step:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们绘制的样本的最小值和最大值之间创建一个`np.linspace`数组，并最终在数组中的数字上调用真实的PDF。我们这样做是为了在下一步中将这些点绘制在图表中：
- en: '[PRE105]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Create a histogram for the drawn samples and a line graph for the points obtained
    via the PDF. In the `plt.hist()` function, specify the `density=True` argument
    so that the heights of the bars are normalized to probabilistic values (numbers
    between 0 and 1), the `alpha=0.2` argument to make the histogram lighter in color,
    and the `bins=20` argument for a greater granularity for the histogram:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为绘制的样本创建一个直方图，并为通过PDF获得的点创建一个折线图。在`plt.hist()`函数中，指定`density=True`参数，以便将条的高度归一化为概率值（0到1之间的数字），`alpha=0.2`参数使直方图颜色较浅，`bins=20`参数使直方图的粒度更大：
- en: '[PRE106]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The preceding code will create (roughly) the following visualization:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建（大致）以下可视化：
- en: '![Figure 2.14: Histogram versus PDF for the normal distribution'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14：正态分布的直方图与PDF'
- en: '](image/B15968_02_14.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_14.jpg)'
- en: 'Figure 2.14: Histogram versus PDF for the normal distribution'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：正态分布的直方图与PDF
- en: We can see that the histogram for the samples we have drawn fits quite nicely
    with the true PDF of the normal distribution. This is evidence that the sampling
    function from NumPy and the PDF function from SciPy are working consistently with
    each other.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们绘制的样本的直方图与正态分布的真实PDF非常匹配。这证明了NumPy的抽样函数和SciPy的PDF函数之间的一致性。
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To get an even smoother histogram, you can try increasing the number of bins
    in the histogram.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得更平滑的直方图，可以尝试增加直方图中的条数。
- en: Next, we will create the same visualization for the Beta distribution with parameters
    (2, 5). For now, we don't need to know too much about the probability distribution
    itself; again, here, we only want to test out the sampling function from NumPy
    and the corresponding PDF from SciPy.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为参数为(2, 5)的Beta分布创建相同的可视化。目前，我们不需要太多了解概率分布本身；同样，在这里，我们只想测试一下NumPy的抽样函数和SciPy的相应概率密度函数。
- en: 'In the next code cell, follow the same procedure that we followed previously:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码单元格中，按照之前的步骤进行操作：
- en: '[PRE107]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This will, in turn, generate the following graph:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Figure 2.15: Histogram versus PDF for the Beta distribution'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：Beta分布的直方图与概率密度函数'
- en: '](image/B15968_02_15.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_15.jpg)'
- en: 'Figure 2.15: Histogram versus PDF for the Beta distribution'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：Beta分布的直方图与概率密度函数
- en: 'Create the same visualization for the Gamma distribution with parameter α =
    1:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数α = 1为Gamma分布创建相同的可视化：
- en: '[PRE108]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following visualization is then plotted:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 然后绘制以下可视化：
- en: '![Figure 2.16: Histogram versus PDF for the Gamma distribution'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.16：Gamma分布的直方图与概率密度函数'
- en: '](image/B15968_02_16.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_16.jpg)'
- en: 'Figure 2.16: Histogram versus PDF for the Gamma distribution'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：Gamma分布的直方图与概率密度函数
- en: Throughout this exercise, we have learned to combine a histogram and a line
    graph to verify a number of probability distributions implemented by NumPy and
    SciPy. We were also briefly introduced to the concept of probability distributions
    and their probability density functions.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们学习了如何结合直方图和折线图来验证NumPy和SciPy实现的多个概率分布。我们还简要介绍了概率分布及其概率密度函数的概念。
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: To access the source code for this specific section, please refer to [https://packt.live/3eZrEbW.](https://packt.live/3eZrEbW
    )
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本特定部分的源代码，请参阅[https://packt.live/3eZrEbW](https://packt.live/3eZrEbW)。
- en: You can also run this example online at [https://packt.live/3gmjLx8.](https://packt.live/3gmjLx8
    )
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3gmjLx8](https://packt.live/3gmjLx8)上在线运行此示例。
- en: This exercise serves as the conclusion for the topic of Matplotlib. In the next
    section, we will end our discussion in this chapter by going through a number
    of shorthand APIs, provided by Seaborn and pandas, to quickly create complex visualizations.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习作为Matplotlib主题的结论。在下一节中，我们将通过Seaborn和pandas提供的一些简写API来快速创建复杂的可视化，结束本章的讨论。
- en: Visualization Shorthand from Seaborn and Pandas
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Seaborn和Pandas的可视化简写
- en: First, let's discuss the Seaborn library, the second most popular visualization
    library in Python after Matplotlib. Though still powered by Matplotlib, Seaborn
    offers simple, expressive functions that can facilitate complex visualization
    methods.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论Seaborn库，它是继Matplotlib之后Python中第二受欢迎的可视化库。尽管仍由Matplotlib支持，Seaborn提供了简单、表达力强的函数，可以促进复杂的可视化方法。
- en: 'After successfully installing Seaborn via pip or Anaconda, the convention programmers
    typically use to import the library is with the `sns` alias. Now, say we have
    a tabular dataset with two numerical attributes, and we''d like to visualize their
    respective distributions:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 成功通过pip或Anaconda安装Seaborn后，程序员通常使用`sns`别名导入库的约定。现在，假设我们有一个具有两个数值属性的表格数据集，并且我们想要可视化它们各自的分布：
- en: '[PRE109]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Normally, we can create two histograms, one for each attribute that we have.
    However, we''d also like to inspect the relationship between the two attributes
    themselves, in which case we can take advantage of the `jointplot()` function
    in Seaborn. Let''s see this in action:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以创建两个直方图，一个用于每个属性。然而，我们也想检查两个属性之间的关系，在这种情况下，我们可以利用Seaborn中的`jointplot()`函数。让我们看看它的作用：
- en: '[PRE110]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see, we can pass in a whole `DataFrame` object to a Seaborn function
    and specify the elements to be plotted in the function arguments. This process
    is arguably less painstaking than passing in the actual attributes we'd like to
    visualize using Matplotlib.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以将整个`DataFrame`对象传递给Seaborn函数，并在函数参数中指定要绘制的元素。这个过程可能比使用Matplotlib传递实际属性更简单。
- en: 'The following visualization will be generated by the preceding code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下可视化：
- en: '![Figure 2.17: Joint plots using Seaborn'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.17：使用Seaborn的联合图'
- en: '](image/B15968_02_17.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_17.jpg)'
- en: 'Figure 2.17: Joint plots using Seaborn'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：使用Seaborn的联合图
- en: This visualization consists of a scatter plot for the two attributes and their
    respective histograms attached to the appropriate axes. From here, we can observe
    the distribution of individual attributes that we put in from the two histograms,
    as well as their *joint* distribution from the scatter plot.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可视化包括两个属性的散点图和它们各自的直方图附加到适当的坐标轴上。从这里，我们可以观察到我们放入两个直方图的各个属性的分布，以及从散点图中观察它们的*联合*分布。
- en: Again, because this is a fairly complex visualization that can offer significant
    insights into the input data, it can be quite difficult to create manually in
    Matplotlib. What Seaborn succeeds in doing is building a pipeline for these complex
    but valuable visualization techniques and creating simple APIs to generate them.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，因为这是一个相当复杂的可视化，可以为输入数据提供重要见解，手动在Matplotlib中创建可能会相当困难。Seaborn成功的地方在于为这些复杂但有价值的可视化技术构建了一个流水线，并创建了简单的API来生成它们。
- en: 'Let''s consider another example. Say we have a larger version of the same student
    dataset that we considered in *Exercise 2.03*, *The Student Dataset*, which looks
    as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子。假设我们有一个与*练习2.03*中考虑的相同学生数据集的较大版本，*学生数据集*，其外观如下：
- en: '[PRE111]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now, we'd like to consider the average GPA of the students we have in the dataset,
    grouped by class. Additionally, within each class, we are also interested in the
    difference between female and male students. This description calls for a grouped/stacked
    bar plot, where each group corresponds to a class and is broken into female and
    male averages.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想考虑数据集中学生的平均GPA，按班级分组。此外，在每个班级内，我们还对女生和男生之间的差异感兴趣。这需要一个分组/堆叠条形图，其中每个组对应一个班级，并分为女生和男生的平均值。
- en: 'With Seaborn, this is again done with a one-liner:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Seaborn，这可以通过一行代码完成：
- en: '[PRE112]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This generates the following plot (notice how the legend is automatically included
    in the plot):'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表（注意图例如何自动包含在图表中）：
- en: '![Figure 2.18: Grouped bar graph using Seaborn'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.18：使用Seaborn的分组条形图'
- en: '](image/B15968_02_18.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_18.jpg)'
- en: 'Figure 2.18: Grouped bar graph using Seaborn'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：使用Seaborn的分组条形图
- en: 'In addition to Seaborn, the pandas library itself also offers unique APIs that
    directly interact with Matplotlib. This is generally done via the `DataFrame.plot`
    API. For example, still using our `student_df` variable we used previously, we
    can quickly generate a histogram for the data in the `gpa` attribute as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Seaborn，pandas库本身也提供了直接与Matplotlib交互的独特API。这通常是通过`DataFrame.plot`API完成的。例如，仍然使用我们之前使用的`student_df`变量，我们可以快速生成`gpa`属性数据的直方图，如下所示：
- en: '[PRE113]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The following graph is then created:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建以下图表：
- en: '![Figure 2.19: Histogram using pandas'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.19：使用pandas的直方图'
- en: '](image/B15968_02_19.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_19.jpg)'
- en: 'Figure 2.19: Histogram using pandas'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：使用pandas的直方图
- en: 'Say we are interested in the percentage breakdown of the classes (that is,
    how much of a portion each class is with respect to all students). We can generate
    a pie chart from the class count (obtained via the `value_counts()` method):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对班级的百分比分布感兴趣（即，每个班级在所有学生中所占的比例）。我们可以从班级计数（通过`value_counts()`方法获得）生成一个饼图：
- en: '[PRE114]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This results in the following output:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 2.20: Pie chart from pandas'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.20：来自pandas的饼图'
- en: '](image/B15968_02_20.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_20.jpg)'
- en: 'Figure 2.20: Pie chart from pandas'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：来自pandas的饼图
- en: Through these examples, we have an idea of how Seaborn and Matplotlib streamline
    the process of creating complex visualizations, especially for `DataFrame` objects,
    using simple function calls. This clearly demonstrates the functional integration
    between various statistical and scientific tools in Python, making it one of the
    most, if not the most, popular modern scientific computing languages.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们可以了解到Seaborn和Matplotlib如何简化创建复杂可视化的过程，特别是对于`DataFrame`对象，只需使用简单的函数调用。这清楚地展示了Python中各种统计和科学工具之间的功能集成，使其成为最受欢迎的现代科学计算语言之一，如果不是最受欢迎的话。
- en: That concludes the material to be covered in the second chapter of this book.
    Now, let's go through a hands-on activity with a real-life dataset.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本书第二章要涵盖的内容。现在，让我们通过一个真实数据集进行实际操作。
- en: 'Activity 2.01: Analyzing the Communities and Crime Dataset'
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：分析Communities and Crime数据集
- en: In this activity, we will practice some basic data processing and analysis techniques
    on a dataset available online called *Communities and Crime*, with the hope of
    consolidating our knowledge and techniques. Specifically, we will process missing
    values in the dataset, iterate through the attributes, and visualize the distribution
    of their values.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将练习一些基本的数据处理和分析技术，使用一个名为*Communities and Crime*的在线数据集，希望巩固我们的知识和技术。具体来说，我们将处理数据集中的缺失值，遍历属性，并可视化它们的值的分布。
- en: 'First, we need to download this dataset to our local environment, which can
    be accessed on this page: [https://packt.live/31C5yrZ](https://packt.live/31C5yrZ
    )'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将这个数据集下载到我们的本地环境中，可以在此页面上访问：[https://packt.live/31C5yrZ](https://packt.live/31C5yrZ)
- en: 'The dataset should have the name `CommViolPredUnnormalizedData.txt`. From the
    same directory as this dataset text file, create a new Jupyter notebook. Now,
    perform the following steps:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集的名称应该是`CommViolPredUnnormalizedData.txt`。从与此数据集文本文件相同的目录中，创建一个新的Jupyter笔记本。现在，执行以下步骤：
- en: 'As a first step, import the libraries that we will be using: pandas, NumPy,
    and Matplotlib.'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入我们将使用的库：pandas、NumPy和Matplotlib。
- en: Read in the dataset from the text file using pandas and print out the first
    five rows by calling the `head()` method on the `DataFrame` object.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas从文本文件中读取数据集，并通过在`DataFrame`对象上调用`head()`方法打印出前五行。
- en: Loop through all the columns in the dataset and print them out line by line.
    At the end of the loop, also print out the total number of columns.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历数据集中的所有列，并逐行打印它们。在循环结束时，还要打印出总列数。
- en: Notice that missing values are indicated as `'?'` in different cells of the
    dataset. Call the `replace()` method on the `DataFrame` object to replace that
    character with `np.nan` to faithfully represent missing values in Python.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，数据集的不完整值在不同单元格中表示为`'?'`。在`DataFrame`对象上调用`replace()`方法，将该字符替换为`np.nan`，以忠实地表示Python中的缺失值。
- en: Print out the list of columns in the dataset and their respective numbers of
    missing values using `df.isnull().sum()`, where `df` is the variable name of the
    `DataFrame` object.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`df.isnull().sum()`打印出数据集中列的列表及其各自的缺失值数量，其中`df`是`DataFrame`对象的变量名。
- en: Using the `df.isnull().sum()[column_name]` syntax (where `column_name` is the
    name of the column we are interested in), print out the number of missing values
    in the `NumStreet` and `PolicPerPop` columns.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`df.isnull().sum()[column_name]`语法（其中`column_name`是我们感兴趣的列的名称），打印出`NumStreet`和`PolicPerPop`列中缺失值的数量。
- en: Compute a `DataFrame` object that contains a list of values in the `state` attribute
    and their respective counts. Then, use the `DataFrame.plot.bar()` method to visualize
    that information in a bar graph.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个包含`state`属性值列表及其各自计数的`DataFrame`对象。然后，使用`DataFrame.plot.bar()`方法将该信息可视化为条形图。
- en: Observe that, with the default scale of the plot, the labels on the x-axis are
    overlapping. Address this problem by making the plot bigger with the `f, ax =
    plt.subplots(figsize=(15, 10))` command. This should be placed at the beginning
    of any plotting commands.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，图表的比例尺上的标签重叠。通过使用`f, ax = plt.subplots(figsize=(15, 10))`命令使图表变大来解决这个问题。这应该放在任何绘图命令的开头。
- en: Using the same value count `DataFrame` object that we used previously, call
    the `DataFrame.plot.pie()` method to create a corresponding pie chart. Adjust
    the figure size to ensure that the labels for your graph are displayed correctly.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与之前使用的相同值计数`DataFrame`对象，调用`DataFrame.plot.pie()`方法来创建相应的饼图。调整图形大小以确保图表的标签正确显示。
- en: 'Create a histogram representing the distribution of the population sizes in
    areas in the dataset (included in the `population` attribute). Adjust the figure
    size to ensure that the labels for your graph are displayed correctly.![Figure
    2.21: Histogram for population distribution'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个直方图，代表数据集中地区人口规模的分布（包含在`population`属性中）。调整图形大小以确保图表的标签正确显示。![图2.21：人口分布的直方图
- en: '](image/B15968_02_21.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_21.jpg)'
- en: 'Figure 2.21: Histogram for population distribution'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：人口分布的直方图
- en: 'Create an equivalent histogram to visualize the distribution of household sizes
    in the dataset (included in the `householdsize` attribute).![Figure 2.22: Histogram
    for household size distribution'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个等效的直方图来可视化数据集中家庭规模的分布（包含在`householdsize`属性中）。![图2.22：家庭规模分布的直方图
- en: '](image/B15968_02_22.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_22.jpg)'
- en: 'Figure 2.22: Histogram for household size distribution'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：家庭规模分布的直方图
- en: Note
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 653.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第653页找到。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter went through the core tools for data science and statistical computing
    in Python, namely, NumPy for linear algebra and computation, pandas for tabular
    data processing, and Matplotlib and Seaborn for visualization. These tools will
    be used extensively in later chapters of this book, and they will prove useful
    in your future projects. In the next chapter, we will go into the specifics of
    a number of statistical concepts that we will be using throughout this book and
    learn how to implement them in Python.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Python中用于数据科学和统计计算的核心工具，即NumPy用于线性代数和计算，pandas用于表格数据处理，Matplotlib和Seaborn用于可视化。这些工具将在本书的后续章节中广泛使用，并且它们将在您未来的项目中证明有用。在下一章中，我们将深入了解本书中将要使用的一些统计概念的具体内容，并学习如何在Python中实现它们。
- en: XBC94
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: XBC94
- en: ABB35
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ABB35
