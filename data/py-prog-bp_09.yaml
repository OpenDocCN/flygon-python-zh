- en: Notification Serverless Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知无服务器应用程序
- en: In this chapter, we are going to explore AWS Lambda Functions and AWS API Gateway.
    AWS Lambda enables us to create serverless functions. *Serverless* doesn't mean
    that it is without a server; in reality, it means that these functions don't require
    the DevOps overhead that you would have if you were running the application on,
    for example, an EC2 instance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索AWS Lambda函数和AWS API Gateway。AWS Lambda使我们能够创建无服务器函数。*无服务器*并不意味着没有服务器；实际上，它意味着这些函数不需要DevOps开销，如果您在运行应用程序，例如在EC2实例上，就会有。
- en: Serverless architecture is not the silver bullet or the solution to all the
    problems, but there are many advantages, such as pricing, the fact that almost
    no DevOps is required, and support for different programming languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构并非银弹或解决所有问题的方案，但有许多优势，例如定价、几乎不需要DevOps以及对不同编程语言的支持。
- en: In the case of Python, tools like Zappa and the microframework for AWS Chalice,
    which is also developed by Amazon, make creating and deploying serverless functions
    incredibly easy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的情况下，像Zappa和由亚马逊开发的AWS Chalice微框架等工具使创建和部署无服务器函数变得非常容易。
- en: 'In this chapter you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Create a service using Flask framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask框架创建服务
- en: Install and configure the AWS CLI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置AWS CLI
- en: Use the CLI to create S3 buckets and upload files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI创建S3存储桶并上传文件
- en: Install and configure Zappa
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Zappa
- en: Deploy an application using Zappa
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Zappa部署应用程序
- en: So without further ado, let's dive right into it!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，话不多说，让我们马上开始吧！
- en: Setting up the environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'Let''s start by creating the folder in which we will place the application
    files. First, create a directory called `notifier` and go into that directory
    so we can create the virtual environment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个文件夹，我们将在其中放置应用程序文件。首先，创建一个名为`notifier`的目录，并进入该目录，以便我们可以创建虚拟环境：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We create the virtual environment using `pipenv`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pipenv`创建虚拟环境：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember that if Python 3 is in our `path`, you can simply call:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果Python 3在我们的`path`中，您可以简单地调用：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To build this service we are going to use the micro web framework Flask, so
    let''s install that:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为构建此服务，我们将使用微型Web框架Flask，因此让我们安装它：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are also going to install the requests package, which will be used when
    sending requests to the order service:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将安装requests包，该包在发送请求到订单服务时将被使用：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That should be everything we need for now. Next, we are going to see how we
    can use AWS Simple Email Service to send emails from our applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该是我们目前所需的一切。接下来，我们将看到如何使用AWS简单邮件服务从我们的应用程序发送电子邮件。
- en: Setting up the Amazon Web Services CLI
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Amazon Web Services CLI
- en: We also need to install the AWS command-line interface, which will save us a
    lot of time when deploying serverless functions and also when creating S3 buckets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装AWS命令行界面，这将在部署无服务器函数和创建S3存储桶时节省大量时间。
- en: The installation is quite simple, as it can be installed via `pip`, and the
    AWS CLI has support for Python 2 and Python 3 and runs on different operating
    systems, such as Linux, macOS, and Windows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常简单，可以通过`pip`安装，AWS CLI支持Python 2和Python 3，并在不同的操作系统上运行，例如Linux、macOS和Windows。
- en: 'Open a terminal and type the command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The upgrade option will tell pip to update all the requirements that are already
    installed, and the `--user` option means that pip will install the AWS CLI in
    our local directory, so it won't touch any library that is installed globally
    on our system. On Linux systems, when installing a Python package using the `--user` option,
    the package will be installed in the directory `.local/bin`, so make sure that
    you have that in your `path`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 升级选项将告诉pip更新所有已安装的要求，`--user`选项意味着pip将在我们的本地目录中安装AWS CLI，因此它不会触及系统全局安装的任何库。在Linux系统上，使用`--user`选项安装Python包时，该包将安装在`.local/bin`目录中，因此请确保您的`path`中包含该目录。
- en: 'Just to verify that the installation worked properly, type the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 只需验证安装是否正常工作，输入以下命令：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see an output similar to this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于此的输出：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here you can see the AWS CLI version, as well as the operating system version,
    Python version, and which version of `botocore` is currently in use. `botocore`
    is the core library used by the AWS CLI. Also, boto is an SDK for Python, which
    allows developers to write software to work with Amazon services like EC2 and
    S3.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到AWS CLI版本，以及操作系统版本、Python版本以及当前使用的`botocore`版本。`botocore`是AWS CLI使用的核心库。此外，boto是Python的SDK，允许开发人员编写与Amazon服务（如EC2和S3）一起工作的软件。
- en: Now we need to configure the CLI, and we will need to have some information
    at hand. First, we need the `aws_access_key_id` and the `aws_secret_access_key`,
    as well as your preferred region and output. The most common value, the output
    option, is JSON.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要配置CLI，并且需要准备一些信息。首先，我们需要`aws_access_key_id`和`aws_secret_access_key`，以及您首选的区域和输出。最常见的值，输出选项，是JSON。
- en: 'To create the access keys, click on the drop-down menu with your username on
    the top right hand of the AWS console page, and select My Security Credentials.
    You will land on this page:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建访问密钥，点击AWS控制台页面右上角的用户名下拉菜单，并选择“我的安全凭证”。您将进入此页面：
- en: '![](assets/7ed0edf2-f265-4321-9cd2-a78f41501ae2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ed0edf2-f265-4321-9cd2-a78f41501ae2.png)'
- en: Here you can configure different account security settings, such as changing
    the password or enabling multi-factor authentication, but the one you should choose
    now is Access keys (access key ID and secret access key). Then click on Create
    New Access Key, and a dialog will be opened with your keys. You will also be given
    the option to download the keys. I suggest you download them and keep them in
    a safe place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以配置不同的帐户安全设置，例如更改密码或启用多因素身份验证，但您现在应该选择的是访问密钥（访问密钥ID和秘密访问密钥）。然后点击“创建新的访问密钥”，将打开一个对话框显示您的密钥。您还将有下载密钥的选项。我建议您下载并将其保存在安全的地方。
- en: Go here [https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)
    to see the AWS regions and endpoints.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里[https://docs.aws.amazon.com/general/latest/gr/rande.html](https://docs.aws.amazon.com/general/latest/gr/rande.html)查看AWS区域和端点。
- en: 'Now we can `configure` the CLI. In the command line, type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以`配置`CLI。在命令行中输入：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will be asked to provide the access key, the secret access key, the region,
    and the default output format.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求提供访问密钥、秘密访问密钥、区域和默认输出格式。
- en: Configuring a Simple Email Service
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置简单电子邮件服务
- en: Amazon already has a service called Simple Email Service that we can use in
    order to send email through our application. We will be running the service in
    sandbox mode, which means that we will also be able to send emails to verified
    email addresses. This can be changed if you plan to use the service in production,
    but for the purposes of this book, it will suffice to just have it running in
    sandbox mode.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊已经有一个名为简单电子邮件服务的服务，我们可以使用它来通过我们的应用程序发送电子邮件。我们将在沙箱模式下运行该服务，这意味着我们还可以向经过验证的电子邮件地址发送电子邮件。如果您计划在生产中使用该服务，可以更改此设置，但是对于本书的目的，只需在沙箱模式下运行即可。
- en: If you plan to have this application running in production and wish to move
    out of the Amazon SES sandbox, you can easily open a support case for increasing
    the email limit. To send the request, you can go to the SES home page, and on
    the left-hand menu, under the section *Email Sending*, you will find the link
    `Dedicated IPs`. There, you will find more information and also a link where you
    can apply to increase your email limit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在生产环境中运行此应用程序，并希望退出亚马逊SES沙箱，您可以轻松地提交支持案例以增加电子邮件限制。要发送请求，您可以转到SES主页，在左侧菜单下的“电子邮件发送”部分，您将找到“专用IP”链接。在那里，您将找到更多信息，还有一个链接，您可以申请增加电子邮件限制。
- en: To get it working, we will need to have two email accounts that we can use.
    In my case, I have my own domain. I have also created two email accounts—`donotreply@dfurtado.com`,
    which will be the email that I will use to send emails, and `pythonblueprints@dfurtado.com`,
    which is the email that will receive the email. A user in an online (video) game
    store application will use this email address and we will place a few orders so
    we can test the notification later on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，我们需要有两个可用的电子邮件帐户。在我的情况下，我有自己的域。我还创建了两个电子邮件帐户——`donotreply@dfurtado.com`，这将是我用来发送电子邮件的电子邮件，以及`pythonblueprints@dfurtado.com`，这是将接收电子邮件的电子邮件。在线（视频）游戏商店应用程序中的用户将使用此电子邮件地址，我们将下订单以便稍后测试通知。
- en: Registering the emails
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册电子邮件
- en: 'So let''s start adding the emails. We are going to register `donotreply@dfurtado.com`
    first. Log in to the AWS console and search for Simple Email Service in the search
    bar. On the left side, you will see a few options. Under Identity Management, click
    on Email Addresses. You will see a screen like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们开始添加电子邮件。首先我们将注册`donotreply@dfurtado.com`。登录到AWS控制台，在搜索栏中搜索“简单电子邮件服务”。在左侧，您将看到一些选项。在身份管理下，单击“电子邮件地址”。您将看到如下屏幕：
- en: '![](assets/4b285c53-779c-4a7a-8775-d9a40cbddf2b.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4b285c53-779c-4a7a-8775-d9a40cbddf2b.png)'
- en: As you can see, the list is empty, so let's go ahead and add two emails. Click
    on Verify a New Email Address and a dialog will appear where you can enter an
    email address. Just enter the email that you wish to use and click on Verify This
    Email Address button. By doing this a verification email will be sent to the email
    address that you specified, and therein you will find a link for the verification.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列表为空，因此让我们继续添加两封电子邮件。单击“验证新电子邮件地址”，将出现一个对话框，您可以在其中输入电子邮件地址。只需输入您希望使用的电子邮件，然后单击“验证此电子邮件地址”按钮。通过这样做，将向您指定的电子邮件地址发送验证电子邮件，在其中您将找到验证链接。
- en: Repeat the same steps for the second email, the one that will receive the messages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个电子邮件重复相同的步骤，该电子邮件将接收消息。
- en: Now, go over to the left side menu again and click on SMTP Settings under Email
    Sending.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次转到左侧菜单，单击“电子邮件发送”下的SMTP设置。
- en: There you will see all the configurations necessary to send emails, and you
    will also have to create SMTP credentials. So click on the button Create My SMTP
    Credentials, and a new page will be opened where you can input the IAM username
    that you wish. In my case, I'm adding `python-blueprints`. After you have done
    that, click the button Create. After the credentials have been created, you will
    be presented with a page where you can see the SMTP username and password. You
    will have the option to download these credentials if you like.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您将看到发送电子邮件所需的所有配置，您还需要创建SMTP凭据。因此，单击“创建我的SMTP凭据”按钮，将打开一个新页面，您可以在其中输入您希望的IAM用户名。在我的情况下，我添加了“python-blueprints”。完成后，单击“创建”按钮。凭据创建后，您将看到一个页面，您可以在其中看到SMTP用户名和密码。如果愿意，您可以选择下载这些凭据。
- en: Creating an S3 bucket
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建S3存储桶
- en: 'In order to send a template email to the users, we need to copy our templates
    to an S3 bucket. We can easily do that through the web, or you can use the AWS
    CLI that we just installed. The command to create the S3 bucket in the `es-west-2`
    region is something like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户发送模板电子邮件，我们需要将我们的模板复制到S3存储桶中。我们可以通过网络轻松完成这项工作，或者您可以使用我们刚刚安装的AWS CLI。在`es-west-2`区域创建S3存储桶的命令类似于：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we use the command `s3api`, which will provide us with different sub-commands
    to interact with the AWS S3 service. We call the sub-command `create-bucket`,
    which, as the name suggests, will create a new S3 bucket. To this sub-command,
    we specify three arguments. First, `--bucket`, which specifies the S3 bucket's
    name, then `--region`, to specify which region the bucket will be created - in
    this case, we are going to create the bucket in the `eu-west-2`. Lastly, locations
    outside the region `us-east-1` request the setting  `LocationConstraint` so the
    bucket can be created in the region that we wish.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用命令`s3api`，它将为我们提供与AWS S3服务交互的不同子命令。我们调用子命令`create-bucket`，正如其名称所示，将创建一个新的S3存储桶。对于这个子命令，我们指定了三个参数。首先是`--bucket`，指定S3存储桶的名称，然后是`--region`，指定要在哪个区域创建存储桶
    - 在这种情况下，我们将在`eu-west-2`创建存储桶。最后，区域外的位置需要设置`LocationConstraint`，以便在我们希望的区域创建存储桶。
- en: Implementing the notification service
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现通知服务
- en: Now that we have everything set up, and the files that we are going to use as
    a template to send emails to the customers of the online (video) game store are
    in place in the `python-blueprints` S3 bucket, it is time to start implementing
    the notification service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一切，我们将要用作向在线（视频）游戏商店的客户发送电子邮件的模板文件已经放在了`python-blueprints` S3存储桶中，现在是时候开始实现通知服务了。
- en: 'Let''s go ahead and create a file called `app.py` in the `notifier` directory,
    and to start with, let''s add some imports:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`notifier`目录中创建一个名为`app.py`的文件，首先让我们添加一些导入：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we import the JSON module so we can serialize and deserialize data. We
    import `HTTPStatus` from the HTTP module so we can use the HTTP status constants
    when sending responses back from the service's endpoints.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入JSON模块，这样我们就可以序列化和反序列化数据。我们从HTTP模块导入`HTTPStatus`，这样我们就可以在服务端点发送响应时使用HTTP状态常量。
- en: Then we import the modules that we will need to send emails. We start by importing
    the `smtplib` and also some exceptions that we want to handle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们导入发送电子邮件所需的模块。我们首先导入`smtplib`，还有一些我们想要处理的异常。
- en: We also import `MIMEText`, which will be used to create a `MIME` object out
    of the email content, and the `MIMEMultipart` that will be used to create the
    message that we are going to send.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入`MIMEText`，它将用于从电子邮件内容创建`MIME`对象，以及`MIMEMultipart`，它将用于创建我们将要发送的消息。
- en: Next, we import the `boto3` package so we can work with the *AWS* services.
    There are some exceptions that we will be handling; in this case, both exceptions
    are related to the *S3* buckets.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入`boto3`包，这样我们就可以使用*AWS*服务。有一些我们将处理的异常；在这种情况下，这两个异常都与*S3*存储桶有关。
- en: Next are some Flask related imports, and last but not least, we import the `Jinja2`
    package to template our emails.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些与Flask相关的导入，最后但并非最不重要的是，我们导入`Jinja2`包来为我们的电子邮件进行模板化。
- en: 'Continuing working on the `app.py` file, let''s define the constant that will
    hold the name or the *S3* bucket that we created:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在`app.py`文件上工作，让我们定义一个常量，用于保存我们创建的*S3*存储桶的名称：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we create the Flask app:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建Flask应用程序：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are also going to add a custom exception called `S3Error`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个名为`S3Error`的自定义异常：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we are going to define two helper functions. The first one is to send
    emails:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将定义两个辅助函数。第一个是发送电子邮件的函数：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we define the function `_send_message`, which gets just one argument, `message`.
    We start this function by creating an object that will encapsulate an SMTP connection.
    We use `SMTP_SSL` because the AWS Simple Email Service required TLS. The first
    argument is the SMTP host, which we created at the AWS Simple Email Service, and
    the second argument is the port, which will be set as `456` when SMTP connections
    over SSL are required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了函数`_send_message`，它只接受一个参数`message`。我们通过创建一个封装了SMTP连接的对象来启动这个函数。我们使用`SMTP_SSL`，因为AWS
    Simple Email Service需要TLS。第一个参数是SMTP主机，我们在AWS Simple Email Service中创建的，第二个参数是端口，在需要SSL连接的情况下将设置为`456`。
- en: Then we call the login method, passing the username and the password, which
    can also be found in the AWS Simple Email Service. In cases where an `SMTPAuthenticationError` exception
    is thrown we send an `UNAUTHORIZED` response back to the client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用登录方法，传递用户名和密码，这些信息也可以在AWS Simple Email Service中找到。在出现`SMTPAuthenticationError`异常的情况下，我们向客户端发送`UNAUTHORIZED`响应。
- en: If logging into the SMTP server is successful, we call the `sendmail` method,
    passing the email that is sending the message, the destination recipient, and
    the message. We handle the situation where some of the recipients reject our message,
    in that we return an `INTERNAL SERVER ERROR` response, and then we just quit the
    connection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功登录到SMTP服务器，我们调用`sendmail`方法，传递发送消息的电子邮件、目标收件人和消息。我们处理一些收件人拒绝我们消息的情况，如果是这样，我们返回`INTERNAL
    SERVER ERROR`响应，然后我们退出连接。
- en: Lastly, we return the `OK` response stating that the message has been sent successfully.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回`OK`响应，说明消息已成功发送。
- en: 'Now, we create a helper function to load the template file from the S3 bucket
    and return a rendered template for us:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个辅助函数，从S3存储桶中加载模板文件并返回一个渲染的模板：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we define the function `_prepare_template` and we take two arguments; `template_name`,
    which is the file name that we stored in the S3 bucket, and `context_data`, which
    is a dictionary containing the data that we are going to render in the template.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了函数`_prepare_template`，它接受两个参数，`template_name`是我们在S3存储桶中存储的文件名，`context_data`是一个包含我们将在模板中渲染的数据的字典。
- en: First, we create an S3 client, then we use the `get_object` method to pass the
    bucket name and the `Key`. We set the bucket keyword argument to `S3_BUCKET_NAME`,
    which we defined at the top of this file with the value of `python-blueprints`.
    The `Key` keyword argument is the name of the file; we set it to the value that
    we specified in the argument `template_name`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个S3客户端，然后使用`get_object`方法传递存储桶名称和`Key`。我们将存储桶关键字参数设置为`S3_BUCKET_NAME`，我们在此文件顶部定义了该值为`python-blueprints`。`Key`关键字参数是文件的名称；我们将其设置为在参数`template_name`中指定的值。
- en: Next, we access the key `Body` in the object returned from the S3 bucket, and
    call the method `read`. This will return a string with the file contents. Then,
    we create a Jinja2 Template object passing the contents of the template's file,
    and finally, we call the render method passing the `context_data`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们访问从S3存储桶返回的对象中的`Body`关键字，并调用`read`方法。这将返回一个包含文件内容的字符串。然后，我们创建一个Jinja2模板对象，传递模板文件的内容，并最后调用渲染方法传递`context_data`。
- en: 'Now, let''s implement the endpoint that will be called to send a confirmation
    email to the customer whose order we receive:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个端点，用于向我们收到订单的顾客发送确认电子邮件：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So here, define a function called `notify_order_received`, which we decorate
    with the `@app.route` to define the route and the methods that are allowed when
    calling this endpoint. The route is defined as `/notify/order-received/` and the
    `methods` keyword argument takes a list with the allowed HTTP methods. In this
    case, we want to allow only POST requests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义一个名为`notify_order_received`的函数，并使用`@app.route`装饰器定义路由和调用此端点时允许的方法。路由定义为`/notify/order-received/`，`methods`关键字参数接受一个允许的HTTP方法列表。在这种情况下，我们只允许POST请求。
- en: We start this function by getting all the data that has been passed in the request.
    In Flask applications this data can be accessed on `request.data`; we use the
    `json.loads` method to pass `request.data` as an argument, so it will deserialize
    the JSON objects into a Python object. Then we get the items, which are a list
    with all the items included in the order, and we get the value of the attribute
    `order_customer` so we can get the customer's email and the customer's name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过获取在请求中传递的所有数据来开始这个函数。在Flask应用程序中，可以通过`request.data`访问这些数据；我们使用`json.loads`方法将`request.data`作为参数传递，以便将JSON对象反序列化为Python对象。然后我们获取项目，这是包含在订单中的所有项目的列表，并获取属性`order_customer`的值，以便获取顾客的电子邮件和顾客的名字。
- en: After that, we get the order ID, which can be accessed via the property `id`,
    and lastly, we get the total purchase value that is in the property `total` of
    the data that has been sent to this endpoint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取订单ID，可以通过属性`id`访问，最后，我们获取已发送到此端点的数据的属性`total`中的总购买价值。
- en: Then we create an instance of `MIMEMultiPart` that passes as an argument `alternative`,
    which means that we will create a message with the `MIME` type set to multipart/alternative.
    After that, we configure a context that will be passed to the email template,
    and we use the `_prepare_template` function to pass the template that we want
    to render and the context with the data that will be displayed in the email. The
    value of the rendered template will be stored in the variable `email_content`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`MIMEMultiPart`的实例，将`alternative`作为参数传递，这意味着我们将创建一个`MIME`类型设置为multipart/alternative的消息。之后，我们配置一个将传递给电子邮件模板的上下文，并使用`_prepare_template`函数传递我们要渲染的模板和包含在电子邮件中显示的数据的上下文。渲染模板的值将存储在变量`email_content`中。
- en: Lastly, we do the final setup for our email message; we attach the rendered
    template to the message, we set subject, sender, and destinations, and we call
    the `_send_message` function to send the message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对电子邮件消息进行最终设置；我们将渲染的模板附加到消息中，设置主题、发件人和目的地，并调用`_send_message`函数发送消息。
- en: 'Next, we are going to add the endpoint that will notify the users when their
    order has changed status to `Shipping`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个端点，用于在用户的订单状态更改为`Shipping`时通知用户。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we define a function called `notify_order_shipped` and decorate it with
    the `@app.route` decorator, passing two arguments and the route, which is set
    to `/notify/order-shipped/`, and define that the method that is going to be accepted
    in this endpoint is the `POST` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个名为`notify_order_shipped`的函数，并使用`@app.route`装饰器装饰它，传递两个参数和路由，路由设置为`/notify/order-shipped/`，并定义此端点接受的方法为`POST`方法。
- en: We start by getting the data that has been passed in the request - basically
    the same as the previous function, the `notify_order_received`. We also create
    an instance of `MIMEMultipart`, setting the `MIME` type to multipart/alternative.
    Next, we use the `_prepare_template` function to load the template and render
    using the context that we are passing in the second argument; in this case, we
    are passing only the customer's name.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取在请求中传递的数据 - 基本上与之前的函数`notify_order_received`相同。我们还创建了一个`MIMEMultipart`的实例，并将`MIME`类型设置为multipart/alternative。接下来，我们使用`_prepare_template`函数加载模板，并使用传递的上下文渲染模板；在这种情况下，我们只传递了顾客的名字。
- en: Then we attach the template to the message and do the final set up, setting
    the subject, the send, and the destination. Finally, we call `_send_message` to
    send the message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将模板附加到消息中，并进行最终设置，设置主题、发送者和目的地。最后，我们调用`_send_message`发送消息。
- en: Next, we are going to create two email templates, one that we are going to use
    when sending an order confirmation notification to the user and the other for
    when an order has been shipped.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个电子邮件模板，一个用于向用户发送订单确认通知，另一个用于订单已发货时的通知。
- en: Email templates
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件模板
- en: Now we are going to create the templates that are going to be used when sending
    the notification emails to the online (video) game store's customers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要创建用于向在线（视频）游戏商店的顾客发送通知邮件的模板。
- en: 'In the application''s `root` directory, create a directory called `templates` and
    create a file called  `order_received_template.html`, with the contents shown
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的`root`目录中，创建一个名为`templates`的目录，并创建一个名为`order_received_template.html`的文件，内容如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s create another template in the same directory called `order_shipped_template.html`,
    with the contents shown as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一个目录中创建另一个名为`order_shipped_template.html`的模板，内容如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you have read [Chapter 7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml), *Online
    Video Game Store with Django*, you should be familiar with this syntax. The Jinja
    2 syntax has a lot of similarities when compared to the Django template language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读过[第7章](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml)，*使用Django创建在线视频游戏商店*，你应该对这种语法很熟悉。与Django模板语言相比，Jinja
    2语法有很多相似之处。
- en: 'Now we can copy the template to the S3 bucket that we created previously. Open
    a terminal and run the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将模板复制到之前创建的S3存储桶中。打开终端并运行以下命令：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Perfect! Next, we are going to deploy our project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！接下来，我们将部署我们的项目。
- en: Deploying the application with Zappa
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zappa部署应用程序
- en: Now we have got to a very interesting section of the chapter. We are going to
    deploy the Flask app that we created using a tool called **Zappa** ([https://github.com/Miserlou/Zappa](https://github.com/Miserlou/Zappa)).
    Zappa is a tool developed in Python (by **Rich Jones**, the principal author of
    Zappa) that makes it very easy to build and deploy serverless Python applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了本章非常有趣的部分。我们将使用一个名为**Zappa**（[https://github.com/Miserlou/Zappa](https://github.com/Miserlou/Zappa)）的工具部署我们创建的Flask应用程序。Zappa是一个由**Rich
    Jones**开发的Python工具（Zappa的主要作者），它使得构建和部署无服务器Python应用程序变得非常容易。
- en: 'The installation is pretty straightforward. Within the virtual environment
    that we have been using to develop this project, you can just run the `pipenv`
    command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安装非常简单。在我们用来开发这个项目的虚拟环境中，你可以运行`pipenv`命令：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After the installation, you can start the configuration. You just need to make
    sure that you have a valid AWS account and the AWS credentials file is in place.
    If you followed this chapter from the beginning and installed and configured the
    AWS CLI you should be all set.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以开始配置。你只需要确保你有一个有效的AWS账户，并且AWS凭据文件已经就位。如果你从头开始阅读本章并安装和配置了AWS CLI，那么你应该已经准备就绪了。
- en: 'To configure Zappa for our project you can run:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的项目配置Zappa，你可以运行：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see the ASCII Zappa logo (very beautiful BTW), and it will start asking
    some questions. The first one is:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到ASCII Zappa标志（非常漂亮顺便说一句），然后它会开始问一些问题。第一个问题是：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can just hit *Enter* to default to `dev`. Next, Zappa will ask the name
    of an AWS S3 bucket:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接按*Enter*键默认为`dev`。接下来，Zappa会询问AWS S3存储桶的名称：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here you can either specify an existent or create a new one. Then, Zappa will
    try to detect the application that we are trying to deploy:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以指定一个已存在的环境或创建一个新的环境。然后，Zappa将尝试检测我们要部署的应用程序：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, Zappa automatically found the Flask app defined in the `notify-service.py`
    file. You can just hit *Enter *to set the default value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Zappa自动找到了`notify-service.py`文件中定义的Flask应用程序。你可以直接按*Enter*键设置默认值。
- en: Next, Zappa will ask if you would like to deploy the application globally; we
    can keep the default and answer `n`. Since we are deploying this application in
    a development environment, we don't really need to deploy it globally. When your
    application goes into production you can evaluate if you need to deploy it globally.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Zappa会问你是否想要全局部署应用程序；我们可以保持默认值并回答`n`。由于我们在开发环境中部署此应用程序，我们实际上不需要全局部署它。当你的应用程序投入生产时，你可以评估是否需要全局部署。
- en: Lastly, the complete configuration will be displayed, and here you have to change
    the review and make any modifications if needed. You don't need to be too worried
    about saving the configuration or not because the Zappa settings file is just
    a text file with the settings in JSON format.  You can just edit the file at any
    time and change it manually.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，完整的配置将被显示出来，在这里你需要更改并进行任何必要的修改。你不需要太担心是保存配置还是不保存，因为Zappa设置文件只是一个文本文件，以JSON格式保存设置。你可以随时编辑文件并手动更改它。
- en: 'If everything went well, you should see a file called `zappa_settings.json`
    on the root''s directory of your application, with the contents similar to the
    content shown as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该在应用程序的根目录下看到一个名为`zappa_settings.json`的文件，内容与下面显示的内容类似：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here you can see the `dev` environment settings. The `app_function` specifies
    the Flask app that I created on the `notify-service.py` file, the `aws_region`
    specifies in which region the application will be deployed - in my case since
    I'm in Sweden, I chose `eu-west-2` *(*London*)* which is the closest region to
    me. The `project_name` will get by default the name of the directory where you
    run the command `zappa init`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`dev`环境设置。`app_function`指定了我在`notify-service.py`文件中创建的Flask应用程序，`aws_region`指定了应用程序将部署在哪个地区
    - 在我的情况下，由于我在瑞典，我选择了`eu-west-2`（*伦敦*）这是离我最近的地区。`project_name`将默认为你运行`zappa init`命令的目录名称。
- en: Then we have the runtime, which refers to the Python version that you are running
    with the application. Since the virtual environment that we created for this project
    used Python 3*,* the value for this property should be a version of Python 3 *-* in
    my case, I have installed 3.6.2\. Lastly, we have the name of the AWS S3 bucket
    that Zappa will use to upload the project files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有运行时，它指的是你在应用程序中使用的Python版本。由于我们为这个项目创建的虚拟环境使用的是Python 3*，*所以这个属性的值应该是Python
    3的一个版本*-*在我的情况下，我安装了3.6.2。最后，我们有Zappa将用来上传项目文件的AWS S3存储桶的名称。
- en: 'Now, let''s deploy the application that we just created! On the terminal, simply
    run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们部署刚刚创建的应用程序！在终端上，只需运行以下命令：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Zappa will perform lots of tasks for you, and at the end it will display the
    URL where the application has been deployed. In my case I''ve got:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Zappa将为您执行许多任务，最后它将显示应用程序部署的URL。在我的情况下，我得到了：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Yours will look slightly different. So, we have defined two endpoints in our
    Flask application, `/notify/order-received` and `/notify/order-shipped`. These
    endpoints can be called with the following URLs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你的情况可能会略有不同。因此，我们在Flask应用程序中定义了两个端点，`/notify/order-received`和`/notify/order-shipped`。可以使用以下URL调用这些端点：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to see more information about the deployment, you can use the Zappa
    command: `zappa status`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看部署的更多信息，可以使用Zappa命令：`zappa status`。
- en: In the next section, we are going to learn how to restrict access to these endpoints
    and create an access key that can be used to make the API calls.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何限制对这些端点的访问，并创建一个可以用来进行API调用的访问密钥。
- en: Restricting access to the API's endpoints
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制对API端点的访问
- en: Our Flask application has been deployed, and at this point anyone can make a
    request to the endpoints that have been configured on the AWS API Gateway. What
    we want to do is restrict the access only to requests that contain an access key.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Flask应用程序已经部署，在这一点上任何人都可以向AWS API Gateway上配置的端点发出请求。我们想要的是只允许包含访问密钥的请求访问。
- en: 'To do that, log into our account on AWS console and on the Services menu search
    for and select Amazon API Gateway*.* Under the API on the left side menu, you
    will see the notifier-dev:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，登录到我们在AWS控制台上的帐户，并在Services菜单中搜索并选择Amazon API Gateway*.*。在左侧菜单上的API下，你将看到notifier-dev：
- en: '![](assets/abc851ca-9fc3-4626-986b-5cb84a46bdb2.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/abc851ca-9fc3-4626-986b-5cb84a46bdb2.png)'
- en: Great! Here we are going to define a usage plan. Click on Usage Plans and then
    click on the Create button, and you will see a form for creating a new usage plan.
    Enter the name `up-blueprints`, uncheck the checkboxes for Enable throttling and
    Enable Quota*,* and click the Next button.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在这里，我们将定义一个使用计划。点击使用计划，然后点击创建按钮，你将看到一个创建新使用计划的表单。输入名称`up-blueprints`，取消启用节流和启用配额的复选框，然后点击下一步按钮。
- en: The next step is to associate an API stage. So far we have only dev, so let's
    add the stage dev; click on Add API Stage button, and on the drop-down list select
    the notifier-dev and the stage dev. Make sure to click on the check button, the
    same row as the drop-down menus, otherwise, the Next button won't be enabled.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是关联API阶段。到目前为止，我们只有dev，所以让我们添加dev阶段；点击添加API阶段按钮，并在下拉列表中选择notifier-dev和阶段dev。确保点击检查按钮，在下拉菜单的同一行，否则下一步按钮将不会启用。
- en: 'After clicking Next you will have to add an API key to the Usage Plan that
    we just created. Here you will have two options; add a new one or pick an existing
    one:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步后，你将不得不向我们刚刚创建的使用计划添加一个API密钥。在这里你将有两个选项；添加一个新的或选择一个现有的：
- en: '![](assets/c6112886-16da-4ef5-a61d-759f7705a0f4.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6112886-16da-4ef5-a61d-759f7705a0f4.png)'
- en: Let's add a new one. Click on the button labeled Create API Key and add to Usage
    Plan. The API Key creation dialog will be shown, so just enter the name `notifiers-devs` and
    click save.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新的。点击标记为创建API密钥并添加到使用计划的按钮。API密钥创建对话框将显示，只需输入名称`notifiers-devs`，然后点击保存。
- en: 'Great! Now if you select API Keys on the left side menu, you should see the
    newly created API Key on the list. If you selected it, you will be able to see
    all the details regarding the key:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，如果你在左侧菜单中选择API Keys，你应该会在列表中看到新创建的API密钥。如果你选择它，你将能够看到有关密钥的所有详细信息：
- en: '![](assets/a128780e-ca68-4ff5-97de-9a01b6be4413.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a128780e-ca68-4ff5-97de-9a01b6be4413.png)'
- en: 'Now, on the left side menu, select APIs -> notifier-dev -> Resources, and on
    the tab Resources, select the root route /. On the right side panel, you can see
    the / Methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在左侧菜单中，选择API -> notifier-dev -> 资源，并在资源选项卡上，选择根路由/。在右侧面板上，你可以看到/方法：
- en: '![](assets/bdc9760b-78aa-4d93-9ff3-69744d5d3f86.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bdc9760b-78aa-4d93-9ff3-69744d5d3f86.png)'
- en: 'Note that ANY says Authorization None and that API Key is set to Not required.
    Let''s change that so the API Key is required. On the Resources panel, click on
    ANY, you should see now a panel similar to the screenshot shown as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ANY表示授权无，API密钥设置为不需要。让我们更改API密钥为必需。在资源面板上，点击ANY，现在你应该看到一个类似于以下截图的面板：
- en: '![](assets/adc0d6fd-888b-4f1f-b754-da4c176a292f.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/adc0d6fd-888b-4f1f-b754-da4c176a292f.png)'
- en: 'Click on Method Request:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Method Request：
- en: '![](assets/bc95c53f-b152-4b64-becd-b97ba441d619.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc95c53f-b152-4b64-becd-b97ba441d619.png)'
- en: Click on the pen icon next to API Key Required and, on the drop-down menu, select
    the value true*.*
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 点击API Key Required旁边的笔图标，在下拉菜单中选择值true*.*。
- en: Great! Now, the API calls to the stage dev should be restricted to requests
    with the API key notifier-dev in the request's Header.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，对于dev阶段的API调用应该限制为请求中包含API密钥notifier-dev。
- en: Lastly, head over to API Keys and click on notifier-keys. On the right side
    panel, in the API `Key`, click on the link show, and the API key will be displayed
    for you. Copy that key, because we are going to use it in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转到API Keys，点击notifier-keys。在右侧面板中，在API `Key`中，点击显示链接，API密钥将显示出来。复制该密钥，因为我们将在下一节中使用它。
- en: Modifying the order service
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改订单服务
- en: Now that we have the notifier application deployed, we have to modify our previous
    project, the order microservice, to make use of the notifier application and send
    notifications when a new order arrives and when the status of the order changes
    to shipped.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了通知应用程序，我们必须修改我们之前的项目，订单微服务，以利用通知应用程序，并在新订单到达时发送通知，以及在订单状态更改为已发货时发送通知。
- en: 'The first thing we have to do is to include the notifier service API key and
    its base URL in the `settings.py` file in the directory, called `order` on the
    order''s `root` directory, and include the following content at the end of the
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是在`settings.py`文件中包含通知服务API密钥和其基本URL，在名为`order`的目录中，在订单的`root`目录中，并在文件末尾包含以下内容：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replace these values with the corresponding values on your environment. If
    you don''t have the value for the `NOTIFIER_BASEURL`, you can obtain it running
    the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用您环境中对应的值替换这些值。如果您没有`NOTIFIER_BASEURL`的值，可以通过运行以下命令来获取它：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The value you want is the API Gateway URL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要的值是API Gateway URL。
- en: 'Now, we are going to create two files. The first one it is a file called `notification_type.py` in
    the `order/main` directory. In this file, we will define an enumeration with the
    notification types that we want to make available in our service:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要创建两个文件。第一个文件是在`order/main`目录中名为`notification_type.py`的文件。在这个文件中，我们将定义一个包含我们想要在我们的服务中提供的通知类型的枚举：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we are going to create a file with a helper function that will make the
    calls to the notification service. Create a file called `notifier.py` in the `order/main/`
    directory with the contents shown as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个帮助函数的文件，该函数将调用通知服务。在`order/main/`目录中创建一个名为`notifier.py`的文件，并包含以下内容：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From the top, we included some import statements; we are importing requests
    to perform the request to the notifier service, so we import the module json,
    so we can serialize the data to be sent to the notifier service. Then we import
    the settings so we can get hold of the constants that we defined with the base
    URL to the notifier service and the API key. Lastly, we import the notification
    type enumeration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们包括了一些导入语句；我们导入请求以执行对通知服务的请求，因此我们导入json模块，以便我们可以将数据序列化为要发送到通知服务的格式。然后我们导入设置，这样我们就可以获得我们在基本URL到通知服务和API密钥方面定义的常量。最后，我们导入通知类型枚举。
- en: The function `notify` that we defined here takes two arguments, the order and
    the notification type, which are the values defined in the enumeration `NotificationType`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的`notify`函数接受两个参数，订单和通知类型，这些值在枚举`NotificationType`中定义。
- en: We start by deciding which endpoint we are going to use, depending on the notification's
    type. Then we add an entry `X-API-KEY` to the request's `HEADER` with the API
    key.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先决定要使用哪个端点，这取决于通知的类型。然后我们在请求的`HEADER`中添加一个`X-API-KEY`条目，其中包含API密钥。
- en: After that, we make a `POST` request that passes a few arguments. The first
    argument is the endpoint's URL, the second is the data that we are going to send
    to the notifier service (we use the `json.dumps` function so the data is sent
    in JSON format), and the third argument is the dictionary with the header data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们进行`POST`请求，传递一些参数。第一个参数是端点的URL，第二个是我们将发送到通知服务的数据（我们使用`json.dumps`函数，以便以JSON格式发送数据），第三个参数是包含标头数据的字典。
- en: Lastly, when we get the response back we just return it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们收到响应时，我们只需返回它。
- en: 'Now we need to modify the view that is responsible for handling a `POST` request
    to create a new order, so that it calls the notify function when an order is created
    in the database. Let''s go ahead and open the file `view.py` in the `order/main`
    directory and add two import statements:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改负责处理`POST`请求以创建新订单的视图，以便在数据库中创建订单时调用`notify`函数。让我们继续打开`order/main`目录中的`view.py`文件，并添加两个导入语句：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The two lines can be added before the first class in the file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行可以添加在文件中的第一个类之前。
- en: 'Perfect, now we need to change the method post in the `CreateOrderView` class.
    Before the first return statement in that method, where we return a `201` (`CREATED`)
    response, include the code shown as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，现在我们需要更改`CreateOrderView`类中的`post`方法。在该方法中的第一个返回语句之前，在我们返回`201`（`CREATED`）响应的地方，包括以下代码：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So here we call the notify function, passing the serialized order using the
    `OrderSerializer` on the first argument, and the notification type - in this case,
    we want to send an `ORDER_RECEIVED` notification.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里我们调用`notify`函数，使用`OrderSerializer`作为第一个参数传递序列化的订单，以及通知类型 - 在这种情况下，我们想发送一个`ORDER_RECEIVED`通知。
- en: We will allow the user of the order service application to update the order
    using the Django Admin. There, they will be able to, for example, update an order's
    status, so we need to implement some code that will handle data changes made by
    users using the Django Admin.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许订单服务应用程序的用户使用Django管理界面更新订单。在那里，他们将能够更新订单的状态，因此我们需要实现一些代码来处理用户在Django管理界面上进行的数据更改。
- en: 'To do this, we need to create a `ModelAdmin` class inside of the `admin.py`
    file in the `order/main` directory. First, we add some import statements:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要在`order/main`目录中的`admin.py`文件中创建一个`ModelAdmin`类。首先，我们添加一些导入语句：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we add the following class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加以下类：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we create a class called `OrderAdmin` that inherits from the `admin.ModelAdmin`,
    and we override the method `save_model` so we have the chance to perform some
    actions before the data is saved. First, we get the order current status, then
    we check if the field `status` is between the list of fields that have been changed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`OrderAdmin`的类，它继承自`admin.ModelAdmin`，并且我们重写了`save_model`方法，这样我们就有机会在保存数据之前执行一些操作。首先，我们获取订单的当前状态，然后我们检查字段`status`是否在已更改的字段列表之间。
- en: The if statement checks if the status field has changed, and if the current
    status of the order equals to `Status.Shipping` then we call the notify function,
    passing the serialized order object and the notification type `NotificationType.ORDER_SHIPPED`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: if语句检查状态字段是否已更改，如果订单的当前状态等于`Status.Shipping`，那么我们调用`notify`函数，传递序列化的订单对象和通知类型`NotificationType.ORDER_SHIPPED`。
- en: Lastly, we call the `save_model` method on the super class to save the object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用超类的`save_model`方法来保存对象。
- en: 'The last piece of this puzzle is to replace this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后一部分是替换这个：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead, put this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will register the admin model `OrderAdmin` for the `Order` model. Now,
    when the user saves the order in the Django admin UI, it will call the `save_model`
    in the `OrderAdmin` class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`Order`模型注册管理模型`OrderAdmin`。现在，当用户在Django管理界面中保存订单时，它将调用`OrderAdmin`类中的`save_model`。
- en: Testing all the pieces together
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试所有部分的整体功能
- en: Now that we have the notifier application deployed and we have also made all
    the necessary modifications to the order service, it is time to test if all the
    applications are working together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了通知应用程序，并且还对订单服务进行了所有必要的修改，是时候测试所有应用程序是否能够一起运行了。
- en: 'Open a terminal, change to the directory where you have implemented the online
    (video) game store, and execute the following command to start up the Django development
    server:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端，切换到您实施在线（视频）游戏商店的目录，并执行以下命令启动Django开发服务器：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This command will start the Django development server running on the default
    port `8000`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将启动默认端口`8000`上运行的Django开发服务器。
- en: 'Now let''s start the order microservice. Open another terminal window, change
    to the directory where you implemented the order microserver, and run the following
    command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启动订单微服务。打开另一个终端窗口，切换到您实施订单微服务的目录，并运行以下命令：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can browse to `http://127.0.0.1:8000`, log in to the application and
    add some items to the cart:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以浏览`http://127.0.0.1:8000`，登录应用程序并向购物车中添加一些商品：
- en: '![](assets/20a6d3cd-f8f3-4541-8c78-caecf5121171.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20a6d3cd-f8f3-4541-8c78-caecf5121171.png)'
- en: As you can see, I added three items and the total amount of this order is $32.75.
    Click on the button SEND ORDER, and you should get a notification on the page
    that the order has been sent.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我添加了三件商品，此订单的总金额为32.75美元。单击“发送订单”按钮，您应该会在页面上收到订单已发送的通知。
- en: '![](assets/a31cb284-c9ec-4db6-ad49-a14fe17cd8e8.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a31cb284-c9ec-4db6-ad49-a14fe17cd8e8.png)'
- en: Great! Working as expected so far. Now we check the user's email, to verify
    if the notification service actually sent the order confirmation email.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！到目前为止一切都按预期进行。现在我们检查用户的电子邮件，以验证通知服务是否实际发送了订单确认电子邮件。
- en: 'Fair enough, the user just got the email:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，用户刚刚收到了邮件：
- en: '![](assets/8fd748de-ba5d-48ac-be77-58e7f81d223c.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8fd748de-ba5d-48ac-be77-58e7f81d223c.png)'
- en: Note that the sender and the destination recipients are the emails that I registered
    in the AWS Simple Email Service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，发件人和收件人的电子邮件是我在AWS简单电子邮件服务中注册的。
- en: So now let's log in to the order service's Django admin and change the status
    for the same order to verify that the confirmation email that the order has been
    shipped will be sent to the user. Remember that the email will only be sent if
    the order has changed its status field to shipped.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们登录订单服务的Django管理界面，并更改相同订单的状态，以验证订单已发货的确认电子邮件是否会发送给用户。请记住，只有当订单将其状态字段更改为已发货时，才会发送电子邮件。
- en: 'Browse to `http://localhost:8001/admin/` and log in with the administrator
    credentials. You will see a page with the menu shown as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览`http://localhost:8001/admin/`并使用管理员凭据登录。您将看到一个带有以下菜单的页面：
- en: '![](assets/063496f6-7f0d-40f4-ad9e-5916bdcdcc20.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/063496f6-7f0d-40f4-ad9e-5916bdcdcc20.png)'
- en: 'Click on Orders and then select the order that we just submitted:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 点击订单，然后选择我们刚刚提交的订单：
- en: '![](assets/92f7f9f5-dd5c-425b-a89e-269748d2f1b4.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92f7f9f5-dd5c-425b-a89e-269748d2f1b4.png)'
- en: On the drop-down menu Status, change the value to Shipping and click the button
    SAVE.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单“状态”中，将值更改为“发货”，然后单击“保存”按钮。
- en: 'Now, if we verify the order customer''s email again we should have got another
    email confirming that the order has been shipped:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次验证订单客户的电子邮件，我们应该已经收到另一封确认订单已发货的电子邮件：
- en: '![](assets/0b0f6c48-27a2-4936-86d4-6d3386d1547c.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b0f6c48-27a2-4936-86d4-6d3386d1547c.png)'
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned a bit more about serverless functions architecture,
    how to build a notification service using the web framework Flask, and how to
    deploy the final application to AWS Lambda using the great project Zappa.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了有关无服务器函数架构的更多信息，如何使用Web框架Flask构建通知服务，以及如何使用伟大的项目Zappa将最终应用程序部署到AWS
    Lambda。
- en: Then, you learned how to install, configure, and use the AWS CLI tool, and used
    it to upload files to an AWS S3 bucket.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学习了如何安装、配置和使用AWS CLI工具，并使用它将文件上传到AWS S3存储桶。
- en: We also learned how to integrate the web application that we developed in [Chapter
    7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml)*, Online Video Game Store with
    Django*,andthe order microservice that we developed in [Chapter 8](27b45ac1-0112-4b71-a3ee-d7c62a740a57.xhtml)*,*
    *Order Microservice*, with the serverless notification application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何将我们在[第7章](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml)*Django在线视频游戏商店*中开发的Web应用程序与我们在[第8章](27b45ac1-0112-4b71-a3ee-d7c62a740a57.xhtml)*订单微服务*中开发的订单微服务与无服务器通知应用程序集成。
