- en: Chapter 1. Network Programming and Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。网络编程和Python
- en: This book will focus on writing programs for networks that use the Internet
    protocol suite. Why have we chosen to do this? Well, of the sets of protocols
    supported by the Python standard library, the TCP/IP protocol is by far the most
    widely employable. It contains the principle protocols used by the Internet. By
    learning to program for TCP/IP, you'll be learning how to potentially communicate
    with just about every device that is connected to this great tangle of network
    cables and electromagnetic waves.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将重点关注编写使用互联网协议套件的网络程序。为什么我们选择这样做呢？嗯，Python标准库支持的协议集中，TCP/IP协议是迄今为止最广泛应用的。它包含了互联网使用的主要协议。通过学习为TCP/IP编程，您将学会如何与连接到这个庞大网络电缆和电磁波的几乎每个设备进行通信。
- en: In this chapter, we will be looking at some concepts and methods around networks
    and network programming in Python, which we'll be using throughout this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些关于网络和Python网络编程的概念和方法，这些内容将贯穿本书始终。
- en: This chapter has two sections. The first section, *An introduction to TCP/IP
    networks*, offers an introduction to essential networking concepts, with a strong
    focus on the TCP/IP stack. We'll be looking at what comprises a network, how the
    **Internet Protocol** (**IP**) allows data transfer across and between networks,
    and how TCP/IP provides us with services that help us to develop network applications.
    This section is intended to provide a grounding in these essential areas and to
    act as a point of reference for them. If you're already comfortable with concepts
    such as IP addresses, routing, TCP and UDP, and protocol stack layers, then you
    may wish to skip to second part, *Network programming with Python*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为两个部分。第一部分，*TCP/IP网络简介*，提供了对基本网络概念的介绍，重点介绍了TCP/IP协议栈。我们将研究网络的组成，**互联网协议**（**IP**）如何允许数据在网络之间传输，以及TCP/IP如何为我们提供帮助开发网络应用程序的服务。本节旨在为这些基本领域提供基础，并作为它们的参考点。如果您已经熟悉IP地址、路由、TCP和UDP以及协议栈层等概念，那么您可能希望跳到第二部分，*使用Python进行网络编程*。
- en: In the second part, we'll look at the way in which network programming is approached
    with Python. We'll be introducing the main standard library modules, looking at
    some examples to see how they relate to the TCP/IP stack, and then we will be
    discussing a general approach for finding and employing modules that meet our
    networking needs. We'll also be taking a look at a couple of general issues that
    we may encounter, when writing applications that communicate over TCP/IP networks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们将看一下使用Python进行网络编程的方式。我们将介绍主要的标准库模块，看一些示例以了解它们与TCP/IP协议栈的关系，然后我们将讨论一般的方法来找到和使用满足我们网络需求的模块。我们还将看一下在编写通过TCP/IP网络进行通信的应用程序时可能遇到的一些一般问题。
- en: An introduction to TCP/IP networks
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP网络简介
- en: The Internet protocol suite, often referred to as TCP/IP, is a set of protocols
    designed to work together to provide end-to-end transmission of messages across
    interconnected networks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议套件，通常称为TCP/IP，是一组旨在共同工作以在互连网络上提供端到端消息传输的协议。
- en: The following discussion is based on **Internet Protocol version 4** (**IPv4**).
    Since the Internet has run out of IPv4 addresses, a new version, IPv6, has been
    developed, which is intended to resolve this situation. However, although IPv6
    is being used in a few areas, its deployment is progressing slowly and a majority
    of the Internet will likely be using IPv4 for a while longer. We'll focus on IPv4
    in this section, and then we will discuss the relevant changes in IPv6 in second
    part of this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下讨论基于**互联网协议第4版**（**IPv4**）。由于互联网已经用尽了IPv4地址，已经开发了一个新版本IPv6，旨在解决这种情况。然而，尽管IPv6在一些领域得到了应用，但其部署进展缓慢，大多数互联网可能会继续使用IPv4。我们将在本节重点讨论IPv4，然后在本章的第二部分讨论IPv6的相关变化。
- en: TCP/IP is specified in documents called **Requests for Comment** (**RFCs**)
    which are published by the **Internet Engineering Task Force** (**IETF**). RFCs
    cover a wide range of standards and TCP/IP is just one of these. They are freely
    available on the IETF's website, which can be found at [www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).
    Each RFC has a number, IPv4 is documented by RFC 791, and other relevant RFCs
    will be mentioned as we progress.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP在称为**请求评论**（**RFCs**）的文件中进行了规定，这些文件由**互联网工程任务组**（**IETF**）发布。RFCs涵盖了广泛的标准，而TCP/IP只是其中之一。它们可以在IETF的网站上免费获取，网址为[www.ietf.org/rfc.html](http://www.ietf.org/rfc.html)。每个RFC都有一个编号，IPv4由RFC
    791记录，随着我们的进展，其他相关的RFC也会被提到。
- en: Note that you won't learn how to set up your own network in this chapter because
    that's a big topic and unfortunately, somewhat beyond the scope of this book.
    But, it should enable you at least to have a meaningful conversation with your
    network support people!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章不会教你如何设置自己的网络，因为这是一个大课题，而且很遗憾，有些超出了本书的范围。但是，至少它应该能让你与网络支持人员进行有意义的交流！
- en: IP addresses
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址
- en: 'So, let''s get started with something you''re likely to be familiar with, that
    is, IP addresses. They typically look something like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从你可能熟悉的内容开始，即IP地址。它们通常看起来像这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: They are actually a single 32-bit number, though they are usually written just
    like the number shown in the preceding example; they are written in the form of
    four decimal numbers that are separated by dots. The numbers are sometimes called
    **octets** or bytes because each one represents 8-bits of the 32-bit number. As
    such, each octet can only take values from 0 to 255, so valid IP addresses range
    from 0.0.0.0 to 255.255.255.255\. This way of writing IP addresses is called **dot-decimal
    notation.**
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它们实际上是一个32位的数字，尽管它们通常被写成前面示例中显示的数字；它们以四个由点分隔的十进制数的形式书写。这些数字有时被称为**八位组**或字节，因为每个数字代表32位数字中的8位。因此，每个八位组只能取0到255的值，因此有效的IP地址范围从0.0.0.0到255.255.255.255。这种写IP地址的方式称为**点十进制表示法**。
- en: 'IP addresses perform two main functions. They are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址执行两个主要功能。它们如下：
- en: They uniquely address each device that is connected to a network
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们唯一地寻址连接到网络的每个设备
- en: They help the traffic to be routed between networks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们帮助在网络之间路由流量
- en: You may have noticed that the network-connected devices that you use have IP
    addresses assigned to them. Each IP address that is assigned to a network device
    is unique and no two devices can share an IP address.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到您使用的网络连接设备都分配了IP地址。分配给网络设备的每个IP地址都是唯一的，没有两个设备可以共享一个IP地址。
- en: Network interfaces
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络接口
- en: You can find out what IP addresses have been assigned to your computer by running
    `ip addr` (or `ipconfig /all` on Windows) on a terminal. In [Chapter 6](ch06.html
    "Chapter 6. IP and DNS"), *IP and DNS*, we'll see how to do this when using Python.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端上运行`ip addr`（或在Windows上运行`ipconfig /all`）来查找分配给您计算机的IP地址。在[第6章](ch06.html
    "第6章。IP和DNS")*IP和DNS*中，我们将看到在使用Python时如何做到这一点。
- en: If we run one of these commands, then we can see that the IP addresses are assigned
    to our device's network interfaces. On Linux, these will have names, such as `eth0`;
    on Windows these will have phrases, such as `Ethernet adapter Local Area Connection`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些命令之一，那么我们可以看到IP地址分配给我们设备的网络接口。在Linux上，这些将具有名称，如`eth0`；在Windows上，这些将具有短语，如`Ethernet
    adapter Local Area Connection`。
- en: 'You will get the following output when you run the `ip addr` command on Linux:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上运行`ip addr`命令时，您将获得以下输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the IP addresses for the interfaces appear after the
    word `inet`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，接口的IP地址出现在单词`inet`之后。
- en: An interface is a device's physical connection to its network media. It could
    be a network card that connects to a network cable, or a radio that uses a specific
    wireless technology. A desktop computer may only have a single interface for a
    network cable, whereas a Smartphone is likely to have at least two interfaces,
    one for connecting to Wi-Fi networks and one for connecting to mobile networks
    that use 4G or other technologies.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是设备与其网络媒体的物理连接。它可以是连接到网络电缆的网络卡，也可以是使用特定无线技术的无线电。台式电脑可能只有一个用于网络电缆的接口，而智能手机可能至少有两个接口，一个用于连接Wi-Fi网络，一个用于连接使用4G或其他技术的移动网络。
- en: An interface is usually assigned only one IP address, and each interface in
    a device has a different IP address. So, going back to the purposes of IP addresses
    discussed in the preceding section, we can now more accurately say that their
    first main function is to uniquely address each device's connection to a network.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个接口只分配一个IP地址，设备中的每个接口都有不同的IP地址。因此，回到前面部分讨论的IP地址的目的，我们现在可以更准确地说，它们的第一个主要功能是唯一地寻址每个设备与网络的连接。
- en: Every device has a virtual interface called the **loopback interface**, which
    you can see in the preceding listing as interface `1`. This interface doesn't
    actually connect to anything outside the device, and only the device itself can
    communicate with it. While this may sound a little redundant, it's actually very
    useful when it comes to local network application testing, and it can also be
    used as a means of inter-process communication. The loopback interface is often
    referred to as **localhost**, and it is almost always assigned the IP address
    127.0.0.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有一个名为**环回接口**的虚拟接口，您可以在前面的列表中看到它作为接口`1`。这个接口实际上并不连接到设备外部的任何东西，只有设备本身才能与它通信。虽然这听起来有点多余，但在进行本地网络应用程序测试时非常有用，它也可以用作进程间通信的手段。环回接口通常被称为**本地主机**，它几乎总是被分配IP地址127.0.0.1。
- en: Assigning IP addresses
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配IP地址
- en: 'IP addresses can be assigned to a device by a network administrator in one
    of two ways: statically, where the device''s operating system is manually configured
    with the IP address, or dynamically, where the device''s operating system is configured
    by using the **Dynamic Host Configuration Protocol** (**DHCP**).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址可以通过网络管理员以两种方式之一分配给设备：静态分配，其中设备的操作系统手动配置IP地址，或动态分配，其中设备的操作系统使用**动态主机配置协议**（**DHCP**）进行配置。
- en: When using DHCP, as soon as the device first connects to a network, it is automatically
    allocated an address by a DHCP server from a predefined pool. Some network devices,
    such as home broadband routers provide a DHCP server service out-of-the-box, otherwise
    a DHCP server must be set up by a network administrator. DHCP is widely deployed,
    and it is particularly useful for networks where different devices may frequently
    connect and disconnect, such as public Wi-Fi hotspots or mobile networks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用DHCP时，设备第一次连接到网络时，它会自动从预定义的池中由DHCP服务器分配一个地址。一些网络设备，如家用宽带路由器，提供了开箱即用的DHCP服务器服务，否则必须由网络管理员设置DHCP服务器。DHCP被广泛部署，特别适用于不同设备可能频繁连接和断开的网络，如公共Wi-Fi热点或移动网络。
- en: IP addresses on the Internet
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网上的IP地址
- en: The Internet is a huge IP network, and every device that sends data over it
    is assigned an IP address.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网是一个庞大的IP网络，每个通过它发送数据的设备都被分配一个IP地址。
- en: The IP address space is managed by an organization called the **Internet Assigned
    Numbers Authority** (**IANA**). IANA decides the global allocation of the IP address
    ranges and assigns blocks of addresses to **Regional Internet Registries** (**RIRs**)
    worldwide, who then allocate address blocks to countries and organizations. The
    receiving organizations have the freedom to allocate the addresses from their
    assigned blocks as they like within their own networks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址空间由一个名为**互联网数字分配机构**（**IANA**）的组织管理。IANA决定IP地址范围的全球分配，并向全球**区域互联网注册机构**（**RIRs**）分配地址块，然后RIRs向国家和组织分配地址块。接收组织有自由在其分配的地址块内自由分配地址。
- en: 'There are some special IP address ranges. IANA has defined ranges of **private
    addresses**. These ranges will never be assigned to any organization, and as such
    these are available for anyone to use for their networks. The private address
    ranges are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的IP地址范围。IANA定义了**私有地址**范围。这些范围永远不会分配给任何组织，因此任何人都可以用于他们的网络。私有地址范围如下：
- en: 10.0.0.0 to 10.255.255.255
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10.0.0.0到10.255.255.255
- en: 172.16.0.0 to 172.31.255.255
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 172.16.0.0到172.31.255.255
- en: 192.168.0.0 to 192.168.255.255
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 192.168.0.0到192.168.255.255
- en: You may be thinking that if anybody can use them, then would'nt that mean that
    devices on the Internet will end up using the same addresses, thereby breaking
    IP's unique addressing property? This is a good question, and this problem has
    been avoided by forbidding traffic from private addresses from being routed over
    the public Internet. Wherever a network using private addresses needs to communicate
    with the public Internet, a technique called **Network Address Translation** (**NAT**)
    is used, which essentially makes the traffic from the private network appear to
    be coming from a single valid public Internet address, and this effectively hides
    the private addresses from the Internet. We'll discuss NAT later on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果任何人都可以使用它们，那么这是否意味着互联网上的设备最终会使用相同的地址，从而破坏IP的唯一寻址属性？这是一个很好的问题，这个问题已经通过禁止私有地址的流量在公共互联网上传输来避免。每当使用私有地址的网络需要与公共互联网通信时，会使用一种称为**网络地址转换**（**NAT**）的技术，这实质上使得来自私有网络的流量看起来来自单个有效的公共互联网地址，这有效地隐藏了私有地址。我们稍后会讨论NAT。
- en: If you inspect the output of `ip addr` or `ipconfig /all` on your home network,
    then you will find that your devices are using private range addresses, which
    would have been assigned to them by your broadband router through DHCP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查家庭网络上`ip addr`或`ipconfig /all`的输出，你会发现你的设备正在使用私有地址范围，这些地址是通过DHCP由你的宽带路由器分配给它们的。
- en: Packets
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据包
- en: We'll be talking about network traffic in the following sections, so let's get
    an idea of what it is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论网络流量，所以让我们先了解一下它是什么。
- en: Many protocols, including the principle protocols in the Internet protocol suite,
    employ a technique called **packetization** to help manage data while it's being
    transmitted across a network.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 许多协议，包括互联网协议套件中的主要协议，使用一种称为**数据包化**的技术来帮助管理数据在网络上传输时的情况。
- en: When a packetizing protocol is given some data to transmit, it breaks it up
    into small units — sequences of bytes, typically a few thousand bytes long and
    then it prefixes each unit with some protocol-specific information. The prefix
    is called a **header,** and the prefix and data together form a **packet**. The
    data within a packet is often called its **payload**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据包协议被给定一些数据进行传输时，它将数据分解成小单元——典型的几千字节长的字节序列，然后在每个单元前面加上一些特定于协议的信息。前缀称为**头部**，前缀和数据一起形成一个**数据包**。数据包中的数据通常被称为其**有效载荷**。
- en: 'What a packet contains is shown in the following figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包的内容如下图所示：
- en: '![Packets](graphics/6008OS_01_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![数据包](graphics/6008OS_01_01.jpg)'
- en: Some protocols use alternative terms for packets, such as frames, but we'll
    stick with the term packets for now. The header includes all the information that
    the protocol implementation running on another device needs to be able to interpret
    what the packet is and how to handle it. For example, the information in an IP
    packet header includes the source IP address, the destination IP address, the
    total length of the packet, and the checksum of the data in the header.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些协议使用数据包的替代术语，如帧，但我们现在将使用数据包这个术语。头部包括协议实现在另一个设备上运行所需的所有信息，以便能够解释数据包是什么以及如何处理它。例如，IP数据包头部中的信息包括源IP地址、目标IP地址、数据包的总长度和头部数据的校验和。
- en: Once created, the packets are sent onto the network, where they are independently
    routed to their destination. Sending the data in packets has several advantages,
    including multiplexing (where more than one device can send data over the network
    at once), rapid notification of errors that may occur on the network, congestion
    control, and dynamic re-routing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，数据包被发送到网络上，然后独立路由到它们的目的地。以数据包形式发送数据有几个优点，包括多路复用（多个设备可以同时在网络上发送数据），快速通知网络上可能发生的错误，拥塞控制和动态重路由。
- en: 'Protocols may call upon other protocols to handle their packets for them; passing
    their packets to the second protocol for delivery. When both the protocols employ
    packetization, nested packets result, as shown in the following figure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可能调用其他协议来处理它们的数据包；将它们的数据包传递给第二个协议进行传递。当两个协议都使用数据包化时，会产生嵌套数据包，如下图所示：
- en: '![Packets](graphics/6008OS_01_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![数据包](graphics/6008OS_01_02.jpg)'
- en: This is called **encapsulation**, and as we'll see shortly, it is a powerful
    mechanism for structuring network traffic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**封装**，正如我们很快将看到的，这是一种构造网络流量的强大机制。
- en: Networks
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: A network is a discrete collection of connected network devices. Networks can
    vary greatly in scale, and they can be made up of smaller networks. Your network-connected
    devices at home or the network-connected computers in a large office building
    are examples of networks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一组连接的网络设备。网络的规模可以有很大的差异，它们可以由较小的网络组成。您家中连接到网络的设备或大型办公楼中连接到网络的计算机都是网络的例子。
- en: There are quite a few ways of defining a network, some loose, some very specific.
    Depending on the context, networks can be defined by physical boundaries, administrative
    boundaries, institutional boundaries, or network technology boundaries.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种定义网络的方法，有些宽泛，有些非常具体。根据上下文，网络可以由物理边界、管理边界、机构边界或网络技术边界来定义。
- en: For this section, we're going to start with a simplified definition of a network,
    and then work toward a more specific definition, in the form of IP subnets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从网络的简化定义开始，然后逐渐朝着更具体的IP子网定义发展。
- en: So for our simplified definition, our common defining feature of a network will
    be that all devices on the network share a single point of connection to the rest
    of the Internet. In some large or specialized networks, you will find that there
    is more than one point of connection, but for the sake of simplicity we'll stick
    to a single connection here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们简化的定义，网络的共同特征将是网络上的所有设备共享与互联网的单一连接点。在一些大型或专业网络中，您会发现有多个连接点，但为了简单起见，我们将在这里坚持单一连接。
- en: This connection point is called a **gateway,** and usually it takes the form
    of a special network device called a **router**. The job of a router is to direct
    traffic between networks. It sits between two or more networks and is said to
    sit at the boundary of these networks. It always has two or more network interfaces;
    one for each network it is attached to. A router contains a set of rules called
    a **routing table,** which tells it how to direct the packets that are passing
    through it onwards, based on the packets' destination IP addresses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个连接点被称为**网关**，通常采用一种称为**路由器**的特殊网络设备的形式。路由器的工作是在网络之间传输流量。它位于两个或多个网络之间，并且被称为位于这些网络的边界。它总是有两个或更多个网络接口；每个网络都连接一个。路由器包含一组称为**路由表**的规则，告诉它如何根据数据包的目标IP地址将通过它传递的数据包进一步传递。
- en: The gateway forwards the packets to another router, which is said to be **upstream**,
    and is usually located at the network's **Internet Service Provider** (**ISP**).
    The ISP's router falls into a second category of routers, that is, it sits outside
    the networks described earlier, and routes traffic between network gateways. These
    routers are run by ISPs and other communications entities. They are generally
    arranged in tiers, and the upper regional tiers route the traffic for some large
    sections of countries or continents and form the Internet's backbone.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 网关将数据包转发到另一个路由器，该路由器被称为**上游**，通常位于网络的**互联网服务提供商**（**ISP**）处。ISP的路由器属于第二类路由器，即它位于前面描述的网络之外，并在网络网关之间路由流量。这些路由器由ISP和其他通信实体运行。它们通常按层次排列，上层区域路由器为一些大片国家或大陆的流量路由，并形成互联网的骨干网。
- en: 'Because these routers can sit between many networks, their routing tables can
    become very extensive and they need to be updated continuously. A simplified illustration
    is shown in the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些路由器可以位于许多网络之间，它们的路由表可能会变得非常庞大，并且需要不断更新。下图显示了一个简化的示例：
- en: '![Networks](graphics/6008OS_01_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![网络](graphics/6008OS_01_03.jpg)'
- en: The preceding diagram gives us an idea of the arrangement. Each ISP gateway
    connects an ISP network to the regional routers, and each home broadband router
    has a home network connected to it. In the real world, this arrangement gets more
    complicated as one goes toward the top. ISPs will often have more than one gateway
    connecting them to the regional routers, and some of these will also themselves
    be acting as regional routers. Regional routers also have more tiers than shown
    here, and they have many connections between one another, which are in arrangements
    that are much more complicated than this simple hierarchy. A rendering of a section
    of the Internet from data gathered in 2005 provides a beautiful illustration of
    just how complex this becomes, it can be found at [http://en.wikipedia.org/wiki/Internet_backbone#/media/File:Internet_map_1024.jpg](http://en.wikipedia.org/wiki/Internet_backbone#/media/File:Internet_map_1024.jpg).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表给了我们一个布局的想法。每个ISP网关连接ISP网络到区域路由器，每个家庭宽带路由器都连接着一个家庭网络。在现实世界中，随着向顶部前进，这种布局变得更加复杂。ISP通常会有多个连接它们到区域路由器的网关，其中一些也会充当区域路由器。区域路由器的层次也比这里显示的更多，它们之间有许多连接，这些连接的布局比这个简单的层次结构复杂得多。从2005年收集的数据中得出的互联网部分的渲染提供了一个美丽的插图，展示了这种复杂性，可以在[http://en.wikipedia.org/wiki/Internet_backbone#/media/File:Internet_map_1024.jpg](http://en.wikipedia.org/wiki/Internet_backbone#/media/File:Internet_map_1024.jpg)找到。
- en: Routing with IP
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用IP进行路由
- en: We mentioned that routers are able to route traffic toward a destination network,
    and implied that this is somehow done by using IP addresses and routing tables.
    But what's really going on here?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到路由器能够将流量路由到目标网络，并暗示这是通过使用IP地址和路由表来完成的。但这里真正发生了什么呢？
- en: One perhaps obvious method for routers to determine the correct router to forward
    traffic to would be to program every router's routing table with a route for every
    IP address. However, in practice, with 4 billion plus IP addresses and constantly
    changing network routes, this turns out to be a completely infeasible method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器确定要转发流量到正确路由器的一种明显的方法可能是在每个路由器的路由表中为每个IP地址编程一个路由。然而，在实践中，随着40多亿个IP地址和不断变化的网络路由，这种方法被证明是完全不可行的。
- en: 'So, how is routing done? The answer lies in another property of IP addresses.
    An IP address can be interpreted as being made up of two logical parts: a **network
    prefix** and a **host identifier**. The network prefix uniquely identifies the
    network a device is on, and the device can use this to determine how to handle
    traffic that it generates, or receives for forwarding. The network prefix is the
    first *n* bits of the IP address when it''s written out in binary (remember an
    IP address is really just a 32-bit number). The *n* bits are supplied by the network
    administrator as a part of a device''s network configuration at the same time
    that it is given its IP address.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，路由是如何完成的？答案在IP地址的另一个属性中。IP地址可以被解释为由两个逻辑部分组成：**网络前缀**和**主机标识符**。网络前缀唯一标识设备所在的网络，设备可以使用这个来确定如何处理它生成的流量，或者接收到的用于转发的流量。当IP地址以二进制形式写出时（记住IP地址实际上只是一个32位的数字），网络前缀是IP地址的前*n*位。这*n*位由网络管理员作为设备的网络配置的一部分提供，同时也提供了IP地址。
- en: 'You''ll see that *n* is written in one of two ways. It can simply be appended
    to the IP address, separated by a slash, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到*n*以两种方式之一写出。它可以简单地附加到IP地址后面，用斜杠分隔，如下所示：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is called **CIDR notation**. Alternatively, it can be written as a **subnet
    mask**, which is sometimes just called a **netmask**. This is the way in which
    you will usually see *n* being specified in a device's network configuration.
    A subnet mask is a 32-bit number written in dot-decimal notation, just like an
    IP address.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**CIDR表示法**。或者，它可以被写成**子网掩码**，有时也被称为**网络掩码**。这通常是在设备的网络配置中指定*n*的方式。子网掩码是一个以点十进制表示的32位数字，就像IP地址一样。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This subnet mask is equivalent to `/24`. We get *n* from it by looking at it
    in binary. A few examples are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子网掩码等同于`/24`。我们可以通过将其转换为二进制来得到*n*。以下是一些例子：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*n* is simply the number of 1 bits in the subnet mask. (It''s always the leftmost
    bits that are set to 1 because this allows us to quickly get the Network prefix
    in binary by doing a bitwise `AND` operation on the IP address and the subnet
    mask).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*只是子网掩码中设置为1的位数。（总是设置为1的最左边的位，因为这使我们可以通过对IP地址和子网掩码进行按位`AND`操作来快速得到二进制中的网络前缀）。'
- en: So, how does this help in routing? When a network device generates network traffic
    that needs to be sent across a network, it first compares the destination's IP
    address with its own network prefix. If the destination IP address has the same
    network prefix as that of the sending device, then the sending device will recognise
    that the destination device is on the same network and, therefore, it can then
    send the traffic directly to it. If the network prefixes differ, then it will
    send the message to its default gateway, which will forward it on towards the
    receiving device.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这如何帮助路由？当网络设备生成需要发送到网络的网络流量时，它首先将目的地的IP地址与自己的网络前缀进行比较。如果目的地IP地址与发送设备的网络前缀相同，那么发送设备将认识到目的设备在同一网络上，因此可以直接将流量发送到目的地。如果网络前缀不同，那么它将将消息发送到默认网关，后者将将其转发到接收设备。
- en: When a router receives traffic that has to be forwarded, it first checks whether
    the destination IP address matches the network prefix of any of the networks that
    it's connected to. If that is the case, then it will send the message directly
    to the destination device on that network. If not, it will consult its routing
    table. If it finds a matching rule, then it sends the message to the router that
    it found listed, and if there are no explicit rules defined, then it will send
    the traffic to its own default gateway.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器接收到需要转发的流量时，它首先检查目的地IP地址是否与它连接到的任何网络的网络前缀匹配。如果是这样，它将直接将消息发送到该网络上的目的设备。如果不是，它将查看其路由表。如果找到匹配的规则，它将将消息发送到列出的路由器，如果没有明确的规则定义，它将将流量发送到自己的默认网关。
- en: 'When we create a network with a given network prefix, in the 32-bits of the
    IP address, the digits to the right of the network prefix are available for assignment
    to the network devices. We can calculate the number of the available addresses
    by raising 2 to the power of the number of available bits. For example, in a `/28`
    network prefix, we have 4 bits left, which means that 16 addresses are available.
    In reality, we are able to assign fewer addresses, since two of the addresses
    in the calculated range are always reserved. These are: the first address in the
    range, which is called the **network address** and the last address in the range,
    which is called the **broadcast address**.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用给定的网络前缀创建一个网络时，在IP地址的32位中，网络前缀右侧的数字可用于分配给网络设备。我们可以通过将2的幂次方提高到可用位数来计算可用地址的数量。例如，在`/28`网络前缀中，我们有4位剩下，这意味着有16个地址可用。实际上，我们能够分配更少的地址，因为计算范围中的两个地址总是保留的。这些是：范围中的第一个地址，称为**网络地址**和范围中的最后一个地址，称为**广播地址**。
- en: This range of addresses, which is identified by its network prefix, is called
    a **subnet**. Subnets are the basic unit of assignment when IANA, an RIR or an
    ISP allocates IP address blocks to organizations. Organizations assign subnets
    to their various networks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地址范围，由其网络前缀标识，被称为**子网**。当IANA、RIR或ISP向组织分配IP地址块时，子网是分配的基本单位。组织将子网分配给它们的各种网络。
- en: Organizations can further partition their addresses into subnets simply by employing
    a longer network prefix than the one they had been assigned. They might do this
    either to make more efficient use of their addresses or to create a hierarchy
    of networks, which can be delegated across the organization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可以通过使用比他们分配的更长的网络前缀来将他们的地址进一步分区。他们可能这样做是为了更有效地使用他们的地址，或者创建一个网络层次结构，可以在整个组织中委派。
- en: DNS
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS
- en: We've discussed connecting to network devices by using IP addresses. However,
    unless you work with networks or in systems administration, it is unlikely that
    you will get to see an IP address very often, even though many of us use the Internet
    every day. When we browse the web or send an e-mail, we usually connect to servers
    using host names or domain names. These must somehow map to the servers' IP addresses.
    But how is this done?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用IP地址连接到网络设备。但是，除非您在网络或系统管理中工作，否则您很少会经常看到IP地址，尽管我们中的许多人每天都使用互联网。当我们浏览网页或发送电子邮件时，我们通常使用主机名或域名连接到服务器。这些必须以某种方式映射到服务器的IP地址。但是这是如何完成的呢？
- en: Documented as RFC 1035, the **Domain Name System** (**DNS**) is a globally distributed
    database of mappings between hostnames and IP addresses. It is an open and hierarchical
    system with many organizations choosing to run their own DNS servers. DNS is also
    a protocol, which devices use to query DNS servers for resolving hostnames to
    IP addresses (and vice-versa).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为RFC 1035记录的**域名系统**（**DNS**）是主机名和IP地址之间映射的全球分布式数据库。它是一个开放和分层的系统，许多组织选择运行自己的DNS服务器。DNS也是一种协议，设备使用它来查询DNS服务器以将主机名解析为IP地址（反之亦然）。
- en: 'The `nslookup` tool comes with most Linux and Windows systems and it lets us
    query DNS on the command line, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`nslookup`工具随大多数Linux和Windows系统一起提供，并允许我们在命令行上查询DNS，如下所示：'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we determined that the `python.org` host has the IP address `104.130.42.121`.
    DNS distributes the work of looking up hostnames by using an hierarchical system
    of caching servers. When connecting to a network, your network device will be
    given a local DNS server through either DHCP or manually, and it will query this
    local server when doing DNS lookups. If that server doesn't know the IP address,
    then it will query its own configured higher tier server, and so on until an answer
    can be found. ISPs run their own DNS caching servers, and broadband routers often
    act as caching servers as well. In this example, my device's local server is `192.168.0.4`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们确定`python.org`主机的IP地址为`104.130.42.121`。DNS通过使用分层的缓存服务器系统来分发查找主机名的工作。连接到网络时，您的网络设备将通过DHCP或手动方式获得本地DNS服务器，并在进行DNS查找时查询此本地服务器。如果该服务器不知道IP地址，那么它将查询自己配置的更高层服务器，依此类推，直到找到答案。ISP运行其自己的DNS缓存服务器，宽带路由器通常也充当缓存服务器。在此示例中，我的设备的本地服务器是`192.168.0.4`。
- en: A device's operating system usually handles DNS, and it provides a programming
    interface, which applications use to ask it to resolve hostnames and IP addresses.
    Python provides an interface for this, which we'll discuss in [Chapter 6](ch06.html
    "Chapter 6. IP and DNS"), *IP and DNS*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的操作系统通常处理DNS，并提供编程接口，应用程序使用该接口来请求解析主机名和IP地址。Python为此提供了一个接口，我们将在[第6章](ch06.html
    "第6章。IP和DNS")中讨论*IP和DNS*。
- en: The protocol stack or why the Internet is like a cake
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议栈或为什么互联网就像蛋糕
- en: The Internet Protocol is a member of the set of protocols that make up the Internet
    protocol suite. Each protocol in the suite has been designed to solve specific
    problems in networking. We just saw how IP solves the problems of addressing and
    routing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议是互联网协议套件中的一种协议。套件中的每个协议都设计用于解决网络中的特定问题。我们刚刚看到IP如何解决寻址和路由问题。
- en: The core protocols in the suite are designed to work together within a stack.
    That is, each protocol occupies a layer within the stack, and the other protocols
    are situated above and below that layer. So, it is layered just like a cake. Each
    layer provides a specific service to the layers above it, while hiding the complexity
    of its own operation from them, following the principle of encapsulation. Ideally,
    each layer only interfaces with the layer below it in order to benefit from the
    entire range of the problem solving powers of all the layers below.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 套件中的核心协议被设计为在堆栈内一起工作。也就是说，套件中的每个协议都占据堆栈内的一层，并且其他协议位于该层的上方和下方。因此，它就像蛋糕一样分层。每一层为其上面的层提供特定的服务，同时隐藏其自身操作的复杂性，遵循封装的原则。理想情况下，每一层只与其下面的层进行接口，以便从下面的所有层的问题解决能力中获益。
- en: Python provides modules for interfacing with different protocols. As the protocols
    employ encapsulation, we typically only need to work with one module to leverage
    the power of the underlying stack, thus avoiding the complexity of the lower layers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了用于与不同协议进行接口的模块。由于协议采用封装，我们通常只需要使用一个模块来利用底层堆栈的功能，从而避免了较低层的复杂性。
- en: 'The TCP/IP Suite defines four layers, although five layers are often used for
    clarity. These are given in the following table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP套件定义了四层，尽管通常为了清晰起见使用五层。这些列在下表中：
- en: '| Layer | Name | Example protocols |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 层 | 名称 | 示例协议 |'
- en: '| --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 5 | Application layer | HTTP, SMTP, IMAP |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 应用层 | HTTP，SMTP，IMAP |'
- en: '| 4 | Transport layer | TCP, UDP |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 传输层 | TCP，UDP |'
- en: '| 3 | Network layer | IP |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 网络层 | IP |'
- en: '| 2 | Data-link layer | Ethernet, PPP, FDDI |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 数据链路层 | 以太网，PPP，FDDI |'
- en: '| 1 | Physical layer | - |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 物理层 | - |'
- en: Layers 1 and 2 correspond to the first layer of the TCP/IP suite. These two
    bottom layers deal with the low level network infrastructure and services.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 层1和层2对应于TCP/IP套件的第一层。这两个底层处理低级网络基础设施和服务。
- en: Layer 1 corresponds to the physical media of the network, such as a cable or
    a Wi-Fi radio. Layer 2 provides the service of getting the data from one network
    device to another, directly connected network device. This layer can employ all
    sorts of layer 2 protocols, such as Ethernet or PPP, as long as the Internet Protocol
    in layer 3 can ask it to get the data to the next device in the network by using
    any type of available physical medium.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第1层对应于网络的物理介质，例如电缆或Wi-Fi无线电。第2层提供了将数据从一个网络设备直接连接到另一个网络设备的服务。只要第3层的互联网协议可以要求它使用任何可用的物理介质将数据传输到网络中的下一个设备，此层可以使用各种第2层协议，例如以太网或PPP。
- en: We don't need to concern ourselves with the two lowest layers, since we will
    rarely need to interface with them when using Python. Their operation is almost
    always handled by the operating system and the network hardware.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Python时，我们不需要关注最低的两层，因为我们很少需要与它们进行交互。它们的操作几乎总是由操作系统和网络硬件处理。
- en: Layer 3 is variously called the Network layer and the Internet layer. It exclusively
    employs the Internet Protocol. As we have already seen, it has been tasked primarily
    with internetwork addressing and routing. Again, we don't typically directly interface
    with this layer in Python.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第3层有时被称为网络层和互联网层。它专门使用互联网协议。正如我们已经看到的，它的主要任务是进行互联网寻址和路由。同样，在Python中我们通常不直接与这一层进行交互。
- en: Layers 4 and 5 are more interesting for our purposes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第4层和第5层对我们的目的更有趣。
- en: Layer 4 – TCP and UDP
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4层 - TCP和UDP
- en: 'Layer 4 is the first layer that we may want to work with in Python. This layer
    can employ one of two protocols: the **Transmission Control Protocol** (**TCP**)
    and the **User Datagram Protocol** (**UDP**). Both of these provide the common
    service of end-to-end transportation of data between applications on different
    network devices.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 第4层是我们可能想要在Python中使用的第一层。这一层可以使用两种协议之一：**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）。这两种协议都提供了在不同网络设备上的应用程序之间端到端数据传输的常见服务。
- en: Network ports
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络端口
- en: Although IP facilitates the transport of data from one network device to another,
    it doesn't provide us with a way of letting the destination device know what it
    should do with the data once it receives it. One possible solution to this would
    be to program every process running on the destination device to check all of
    the incoming data to see if they are interested in it, but this would quickly
    lead to obvious performance and security problems.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IP促进了数据从一个网络设备传输到另一个网络设备，但它并没有为我们提供一种让目标设备知道一旦接收到数据应该做什么的方法。解决这个问题的一个可能方案是编写运行在目标设备上的每个进程，以检查所有传入的数据，看看它们是否感兴趣，但这很快会导致明显的性能和安全问题。
- en: TCP and UDP provide the answer by introducing the concept of **ports**. A port
    is an endpoint, which is attached to one of the IP addresses assigned to the network
    device. Ports are claimed by a process running on the device, and the process
    is then said to be **listening** on that port. Ports are represented by a 16-bit
    number, so that each IP address on a device has 65,535 possible ports that the
    processes can claim (port number 0 is reserved). Ports can only be claimed by
    one process at a time, even though a process can claim more than one port at a
    time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP通过引入**端口**的概念提供了答案。端口是一个端点，附加到网络设备分配的IP地址之一。端口由设备上运行的进程占用，然后该进程被称为在该端口上**监听**。端口由一个16位数字表示，因此设备上的每个IP地址都有65,535个可能的端口，进程可以占用（端口号0被保留）。端口一次只能被一个进程占用，尽管一个进程可以同时占用多个端口。
- en: When a message is sent over the network through TCP or UDP, the sending application
    sets the destination port number in the header of the TCP or UDP packet. When
    the message arrives at the destination, the TCP or UDP protocol implementation
    running on the receiving device reads the port number and then delivers the message
    payload to the process that is listening on that port.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过TCP或UDP在网络上传送消息时，发送应用程序在TCP或UDP数据包的标头中设置目标端口号。当消息到达目的地时，运行在接收设备上的TCP或UDP协议实现读取端口号，然后将消息有效载荷传递给在该端口上监听的进程。
- en: Port numbers need to be known before the messages are sent. The main mechanism
    for this is convention. In addition to managing the IP address space, it is also
    the responsibility of IANA to manage the assignment of port numbers to network
    services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送消息之前，需要知道端口号。这主要是通过约定来实现的。除了管理IP地址空间外，IANA还负责管理端口号分配给网络服务。
- en: A service is a class of application, for example a web server, or a DNS server,
    which is usually tied to an application protocol. Ports are assigned to services
    rather than specific applications, because it gives service providers the flexibility
    to choose what kind of software they want to use to provide a service, without
    having to worry about the users who would need to look up and connect to a new
    port number simply because the server has started using Apache instead of IIS,
    for example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一类应用程序，例如Web服务器或DNS服务器，通常与应用程序协议相关联。端口分配给服务而不是特定的应用程序，因为这样可以让服务提供者灵活选择要使用的软件类型来提供服务，而不必担心用户需要查找和连接到新的端口号，仅仅是因为服务器开始使用Apache而不是IIS，例如。
- en: Most operating systems contain a copy of this list of services and their assigned
    port numbers. On Linux, this is usually found at `/etc/services`, and on Windows
    this is usually found at `c:\windows\system32\drivers\etc\services`. The complete
    list can also be viewed online at [http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都包含了这个服务列表及其分配的端口号的副本。在Linux上，通常可以在`/etc/services`找到，在Windows上，通常可以在`c:\windows\system32\drivers\etc\services`找到。完整的列表也可以在[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)上在线查看。
- en: TCP and UDP packet headers may also include a **source port** number. This is
    optional for UDP, but mandatory for TCP. The source port number tells the receiving
    application on the server where it should send replies to when sending data back
    to the client. Applications can specify the source port that they wish to use,
    or if a source port has not been specified for TCP, then one is assigned randomly
    by the operating system when the packet is sent. Once the OS has a source port
    number, it assigns it to the calling application and starts listening on it for
    a reply. If a reply is received on that port, then the received data is passed
    to the sending application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP数据包头也可能包括**源端口**号。对于UDP来说，这是可选的，但对于TCP来说是强制的。源端口号告诉服务器上的接收应用程序在向客户端发送数据时应该将回复发送到哪里。应用程序可以指定它们希望使用的源端口，或者如果没有为TCP指定源端口，则在发送数据包时操作系统会随机分配一个。一旦操作系统有了源端口号，它就会将其分配给调用应用程序，并开始监听以获取回复。如果在该端口上收到回复，则接收到的数据将传递给发送应用程序。
- en: So, both TCP and UCP provide an end-to-end transport for the application data
    through the provision of ports, and both of them employ the Internet Protocol
    to get the data to the destination device. Now, let's look at their features.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TCP和UCP都通过提供端口为应用程序数据提供端到端的传输，并且它们都使用互联网协议将数据传输到目标设备。现在，让我们来看看它们的特点。
- en: UDP
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDP
- en: 'UDP is documented as RFC 768\. It is deliberately uncomplicated: it provides
    no services other than those that we described in the previous section. It just
    takes the data that we want to send, packetizes it with the destination port number
    (and optional source port number), and hands it off to the local Internet Protocol
    implementation for delivery. Applications on the receiving end see the data in
    the same discrete chunks in which it was packetized.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: UDP的文档编号为RFC 768。它故意简单：它除了我们在前一节中描述的服务之外，不提供任何服务。它只是获取我们要发送的数据，使用目标端口号（和可选的源端口号）对其进行数据包化，并将其交给本地互联网协议实现进行传递。接收端的应用程序以与数据包化时相同的离散块看到数据。
- en: Both IP and UDP are what are called connectionless protocols. This means that
    they attempt to deliver their packets on a best effort basis, but if something
    goes wrong, then they will just shrug their metaphorical shoulders and move on
    to delivering the next packet. There is no guarantee that our packets will reach
    their destinations, and no error notification if a delivery fails. If the packets
    do make it, then there is no guarantee that they will do so in the same order
    as they were sent. It's up to a higher layer protocol or the sending application
    to determine if the packets have arrived and whether to handle any problems. These
    are protocols in the fire-and-forget style.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: IP和UDP都是所谓的无连接协议。这意味着它们试图尽最大努力交付它们的数据包，但如果出现问题，它们将只是耸耸肩并继续交付下一个数据包。我们的数据包到达目的地的保证，并且如果交付失败，也没有错误通知。如果数据包成功到达，也不能保证它们会按照发送顺序到达。这取决于更高层的协议或发送应用程序来确定数据包是否已到达以及如何处理任何问题。这些是一种“发射即忘”的协议。
- en: The typical applications of UDP are internet telephony and video streaming.
    DNS queries are also transported using UDP.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: UDP的典型应用是互联网电话和视频流。DNS查询也使用UDP进行传输。
- en: We'll now look at UDP's more dependable sibling, TCP, and then discuss the differences,
    and why applications may choose to use one or the other.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一下UDP的更可靠的兄弟TCP，然后讨论它们之间的区别，以及应用程序可能选择使用其中一个的原因。
- en: TCP
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP
- en: The Transmission Control Protocol is documented as RFC 761\. As opposed to UDP,
    TCP is a connection based protocol. In such a protocol, no data is sent until
    the server and the client have performed an initial exchange of control packets.
    This exchange is called a **handshake**. This establishes a connection, and from
    then on data can be sent. Each data packet that is received is acknowledged by
    the receiving party, and it does so by sending a packet called an **ACK**. As
    such, TCP always requires that the packets include a source port number, because
    it depends on the continual two-way exchange of messages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议的文档编号为RFC 761。与UDP相反，TCP是一种基于连接的协议。在这种协议中，直到服务器和客户端执行了初始的控制数据包交换之前，才会发送数据。这种交换被称为**握手**。这建立了一个连接，从那时起就可以发送数据。接收到的每个数据包都会得到接收方的确认，它通过发送一个称为**ACK**的数据包来进行确认。因此，TCP总是要求数据包包括源端口号，因为它依赖于持续的双向消息交换。
- en: From an application's point of view, the key difference between UDP and TCP
    is that the application no longer sees the data in discrete chunks; the TCP connection
    presents the data to the application as a continuous, seamless stream of bytes.
    This makes things much simpler if we are sending messages that are larger than
    a typical packet, however it means that we need to start thinking about *framing*
    our messages. While with UDP, we can rely on its packetization to provide a means
    of doing this, with TCP we must decide a mechanism for unambiguously determining
    where our messages start and end. We'll see more about this in [Chapter 8](ch08.html
    "Chapter 8. Client and Server Applications"), *Client and Server Applications*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序的角度来看，UDP和TCP之间的关键区别是应用程序不再以离散的块看到数据；TCP连接将数据呈现给应用程序作为连续的、无缝的字节流。如果我们发送的消息大于典型的数据包，这会使事情变得简单得多，但这意味着我们需要开始考虑*帧*我们的消息。虽然使用UDP，我们可以依赖其数据包化来提供这样的手段，但是使用TCP，我们必须决定一个机制来明确地确定我们的消息从哪里开始和结束。我们将在[第8章](ch08.html
    "第8章。客户端和服务器应用程序")中看到更多关于这一点，“客户端和服务器应用程序”。
- en: 'TCP provides the following services:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: TCP提供以下服务：
- en: In-order delivery
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序交付
- en: Receipt acknowledgment
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收确认
- en: Error detection
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误检测
- en: Flow and congestion control
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流和拥塞控制
- en: Data sent through TCP is guaranteed to get delivered to the receiving application
    in the order that it was sent in. The receiving TCP implementation buffers the
    received packets on the receiving device and then waits until it can deliver them
    in the correct order before passing them to the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TCP发送的数据保证按发送顺序传递到接收应用程序。接收TCP实现在接收设备上缓冲接收的数据包，然后等待直到能够按正确顺序传递它们给应用程序。
- en: Because the data packets are acknowledged, sending applications can be sure
    that the data is arriving and that it is okay to continue sending the data. If
    an ACK is not received for a sent packet, then within a set time period the packet
    will be resent. If there's still no response, then TCP will keep resending the
    packet at increasing intervals, until a second, longer timeout period expires.
    At this point, it will give up and notify the calling application that it has
    encountered a problem.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据包被确认，发送应用程序可以确保数据正在到达，并且可以继续发送数据。如果发送的数据包没有收到确认，那么在一定时间内数据包将被重新发送。如果仍然没有响应，那么TCP将以递增的间隔不断重新发送数据包，直到第二个更长的超时期限到期。在这一点上，它将放弃并通知调用应用程序遇到了问题。
- en: The TCP header includes a checksum of the header data and the payload. This
    allows the receiver to verify whether a packet's contents have been modified during
    the transmission.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TCP头部包括头部数据和有效载荷的校验和。这允许接收方验证数据包的内容在传输过程中是否被修改。
- en: TCP also includes algorithms which ensure that traffic is not sent too quickly
    for the receiving device to process, and these algorithms also infer network conditions
    and regulate the transmission rate to avoid network congestion.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: TCP还包括算法，确保流量不会发送得太快，以至于接收设备无法处理，并且这些算法还推断网络条件并调节传输速率以避免网络拥塞。
- en: Together these services provide a robust and reliable transport system for application
    data. This is one of the reasons many popular higher level protocols, such as
    HTTP, SMTP, SSH, and IMAP, depend on TCP.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务共同为应用程序数据提供了强大可靠的传输系统。这是许多流行的高级协议（如HTTP、SMTP、SSH和IMAP）依赖TCP的原因之一。
- en: UDP versus TCP
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UDP与TCP
- en: Given the features of TCP, you may be wondering what the use of a connectionless
    protocol like UDP is. Well, the Internet is still a pretty reliable network, and
    most of the packets do get delivered. The connectionless protocols are useful
    where the minimum transfer overhead is required, and where the occasional dropped
    packet is not a big deal. TCP's reliability and congestion control comes at the
    cost of needing additional packets and round-trips, and the introduction of deliberate
    delays when packets are lost in order to prevent congestion. These can drastically
    increase latency, which is the arch-nemesis of real-time services, while not providing
    any real benefit for them. A few dropped packets might result in a transient glitch
    or a drop in signal quality in a media stream, but as long as the packets keep
    coming, the stream can usually recover.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于TCP的特性，您可能想知道无连接协议UDP的用途是什么。嗯，互联网仍然是一个相当可靠的网络，大多数数据包确实会被传递。无连接协议在需要最小传输开销和偶尔丢包不是大问题的情况下很有用。TCP的可靠性和拥塞控制需要额外的数据包和往返时间，并且在数据包丢失时引入故意的延迟以防止拥塞。这可能会大大增加延迟，这是实时服务的大敌，而对它们并没有提供任何真正的好处。一些丢失的数据包可能会导致媒体流中的瞬时故障或信号质量下降，但只要数据包继续到达，流通常可以恢复。
- en: UDP is also the main protocol that is used for DNS, which is interesting because
    most DNS queries fit inside a single packet, so TCP's streaming abilities aren't
    generally needed. DNS is also usually configured such that it does not depend
    upon a reliable connection. Most devices are configured with multiple DNS servers,
    and it's usually quicker to resend a query to a second server after a short timeout
    rather than wait for a TCP back-off period to expire.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: UDP也是用于DNS的主要协议，这很有趣，因为大多数DNS查询都适合在一个数据包内，因此通常不需要TCP的流能力。DNS通常也配置为不依赖于可靠的连接。大多数设备配置有多个DNS服务器，通常更快地重新发送查询到第二个服务器，而不是等待TCP的退避期限到期。
- en: The choice between UDP and TCP comes down to the message size, whether latency
    is an issue, and how much of TCP's functionality the application wants to perform
    itself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: UDP和TCP之间的选择取决于消息大小，延迟是否是一个问题，以及应用程序希望自己执行多少TCP功能。
- en: Layer 5 – The application layer
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5层 - 应用层
- en: Finally we come to the top of the stack. The application layer is deliberately
    left open in the IP protocol suite, and it's really a catch-all for any protocol
    that is developed by application developers on top of TCP or UDP (or even IP,
    though these are rarer). Application layer protocols include HTTP, SMTP, IMAP,
    DNS, and FTP.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们来到了堆栈的顶部。应用层在IP协议套件中被故意保持开放，它实际上是任何在TCP或UDP（甚至IP，尽管这些更少见）之上由应用程序开发人员开发的协议的综合。应用层协议包括HTTP、SMTP、IMAP、DNS和FTP。
- en: Protocols may even become their own layers, where an application protocol is
    built on top of another application protocol. An example of this is the **Simple
    Object Access Protocol** (**SOAP**), which defines an XML-based protocol that
    can be used over almost any transport, including HTTP and SMTP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 协议甚至可以成为它们自己的层，其中一个应用程序协议建立在另一个应用程序协议之上。一个例子是**简单对象访问协议**（**SOAP**），它定义了一种基于XML的协议，可以在几乎任何传输上使用，包括HTTP和SMTP。
- en: Python has standard library modules for many application layer protocols and
    third-party modules for many more. If we write low-level server applications,
    then we will be more likely to be interested in TCP and UDP, but if not, then
    application layer protocols are the ones we'll be working with, and we'll be looking
    at some of them in detail over the next few chapters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有许多应用层协议的标准库模块和许多第三方模块。如果我们编写低级服务器应用程序，那么我们更有可能对TCP和UDP感兴趣，但如果不是，那么应用层协议就是我们将要使用的协议，我们将在接下来的几章中详细讨论其中一些。
- en: On to Python!
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是Python！
- en: Well, that's it for our rundown of the TCP/IP stack. We'll move on to the next
    section of this chapter, where we'll look at how to start using Python and how
    to work with some of the topics we've just covered.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，关于TCP/IP栈的介绍就到此为止。我们将继续本章的下一部分，我们将看一下如何开始使用Python以及如何处理我们刚刚涵盖的一些主题。
- en: Network programming with Python
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络编程
- en: In this section, we're going to look at the general approach to network programming
    in Python. We'll look at how Python lets us interface with the network stack,
    how to track down useful modules, and cover some general network programming tips.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下Python中网络编程的一般方法。我们将看一下Python如何让我们与网络栈进行接口，如何追踪有用的模块，并涵盖一些一般的网络编程技巧。
- en: Breaking a few eggs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破一些蛋
- en: The power of the layer model of network protocols is that a higher layer can
    easily build on the services provided by the lower layers and this enables them
    to add new services to the network. Python provides modules for interfacing with
    protocols at different levels in the network stack, and modules that support higher-layer
    protocols follow the aforementioned principle by using the interfaces supplied
    by the lower level protocols. How can we visualize this?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议层模型的强大之处在于更高层可以轻松地建立在较低层提供的服务之上，这使它们能够向网络添加新的服务。Python提供了用于与网络栈中不同层级的协议进行接口的模块，而支持更高层协议的模块通过使用较低级别协议提供的接口来遵循前述原则。我们如何可以可视化这一点呢？
- en: Well, sometimes a good way to see inside something like this is by breaking
    it. So, let's break Python's network stack. Or, more specifically, let's generate
    a traceback.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，有时候看清楚这样的东西的一个好方法就是打破它。所以，让我们打破Python的网络栈。或者更具体地说，让我们生成一个回溯。
- en: 'Yes, this means that the first piece of Python that we''re going to write is
    going to generate an exception. But, it will be a good exception. We''ll learn
    from it. So, fire up your Python shell and run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这意味着我们要写的第一段Python将生成一个异常。但是，这将是一个好的异常。我们会从中学到东西。所以，启动你的Python shell并运行以下命令：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What are we doing here? We are importing `smtplib`, which is Python's standard
    library for working with the SMTP protocol. SMTP is an application layer protocol,
    which is used for sending e-mails. We will then try to open an SMTP connection
    by instantiating an `SMTP` object. We want the connection to fail and that is
    why we've specified the port number 66000, which is an invalid port. We will specify
    the local host for the connection, as this will cause it to fail quickly, rather
    than make it wait for a network timeout.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？我们正在导入`smtplib`，这是Python用于处理SMTP协议的标准库。SMTP是一个应用层协议，用于发送电子邮件。然后，我们将尝试通过实例化一个`SMTP`对象来打开一个SMTP连接。我们希望连接失败，这就是为什么我们指定了端口号66000，这是一个无效的端口。我们将为连接指定本地主机，因为这将导致它快速失败，而不是让它等待网络超时。
- en: 'On running the preceding command, you should get the following traceback:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令时，您应该会得到以下回溯：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This was generated by using Python 3.4.1 on a Debian 7 machine. The final error
    message will be slightly different from this if you run this on Windows, but the
    stack trace will remain the same.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Debian 7机器上使用Python 3.4.1生成的。如果你在Windows上运行这个命令，最终的错误消息将与此略有不同，但堆栈跟踪将保持不变。
- en: Inspecting it will reveal how the Python network modules act as a stack. We
    can see that the call stack starts in `smtplib.py`, and then as we go down, it
    moves into `socket.py`. The `socket` module is Python's standard interface for
    the transport layer, and it provides the functions for interacting with TCP and
    UDP as well as for looking up hostnames through DNS. We'll learn much more about
    this in [Chapter 7](ch07.html "Chapter 7. Programming with Sockets"), *Programming
    with Sockets*, and [Chapter 8](ch08.html "Chapter 8. Client and Server Applications"),
    *Client and Server Applications*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 检查它将揭示Python网络模块如何作为一个栈。我们可以看到调用栈从`smtplib.py`开始，然后向下移动到`socket.py`。`socket`模块是Python的标准接口，用于传输层，并提供与TCP和UDP的交互功能，以及通过DNS查找主机名的功能。我们将在[第7章](ch07.html
    "第7章。使用套接字编程")*使用套接字编程*和[第8章](ch08.html "第8章。客户端和服务器应用程序")*客户端和服务器应用程序*中学到更多。
- en: From the preceding program, it's clear that the `smtplib` module calls into
    the `socket` module. The application layer protocol has employed a transport layer
    protocol (which in this case is TCP).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的程序中可以清楚地看出，`smtplib`模块调用了`socket`模块。应用层协议已经使用了传输层协议（在本例中是TCP）。
- en: Right at the bottom of the traceback, we can see the exception itself and the
    `Errno 111`. This is an error message from the operating system. You can verify
    this by going through `/usr/include/asm-generic/errno.h` (`asm/errno.h` on some
    systems) for the error message number 111 (on Windows the error will be a WinError,
    so you can see that it has clearly been generated by the OS). From this error
    message we can see that the `socket` module is calling down yet again and asking
    the operating system to manage the TCP connection for it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在回溯的最底部，我们可以看到异常本身和`Errno 111`。这是操作系统的错误消息。您可以通过查看`/usr/include/asm-generic/errno.h`（某些系统上的`asm/errno.h`）来验证这一点，以获取错误消息编号111（在Windows上，错误将是WinError，因此您可以看到它显然是由操作系统生成的）。从这个错误消息中，我们可以看到`socket`模块再次调用并要求操作系统为其管理TCP连接。
- en: Python's network modules are working as the protocol stack designers intended
    them to. They call on the lower levels in the stack to employ their services to
    perform the network tasks. We can work by using simple calls made to the application
    layer protocol, which in this case is SMTP, without having to worry about the
    underlying network layers. This is network encapsulation in action, and we want
    to make as much use of this as we can in our applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python的网络模块正在按照协议栈设计者的意图工作。它们调用协议栈中的较低级别来利用它们的服务来执行网络任务。我们可以通过对应用层协议（在本例中为SMTP）进行简单调用来工作，而不必担心底层网络层。这就是网络封装的实际应用，我们希望在我们的应用程序中尽可能多地利用这一点。
- en: Taking it from the top
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从顶部开始
- en: Before we start writing code for a new network application, we want to make
    sure that we're taking as much advantage of the existing stack as possible. This
    means finding a module that provides an interface to the services that we want
    to use, and that is as high up the stack as we can find. If we're lucky, someone
    has already written a module that provides an interface that provides the exact
    service we need.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为新的网络应用程序编写代码之前，我们希望尽可能充分利用现有的堆栈。这意味着找到一个提供我们想要使用的服务接口的模块，并且尽可能高地找到。如果我们幸运的话，有人已经编写了一个提供我们需要的确切服务接口的模块。
- en: Let's use an example to illustrate this process. Let's write a tool for downloading
    **Request for Comments** (**RFC**) documents from IETF, and then display them
    on screen.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这个过程。让我们编写一个工具，用于从IETF下载**请求评论**（**RFC**）文档，然后在屏幕上显示它们。
- en: Let's keep the RFC downloader simple. We'll make it a command-line program that
    just accepts an RFC number, downloads the RFC in text format, and then prints
    it to `stdout`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持RFC下载器简单。我们将把它制作成一个命令行程序，只接受RFC编号，下载RFC的文本格式，然后将其打印到`stdout`。
- en: Now, it's possible that somebody has already written a module for doing this,
    so let's see if we can find anything.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有可能有人已经为此编写了一个模块，所以让我们看看能否找到任何东西。
- en: The first place we look should always be the Python standard library. The modules
    in the library are well maintained, and well documented. When we use a standard
    library module, the users of your application won't need to install any additional
    dependencies for running it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该总是首先查看Python标准库。标准库中的模块得到了很好的维护和文档化。当我们使用标准库模块时，您的应用程序的用户不需要安装任何额外的依赖项来运行它。
- en: A look through the *Library Reference* at [https://docs.python.org](https://docs.python.org)
    doesn't seem to show anything directly relevant to our requirement. This is not
    entirely surprising!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.python.org](https://docs.python.org)的*库参考*中查看，似乎没有显示与我们要求直接相关的内容。这并不完全令人惊讶！
- en: So, next we will turn to third-party modules. The Python package index, which
    can be found at [https://pypi.python.org](https://pypi.python.org), is the place
    where we should look for these. Here as well, running a few searches around the
    theme of RFC client and RFC download doesn't seem to reveal anything useful. The
    next place to look will be Google, though again, the searches don't reveal anything
    promising. This is slightly disappointing, but this is why we're learning network
    programming, to fill these gaps!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，接下来我们将转向第三方模块。可以在[https://pypi.python.org](https://pypi.python.org)找到Python软件包索引，这是我们应该寻找这些模块的地方。在这里，围绕RFC客户端和RFC下载主题运行几次搜索似乎没有发现任何有用的东西。下一个要查找的地方将是Google，尽管再次搜索没有发现任何有希望的东西。这有点令人失望，但这就是我们学习网络编程的原因，以填补这些空白！
- en: There are other ways in which we may be able to find out about useful third-party
    modules, including mailing lists, Python user groups, the programming Q&A site
    [http://stackoverflow.com](http://stackoverflow.com), and programming textbooks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以找到有用的第三方模块，包括邮件列表、Python用户组、编程问答网站[http://stackoverflow.com](http://stackoverflow.com)和编程教材。
- en: For now, let's assume that we really can't find a module for downloading RFCs.
    What next? Well, we need to think lower in the network stack. This means that
    we need to identify the network protocol that we'll need to use for getting hold
    of the RFCs in text format by ourselves.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们真的找不到一个用于下载RFC的模块。接下来呢？嗯，我们需要在网络堆栈中考虑更低的层次。这意味着我们需要自己识别我们需要使用的网络协议，以便以文本格式获取RFC。
- en: The IETF landing page for RFCs is [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html),
    and reading through it tell us exactly what we want to know. We can access a text
    version of an RFC using a URL of the form [http://www.ietf.org/rfc/rfc741.txt](http://www.ietf.org/rfc/rfc741.txt).
    The RFC number in this case is 741\. So, we can get text format of RFCs using
    HTTP.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: RFC的IETF登陆页面是[http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html)，通过阅读它告诉我们确切的信息。我们可以使用形式为[http://www.ietf.org/rfc/rfc741.txt](http://www.ietf.org/rfc/rfc741.txt)的URL访问RFC的文本版本。在这种情况下，RFC编号是741。因此，我们可以使用HTTP获取RFC的文本格式。
- en: Now, we need a module that can speak HTTP for us. We should look at the standard
    library again. You will notice that there is, in fact, a module called `http`.
    Sounds promising, though looking at its documentation will tell us that it's a
    low level library and that something called `urllib` will prove to be more useful.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个可以代表我们说HTTP的模块。我们应该再次查看标准库。您会注意到，实际上有一个名为`http`的模块。听起来很有希望，尽管查看其文档将告诉我们它是一个低级库，而名为`urllib`的东西将被证明更有用。
- en: Now, looking at the `urllib` documentation, we find that it does indeed do what
    we need. It downloads the target of a URL through a straightforward API. We've
    found our protocol module.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看`urllib`的文档，我们发现它确实可以做我们需要的事情。它通过一个简单的API下载URL的目标。我们找到了我们的协议模块。
- en: Downloading an RFC
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载RFC
- en: 'Now we can write our program. For this, create a text file called `RFC_downloader.py`
    and save the following code to it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的程序。为此，创建一个名为`RFC_downloader.py`的文本文件，并将以下代码保存到其中：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can run the preceding code by using the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行前面的代码：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On Windows, you'll need to use `more` instead of `less`. RFCs can run to many
    pages, hence we use a pager here. If you try this, then you should see some useful
    information on the remote control of coffee pots.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您需要使用`more`而不是`less`。RFC可能有很多页，因此我们在这里使用一个分页器。如果您尝试这样做，那么您应该会在咖啡壶的远程控制上看到一些有用的信息。
- en: Let's go through our code and look at what we've done so far.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们迄今为止所做的工作。
- en: First, we import our modules and check whether an RFC number has been supplied
    on the command line. Then, we construct our URL by substituting the supplied RFC
    number. Next, the main activity, the `urlopen()` call will construct an HTTP request
    for our URL, and then it will contact the IETF web server over the Internet and
    download the RFC text. Next, we decode the text to Unicode, and finally we print
    it out to screen.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的模块并检查命令行上是否提供了RFC编号。然后，我们通过替换提供的RFC编号来构造我们的URL。接下来，主要活动是`urlopen()`调用将为我们的URL构造一个HTTP请求，然后它将通过互联网联系IETF网络服务器并下载RFC文本。接着，我们将文本解码为Unicode，最后将其打印到屏幕上。
- en: So, we can easily view any RFC that we like from the command line. In retrospect,
    it's not entirely surprising that there isn't a module for this, because we can
    use `urllib` to do most of the hard work!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以轻松地从命令行查看任何我们喜欢的RFC。回顾起来，毫不奇怪没有一个模块可以做到这一点，因为我们可以使用`urllib`来完成大部分繁重的工作！
- en: Looking deeper
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解
- en: 'But, what if HTTP was brand new and there were no modules, such as `urllib`,
    which we could use to speak HTTP for us? Well, then we would have to step down
    the stack again and use TCP for our purposes. Let''s modify our program according
    to this scenario, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果HTTP是全新的，没有像`urllib`这样的模块可以代表我们发起HTTP请求，那该怎么办呢？那么我们将不得不再次向下调整堆栈，并使用TCP来实现我们的目的。让我们根据这种情况修改我们的程序，如下所示：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first noticeable change is that we have used `socket` instead of `urllib`.
    Socket is Python's interface for the operating system's TCP and UDP implementation.
    The command-line check remains the same, but then we will see that we now need
    to handle some of the things that `urllib` was doing for us before.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个显而易见的变化是我们使用了`socket`而不是`urllib`。Socket是Python操作系统TCP和UDP实现的接口。命令行检查保持不变，但接着我们会发现现在需要处理一些`urllib`之前为我们做的事情。
- en: We have to tell socket which transport layer protocol that we want to use. We
    do this by using the `socket.create_connection()` convenience function. This function
    will always create a TCP connection. You'll notice that we have to explicitly
    supply the TCP port number that `socket` should use to establish the connection
    as well. Why 80? 80 is the standard port number for web services over HTTP. We've
    also had to separate the host from the URL, since `socket` has no understanding
    of URLs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须告诉套接字我们想要使用哪种传输层协议。我们通过使用`socket.create_connection()`便利函数来实现这一点。这个函数将始终创建一个TCP连接。您会注意到我们还必须显式提供`socket`应该用来建立连接的TCP端口号。为什么是80？80是HTTP上的Web服务的标准端口号。我们还必须将主机与URL分开，因为`socket`不理解URL。
- en: 'The request string that we create to send to the server is also much more complicated
    than the URL that we used before: it''s a full HTTP request. In the next chapter,
    we''ll be looking at these in detail.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的发送到服务器的请求字符串也比我们之前使用的URL复杂得多：它是一个完整的HTTP请求。在下一章中，我们将详细讨论这些。
- en: Next, we deal with the network communication over the TCP connection. We send
    the entire request string to the server using the `sendall()` call. The data sent
    through TCP must be in raw bytes, so we have to encode the request text as ASCII
    before sending it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理TCP连接上的网络通信。我们使用`sendall()`调用将整个请求字符串发送到服务器。通过TCP发送的数据必须是原始字节，因此我们必须在发送之前将请求文本编码为ASCII。
- en: Then, we piece together the server's response as it arrives in the `while` loop.
    Bytes that are sent to us through a TCP socket are presented to our application
    in a continuous stream. So, like any stream of unknown length, we have to read
    it iteratively. The `recv()` call will return the empty string after the server
    sends all its data and closes the connection. Hence, we can use this as a condition
    for breaking out and printing the response.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`while`循环中将服务器的响应拼接在一起。通过TCP套接字发送给我们的字节以连续流的形式呈现给我们的应用程序。因此，就像任何长度未知的流一样，我们必须进行迭代读取。在服务器发送所有数据并关闭连接后，`recv()`调用将返回空字符串。因此，我们可以将其用作打破循环并打印响应的条件。
- en: 'Our program is clearly more complicated. Compared to our previous one, this
    is not good in terms of maintenance. Also, if you run the program and look at
    the start of the output RFC text, then you''ll notice that there are some extra
    lines at the beginning, and these are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序显然更加复杂。与我们之前的程序相比，这在维护方面并不好。此外，如果您运行程序并查看输出RFC文本的开头，您会注意到开头有一些额外的行，如下所示：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because we're now dealing with a raw HTTP protocol exchange, we're seeing the
    extra header data that HTTP includes in a response. This has a similar purpose
    to the lower-level packet headers. The HTTP header contains HTTP-specific metadata
    about the response that tells the client how to interpret it. Before, `urllib`
    parsed this for us, added the data as attributes to the response object, and removed
    the header data from the output data. We would need to add code to do this as
    well to make this program as capable as our first one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在正在处理原始的HTTP协议交换，我们看到了HTTP在响应中包含的额外头部数据。这与较低级别的数据包头部具有类似的目的。HTTP头部包含有关响应的HTTP特定元数据，告诉客户端如何解释它。以前，`urllib`为我们解析了这些数据，将数据添加为响应对象的属性，并从输出数据中删除了头部数据。为了使这个程序与我们的第一个程序一样强大，我们需要添加代码来完成这一点。
- en: What can't immediately be seen from the code is that we're also missing out
    on the `urllib` module's error checking and handling. Although low-level network
    errors will still generate exceptions, we will no longer catch any problems in
    the HTTP layer, which `urllib` would have done.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中无法立即看到的是，我们还错过了`urllib`模块的错误检查和处理。虽然低级网络错误仍会生成异常，但我们将不再捕获`urllib`本应捕获的HTTP层的任何问题。
- en: The `200` value in the first line of the aforementioned headers is an HTTP **status
    code,** which tells us whether there were any problems with the HTTP request or
    response. 200 means that everything went well, but other codes, such as the infamous
    404 'not found' can mean something went wrong. The `urllib` module would check
    these for us and raise an exception. But here, we need to handle these ourselves.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述标题的第一行中的“200”值是HTTP状态码，告诉我们HTTP请求或响应是否存在任何问题。200表示一切顺利，但其他代码，如臭名昭著的404“未找到”，可能意味着出现了问题。
    urllib模块会为我们检查这些并引发异常。但在这里，我们需要自己处理这些问题。
- en: So, there are clear benefits of using modules as far up the stack as possible.
    Our resulting programs will be less complicated, which will make them quicker
    to write, and easier to maintain. It also means that their error handling will
    be more robust, and we will benefit from the expertise of the modules' developers.
    Also, we benefit from the testing that the module would have undergone for catching
    unexpected and tricky edge-case problems. Over the next few chapters, we'll be
    discussing more modules and protocols that live at the top of the stack.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽可能在堆栈的顶部使用模块是有明显好处的。我们的最终程序将更简单，这将使它们更快地编写，并更容易维护。这也意味着它们的错误处理将更加健壮，并且我们将受益于模块开发人员的专业知识。此外，我们还将受益于模块为捕捉意外和棘手的边缘情况问题而经历的测试。在接下来的几章中，我们将讨论更多位于堆栈顶部的模块和协议。
- en: Programming for TCP/IP networks
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为TCP/IP网络编程
- en: 'To round up, we''re going to look at a few frequently encountered aspects of
    TCP/IP networks that can cause a lot of head-scratching for application developers
    who haven''t encountered them before. These are: firewalls, Network Address Translation,
    and some of the differences between IPv4 and IPv6.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下TCP/IP网络中经常遇到的一些方面，这些方面可能会让以前没有遇到过它们的应用程序开发人员感到困惑。这些是：防火墙，网络地址转换以及IPv4和IPv6之间的一些差异。
- en: Firewalls
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防火墙
- en: A firewall is a piece of hardware or software that inspects the network packets
    that flow through it and, based on the packet's properties, it filters what it
    lets through. It is a security mechanism for preventing unwanted traffic from
    moving from one part of a network to another. Firewalls can sit at network boundaries
    or can be run as applications on network clients and servers. For example, iptables
    is the de facto firewall software for Linux. You'll often find a firewall built
    into desktop anti-virus programs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙是一种硬件或软件，它检查流经它的网络数据包，并根据数据包的属性过滤它允许通过的内容。它是一种安全机制，用于防止不需要的流量从网络的一部分移动到另一部分。防火墙可以位于网络边界，也可以作为网络客户端和服务器上的应用程序运行。例如，iptables是Linux的事实防火墙软件。您经常会在桌面防病毒程序中找到内置防火墙。
- en: 'The filtering rules can be based on any property of the network traffic. The
    commonly used properties are: the transport layer protocol (that is, whether traffic
    uses TCP or UDP), the source and destination IP addresses, and the source and
    destination port numbers.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤规则可以基于网络流量的任何属性。常用的属性包括：传输层协议（即流量是否使用TCP或UDP）、源和目标IP地址以及源和目标端口号。
- en: A common filtering strategy is to deny all inbound traffic and only allow traffic
    that matches very specific parameters. For example, a company might have a web
    server it wants to allow access to from the Internet, but it wants to block all
    traffic from the Internet that is directed towards any of the other devices on
    its network. To do so, it would put a firewall directly in front of or behind
    its gateway, and then configure it to block all incoming traffic, except TCP traffic
    with the destination IP address of the web server, and the destination port number
    80 (since port 80 is the standard port number for the HTTP service).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的过滤策略是拒绝所有入站流量，并仅允许符合非常特定参数的流量。例如，一家公司可能有一个希望允许从互联网访问的Web服务器，但希望阻止来自互联网的所有流量，这些流量指向其网络中的任何其他设备。为此，它将在其网关的正面或背面直接放置一个防火墙，然后配置它以阻止所有传入流量，除了目标IP地址为Web服务器的TCP流量和目标端口号为80的流量（因为端口80是HTTP服务的标准端口号）。
- en: Firewalls can also block outbound traffic. This may be done to stop malicious
    software that finds its way onto internal network devices from calling home or
    sending spam e-mail.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙也可以阻止出站流量。这可能是为了阻止恶意软件从内部网络设备上找到家或发送垃圾邮件。
- en: Because firewalls block network traffic, they can cause obvious problems for
    network applications. When testing our applications over a network, we need to
    be sure that the firewalls that exist between our devices are configured such
    that they let our application's traffic through. Usually, this means that we need
    to make sure that the ports which we need are open on the firewall for the traffic
    between the source and the destination IP addresses to flow freely. This may take
    some negotiating with an IT support team or two, and maybe looking at our operating
    system's and local network router's documentation. Also, we need to make sure
    that our application users are aware of any firewall configuration that they need
    to perform in their own environments in order to make use of our program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因为防火墙阻止网络流量，它们可能会对网络应用程序造成明显的问题。在通过网络测试我们的应用程序时，我们需要确保存在于我们的设备之间的防火墙被配置为允许我们应用程序的流量通过。通常，这意味着我们需要确保我们需要的端口在防火墙上对源和目标IP地址之间的流量是开放的。这可能需要与IT支持团队进行一些协商，可能需要查看我们操作系统和本地网络路由器的文档。此外，我们需要确保我们的应用程序用户知道他们需要在自己的环境中执行任何防火墙配置，以便使用我们的程序。
- en: Network Address Translation
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络地址转换
- en: Earlier, we discussed private IP address ranges. While they are potentially
    very useful, they come with a small catch. Packets with source or destination
    addresses in the private ranges are forbidden from being routed over the public
    Internet! So, without some help, devices using private range addresses can't talk
    to devices using addresses on the public Internet. However, with **Network Address
    Translation** (**NAT**), we can solve this. Since most home networks use private
    range addresses, NAT is likely to be something that you'll encounter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们讨论了私有IP地址范围。虽然它们可能非常有用，但有一个小问题。源地址或目的地址在私有范围内的数据包被禁止在公共互联网上传输！因此，如果没有一些帮助，使用私有范围地址的设备无法与使用公共互联网上的地址的设备通信。然而，通过**网络地址转换**（**NAT**），我们可以解决这个问题。由于大多数家庭网络使用私有范围地址，NAT很可能是你会遇到的东西。
- en: Although NAT can be used in other circumstances, it is most commonly performed
    by a gateway at the boundary of the public Internet and a network that is using
    private range IP addresses. To enable the packets from the gateway's network to
    be routed on the public Internet as the gateway receives packets from the network
    that are destined for the Internet, it rewrites the packets' headers and replaces
    the private range source IP addresses with its own public range IP address. If
    the packets contain TCP or UDP packets, and these contain a source port, then
    it may also open up a new source port for listening on its external interface
    and rewrite the source port number in the packets to match this new number.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管NAT可以在其他情况下使用，但它最常见的用法是由一个位于公共互联网和使用私有范围IP地址的网络边界的网关执行。为了使来自网关网络的数据包在网关接收到发送到互联网的网络的数据包时能够在公共互联网上路由，它会重写数据包的头，并用自己的公共范围IP地址替换私有范围的源IP地址。如果数据包包含TCP或UDP数据包，并且这些数据包包含源端口，则它还可能在其外部接口上打开一个新的用于监听的源端口，并将数据包中的源端口号重写为匹配这个新号码。
- en: As it does these rewrites, it records the mapping between the newly opened source
    port and the source device on the internal network. If it receives a reply to
    the new source port, then it reverses the translation process and sends the received
    packets to the original device on the internal network. The originating network
    device shouldn't be made aware of the fact that its traffic is undergoing NAT.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些重写时，它记录了新打开的源端口与内部网络上的源设备之间的映射。如果它接收到对新源端口的回复，那么它会反转转换过程，并将接收到的数据包发送到内部网络上的原始设备。发起网络设备不应该意识到其流量正在经历NAT。
- en: There are several benefits of using NAT. The internal network devices are shielded
    from malicious traffic directed toward the network from the Internet, devices
    which use NAT devices are provided with a layer of privacy since their private
    addresses are hidden, and the number of network devices that need to be assigned
    precious public IP addresses is reduced. It's actually the heavy use of NAT that
    allows the Internet to continue functioning despite having run out of IPv4 addresses.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NAT有几个好处。内部网络设备免受来自互联网的恶意流量的侵害，使用NAT设备的设备由于其私有地址被隐藏而获得了一层隐私，需要分配宝贵的公共IP地址的网络设备数量减少。实际上，正是NAT的大量使用使得互联网在耗尽IPv4地址的情况下仍然能够继续运行。
- en: NAT can cause some problems for network's applications, if it is not taken into
    consideration at design time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在设计时没有考虑NAT，NAT可能会对网络应用程序造成一些问题。
- en: If the transmitted application data includes information about a device's network
    configuration and that device is behind a NAT router, then problems can occur
    if the receiving device acts on the assumption that the application data matches
    the IP and the TCP/UDP header data. NAT routers will rewrite the IP and TCP/UDP
    header data, but not the application data. This is a well known problem in the
    FTP protocol.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传输的应用程序数据包含有关设备网络配置的信息，并且该设备位于NAT路由器后面，那么如果接收设备假定应用程序数据与IP和TCP/UDP头数据匹配，就可能会出现问题。NAT路由器将重写IP和TCP/UDP头数据，但不会重写应用程序数据。这是FTP协议中一个众所周知的问题。
- en: Another problem that FTP has with NAT is that in FTP active mode, a part of
    the protocol operation involves the client opening a port for listening on, and
    the server creating a new TCP connection to that port (as opposed to just a regular
    reply). This fails when the client is behind a NAT router because the router doesn't
    know what to do with the server's connection attempt. So, be careful about assuming
    that servers can create new connections to clients, since they may be blocked
    by a NAT router, or firewall. In general, it's best to program under the assumption
    that it's not possible for a server to establish a new connection to a client.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: FTP与NAT的另一个问题是，在FTP主动模式中，协议操作的一部分涉及客户端打开一个用于监听的端口，服务器创建一个新的TCP连接到该端口（而不仅仅是一个常规的回复）。当客户端位于NAT路由器后面时，这将失败，因为路由器不知道如何处理服务器的连接尝试。因此，要小心假设服务器可以创建新的连接到客户端，因为它们可能会被NAT路由器或防火墙阻止。一般来说，最好根据这样的假设进行编程，即服务器无法与客户端建立新连接。
- en: IPv6
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6
- en: We mentioned that the earlier discussion is based on IPv4, but that there is
    a new version called IPv6\. IPv6 is ultimately designed to replace IPv4, but this
    process is unlikely to be completed for a while yet.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到早期的讨论是基于IPv4的，但有一个名为IPv6的新版本。IPv6最终被设计来取代IPv4，但这个过程可能要等一段时间才能完成。
- en: Since most Python standard library modules have now been updated to support
    IPv6 and to accept IPv6 addresses, moving to IPv6 in Python shouldn't have much
    impact on our applications. However, there are a few small glitches to watch out
    for.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数Python标准库模块现在已经更新以支持IPv6并接受IPv6地址，因此在Python中转移到IPv6对我们的应用程序不应该有太大影响。然而，还是有一些小问题需要注意。
- en: The main difference that you'll notice in IPv6 is that the address format has
    been changed. One of the main design goals of the new protocol was to alleviate
    the global shortage of IPv4 addresses and to prevent it from happening again the
    IETF quadrupled the length of an address, to 128 bits, creating a large enough
    address space to give each human on the planet a billion times as many addresses
    as there are in the entire IPv4 address space.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在IPv6中注意到的主要区别是地址格式已更改。新协议的主要设计目标之一是缓解IPv4地址的全球短缺，并防止再次发生，因此IETF将地址长度增加了四倍，达到128位，从而创建了足够大的地址空间，以便为地球上的每个人提供比整个IPv4地址空间中的地址多十亿倍的地址。
- en: 'The new format IP addresses are written differently, they look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 新格式的IP地址写法不同，看起来像这样：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the use of colons and hexadecimal format.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用冒号和十六进制格式。
- en: 'There are rules for writing IPv6 addresses in more compact forms as well. This
    is principally done by omitting runs of consecutive zeros. For example, the address
    in the preceding example could be shortened to:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些规则可以以更
- en: '[PRE13]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If a program needs to compare or parse text-formatted IPv6 addresses, then it
    will need to be made aware of these compacting rules, as a single IPv6 address
    can be represented in more than one way. Details of these rules can be found in
    RFC 4291, which is available at [http://www.ietf.org/rfc/rfc4291.txt](http://www.ietf.org/rfc/rfc4291.txt).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序需要比较或解析文本格式的IPv6地址，那么它将需要了解这些压缩规则，因为单个IPv6地址可以以多种方式表示。这些规则的详细信息可以在RFC 4291中找到，可在[http://www.ietf.org/rfc/rfc4291.txt](http://www.ietf.org/rfc/rfc4291.txt)上找到。
- en: 'Since colons may cause conflicts when used in URIs, IPv6 addresses need to
    be enclosed in square brackets when they are used in this manner, for example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于冒号可能在URI中使用时会引起冲突，因此在以这种方式使用时，IPv6地址需要用方括号括起来，例如：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Also, in IPv6, it is now standard practice for network interfaces to have multiple
    IP addresses assigned to them. IPv6 addresses are classified by what scope they
    are valid in. The scopes include the global scope (that is, the public Internet)
    and the link-local scope, which is only valid for the local subnet. An IP address's
    scope can be determined by inspecting its high-order bits. If we enumerate the
    IP addresses of local interfaces to use for a certain purpose, then we need to
    check if we have used the correct address for the scope that we intend to work
    with. There are more details in RFC 4291.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在IPv6中，网络接口现在标准做法是分配多个IP地址。IPv6地址根据其有效范围进行分类。范围包括全局范围（即公共互联网）和链路本地范围，仅对本地子网有效。可以通过检查其高阶位来确定IP地址的范围。如果我们枚举用于特定目的的本地接口的IP地址，那么我们需要检查我们是否使用了正确的地址来处理我们打算使用的范围。RFC
    4291中有更多细节。
- en: Finally, with the mind-boggling cornucopia of addresses that are available in
    IPv6, the idea is that every device (and component, and bacterium) can be given
    a globally unique public IP address, and NAT will become a thing of the past.
    Though it sounds great in theory, some concerns have been raised about the implications
    that this has for issues like user privacy. As such, additions designed for alleviating
    these concerns have been made to the protocol ([http://www.ietf.org/rfc/rfc3041.txt](http://www.ietf.org/rfc/rfc3041.txt)).
    This is a welcome progression; however, it can cause problems for some applications.
    So reading through the RFC is worth your while, if you're planning for your program
    to employ IPv6.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着IPv6中可用的地址数量之多，每个设备（和组件，和细菌）都可以被分配一个全球唯一的公共IP地址，NAT将成为过去。尽管在理论上听起来很棒，但一些人对这对用户隐私等问题的影响提出了一些担忧。因此，为缓解这些担忧而设计的附加功能已添加到协议中（[http://www.ietf.org/rfc/rfc3041.txt](http://www.ietf.org/rfc/rfc3041.txt)）。这是一个受欢迎的进展；然而，它可能会对一些应用程序造成问题。因此，如果您计划使用IPv6来使用您的程序，阅读RFC是值得的。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the first part of this chapter, we looked at the essentials of networking
    with TCP/IP. We discussed the concept of network stacks, and looked at the principle
    protocols of the Internet protocol suite. We saw how IP solves the problem of
    sending messages between devices on different networks, and how TCP and UDP provide
    end-to-end transport between applications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们看了一下使用TCP/IP进行网络的基本知识。我们讨论了网络堆栈的概念，并研究了互联网协议套件的主要协议。我们看到了IP如何解决在不同网络上的设备之间发送消息的问题，以及TCP和UDP如何为应用程序提供端到端的传输。
- en: In the second section, we looked at how network programming is generally approached
    when using Python. We discussed the general principle of using modules that interface
    with services as far up the network stack as we can manage. We also discussed
    where we might find those modules. We looked at examples of employing modules
    that interface with the network stack at different layers to accomplish a simple
    network task.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们看了一下在使用Python时通常如何处理网络编程。我们讨论了使用模块的一般原则，这些模块尽可能地与网络堆栈上层的服务进行接口。我们还讨论了在哪里可以找到这些模块。我们看了一些使用与网络堆栈在不同层进行接口的模块来完成简单网络任务的示例。
- en: Finally, we discussed some common pitfalls of programming for TCP/IP networks
    and some steps that may be taken to avoid them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了为TCP/IP网络编程的一些常见陷阱以及可以采取的一些措施来避免它们。
- en: This chapter has been heavy on the networking theory side of things. But, now
    it's time to get stuck into Python and put some application layer protocols to
    work for us.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章在网络理论方面非常重要。但是，现在是时候开始使用Python并让一些应用层协议为我们工作了。
