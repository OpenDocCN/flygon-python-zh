- en: Ansible for System Administration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统管理的Ansible
- en: In this chapter, we will explore one of the popular automation frameworks used
    by thousands of network and system engineers called *Ansible*, Ansible is used
    to administrate servers and network devices over multiple transport protocols
    such as SSH, Netconf, and API  in order to deliver a reliable infrastructure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索一种被成千上万的网络和系统工程师使用的流行自动化框架*Ansible*，Ansible用于管理服务器和网络设备，通过多种传输协议如SSH、Netconf和API来提供可靠的基础设施。
- en: We will start first by learning the terminologies used in ansible, how to construct
    an inventory file that contains the infrastructure access details, Building a
    robust Ansible playbook using features like conditions, loops, and template rendering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将学习ansible中使用的术语，如何构建包含基础设施访问详细信息的清单文件，使用条件、循环和模板渲染等功能构建强大的Ansible playbook。
- en: Ansible belongs to the configuration management class of software; it is used
    to manage the configuration life cycle on multiple different devices and servers,
    making sure that the same steps are applied on all of them and help to create
    Infrastructure as a code (IaaC) environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible属于软件配置管理类别；它用于管理多个不同设备和服务器上的配置生命周期，确保所有设备上都应用相同的步骤，并帮助创建基础设施即代码（IaaC）环境。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Ansible and its terminology
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible及其术语
- en: Installing Ansible on Linux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上安装Ansible
- en: Using Ansible in ad hoc mode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在临时模式下使用Ansible
- en: Create your first playbook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个playbook
- en: Understanding Ansible conditions, handlers, and loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Ansible的条件、处理程序和循环
- en: Working with Ansible facts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible事实
- en: Working with the Ansible template
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible模板
- en: Ansible terminology
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible术语
- en: Ansible is an automation tool and a complete framework that provides an abstraction
    layer based on Python tools. Originally, it was designed to handle task automation.
    This task might be executed  on a single server or on thousands of servers and
    ansible will handle them without any problem; later, Ansible's scope extended
    to network devices and cloud providers. Ansible follows the concept of `idempotency`,
    wherein Ansible instructions can run the same task multiple times and always give
    the same configuration on all devices at the end, reaching a desired state with
    minimal changes. For example, if we run Ansible to upload a file to a specific
    group of servers, then run it again, Ansible will first validate if the file already
    exist in the remote destination as a result a previous execution or not. if it
    exist, then the ansible won't upload it
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个自动化工具和完整的框架，它提供了基于Python工具的抽象层。最初，它是设计用来处理任务自动化的。这个任务可以在单个服务器上执行，也可以在成千上万的服务器上执行，ansible都可以毫无问题地处理；后来，Ansible的范围扩展到了网络设备和云提供商。Ansible遵循“幂等性”的概念，其中Ansible指令可以多次运行相同的任务，并始终在所有设备上给出相同的配置，最终达到期望的状态，变化最小。例如，如果我们运行Ansible将文件上传到特定组的服务器，然后再次运行它，Ansible将首先验证文件是否已经存在于远程目的地，如果存在，那么ansible就不会再次上传它。
- en: again. This feature called **idempotency**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 再次。这个功能叫做“幂等性”。
- en: 'Another aspect of Ansible is that it is agentless. Ansible doesn''t require
    any agents to be installed in the servers before it runs tasks. It leverages the
    SSH connection and Python standard libraries to execute tasks on remote servers
    and return the output to the Ansible server. Also, it doesn''t create a database
    to store remote machine information, but depends on a flat text file called `inventory`
    to store all required server information, such as IP addresses, credentials, and
    infrastructure categorization. The following is an example of a simple inventory
    file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的另一个方面是它是无代理的。在运行任务之前，Ansible不需要在服务器上安装任何代理。它利用SSH连接和Python标准库在远程服务器上执行任务，并将输出返回给Ansible服务器。此外，它不会创建数据库来存储远程机器信息，而是依赖于一个名为“inventory”的平面文本文件来存储所有所需的服务器信息，如IP地址、凭据和基础设施分类。以下是一个简单清单文件的示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that we group together servers that perform the same functions in our
    infrastructure (such as database servers, in a group called `[db-servers]`; the
    same goes for `[web-servers]`). Then, we define a special group, called `[all]`,
    that combines both groups, in case we have a task targeted to all of our servers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在我们的基础设施中执行相同功能的服务器分组在一起（比如数据库服务器，在一个名为“[db-servers]”的组中；同样的，对于“[web-servers]”也是如此）。然后，我们定义一个特殊的组，称为“[all]”，它结合了这两个组，以防我们有一个针对所有服务器的任务。
- en: The keyword `children`, in `[all:children]`, means that the entries inside the
    group are also groups that contain hosts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “children”关键字在“[all:children]”中的意思是组内的条目也是包含主机的组。
- en: Ansible's **ad hoc** mode allows users to execute tasks directly from the Terminal,
    towards the remote servers. Let's suppose that you want to update specific packages
    on specific types of servers, such as databases or web backend servers, to resolve
    a new bug. At the same time, you don't want to go all the way to developing a
    complex playbook to execute a simple task. By leveraging the ad hoc mode in Ansible, you
    can execute any command on the remote servers by typing it on the Ansible host
    Terminal. Even some modules can be executed in the Terminal; we will see that
    in the *Using Ansible in ad hoc mode* section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的“临时”模式允许用户直接从终端向远程服务器执行任务。假设您想要在特定类型的服务器上更新特定的软件包，比如数据库或Web后端服务器，以解决一个新的bug。与此同时，您不想要开发一个复杂的playbook来执行一个简单的任务。通过利用Ansible的临时模式，您可以在Ansible主机终端上输入命令来在远程服务器上执行任何命令。甚至一些模块也可以在终端上执行；我们将在“在临时模式下使用Ansible”部分中看到这一点。
- en: Installing Ansible on Linux
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装Ansible
- en: The Ansible package is available on all major Linux distributions. In this section,
    we will install it onto both Ubuntu and CentOS machines. The Ansible 2.5 release
    was used at the time of developing this book, and it provides support for both
    Python 2.6 and Python 2.7\. Also, starting from version 2.2, Ansible provides
    a tech preview for Python 3.5+.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible软件包在所有主要的Linux发行版上都可用。在本节中，我们将在Ubuntu和CentOS机器上安装它。在编写本书时使用的是Ansible
    2.5版本，并且它支持Python 2.6和Python 2.7。此外，从2.2版本开始，Ansible为Python 3.5+提供了技术预览。
- en: On RHEL and CentOS
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RHEL和CentOS
- en: 'You will need to have the EPEL repository installed and enabled before installing
    Ansible. To do so, use the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Ansible之前，您需要安装和启用EPEL存储库。要这样做，请使用以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, proceed with the Ansible package installation, as shown in the following
    command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下命令安装Ansible软件包：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ubuntu
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu
- en: 'First, make sure that your system is up to date, and add the Ansible channel.
    Finally, install the Ansible package itself, as shown in the following snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保您的系统是最新的，并添加Ansible通道。最后，安装Ansible软件包本身，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more installation flavors, you can check the official Ansible website ([http://docs.Ansible.com/Ansible/latest/installation_guide/intro_installation.html?#installing-the-control-machine](http://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html?#installing-the-control-machine)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多安装选项，请查看官方Ansible网站（[http://docs.Ansible.com/Ansible/latest/installation_guide/intro_installation.html?#installing-the-control-machine](http://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html?#installing-the-control-machine)）。
- en: 'You can validate your installation by running `Ansible --version` to check
    the installed version:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`Ansible --version`来验证您的安装，以检查已安装的版本：
- en: '![](../images/00164.jpeg)The Ansible configuration files are usually stored
    in `/etc/Ansible`, with the filename `Ansible.cfg`.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00164.jpeg)Ansible配置文件通常存储在`/etc/Ansible`中，文件名为`Ansible.cfg`。'
- en: Using Ansible in ad hoc mode
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在临时模式下使用Ansible
- en: Ansible ad hoc mode is used when you need to execute simple operations on remote
    machines, without creating complex and persistent tasks. This is where a user
    usually starts when they first work on Ansible, before performing advanced tasks
    in a playbook.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在远程机器上执行简单操作而不创建复杂和持久的任务时，可以使用Ansible临时模式。这通常是用户在开始使用Ansible时首先使用的地方，然后再执行playbook中的高级任务。
- en: 'Executing the ad-hoc command requires two things. First, you will need the
    host or group from the inventory file; secondly, you will need the Ansible module
    that you want to execute towards the target machine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行临时命令需要两件事。首先，您需要清单文件中的主机或组；其次，您需要要执行的针对目标机器的Ansible模块：
- en: 'First, let''s define our hosts and add the CentOS and Ubuntu machines in a
    separate group:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的主机，并将CentOS和Ubuntu机器添加到一个单独的组中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save this file as `hosts`, under `/root/` or your home directory in the `AutomationServer`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件保存为`hosts`，放在`/root/`或您的主目录中的`AutomationServer`下。
- en: 'Then, run the `Ansible` command with the `ping` module:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`ping`模块运行`Ansible`命令：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `-i` argument will accept the inventory file that we added, while the `-m`
    argument will specify the name of the Ansible module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`参数将接受我们添加的清单文件，而`-m`参数将指定Ansible模块的名称。'
- en: 'After running the command, you will get the following output, indicating a
    failure in connecting to the remote machine:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您将得到以下输出，指示连接到远程机器失败：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This happened because the remote machines are not inside of the `known_hosts`
    of the Ansible server; it can be solved through two methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为远程机器不在Ansible服务器的`known_hosts`中；可以通过两种方法解决。
- en: 'The first method is SSHing to them manually, which will add the host fingerprint
    to the server. Or, you can completely disable host key checking in the Ansible
    configuration, as shown in the following snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是手动SSH到它们，这将将主机指纹添加到服务器。或者，您可以在Ansible配置中完全禁用主机密钥检查，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Rerun the `Ansible` command, and you should get successful output from the
    three machines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`Ansible`命令，您应该从三台机器中获得成功的输出：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ping` module in Ansible does not perform the ICMP operation against the
    device. It actually tries to log in to the device by using the SSH with provided
    credentials; if the login succeeds, it will return the `pong` keyword to the Ansible
    host.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中的`ping`模块不执行针对设备的ICMP操作。它实际上尝试使用提供的凭据通过SSH登录到设备；如果登录成功，它将返回`pong`关键字给Ansible主机。
- en: 'Another useful module is `apt`, or `yum`, which is used to manage the package
    on either an Ubuntu or CentOS server. The following example will install the `apache2`
    package on the Ubuntu machines:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的模块是`apt`或`yum`，用于管理Ubuntu或CentOS服务器上的软件包。以下示例将在Ubuntu机器上安装`apache2`软件包：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The state in the `apt` module can have the following values:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`apt`模块中的状态可以有以下值：'
- en: '| **State** | **Action** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | **操作** |'
- en: '| `absent` | Removes the package from the system. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `absent` | 从系统中删除软件包。 |'
- en: '| `present` | Makes sure that the package is installed on the system. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `present` | 确保软件包已安装在系统上。 |'
- en: '| `latest` | Ensures that the package is in the latest version. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `latest` | 确保软件包是最新版本。 |'
- en: You can access the Ansible module documentation by running `Ansible-doc <module_name>`;
    you will see the full options, with examples, for the module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`Ansible-doc <module_name>`来访问Ansible模块文档；您将看到模块的完整选项和示例。
- en: The `service` module is used to manage operation and current status of the 
    service. You can change the service status to either `started`, `restarted` or
    `stopped` in the `state` option and ansible will run the appropriate command to
    change the status. In the meantime, you can configure whether service is enabled
    at boot time or disabled by configuring the `enabled` .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`service`模块用于管理服务的操作和当前状态。您可以在`state`选项中将服务状态更改为`started`、`restarted`或`stopped`，ansible将运行适当的命令来更改状态。同时，您可以通过配置`enabled`来配置服务是否在启动时启用或禁用。'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, you can restart the service by providing the service name, with the `state`
    set as `restarted`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过提供服务名称并将`state`设置为`restarted`来重新启动服务：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The other way to run Ansible in ad hoc mode is to pass the command directly
    to Ansible, using not the built-in modules but the `-a` argument:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以adhoc模式运行Ansible的另一种方法是直接将命令传递给Ansible，而不是使用内置模块，而是使用`-a`参数：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can even reboot the servers by running the `reboot` command; but this time,
    we will only run it against the CentOS servers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过运行`reboot`命令重新启动服务器；但这次，我们只会针对CentOS服务器运行它：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sometimes, you will need to run the command (or the module) using a different
    user. This will be useful when you run a script on a remote server with specific
    permissions assigned to a user different than the SSH user. In that case, we will
    add the `-u`, `--become`, and `--ask-become-pass` (`-K`) switches. This will make
    Ansible run the command with the provided username and prompt you for the user''s
    password:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要使用不同的用户运行命令（或模块）。当您在具有分配给不同于SSH用户的特定权限的远程服务器上运行脚本时，这将非常有用。在这种情况下，我们将添加`-u`，`--become`和`--ask-become-pass`（`-K`）开关。这将使Ansible使用提供的用户名运行命令，并提示您输入用户的密码：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How Ansible actually works
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的实际工作方式
- en: Ansible is basically written in Python, However it use it's own DSL (Domain
    Specific Language). You can write using this DSL and ansible will convert it to
    Python on remote machines to execute tasks. So, it first validates the task syntax
    and copies the module from the Ansible host to the remote server, and then executes
    it on the machine itself over SSH.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible基本上是用Python编写的，但它使用自己的DSL（领域特定语言）。您可以使用此DSL编写，ansible将在远程机器上将其转换为Python以执行任务。因此，它首先验证任务语法并从Ansible主机复制模块到远程服务器，然后在远程服务器上执行它。
- en: 'The result from the execution is returned back to the Ansible host in a `json`
    format, so you can match any returned values by knowing its key:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的结果以`json`格式返回到Ansible主机，因此您可以通过了解其键来匹配任何返回的值：
- en: '![](../images/00165.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00165.jpeg)'
- en: 'In the case of network devices where Python is installed on the **Network Operating
    System **(**NOS**), Ansible uses either an API or `netconf`, if the network device
    supports it (such as Juniper and Cisco Nexus); or, it just executes commands using
    the paramiko `exec_command()` function, and returns the output to the Ansible
    host. This can be done by using the `raw` module, as shown in the following snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Python的网络设备的情况下，Ansible使用API或`netconf`（如果网络设备支持，例如Juniper和Cisco Nexus）；或者，它只是使用paramiko的`exec_command()`函数执行命令，并将输出返回到Ansible主机。这可以通过使用`raw`模块来完成，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating your first playbook
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个剧本
- en: Now the magic party can begin. An Ansible playbook is a set of commands (called
    tasks) that need to be executed in order, and it describes the desired state of
    the hosts after execution finishes. Think of a playbook as a manual that contains
    a set of instructions for how to change the state of an infrastructure; each instruction
    depends on many built-in Ansible modules to perform the tasks. For example, you
    may have a playbook that is used to build web applications that consist of SQL
    servers, to act as backend databases and nginx web servers. The playbook will
    have a list of tasks to perform against each group of servers, to change their
    states from `No-Exist` to `Present`, or to `Restarted` or `Absent`, if you want
    to delete the web app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在魔术派对可以开始了。Ansible剧本是一组需要按顺序执行的命令（称为任务），它描述了执行完成后主机的期望状态。将剧本视为包含一组指令的手册，用于更改基础设施的状态；每个指令都依赖于许多内置的Ansible模块来执行任务。例如，您可能有一个用于构建Web应用程序的剧本，其中包括SQL服务器，用作后端数据库和nginx
    Web服务器。剧本将有一系列任务针对每组服务器执行，以将它们的状态从`不存在`更改为`存在`，或者更改为`重新启动`或`不存在`，如果要删除Web应用程序。
- en: 'The power of having the playbook, over the ad hoc commands is that you can
    use it to configure and set up your infrastructure everywhere. The same procedure
    used to create the dev environment will be used in the production environment.
    A playbook is used to create the automation workflow that runs on your infrastructure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 剧本的强大之处在于您可以使用它在任何地方配置和设置基础设施。用于创建开发环境的相同过程将用于生产环境。剧本用于创建在您的基础设施上运行的自动化工作流程：
- en: '![](../images/00166.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00166.jpeg)'
- en: Playbooks are written with YAML, which we discussed in [Chapter 6](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f),
    *Configuration Generator with Python and Jinja2*. A playbook consists of multiple
    plays, executed against a set of hosts that are defined in the inventory file.
    The hosts will be converted to a Python `list`, and each item inside the list
    will be called a `play`. In the preceding example, the `db-servers` tasks are
    some of the plays, and are executed against the `db-servers` only. During playbook
    execution, you can decide to run all of the plays in the file, only a specific
    play, or tasks with specific tags, regardless of which play they belong to.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 剧本是用YAML编写的，我们在[第6章](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f)中讨论过，*使用Python和Jinja2生成配置*。剧本由多个play组成，针对清单文件中定义的一组主机执行。主机将被转换为Python
    `list`，列表中的每个项目将被称为`play`。在前面的示例中，`db-servers`任务是一些play，并且仅针对`db-servers`执行。在剧本执行期间，您可以决定运行文件中的所有play，仅特定play或具有特定标记的任务，而不管它们属于哪个play。
- en: 'Now, let''s look at our first playbook, to get the look and feel of it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的第一个剧本，以了解其外观和感觉：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a simple playbook, with a single `play` that contains two `tasks`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的剧本，有一个包含两个任务的`play`：
- en: Install `openssh-server`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`openssh-server`。
- en: Start the `sshd` service after installation, and make sure that it's available
    at the boot time.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后启动`sshd`服务，并确保它在启动时可用。
- en: Now, we need to apply this to a specific host (or a group of hosts). So, we
    set the `hosts` to be `CentOS-servers`, defined previously in the inventory file,
    and we also set the `remote_user` to be the root, to ensure that the tasks after
    it will be executed with root permissions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将其应用于特定主机（或一组主机）。因此，我们将`hosts`设置为之前在inventory文件中定义的`CentOS-servers`，并且我们还将`remote_user`设置为root，以确保之后的任务将以root权限执行。
- en: The tasks will consist of the names and the Ansible modules. The name is used
    to describe the task. It's not mandatory to provide names for your tasks, but
    it's recommended, in case you need to start the execution from a specific task.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 任务将包括名称和Ansible模块。名称用于描述任务。为任务提供名称并不是强制性的，但建议这样做，以防需要从特定任务开始执行。
- en: The second part is the Ansible module, which is mandatory. In our example, we
    used the core module `yum` to install the `openssh-server` package onto the target
    servers. The second task has the same structure, but this time, we will use another
    core module, called `service`, to start and enable the `sshd` daemon.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是Ansible模块，这是必需的。在我们的示例中，我们使用了核心模块`yum`来在目标服务器上安装`openssh-server`软件包。第二个任务具有相同的结构，但这次我们将使用另一个核心模块，称为`service`，来启动和启用`sshd`守护程序。
- en: A final note is to watch the indentation for different components inside of
    Ansible. For example, the names of the tasks should be on the same level, while
    the `tasks` should align with the `hosts` on the same line.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意Ansible中不同组件的缩进。例如，任务的名称应该在同一级别，而`tasks`应该与同一行上的`hosts`对齐。
- en: 'Let''s run the playbook in our automation server and check the output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的自动化服务器上运行playbook并检查输出：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that the playbook is executed on `centos-machine01`, and the tasks
    are executed sequentially, as defined in the playbook.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到playbook在`centos-machine01`上执行，并且任务按照playbook中定义的顺序依次执行。
- en: YAML requires that you preserve the indentation level and don't mix between
    the tabs and spaces; otherwise, it will give an error. Many text editors and IDEs
    will convert the tab to a set of white spaces. An example of that option is shown
    in the following screenshot, in the notepad++ editor preferences:![](../images/00167.jpeg)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: YAML要求保留缩进级别，并且不要混合制表符和空格；否则，将会出现错误。许多文本编辑器和IDE将制表符转换为一组空格。以下截图显示了该选项的示例，在notepad++编辑器首选项中：![](../images/00167.jpeg)
- en: Understanding Ansible conditions, handlers, and loops
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Ansible条件、处理程序和循环
- en: In this part of the chapter, we will look at some of the advanced features in
    the Ansible playbook.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将看一些Ansible playbook中的高级功能。
- en: Designing conditions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计条件
- en: An Ansible playbook can execute tasks (or skip them) based on the results of
    specific conditions inside the task—for example, when you want to install packages
    on a specific family of operating systems (Debian or CentOS), or when the operating
    system is a particular version, or even when the remote hosts are virtual, not
    bare metal. This can be done by using the `when` clause inside of the task.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook可以根据任务内部特定条件的结果执行任务（或跳过任务）——例如，当您想要在特定操作系统家族（Debian或CentOS）上安装软件包时，或者当操作系统是特定版本时，甚至当远程主机是虚拟机而不是裸机时。这可以通过在任务内部使用`when`子句来实现。
- en: Let's enhance the previous playbook and limit the `openssh-server` installation
    to only CentOS based systems, so that it does not give an error when it hits an
    Ubuntu server that uses the `apt` module, not `yum`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增强先前的playbook，并将`openssh-server`安装限制为仅适用于基于CentOS的系统，这样当它遇到使用`apt`模块而不是`yum`的Ubuntu服务器时，就不会出错。
- en: 'First, we will add the following two sections to our `inventory` file, to group
    the CentOS and Ubuntu machines in the `infra` section:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的`inventory`文件中添加以下两个部分，将CentOS和Ubuntu机器分组到`infra`部分中：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we will redesign the tasks inside of the playbook to have the `when`
    clause, which limits task execution to only CentOS based machines. This should
    read as `if the remote machine is CentOS based, then I will execute the task;
    otherwise, skip`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将重新设计playbook中的任务，添加`when`子句，将任务执行限制为仅适用于基于CentOS的机器。这应该读作`如果远程机器是基于CentOS的，那么我将执行任务；否则，跳过`。
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s run the playbook:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行playbook：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the playbook first gathers the facts about the remote machines (we
    will discuss that later in this chapter), and then checks the operating system.
    The task will be skipped when it hits an `ubuntu-machine01`, and it will run normally
    on the CentOS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，playbook首先收集有关远程机器的信息（我们将在本章后面讨论），然后检查操作系统。当它遇到`ubuntu-machine01`时，任务将被跳过，并且在CentOS上将正常运行。
- en: 'You can also have multiple conditions that need to be true in order to run
    the task. For example, you can have the following playbook, which validates two
    things—first, that the machine is based on Debian, and second, that it is a virtual
    machine, not a baremetal:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以有多个条件需要满足才能运行任务。例如，您可以有以下playbook，验证两件事情——首先，机器基于Debian，其次，它是一个虚拟机，而不是裸机：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running this playbook will result in the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此playbook将产生以下输出：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Ansible `when` clause also accepts expressions. For example, you can check
    whether a specific keyword exists in the returned output (that you saved using
    the register flag), and, based on that, execute the task.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的`when`子句还接受表达式。例如，您可以检查返回的输出中是否存在特定关键字（使用注册标志保存），并根据此执行任务。
- en: 'The following playbook will validate the OSPF neighbor status. The first task
    will execute `show ip ospf neighbor` on the routers and register the output in
    a variable called `neighbors`. The next task will check for `EXSTART` or `EXCHANGE`
    in the returned output; if found, it will print a message back to the console:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下playbook将验证OSPF邻居状态。第一个任务将在路由器上执行`show ip ospf neighbor`并将输出注册到名为`neighbors`的变量中。接下来的任务将检查返回的输出中是否有`EXSTART`或`EXCHANGE`，如果找到，将在控制台上打印一条消息：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can check the facts commonly used in the `when` clause at [http://docs.Ansible.com/Ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts](http://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://docs.Ansible.com/Ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts](http://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html#commonly-used-facts)中检查在`when`子句中常用的事实。
- en: Creating loops in ansible
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ansible中创建循环
- en: 'Ansible provides many ways to repeat the same task inside a play, but with
    a different value each time. For example, when you want to install multiple packages
    on a server, you don''t need to create a task for each package. Rather, you can
    create a task that installs a package and provides a list of package names to
    the task, and Ansible will iterate over them until it finishes the installation.
    To accomplish this, we will need the `with_items` flag inside of the task that
    contains a list, and the variable `{{ item }}`, which serves as a placeholder
    for the items in the list. The playbook will leverage the `with_items` flag to
    iterate over a set of packages and provide them to the `yum` module, which requires
    the name and state of the package:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了许多重复在play中执行相同任务的方法，但每次都有不同的值。例如，当您想在服务器上安装多个软件包时，您不需要为每个软件包创建一个任务。相反，您可以创建一个任务，安装一个软件包并向任务提供软件包名称的列表，Ansible将对它们进行迭代，直到完成安装。为此，我们需要在包含列表的任务内使用`with_items`标志，并使用变量`{{
    item }}`，它作为列表中项目的占位符。playbook将利用`with_items`标志对一组软件包进行迭代，并将它们提供给`yum`模块，该模块需要软件包的名称和状态：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can hardcode the value of the state to be `present`; in that case, all of
    the packages will be installed. However, in the previous case, `with_items` will
    provide the two elements to the `yum` module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将状态的值硬编码为`present`；在这种情况下，所有的软件包都将被安装。然而，在前一种情况下，`with_items`将向`yum`模块提供两个元素。
- en: 'The playbook''s output is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: playbook的输出如下：
- en: '![](../images/00168.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00168.jpeg)'
- en: Trigger tasks with handlers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用处理程序触发任务
- en: Okay; you have installed and removed a series of packages in your system. You
    have copied files to/from your server. And you have changed many things in the
    server by using an Ansible playbook. Now, you need to restart a few other services,
    or add some lines to the files, to complete the configuration of the service.
    So, you should add a new task, right? Yes, that's correct. However, Ansible provides
    another great option, called **handlers**, which will not automatically execute
    when it hits (unlike tasks), but will rather be executed only when it is called.
    This provides you with the flexibility to call them upon the execution of tasks
    inside the play.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；您已经在系统中安装和删除了一系列软件包。您已经将文件复制到/从服务器。并且您已经通过使用Ansible playbook在服务器上做了很多改变。现在，您需要重新启动一些其他服务，或者向文件中添加一些行，以完成服务的配置。所以，您应该添加一个新的任务，对吗？是的，这是正确的。然而，Ansible提供了另一个很棒的选项，称为**handlers**，它不会在触发时自动执行（不像任务），而是只有在被调用时才会执行。这为您提供了灵活性，可以在play中的任务执行时调用它们。
- en: Handlers have the same alignment as the hosts and tasks, and are located at
    the bottom of each play. When you need to call a handler, you use the `notify`
    flag inside of the original task, to determine which handler will be executed;
    Ansible will link them together.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序与主机和任务具有相同的对齐方式，并位于每个play的底部。当您需要调用处理程序时，您可以在原始任务内使用`notify`标志，以确定将执行哪个处理程序；Ansible将它们链接在一起。
- en: 'Let''s look at an example. We will write a playbook that installs and configures
    the KVM on the CentOS servers. The KVM requires a few changes after installation,
    such as loading the `sysctl`, enabling the `kvm` and `802.1q` modules, and loading
    the `kvm` at `boot`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们将编写一个playbook，在CentOS服务器上安装和配置KVM。KVM在安装后需要进行一些更改，比如加载`sysctl`，启用`kvm`和`802.1q`模块，并在`boot`时加载`kvm`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice the usage of `notify` after the installation task. When the task runs,
    it will notify three handlers in sequence, so that they will execute. The handlers
    will run after the task has successfully executed. That means that if the task
    has failed to run (for example, the `kvm` package was not found, or there's no
    internet connection to download it), there will be no changes to your system,
    and `kvm` will not be enabled.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意安装任务后使用`notify`。当任务运行时，它将按顺序通知三个处理程序，以便它们将被执行。处理程序将在任务成功执行后运行。这意味着如果任务未能运行（例如，找不到`kvm`软件包，或者没有互联网连接来下载它），则系统不会发生任何更改，`kvm`也不会被启用。
- en: Another awesome feature of the handler is that it's only run when there's a
    change in the task. For example, if you rerun the task, Ansible won't install
    the `kvm` package since it's already installed; it won't call any handlers, as
    it doesn't detect any changes in the system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序的另一个很棒的特性是，它只在任务中有更改时才运行。例如，如果您重新运行任务，Ansible不会安装`kvm`软件包，因为它已经安装；它不会调用任何处理程序，因为它在系统中没有检测到任何更改。
- en: 'We will add a final note about two modules: `lineinfile` and `command`. The
    first module is actually inserting or deleting lines from configuration files
    by using regular expressions; we used it in order to insert the `kvm` into `/etc/modules`,
    to automatically boot the KVM when the machine starts. The second module, `command`,
    is used to execute a shell command directly on the device and return the output
    to the Ansible host.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在最后关于两个模块添加一个注释：`lineinfile`和`command`。第一个模块实际上是通过使用正则表达式向配置文件中插入或删除行；我们使用它来将`kvm`插入`/etc/modules`，以便在机器启动时自动启动KVM。第二个模块`command`用于在设备上直接执行shell命令并将输出返回给Ansible主机。
- en: Working with Ansible facts
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible事实
- en: Ansible is not only used to deploy and configure remote hosts. It can be used
    to gather all kinds of information and facts about them. The facts collection
    can take significant amount of time to collect everything from a busy system,
    but will provide a full view of the target machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible不仅用于部署和配置远程主机。它可以用于收集有关它们的各种信息和事实。事实收集可能需要大量时间来从繁忙的系统中收集所有内容，但将为目标机器提供全面的视图。
- en: 'The facts that are gathered can be used inside the playbook later, to design
    a task condition. For example, we used the `when` clause to limit the `openssh`
    installation to only CentOS-based systems:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到的事实可以在后续的playbook中使用，设计任务条件。例如，我们使用`when`子句将`openssh`安装限制为仅适用于基于CentOS的系统：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can enable/disable fact gathering in the Ansible plays by configuring `gather_facts`
    on the same level as hosts and tasks:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在与主机和任务相同级别上配置`gather_facts`来在Ansible plays中启用/禁用事实收集。
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another way to gather facts and print them in Ansible is to use the `setup`
    module in the ad hoc mode. The returned results are in the form of nested dictionaries
    and lists, to describe the remote target facts, such as the server architecture,
    memory, networking settings, OS version, and so on:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中收集事实并打印它们的另一种方法是在adhoc模式中使用`setup`模块。返回的结果以嵌套的字典和列表的形式描述远程目标的事实，例如服务器架构、内存、网络设置、操作系统版本等：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](../images/00169.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00169.jpeg)'
- en: You can get to a specific value from the facts by using either a dot notation
    or square brackets. For example, to get the IPv4 address for `eth0`, you can use
    either  `Ansible_eth0["ipv4"]["address"]` or `Ansible_eth0.ipv4.address`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用点表示法或方括号从事实中获取特定值。例如，要获取`eth0`的IPv4地址，可以使用`Ansible_eth0["ipv4"]["address"]`或`Ansible_eth0.ipv4.address`。
- en: Working with the Ansible template
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible模板
- en: The last piece of working with Ansible is understanding how it handles the template.
    Ansible uses the Jinja2 template, which we discussed in [Chapter 6](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f),
    *Configuration Generator with Python and Jinja2*. It fills the parameters with
    either Ansible facts or the static values provided in the `vars` section, or even
    with the result of a task stored using the `register` flag.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ansible一起工作的最后一部分是了解它如何处理模板。Ansible使用我们在[第6章](part0102.html#318PC0-9cfcdc5beecd470bbeda046372f0337f)中讨论过的Jinja2模板，*使用Python和Jinja2生成配置*。它使用Ansible事实或在`vars`部分提供的静态值填充参数，甚至使用使用`register`标志存储的任务的结果。
- en: 'In the following example, we will build an Ansible playbook that gathers the
    previous three cases. First, we define a variable called `Header` in the `vars`
    section, holding a welcome message as a static value. Then, we enable the `gather_facts`
    flag, to get all possible information from the target machine. Finally, we execute
    the `date` command, to get the current date in the server and store the output
    in the `date_now` variable:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将构建一个Ansible playbook，其中包含前面三个案例。首先，在`vars`部分中定义一个名为`Header`的变量，其中包含一个欢迎消息作为静态值。然后，我们启用`gather_facts`标志，以从目标机器获取所有可能的信息。最后，我们执行`date`命令，以获取服务器的当前日期并将输出存储在`date_now`变量中：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The template module that was used in the preceding playbook will accept a Jinja2
    file named `index.j2`, located in the same directory of the playbook; it will
    then provide all of the values for the jinj2 variables from the three sources
    we discussed previously. Then, the rendered file will be stored in a path provided
    by the `dest` option, inside the template module.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的playbook中使用的模板模块将接受一个名为`index.j2`的Jinja2文件，该文件位于playbook的同一目录中；然后，它将从我们之前讨论过的三个来源中提供所有jinj2变量的值。然后，渲染后的文件将存储在模板模块提供的`dest`选项中的路径中。
- en: 'The content of `index.j2` will be as follows. It will be a simple HTML page
    that leverages the jinja2 language to generate a final HTML page:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.j2`的内容如下。它将是一个简单的HTML页面，利用jinja2语言生成最终的HTML页面：'
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running this playbook will result in installing the nginx web server on the
    CentOS machine, and adding an `index.html` page to it. You can access the page
    by using the browser:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此playbook将在CentOS机器上安装nginx web服务器，并向其添加一个`index.html`页面。您可以通过浏览器访问该页面：
- en: '![](../images/00170.gif)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00170.gif)'
- en: You can also utilize the template module to generate network device configurations.
    The jinja2 templates used in [Chapter 6](https://cdp.packtpub.com/hands_on_enterprise_automation_with_python/wp-admin/post.php?post=322&action=edit#post_33), *Configuration
    Generator with Python and Jinja2,* which generated the `day0` and `day1` configurations
    for the router, can be reused inside of the Ansible playbook.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以利用模板模块生成网络设备配置。在[第6章](https://cdp.packtpub.com/hands_on_enterprise_automation_with_python/wp-admin/post.php?post=322&action=edit#post_33)中使用的jinja2模板，*使用Python和Jinja2生成配置*，为路由器生成了`day0`和`day1`配置，可以在Ansible
    playbook中重复使用。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible is a very powerful tool, used to automate IT infrastructure. It contains
    many modules and libraries that cover almost everything in system and network
    automation, making software deployment, package management, and configuration
    management very easy. While Ansible can execute a single module in ad hoc mode,
    the real power of Ansible is in writing and developing playbooks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个非常强大的工具，用于自动化IT基础设施。它包含许多模块和库，几乎涵盖了系统和网络自动化中的所有内容，使软件部署、软件包管理和配置管理变得非常容易。虽然Ansible可以在adhoc模式下执行单个模块，但Ansible的真正力量在于编写和开发playbook。
