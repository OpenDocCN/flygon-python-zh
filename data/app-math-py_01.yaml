- en: Basic Packages, Functions, and Concepts
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 基本包、函数和概念
- en: Before getting started on any practical recipes, we'll use this opening chapter
    to introduce several core mathematical concepts and structures and their Python
    representations. In particular, we'll look at basic numerical types, basic mathematical
    functions (trigonometric functions, the exponential function, and logarithms),
    and matrices. Matrices are fundamental in most computational applications because
    of the connection between matrices and solutions of systems of linear equations.
    We'll explore some of these applications in this chapter, but matrices will play
    an important role throughout this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何实际配方之前，我们将使用本章来介绍几个核心数学概念和结构及其Python表示。特别是，我们将研究基本数值类型、基本数学函数（三角函数、指数函数和对数）以及矩阵。由于矩阵与线性方程组的解之间的联系，矩阵在大多数计算应用中都是基本的。我们将在本章中探讨其中一些应用，但矩阵将在整本书中发挥重要作用。
- en: 'We''ll cover the following main topics in this order:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序涵盖以下主要主题：
- en: Python numerical types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python数值类型
- en: Basic mathematical functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数学函数
- en: NumPy arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy数组
- en: Matrices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, and throughout this book, we will use Python version 3.8,
    which is the most recent version of Python at the time of writing. Most of the
    code in this book will work on recent versions of Python from 3.6\. We will use
    features that were introduced in Python 3.6 at various points, including f-strings.
    This means that you may need to change `python3.8`, which appears in any terminal
    commands to match your version of Python. This might be another version of Python,
    such as `python3.6` or `python3.7`, or a more general command such as `python3`
    or `python`. For the latter commands, you need to check that the version of Python
    is at least 3.6 by using the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书的整个过程中，我们将使用Python 3.8版本，这是写作时最新的Python版本。本书中的大部分代码将适用于Python 3.6及更高版本。我们将在不同的地方使用Python
    3.6引入的功能，包括f-strings。这意味着您可能需要更改任何终端命令中出现的`python3.8`，以匹配您的Python版本。这可能是另一个版本的Python，如`python3.6`或`python3.7`，或者更一般的命令，如`python3`或`python`。对于后者的命令，您需要使用以下命令检查Python的版本至少为3.6：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python has built-in numerical types and basic mathematical functions that suffice
    for small applications that involve only small calculations. The NumPy package
    provides a high performance array type and associated routines (including basic
    mathematical functions that operate efficiently on arrays). This package will
    be used in many of the recipes in this chapter and the remainder of this book.
    We will also make use of the SciPy package in the latter recipes of this chapter.
    Both can be installed using your preferred package manager, such as `pip`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有内置的数值类型和基本的数学函数，足以满足只涉及小计算的小型应用。NumPy包提供了高性能的数组类型和相关例程（包括对数组进行高效操作的基本数学函数）。这个包将在本章和本书的其余部分中使用。我们还将在本章的后续配方中使用SciPy包。这两个包都可以使用您喜欢的包管理器（如`pip`）进行安装：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By convention, we import these package under a shorter alias. We import `numpy`
    as `np` and `scipy` as `sp` using the following `import` statements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们将这些包导入为更短的别名。我们使用以下`import`语句将`numpy`导入为`np`，将`scipy`导入为`sp`：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These conventions are used in the official documentation for these packages,
    along with many tutorials and other materials that use these packages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定在这些包的官方文档中使用，以及许多使用这些包的教程和其他材料中使用。
- en: The code for this chapter can be found in the `Chapter 01` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2001](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2001).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库的`Chapter 01`文件夹中找到，网址为[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2001](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2001)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3g3eBXv](https://bit.ly/3g3eBXv).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：[https://bit.ly/3g3eBXv](https://bit.ly/3g3eBXv)。
- en: Python numerical types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python数值类型
- en: Python provides basic numerical types such as arbitrarily sized integers and
    floating-point numbers (double precision) as standard, but it also provides several
    additional types that are useful in specific applications where precision is especially
    important. Python also provides (built-in) support for complex numbers, which
    are useful for some more advanced mathematical applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了基本的数值类型，如任意大小的整数和浮点数（双精度）作为标准，但它还提供了几种在精度特别重要的特定应用中有用的附加类型。Python还提供了对复数的（内置）支持，这对一些更高级的数学应用很有用。
- en: Decimal type
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十进制类型
- en: 'For applications that require decimal digits with accurate arithmetic operations,
    use the`Decimal` type from the`decimal` module in the Python Standard Library:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要精确算术运算的十进制数字的应用，可以使用Python标准库中的`decimal`模块中的`Decimal`类型：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Performing this calculation with float objects gives the result 2.6630000000000003,
    which includes a small error arising from the fact that certain numbers cannot
    be represented exactly using a finite sum of powers of 2\. For example, 0.1 has
    a binary expansion 0.000110011..., which does not terminate. Any floating-point
    representation of this number will therefore carry a small error. Note that the
    argument to `Decimal` is given as a string rather than a float.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮点对象进行此计算会得到结果2.6630000000000003，这包括了一个小误差，这是因为某些数字不能用有限的2的幂的和来精确表示。例如，0.1的二进制展开是0.000110011...，它不会终止。因此，这个数字的任何浮点表示都会带有一个小误差。请注意，`Decimal`的参数是一个字符串，而不是一个浮点数。
- en: The `Decimal` type is based on the IBM General Decimal Arithmetic Specification
    ([http://speleotrove.com/decimal/decarith.html](http://speleotrove.com/decimal/decarith.html)),
    which is an alternative specification for floating-point arithmetic that represents
    decimal numbers exactly by using powers of 10 rather than powers of 2\. This means
    that it can be safely used for calculations in finance where the accumulation
    of rounding errors would have dire consequences. However, the `Decimal` format
    is less memory efficient, since it must store decimal digits rather than binary
    digits (bits), and are more computationally expensive than traditional floating-point
    numbers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal` 类型基于 IBM 通用十进制算术规范（[http://speleotrove.com/decimal/decarith.html](http://speleotrove.com/decimal/decarith.html)），这是一种浮点算术的替代规范，它通过使用
    10 的幂而不是 2 的幂来精确表示十进制数。这意味着它可以安全地用于金融计算，其中舍入误差的累积将产生严重后果。然而，`Decimal` 格式的内存效率较低，因为它必须存储十进制数字而不是二进制数字（位），并且比传统的浮点数更加计算密集。'
- en: 'The`decimal` package also provides a`Context` object, which allows fine-grained
    control over the precision, display, and attributes of`Decimal` objects. The current
    (default) context can be accessed using the`getcontext` function from the `decimal`
    module. The`Context` object returned by`getcontext` has a number of attributes
    that can be modified. For example, we can set the precision for arithmetic operations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal` 包还提供了一个`Context`对象，它允许对`Decimal`对象的精度、显示和属性进行精细控制。可以使用`decimal`模块的`getcontext`函数访问当前（默认）上下文。`getcontext`返回的`Context`对象具有许多可以修改的属性。例如，我们可以设置算术运算的精度：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we set the precision to `4`, rather than the default `28`, we see that
    the fourth power of 1.1 is rounded to 4 significant figures.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将精度设置为 `4` 时，而不是默认的 `28`，我们会发现 1.1 的四次方被舍入为 4 个有效数字。
- en: 'The context can even be set locally by using the`localcontext`function, which
    returns a context manager that restores the original environment at the end of
    the `with` block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以使用`localcontext`函数在本地设置上下文，该函数返回一个上下文管理器，在`with`块结束时恢复原始环境：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that the context can be freely modified inside the `with` block,
    and will be returned to the default at the end.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着上下文可以在`with`块内自由修改，并且在结束时将返回默认值。
- en: Fraction type
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数类型
- en: 'Alternatively, for working with applications that require accurate representations
    of integer fractions, such as when working with proportions or probabilities,
    there is the `Fraction` type from the `fractions` module in the Python Standard
    Library. The usage is similar, except that we typically give the numerator and
    denominator of the fraction as arguments:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于需要准确表示整数分数的应用程序，例如处理比例或概率时，可以使用 Python 标准库中 `fractions` 模块的 `Fraction`
    类型。用法类似，只是我们通常将分数的分子和分母作为参数给出：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Fraction` type simply stores two integers, the numerator and the denominator,
    and arithmetic is performed using the basic rules for the addition and multiplication
    of fractions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fraction` 类型只是简单地存储两个整数，即分子和分母，并且使用分数的加法和乘法的基本规则执行算术运算。'
- en: Complex type
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数类型
- en: 'Python also has support for complex numbers, including a literal character
    to denote the complex unit `1j` in code. This might be different from the idiom
    for representing the complex unit that you are familiar with from other sources
    on complex numbers. Most mathematical texts will often use the symbol *i* to represent
    the complex unit:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也支持复数，包括在代码中表示复数单位 `1j` 的文字字符。这可能与您从其他复数源上熟悉的表示复数单位的习语不同。大多数数学文本通常会使用符号
    *i* 来表示复数单位：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Special "complex number" - aware mathematical functions are provided in the
    `cmath` module of the Python Standard Library.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库的 `cmath` 模块提供了专门针对“复数” - 意识的数学函数。
- en: Basic mathematical functions
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数学函数
- en: Basic mathematical functions appear in many applications. For example, logarithms
    can be used to scale data that grows exponentially to give linear data. The exponential
    function and trigonometric functions are common fixtures when working with geometric
    information, the *gamma function* appears in combinatorics, and the *Gaussian
    error function* is important in statistics*.*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数学函数出现在许多应用程序中。例如，对数可以用于将呈指数增长的数据缩放为线性数据。指数函数和三角函数在处理几何信息时是常见的固定内容，*gamma
    函数* 出现在组合学中，*高斯误差函数* 在统计学中很重要*.*
- en: 'The `math` module in the Python Standard Library provides all of the standard
    mathematical functions, along with common constants and some utility functions,
    and it can be imported using the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的 `math` 模块提供了所有标准数学函数，以及常见常数和一些实用函数，可以使用以下命令导入：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once it''s imported, we can use any of the mathematical functions that are
    contained in this module. For instance, to find the square root of a non-negative
    number, we would use the `sqrt` function from `math`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入，我们可以使用此模块中包含的任何数学函数。例如，要找到非负数的平方根，我们将使用 `math` 中的 `sqrt` 函数：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Attempting to use the `sqrt` function with a negative argument will raise a
    ValueError. The square root of a negative number is not defined for this `sqrt`
    function, which deals only with *real numbers*. The square root of a negative
    number—this will be a complex number—can be found using the alternative `sqrt`
    function from the `cmath` module in the Python Standard Library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 `sqrt` 函数的负参数将引发 ValueError。这个 `sqrt` 函数不定义负数的平方根，它只处理*实数*。负数的平方根——这将是一个复数——可以使用
    Python 标准库中 `cmath` 模块的替代 `sqrt` 函数找到。
- en: 'The trigonometric functions, sine, cosine, and tangent, are available under
    their common abbreviations `sin`, `cos`, and `tan`, respectively, in the `math`
    module. The`pi` constant holds the value of π, which is approximately 3.1416:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 三角函数，正弦、余弦和正切，在`math`模块中分别以它们的常见缩写`sin`、`cos`和`tan`可用。`pi` 常数保存了π的值，约为 3.1416：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The inverse trigonometric functions are named `acos`, `asin`, and `atan` in
    the `math` module:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块中的反三角函数分别命名为`acos`、`asin`和`atan`：'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `log` function in the `math` module performs logarithms. It has an optional
    argument to specify the base of the logarithm (note that the second argument is
    positional only). By default, without the optional argument, it is the *natural
    logarithm* with base *e*. The *e*constant can be accessed using `math.e`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块中的`log`函数执行对数。它有一个可选参数来指定对数的底数（注意第二个参数只能是位置参数）。默认情况下，没有可选参数，它是以*自然对数*为底数*e*。*e*常数可以使用`math.e`来访问：'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `math` module also contains the function `gamma`, which is the gamma function,
    and the function `erf`, the Gaussian error function, which is important in statistics.
    Both of these functions are defined by integrals. The gamma function is defined
    by the integral
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块还包含`gamma`函数，即伽玛函数，以及`erf`函数，即高斯误差函数，这在统计学中非常重要。这两个函数都是通过积分来定义的。伽玛函数由积分定义'
- en: '![](assets/cce1e648-6fc9-4ba8-8bda-370d76d95bc6.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cce1e648-6fc9-4ba8-8bda-370d76d95bc6.png)'
- en: and the error function is defined by
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 误差函数由下式定义
- en: '![](assets/a942862a-1ef4-40bd-8a6c-1bd93716ea47.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a942862a-1ef4-40bd-8a6c-1bd93716ea47.png)'
- en: 'The integral in the definition of the error function cannot be evaluated using
    calculus, and instead must be computed numerically:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 误差函数定义中的积分无法使用微积分来求解，而必须通过数值计算来完成：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to standard functions such as trigonometric functions, logarithms,
    and exponential functions, the `math` module contains various number of theoretic
    and combinatorial functions. These include the functions `comb` and `factorial`,
    which are useful in a variety of applications. The `comb` function called with
    arguments *n* and *k* returns the number of ways to choose *k* items from a collection
    of *n* without repeats if order is not important. For example, picking 1 then
    2 is the same as picking 2 then 1\. This number is sometimes written *^nC[k]*.
    The factorial called with argument *n* returns the factorial *n! = n(n-1)(n-2)*…1:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准函数，如三角函数、对数和指数函数之外，`math`模块还包含各种理论和组合函数。这些包括`comb`和`factorial`函数，它们在各种应用中非常有用。使用参数*n*和*k*调用的`comb`函数返回从*n*个项目的集合中选择*k*个项目的方式数，如果顺序不重要且没有重复。例如，先选择1再选择2与先选择2再选择1是相同的。这个数字有时被写为*^nC[k]*。使用参数*n*调用的阶乘函数返回阶乘*n!
    = n(n-1)(n-2)*…1：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Applying the factorial to a negative number raises a `ValueError`. The factorial
    of an integer *n,* coincides with the value of the gamma function at *n + 1*;
    that is,
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对负数应用阶乘会引发`ValueError`。整数*n*的阶乘与*n + 1*处的伽玛函数的值相符，即
- en: '![](assets/07b31532-3dc5-4e0e-bda5-374fc8eb499e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07b31532-3dc5-4e0e-bda5-374fc8eb499e.png)'
- en: 'The `math` module also contains a function that returns the *greatest common
    divisor* of its arguments called `gcd`. The greatest common divisor of *a* and
    *b* is the largest integer *k* such that *k* divides both *a* and *b* exactly:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块还包含一个返回其参数的*最大公约数*的函数，称为`gcd`。*a*和*b*的最大公约数是最大的整数*k*，使得*k*能够完全整除*a*和*b*：'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are also a number of functions for working with floating-point numbers.
    The `fsum` function performs addition on an iterable of numbers and keeps track
    of the sums each step to reduce the error in the result. This is nicely illustrated
    by the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些用于处理浮点数的函数。`fsum`函数对数字的可迭代对象执行加法，并在每一步跟踪总和，以减少结果中的误差。以下示例很好地说明了这一点：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `isclose`functionreturns`True` if the difference between the arguments is
    smaller than the tolerance. This is especially useful in unit tests, where there
    may be small variations in results based on machine architecture or data variability.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`isclose`函数返回`True`，如果参数之间的差小于公差。这在单元测试中特别有用，因为基于机器架构或数据变异性，结果可能会有小的变化。'
- en: Finally, the `floor` and `ceil`functionsfrom`math` provide the floor and ceiling
    of their argument. The*floor* of a number *x*is the largest integer*f* with*f
    ≤ x*, and the*ceiling* of*x* is the smallest integer*c* with*x ≤ c*. These functions
    are useful when converting between a float obtained by dividing one number by
    another and an integer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`math`中的`floor`和`ceil`函数提供了它们的参数的下限和上限。数字*x*的*floor*是最大的整数*f*，使得*f ≤ x*，*x*的*ceiling*是最小的整数*c*，使得*x
    ≤ c*。在将一个数字除以另一个数字得到浮点数和整数之间转换时，这些函数非常有用。
- en: The `math` module contains functions that are implemented in C (assuming you
    are running CPython), and so are much faster than those implemented in Python.
    This module is a good choice if you need to apply a function to a relatively small
    collection of numbers. If you want to apply these functions to a large collection
    of data simultaneously, it is better to use their equivalents from the NumPy package,
    which are more efficient for working with arrays.​ In general, if you have imported
    the NumPy package already, then it is probably best to always use NumPy equivalents
    of these functions to limit the chance of error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块包含了在C中实现的函数（假设你正在运行CPython），因此比在Python中实现的函数要快得多。如果你需要将函数应用于一个相对较小的数字集合，这个模块是一个不错的选择。如果你想要同时将这些函数应用于大量数据集合，最好使用NumPy包中的等效函数，这些函数对数组的处理更有效率。总的来说，如果你已经导入了NumPy包，那么最好总是使用这些函数的NumPy等效函数，以减少出错的机会。'
- en: NumPy arrays
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy数组
- en: NumPy provides high performance array types and routines for manipulating these
    arrays in Python. These arrays are useful for processing large datasets where
    performance is crucial. NumPy forms the base for the numerical and scientific
    computing stack in Python. Under the hood, NumPy makes use of low-level libraries
    for working with vectors and matrices, such as the **Basic Linear Algebra Subprograms**
    (**BLAS**) package, and the **Linear Algebra Package** (**LAPACK**)contains more
    advanced routines for linear algebra.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了高性能的数组类型和用于在Python中操作这些数组的例程。这些数组对于处理性能至关重要的大型数据集非常有用。NumPy构成了Python中的数值和科学计算堆栈的基础。在幕后，NumPy利用低级库来处理向量和矩阵，例如**基本线性代数子程序**（**BLAS**）包，以及**线性代数包**（**LAPACK**）包含更高级的线性代数例程。
- en: 'Traditionally, the NumPy package is imported under the shorter alias `np`,
    which can be accomplished using the following `import` statement:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，NumPy包是使用更短的别名`np`导入的，可以使用以下`import`语句来实现：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In particular, this convention is used in the NumPy documentation and in the
    wider scientific Python ecosystem (SciPy, Pandas, and so on).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在NumPy文档和更广泛的科学Python生态系统（SciPy、Pandas等）中使用了这种约定。
- en: 'The basic type provided by the NumPy library is the `ndarray` type (henceforth
    referred to as a NumPy array). Generally, you won''t create your own instances
    of this type, and will instead use one of the helper routines such as `array`
    to set up the type correctly. The `array` routine creates NumPy arrays from an
    array-like object, which is typically a list of numbers or a list of lists (of
    numbers). For example, we can create a simple array by providing a list with the
    required elements:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy库提供的基本类型是`ndarray`类型（以下简称NumPy数组）。通常，您不会创建此类型的自己的实例，而是使用`array`之类的辅助例程之一来正确设置类型。`array`例程从类似数组的对象创建NumPy数组，这通常是一组数字或一组（数字）列表。例如，我们可以通过提供包含所需元素的列表来创建一个简单的数组：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The NumPy array type (`ndarray`) is a Python wrapper around an underlying C
    array structure. The array operations are implemented in C and optimized for performance.
    NumPy arrays must consist of homogeneous data (all elements have the same type),
    although this type could be a pointer to an arbitrary Python object. NumPy will
    infer an appropriate data type during creation if one is not explicitly provided
    using the`dtype` keyword argument:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组类型（`ndarray`）是围绕基础C数组结构的Python包装器。数组操作是用C实现的，并针对性能进行了优化。NumPy数组必须由同质数据组成（所有元素具有相同的类型），尽管此类型可以是指向任意Python对象的指针。如果在创建时未明确提供使用`dtype`关键字参数，则NumPy将推断出适当的数据类型：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Under the hood, a NumPy array of any shape is a buffer containing the raw data
    as a flat (one-dimensional) array, and a collection of additional metadata that
    specifies details such as the type of the elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，任何形状的NumPy数组都是一个包含原始数据的缓冲区，作为一个平坦（一维）数组，并包含一系列额外的元数据，用于指定诸如元素类型之类的细节。
- en: 'After creation, the data type can be accessed using the`dtype` attribute of
    the array. Modifying the`dtype` attribute will have undesirable consequences since
    the raw bytes that constitute the data in the array will simply be reinterpreted
    as the new data type. For example, if we create an array using Python integers,
    NumPy will convert those to 64-bit integers in the array. Changing the `dtype`
    value will cause NumPy to reinterpret these 64-bit integers to the new data type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，可以使用数组的`dtype`属性访问数据类型。修改`dtype`属性将产生不良后果，因为构成数组中的原始字节将被重新解释为新的数据类型。例如，如果我们使用Python整数创建数组，NumPy将在数组中将其转换为64位整数。更改`dtype`值将导致NumPy将这些64位整数重新解释为新的数据类型：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each 64-bit integer has been re-interpreted as two 32-bit, floating-point numbers,
    which clearly gives nonsense values. Instead, if you wish to change the data type
    after creation, use the`astype` method to specify the new type. The correct way
    to change the data type is shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个64位整数都被重新解释为两个32位浮点数，这显然会产生无意义的值。相反，如果您希望在创建后更改数据类型，请使用`astype`方法指定新类型。更改数据类型的正确方法如下所示：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: NumPy also provides a number of routines for creating various standard arrays.
    The`zeros` routine creates an array, of the specified shape, in which every element
    is `0`, and the`ones` routine creates an array in which every element is `1`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了一些用于创建各种标准数组的例程。`zeros`例程创建一个指定形状的数组，其中每个元素都是`0`，而`ones`例程创建一个数组，其中每个元素都是`1`。
- en: Element access
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素访问
- en: 'NumPy arrays support the `getitem` protocol, so elements in an array can be
    accessed as if it were a list and support all of the arithmetic operations, which
    are performed component-wise. This means we can use the index notation and the
    index to retrieve the element from the specified index as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组支持`getitem`协议，因此可以像列表一样访问数组中的元素，并支持所有按组件执行的算术操作。这意味着我们可以使用索引表示法和索引来检索指定索引处的元素，如下所示：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This also includes the usual slice syntax for extracting an array of data from
    an existing array. A slice of an array is again an array, containing the elements
    specified by the slice. For example, we can retrieve an array containing the first
    two elements of `ary`, or an array containing the elements at even indexes, as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这还包括从现有数组中提取数据数组的常规切片语法。数组的切片再次是一个数组，其中包含切片指定的元素。例如，我们可以检索包含`ary`的前两个元素的数组，或者包含偶数索引处的元素的数组，如下所示：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The syntax for a slice is `start:stop:step`. We can omit either, or both, of
    `start` and `stop` to take from the beginning or the end, respectively, of all
    elements. We can also omit the `step` parameter, in which case we also drop the
    trailing `:`. The `step` parameter describes the elements from the chosen range
    that should be selected. A value of `1` selects every element or, as in the recipe,
    a value of `2` selects every second element (starting from `0` gives even-numbered
    elements). This syntax is the same as for slicing Python lists.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的语法是`start:stop:step`。我们可以省略`start`和`stop`中的一个或两个，以从所有元素的开头或结尾分别获取。我们也可以省略`step`参数，这种情况下我们也会去掉尾部的`:`。`step`参数描述了应该选择的选定范围内的元素。值为`1`选择每个元素，或者如本例中，值为`2`选择每第二个元素（从`0`开始给出偶数编号的元素）。这个语法与切片Python列表的语法相同。
- en: Array arithmetic and functions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的算术和函数
- en: NumPy provides a number of *universal functions* (ufunc), which are routines
    that can operate efficiently on NumPy array types. In particular, all of the basic
    mathematical functions discussed in the *Basic mathematical functions* section
    have analogues in NumPy that can operate on NumPy arrays. Universal functions
    can also perform *broadcasting*, to allow them to operate on arrays of different—but
    compatible—shapes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了许多*通用函数*（ufunc），这些函数可以高效地操作NumPy数组类型。特别是，在*基本数学函数*部分讨论的所有基本数学函数在NumPy中都有类似的函数，可以在NumPy数组上操作。通用函数还可以执行*广播*，以允许它们在不同但兼容的形状的数组上进行操作。
- en: 'The arithmetic operations on NumPy arrays are performed component-wise. This
    is best illustrated by the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组上的算术运算是逐分量执行的。以下示例最能说明这一点：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the arrays must be the same shape, which means have the same length.
    Using an arithmetic operation on arrays of different shapes will result in a `ValueError`.
    Adding, subtracting, multiplying, or dividing by a number will result in array
    where the operation has been applied to each component. For example, we can multiply
    all elements in an array by `2` by using the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组必须具有相同的形状，这意味着具有相同的长度。对不同形状的数组进行算术运算将导致`ValueError`。通过数字进行加法、减法、乘法或除法将导致数组，其中已对每个分量应用了操作。例如，我们可以使用以下命令将数组中的所有元素乘以`2`：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Useful array creation routines
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的数组创建例程
- en: 'To generate arrays of numbers at regular intervals between two given end points,
    you can use either the`arange` routine or the`linspace` routine. The difference
    between these two routines is that`linspace` generates a number (the default is
    50) of values with equal spacing between the two end points, including both endpoints,
    while`arange` generates numbers at a given step size up to, but not including,
    the upper limit. The `linspace` routine generates values in the closed interval
    *a ≤ x ≤ b* and the `arange` routine generates values in the half-open interval
    *a≤ x < b*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个给定端点之间以规则间隔生成数字数组，可以使用`arange`例程或`linspace`例程。这两个例程之间的区别在于`linspace`生成一定数量（默认为50）的值，这些值在两个端点之间具有相等的间距，包括两个端点，而`arange`生成给定步长的数字，但不包括上限。`linspace`例程生成封闭区间*a
    ≤ x ≤ b*中的值，而`arange`例程生成半开区间*a≤ x < b*中的值：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the array generated using `linspace` has exactly 5 points, specified
    by the third argument, including the two end points, `0` and `1`. The array generated
    by `arange` has 4 points, and does not include the right end point, `1`; an additional
    step of 0.3 would equal 1.2, which is larger than 1.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`linspace`生成的数组恰好有5个点，由第三个参数指定，包括`0`和`1`两个端点。使用`arange`生成的数组有4个点，不包括右端点`1`；0.3的额外步长将等于1.2，这比1大。
- en: Higher dimensional arrays
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高维度的数组
- en: 'NumPy can create arrays with any number of dimensions, which are created using
    the same `array` routine as simple one-dimensional arrays. The number of dimensions
    of an array is specified by the number of nested lists provided to the `array`
    routine. For example, we can create a two-dimensional array by providing a list
    of lists, where each member of the inner list is a number, such as the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy可以创建任意维度的数组，使用与简单一维数组相同的`array`例程创建。数组的维数由提供给`array`例程的嵌套列表的数量指定。例如，我们可以通过提供一个列表的列表来创建一个二维数组，其中内部列表的每个成员都是一个数字，如下所示：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: NumPy arrays have a `shape`*attribute, which describes the arrangement of the
    elements in each dimension. For a two-dimensional array, the shape can be interpreted
    as the number of rows and the number of columns of the array.*
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组具有`shape`*属性，描述了每个维度中元素的排列方式。对于二维数组，形状可以解释为数组的行数和列数。*
- en: '*NumPy stores the shape as the `shape` attribute on the array object, which
    is a tuple. The number of elements in this tuple is the number of dimensions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*NumPy将形状存储为数组对象上的`shape`属性，这是一个元组。这个元组中的元素数量就是数组的维数：'
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since the data in a NumPy array is stored in a flat (one-dimensional) array,
    an array can be reshaped with little cost by simply changing the associated metadata.
    This is done using the`reshape` method on a NumPy array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NumPy数组中的数据存储在一个扁平（一维）数组中，可以通过简单地更改相关的元数据来以很小的成本重新塑造数组。这是通过NumPy数组的`reshape`方法完成的：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the total number of elements must remain unchanged. The matrix`mat`
    originally has shape`(2, 2)` with a total of 4 elements, and the latter is a one-dimensional
    array with shape`(4,)`, which again has a total of 4 elements. Attempting to reshape
    when there is a mismatch in the total number of elements will result in a`ValueError`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，元素的总数必须保持不变。矩阵`mat`最初的形状为`(2, 2)`，共有4个元素，后者是一个形状为`(4,)`的一维数组，再次共有4个元素。当总元素数量不匹配时，尝试重新塑造将导致`ValueError`。
- en: 'To create an array of higher dimensions, simply add more levels of nested lists.
    To make this clearer, in the following example, we separate out the lists for
    each element in the third dimension before we construct the array:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建更高维度的数组，只需添加更多级别的嵌套列表。为了更清楚地说明这一点，在下面的示例中，我们在构造数组之前将第三维度中的每个元素的列表分开：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the first element of the shape is the outermost, and the last element
    is the innermost.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，形状的第一个元素是最外层的，最后一个元素是最内层的。
- en: This means that adding an additional dimension to an array is a simple matter
    of providing the relevant metadata. Using the `array` routine, the `shape` metadata
    is described by the length of each list in the argument. The length of the outermost
    list defines the corresponding `shape` parameter for that dimension, and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着向数组添加一个额外的维度只是提供相关的元数据。使用`array`例程，`shape`元数据由参数中每个列表的长度描述。最外层列表的长度定义了该维度的相应`shape`参数，依此类推。
- en: The size in memory of a NumPy array does not significantly depend on the number
    of dimensions, but only on the total number of elements, which is the product
    of the `shape` parameters. However, note that th e total number of elements tends
    to be larger in higher dimensional arrays.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组在内存中的大小并不显著取决于维度的数量，而只取决于元素的总数，这是`shape`参数的乘积。但是，请注意，高维数组中的元素总数往往较大。
- en: 'To access an element in a multi-dimensional array, you use the usual index
    notation, but rather than providing a single number, you need to provide the index
    in each dimension. For a 2 × 2 matrix, this means specifying the row and column
    for the desired element:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问多维数组中的元素，您可以使用通常的索引表示法，但是不是提供单个数字，而是需要在每个维度中提供索引。对于2×2矩阵，这意味着指定所需元素的行和列：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The index notation also supports slicing in each dimension, so we can extract
    all members of a single column by using the slice `mat[:, 0]` like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 索引表示法还支持在每个维度上进行切片，因此我们可以使用切片`mat[:, 0]`提取单列的所有成员，如下所示：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that the result of the slice is a one-dimensional array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，切片的结果是一个一维数组。
- en: The array creation functions, `zeros` and `ones`, can create multi-dimensional
    arrays by simply specifying a shape with more than one dimension parameter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数组创建函数`zeros`和`ones`可以通过简单地指定一个具有多个维度参数的形状来创建多维数组。
- en: Matrices
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: NumPy arrays also serve as *matrices*, which are fundamental in mathematics
    and computational programming. A *matrix* is simply a two-dimensional array. Matrices
    are central in many applications, such as geometric transformations and simultaneous
    equations, but also appear as useful tools in other areas such a statistics. Matrices
    themselves are only distinctive (compared to any other array) once we equip them
    with *matrix arithmetic*. Matrices have element-wise addition and subtraction
    operations, just as for NumPy arrays, a third operation called *scalar multiplication*,
    where we multiply every element of the matrix by a constant number, and a different
    notion of *matrix multiplication*. Matrix multiplication is fundamentally different
    from other notions of multiplication, as we will see later.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组也可以作为*矩阵*，在数学和计算编程中是基本的。*矩阵*只是一个二维数组。矩阵在许多应用中都是核心，例如几何变换和同时方程，但也出现在其他领域的有用工具中，例如统计学。矩阵本身只有在我们为它们配备*矩阵算术*时才是独特的（与任何其他数组相比）。矩阵具有逐元素的加法和减法运算，就像NumPy数组一样，还有一种称为*标量乘法*的第三种运算，其中我们将矩阵的每个元素乘以一个常数，以及一种不同的*矩阵乘法*概念。矩阵乘法与其他乘法概念根本不同，我们稍后会看到。
- en: One of the most important attributes of a matrix is its shape, defined exactly
    as for NumPy arrays. A matrix with *m* rows and *n* columns is usuallydescribed
    as an *m × n* matrix. A matrix that has the same number of rows as columns is
    said to be a *square* matrix, and these matrices play a special role in the theory
    of vectors and matrices.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的一个最重要的属性是其形状，与NumPy数组的定义完全相同。具有*m*行和*n*列的矩阵通常被描述为*m×n*矩阵。具有与列数相同的行数的矩阵被称为*方阵*，这些矩阵在向量和矩阵理论中起着特殊的作用。
- en: 'The *identity matrix* (of size*n*) is the*n ×**n* matrix where the (*i*,*i*)-th
    entry is 1, and the (*i*, *j*)-th entry is zero for*i* ≠ *j*. There is an array
    creation routine that gives an*n × n* identity matrix for a specified*n* value:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*单位矩阵*（大小为*n*）是*n×n*矩阵，其中（*i*，*i*）-th条目为1，而（*i*，*j*）-th条目对于*i* ≠ *j*为零。有一个数组创建例程，为指定的*n*值提供*n×n*单位矩阵：'
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Basic methods and properties
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本方法和属性
- en: There are a large number of terms and quantities associated with matrices. We
    only mention two such properties here, since they will be useful later. These
    are the *transpose* of a matrix, where rows and columns are interchanged, and
    the *trace* of a square matrix, which is the sum of the elements along the *leading
    diagonal*. The leading diagonal consists of the elements *a[ii]* along the line
    from the top left of the matrix to the bottom right.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩阵相关的术语和数量有很多。我们在这里只提到两个这样的属性，因为它们以后会有用。这些是矩阵的*转置*，其中行和列互换，以及*迹*，它是方阵沿着*主对角线*的元素之和。主对角线由从矩阵左上角到右下角的线上的元素*a[ii]*组成。
- en: 'NumPy arrays can be easily transposed by calling the `transpose`method on the
    `array` object. In fact, since this is such a common operation, arrays have a
    convenience property`T` that returns the transpose of the matrix. The transposition
    reverses the order of the shape of a matrix (array), so that rows become columns
    and columns become rows. For example, if we start with a 3 × 2 matrix (3 rows,
    2 columns), then its transpose will be a 2 × 3 matrix, such as in the following
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组可以通过在`array`对象上调用`transpose`方法轻松转置。实际上，由于这是一个常见的操作，数组有一个方便的属性`T`，它返回矩阵的转置。转置会颠倒矩阵（数组）的形状顺序，使行变为列，列变为行。例如，如果我们从一个3×2矩阵（3行，2列）开始，那么它的转置将是一个2×3矩阵，就像下面的例子一样：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Another quantity associated with matrices that is occasionally useful is the
    *trace*. Thetrace of a square matrix*A*, with entries as in the preceding code,
    is defined to be the sum of the elements along the*leading diagonal, which consists
    of the elements starting from the top left diagonally to the bottom right. The
    formula for the trace is given as*
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩阵相关的另一个数量有时也是有用的是*trace*。方阵*A*的trace，其条目如前面的代码所示，被定义为*leading diagonal*上的元素之和，它由从左上角对角线到右下角的元素组成。trace的公式如下*
- en: '*![](assets/e8eaa631-c006-4401-853f-b474da2c9319.png)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](assets/e8eaa631-c006-4401-853f-b474da2c9319.png)'
- en: 'NumPy arrays have a `trace` method that returns the trace of a matrix:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组有一个`trace`方法，返回矩阵的迹：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The trace can also be accessed using the `np.trace` function, which is not bound
    to the array.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: trace也可以使用`np.trace`函数访问，它不绑定到数组。
- en: Matrix multiplication
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Matrix multiplication is an operation performed on two matrices, which preserves
    some of the structure and character of both matrices. Formally, if *A* is an *l
    × m* matrix, and *B* is an *m × n* matrix, say
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法是在两个矩阵上执行的操作，它保留了两个矩阵的一些结构和特性。形式上，如果*A*是一个*l × m*矩阵，*B*是一个*m × n*矩阵，如下所述
- en: '![](assets/76bace88-ee7c-41ba-b7a5-d20ce18c1cca.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76bace88-ee7c-41ba-b7a5-d20ce18c1cca.png)'
- en: then the matrix product *C* of *A* and *B* is an *l × n* matrix whose (*p*,
    *q*)-th entry is given by
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么矩阵积*A*和*B*是一个*l × n*矩阵，其(*p*, *q*)-th条目由下式给出
- en: '![](assets/9b077bba-836c-4376-acf6-177457bb7e62.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9b077bba-836c-4376-acf6-177457bb7e62.png)'
- en: 'Note that the number of columns of the first matrix **must** match the number
    of rows of the second matrix in order for matrix multiplication to be defined.
    We usually write *AB* for the matrix product of *A* and *B,* if it is defined.
    Matrix multiplication is a peculiar operation. It is not *commutative* like most
    other arithmetic operations: even if *AB* and *BA* can both be computed, there
    is no need for them to be equal. In practice, this means that the order of multiplication
    matters for matrices. This arises from the origins of matrix algebras as representations
    of linear maps, where multiplication corresponds to the composition of functions.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个矩阵的列数**必须**与第二个矩阵的行数匹配，以便定义矩阵乘法。如果定义了矩阵乘积*AB*，我们通常写*AB*，如果它被定义。矩阵乘法是一种特殊的操作。它不像大多数其他算术运算那样是*交换的*：即使*AB*和*BA*都可以计算，它们不一定相等。实际上，这意味着矩阵的乘法顺序很重要。这源自矩阵代数作为线性映射的表示的起源，其中乘法对应于函数的组合。
- en: 'Python has an operator reserved for matrix multiplication`@`, which was added
    in Python 3.5\. NumPy arrays implement the operator to perform matrix multiplication.
    Note that this is fundamentally different from the component-wise multiplication
    of arrays`*`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个保留给矩阵乘法的运算符`@`，这是在Python 3.5中添加的。NumPy数组实现了这个运算符来执行矩阵乘法。请注意，这与数组的分量乘法`*`在本质上是不同的：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The identity matrix is a *neutral element* under matrix multiplication. That
    is, if *A* is any *l × m* matrix, and *I* is the *m* × *m* identity matrix, then
    *AI = A*. This can be easily checked for specific examples using NumPy arrays:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵是矩阵乘法下的*中性元素*。也就是说，如果*A*是任意的*l × m*矩阵，*I*是*m* × *m*单位矩阵，则*AI = A*。可以使用NumPy数组轻松检查特定示例：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Determinants and inverses
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行列式和逆
- en: The *determinant* of a square matrix is important in most applications because
    of its strong link with finding the inverse of a matrix. A matrix is *square*
    if the number of rows and columns are equal. In particular, a matrix that has
    a non-zero determinant has a (unique) inverse, which translates to unique solutions
    of certain systems of equations. The determinant of a matrix is defined recursively.
    For a 2 × 2 matrix
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方阵的*determinant*在大多数应用中都很重要，因为它与找到矩阵的逆的强连接。如果行和列的数量相等，则矩阵是*方阵*。特别地，一个具有非零行列式的矩阵具有（唯一的）逆，这对于某些方程组的唯一解是成立的。矩阵的行列式是递归定义的。对于一个2×2矩阵
- en: '![](assets/33bf7b70-0248-45b7-8576-937cb4ef8186.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/33bf7b70-0248-45b7-8576-937cb4ef8186.png)'
- en: the *determinant* of *A* is defined by the formula
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵*A*的*determinant*由以下公式定义
- en: '![](assets/16497d22-d726-4c2e-877a-ddc3f766124c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16497d22-d726-4c2e-877a-ddc3f766124c.png)'
- en: For a general *n* × *n* matrix
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个一般的*n*×*n*矩阵
- en: '![](assets/b9423b8e-3454-4283-bdba-97469ed68558.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b9423b8e-3454-4283-bdba-97469ed68558.png)'
- en: where *n* > 2, we define the submatrix *A[i,j]* for 1 ≤ *i*, *j*≤*n*, to be
    the result of deleting the *i*th row and *j*th column from *A*. The submatrix
    *A[i,j]* is an *(n-1) ×* (*n*-1) matrix, and so we can compute the determinant.
    We then define the determinant of *A* to be the quantity
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n* > 2，我们定义子矩阵*A[i,j]*，对于1 ≤ *i*，*j* ≤ *n*，为从*A*中删除第*i*行和第*j*列的结果。子矩阵*A[i,j]*是一个*(n-1)
    ×* (*n*-1)矩阵，因此我们可以计算行列式。然后我们定义*A*的行列式为数量
- en: '![](assets/6d24b037-4dcf-4bb0-9da9-ed1338f1e34b.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d24b037-4dcf-4bb0-9da9-ed1338f1e34b.png)'
- en: In fact, the index 1 that appears in the preceding equation can be replaced
    by any 1 ≤ i≤ *n* and the result will be the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，出现在前述方程中的索引1可以被任何1 ≤ i≤ *n*替换，结果将是相同的。
- en: 'The NumPy routine for computing the determinant of a matrix is contained in
    a separate module called `linalg`. This module contains many common routines for
    *linear algebra*, which is the branch of mathematics that covers vector and matrix
    algebra. The routine for computing the determinant of a square matrix is the `det`
    routine:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵行列式的NumPy例程包含在一个名为`linalg`的单独模块中。这个模块包含了许多关于*线性代数*的常见例程，线性代数是涵盖向量和矩阵代数的数学分支。计算方阵行列式的例程是`det`例程：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that a floating-point rounding error has occurred in the calculation of
    the determinant.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在计算行列式时发生了浮点舍入误差。
- en: The SciPy package, if installed, also offers a`linalg` module that extends NumPy's`linalg`.
    The SciPy version not only includes additional routines, but it is also always
    compiled with BLAS and LAPACK support, while for the NumPy version, this is optional.
    Thus, the SciPy variant may be preferable, depending on how NumPy was compiled,
    if speed is important.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了SciPy包，还提供了一个扩展了NumPy`linalg`的`linalg`模块。SciPy版本不仅包括额外的例程，而且始终使用BLAS和LAPACK支持进行编译，而对于NumPy版本，这是可选的。因此，如果速度很重要，SciPy变体可能更可取，这取决于NumPy的编译方式。
- en: The*inverse* of an*n ×**n* matrix*A* is the (necessarily unique) *n ×**n*matrix*B*,
    such that*AB*=*BA*=*I*, where*I*denotes the *n ×**n* identity matrix and the multiplication
    performed here is matrix multiplication. Not every square matrix has an inverse;
    those that do not are sometimes called*singular* matrices. In fact, a matrix is
    non-singular (that is, has an inverse) if, and only if, the determinant of that
    matrix is not 0\. When*A* has an inverse, it is customary to denote it by*A^(-1)*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*n × n*矩阵*A*的*逆*是（必然唯一的）*n × n*矩阵*B*，使得*AB*=*BA*=*I*，其中*I*表示*n × n*单位矩阵，这里执行的乘法是矩阵乘法。并非每个方阵都有逆；那些没有逆的有时被称为*奇异*矩阵。事实上，当*A*没有逆时，也就是说，当该矩阵的行列式为0时，它是非奇异的。当*A*有逆时，习惯上用*A^(-1)*表示它。'
- en: 'The `inv` routine from the `linalg` module computes the inverse of a matrix,
    if it exists:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg`模块的`inv`例程计算矩阵的逆，如果存在的话：'
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can check that the matrix given by the `inv` routine is indeed the matrix
    inverse of `A` by matrix multiplying (on either side) by the inverse and checking
    that we get the 2 × 2 identity matrix:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过矩阵乘法（在任一侧）乘以逆矩阵，并检查我们是否得到了2 × 2单位矩阵，来检查`inv`例程给出的矩阵是否确实是`A`的矩阵逆：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There will be a floating-point error in these computations, which has been hidden
    away behind the `Approximately` comment, due to the way that matrix inverses are
    computed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算中会有浮点误差，这已经被隐藏在`Approximately`注释后面，这是由于计算矩阵的逆的方式。
- en: The `linalg` package also contains a number of other methods such as `norm`,
    which computes various norms of a matrix. It also contains functions for decomposing
    matrices in various ways and solving systems of equations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg`包还包含许多其他方法，如`norm`，它计算矩阵的各种范数。它还包含了各种分解矩阵和解方程组的函数。'
- en: There are also the matrix analogues of the exponential function `expm`, the
    logarithm `logm`, sine `sinm`, cosine `cosm`, and tangent `tanm`. Note that these
    functions are not the same as the standard `exp`, `log`, `sin`, `cos`, and `tan`
    functions in the base NumPy package, which apply the corresponding function on
    an element by element basis. In contrast, the matrix exponential function is defined
    using a "power series" of matrices
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有指数函数`expm`、对数函数`logm`、正弦函数`sinm`、余弦函数`cosm`和切线函数`tanm`的矩阵类比。请注意，这些函数与基本NumPy包中的标准`exp`、`log`、`sin`、`cos`和`tan`函数不同，后者是在元素基础上应用相应的函数。相反，矩阵指数函数是使用矩阵的“幂级数”定义的。
- en: '![](assets/3ca5b8f2-59d4-40cd-b789-e6a3561dde62.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ca5b8f2-59d4-40cd-b789-e6a3561dde62.png)'
- en: where *A* is an *n × n* matrix and *A^k* is the *k*th *matrix power* of *A*;
    that is, the *A* matrix multiplied by itself *k* times. Note that this "power
    series" always converges in an appropriate sense. By convention, we take *A⁰*
    = *I*, where *I* is the *n × n* identity matrix. This is completely analogous
    to the usual power series definition of the exponential function for real or complex
    numbers, but with matrices and matrix multiplication in place of numbers and (regular)
    multiplication. The other functions are defined in a similar fashion, but we will
    skip the details.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*A*是一个*n × n*矩阵，*A^k*是*A*的第*k*个*矩阵幂*；也就是说，*A*矩阵连续乘以自身*k*次。请注意，这个“幂级数”总是在适当的意义下收敛。按照惯例，我们取*A⁰*
    = *I*，其中*I*是*n × n*单位矩阵。这与实数或复数的指数函数的常规幂级数定义完全类似，但是用矩阵和矩阵乘法代替了数字和（常规）乘法。其他函数也是以类似的方式定义的，但我们将跳过细节。
- en: Systems of equations
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方程组
- en: Solving systems of (linear) equations is one of the main motivations for studying
    matrices in mathematics. Problems of this type occur frequently in a variety of
    applications. We start with a system of linear equations written as
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 解（线性）方程组是研究矩阵的主要动机之一。这类问题在各种应用中经常出现。我们从写成线性方程组的形式开始
- en: '![](assets/4ebf6e1d-e0bd-4f8c-a95f-58b5dd15d391.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ebf6e1d-e0bd-4f8c-a95f-58b5dd15d391.png)'
- en: where *n* is at least two, *a[i,j]*[and *b[i]* are known values, and the *x[i]*
    values are the unknown values that we wish to find.]
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n*至少为2，*a[i,j]*和*b[i]*是已知值，*x[i]*值是我们希望找到的未知值。
- en: Before we can solve such a system of equations, we need to convert the problem
    into a matrix equation. This is achieved by collecting together the coefficients
    *a[i,j]* into an *n × n* matrix and using the properties of matrix multiplication
    to relate this matrix to the system of equations. So, let
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在解这样的方程组之前，我们需要将问题转化为矩阵方程。这是通过将系数*a[i,j]*收集到一个*n × n*矩阵中，并使用矩阵乘法的性质将这个矩阵与方程组联系起来实现的。因此，让
- en: '![](assets/0bf397b7-5253-4e69-a7f5-d6b81502427a.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0bf397b7-5253-4e69-a7f5-d6b81502427a.png)'
- en: be the matrix containing the coefficients taken from the equations. Then, if
    we take **x** to be the unknown (column) vector containing the *x[i]* values and
    **b** to be the (column) vector containing the known values *b[i]*, then we can
    rewrite the system of equations as the single matrix equation
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 是包含方程中系数的矩阵。然后，如果我们将**x**作为未知数（列）向量，包含*x[i]*值，**b**作为（列）向量，包含已知值*b[i]*，那么我们可以将方程组重写为单个矩阵方程
- en: '![](assets/08d03070-dc5f-4c12-999d-3e555762c0ae.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/08d03070-dc5f-4c12-999d-3e555762c0ae.png)'
- en: 'which we can now solve using matrix techniques. In this situation, we view
    a column vector as an *n × 1* matrix, so the multiplication in the preceding equation
    is matrix multiplication. To solve this matrix equation, we use the `solve` routine
    in the `linalg` module. To illustrate the technique, we will solve the following
    system of equations as an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用矩阵技术来解决这个问题。在这种情况下，我们将列向量视为*n × 1*矩阵，因此前面方程中的乘法是矩阵乘法。为了解决这个矩阵方程，我们使用`linalg`模块中的`solve`例程。为了说明这种技术，我们将解决以下方程组作为示例：
- en: '![](assets/47b1fa6c-38f1-4b2d-9a9a-9b78774dcc02.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47b1fa6c-38f1-4b2d-9a9a-9b78774dcc02.png)'
- en: 'These equations have three unknown values, *x[1]*, *x[2]*, and *x[3]*. First,
    we create the matrix of coefficients and the vector **b**. Since we are using
    NumPy as our means of working with matrices and vectors, we create a two-dimensional
    NumPy array for the matrix *A* and a one-dimensional array for **b**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程有三个未知值，*x[1]*，*x[2]*和*x[3]*。首先，我们创建系数矩阵和向量**b**。由于我们使用NumPy来处理矩阵和向量，我们为矩阵*A*创建一个二维NumPy数组，为**b**创建一个一维数组：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, the solution to the system of equations can be found using the `solve`
    routine:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用`solve`例程找到方程组的解：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is indeed the solution to the system of equations, which can be easily
    verified by computing `A @ x` and checking the result against the `b`array. There
    may be a floating-point rounding error in this computation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是方程组的解，可以通过计算`A @ x`并将结果与`b`数组进行对比来轻松验证。在这个计算中可能会出现浮点舍入误差。
- en: The `solve` function expects two inputs, which are the matrix of coefficients
    *A* and the right-hand side vector **b**. It solves the system of equations using
    LAPACK routines that decompose matrix *A* into simpler matrices to quickly reduce
    to an easier problem that can be solved by simple substitution. This technique
    for solving matrix equations is extremely powerful and efficient, and is less
    prone to the floating-point rounding errors that dog some other methods. For instance,
    the solution to a system of equations could be computed by multiplying (on the
    left) by the inverse of the matrix *A*, if the inverse is known. However, this
    is generally not as good as using the `solve` routine since it may be slower or
    result in larger numerical errors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve`函数需要两个输入，即系数矩阵*A*和右侧向量**b**。它使用LAPACK例程解决方程组，将矩阵*A*分解为更简单的矩阵，以快速减少为一个可以通过简单替换解决的更简单的问题。这种解决矩阵方程的技术非常强大和高效，并且不太容易受到浮点舍入误差的影响。例如，可以通过与矩阵*A*的逆矩阵相乘（在左侧）来计算方程组的解，如果已知逆矩阵。然而，这通常不如使用`solve`例程好，因为它可能更慢或导致更大的数值误差。'
- en: 'In the example we used, the coefficient matrix *A* was square. That is, there
    are the same number of equations as there are unknown values. In this case, the
    system of equations has a unique solution if (and only if) the determinant of
    this matrix *A* is not 0\. In cases where the determinant of *A* is 0, one of
    two things can happen: the system can have no solution, in which case we say that
    the system is *inconsistent*; or there can be infinitely many solutions. The difference
    between a consistent and inconsistent system is usually determined by the vector
    **b**. For example, consider the following systems of equations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的示例中，系数矩阵*A*是方阵。也就是说，方程的数量与未知值的数量相同。在这种情况下，如果且仅当矩阵*A*的行列式不为0时，方程组有唯一解。在矩阵*A*的行列式为0的情况下，可能会出现两种情况：方程组可能没有解，这种情况下我们称方程组是*不一致*的；或者可能有无穷多个解。一致和不一致系统之间的区别通常由向量**b**决定。例如，考虑以下方程组：
- en: '![](assets/01c4d5b9-99a5-4ca5-a7e4-b3deb5cc1190.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/01c4d5b9-99a5-4ca5-a7e4-b3deb5cc1190.png)'
- en: The left-hand system of equations is consistent and has infinitely many solutions;
    for instance, taking *x* = 1 and *y = 1* or *x = 0* and *y = 2* are both solutions.
    The right-hand system of equations is inconsistent, and there are no solutions.
    In both of the above, the `solve` routine will fail because the coefficient matrix
    is singular.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的方程组是一致的，有无穷多个解；例如，取*x* = 1和*y = 1*或*x = 0*和*y = 2*都是解。右侧的方程组是不一致的，没有解。在上述两种情况下，`solve`例程将失败，因为系数矩阵是奇异的。
- en: The coefficient matrix does not need to be square for the system to be solvable.
    For example, if there are more equations than there are unknown values (a coefficient
    matrix has more rows than columns). Such a system is said to be *over-specified*
    and, provided that it is consistent, it will have a solution. If there are fewer
    equations than there are unknown values, then the system is said to be *under-specified.*
    Under-specified systems of equations generally have infinitely many solutions
    if they are consistent, since there is not enough information to uniquely specify
    all the unknown values. Unfortunately, the `solve` routine will not be able to
    find solutions for systems where the coefficient matrix is not square, even if
    the system does have a solution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 系数矩阵不需要是方阵才能解决方程组。例如，如果方程比未知值多（系数矩阵的行数多于列数）。这样的系统被称为*过度规定*，只要是一致的，它就会有解。如果方程比未知值少，那么系统被称为*不足规定*。如果是一致的，不足规定的方程组通常有无穷多个解，因为没有足够的信息来唯一指定所有未知值。不幸的是，即使系统有解，`solve`例程也无法找到系数矩阵不是方阵的系统的解。
- en: Eigenvalues and eigenvectors
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征值和特征向量
- en: Consider the matrix equation *A***x** = λ**x**, where *A* is a square (*n ×
    n*) matrix, **x** is a vector, and λ is a number. Numbers λ for which there is
    an **x** that solves this equation are called *eigenvalues*, and the corresponding
    vectors **x** are called *eigenvectors.* Pairs of eigenvalues and corresponding
    eigenvectors encode information about the matrix *A*, and are therefore important
    in many applications where matrices appear.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑矩阵方程*A***x** = λ**x**，其中*A*是一个方阵（*n × n*），**x**是一个向量，λ是一个数字。对于这个方程有一个**x**可以解决的λ被称为*特征值*，相应的向量**x**被称为*特征向量*。特征值和相应的特征向量对编码了关于矩阵*A*的信息，因此在许多矩阵出现的应用中非常重要。
- en: 'We will demonstrate computing eigenvalues and eigenvectors using the following
    matrix:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示使用以下矩阵计算特征值和特征向量：
- en: '![](assets/192ad11a-26cd-4dd1-a9d6-21df5cb79e7e.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/192ad11a-26cd-4dd1-a9d6-21df5cb79e7e.png)'
- en: 'We must first define this as a NumPy array:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须首先将其定义为NumPy数组：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `eig` routine in the `linalg` module is used to find the eigenvalues and
    eigenvectors of a square matrix. This routine returns a pair `(v, B)` where `v`
    is a one-dimensional array containing the eigenvalues and `B` is a two-dimensional
    array whose columns are the corresponding eigenvectors:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`linalg`模块中的`eig`例程用于找到方阵的特征值和特征向量。这个例程返回一对`(v, B)`，其中`v`是包含特征值的一维数组，`B`是其列是相应特征向量的二维数组：'
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is perfectly possible for a matrix with only real entries to have complex
    eigenvalues and eigenvectors. For this reason, the return type of the `eig` routine
    will sometimes be a complex number type such as `complex32` or `complex64`. In
    some applications, complex eigenvalues have a special meaning, while in others
    we only consider the real eigenvalues.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只有具有实数条目的矩阵才可能具有复特征值和特征向量。因此，`eig`例程的返回类型有时将是复数类型，如`complex32`或`complex64`。在某些应用中，复特征值具有特殊含义，而在其他情况下，我们只考虑实特征值。
- en: 'We can extract an eigenvalue/eigenvector pair from the output of `eig` using
    the following sequence:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下序列从`eig`的输出中提取特征值/特征向量对：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The eigenvectors returned by the `eig` routine are *normalized* so that they
    have norm (length) 1\. (The *Euclidean norm* is defined to be the square root
    of the sum of the squares of the members of the array.) We can check that this
    is the case by evaluating in the norm of the vector using the `norm` routine from
    `linalg`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`eig`例程返回的特征向量是*归一化*的，使得它们的范数（长度）为1。 （*欧几里得范数*被定义为数组成员的平方和的平方根。）我们可以通过使用`linalg`中的`norm`例程计算向量的范数来检查这一点：'
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we can check that these values do indeed satisfy the definition of
    an eigenvalue/eigenvector pair by computing the product `A @ x0` and checking
    that, up to floating-point precision, this is equal to `lambda0*x0`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过计算乘积`A @ x0`并检查，直到浮点精度，这等于`lambda0*x0`，来检查这些值确实满足特征值/特征向量对的定义：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The norm computed here represents the "distance" between the left-hand side
    `lhs` and the right-hand side `rhs` of the equation *A***x** = λ**x**. Since this
    distance is extremely small (0 to 14 decimal places), we can be fairly confident
    that they are actually the same. The fact that this is not zero is likely due
    to floating-point precision error.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里计算的范数表示方程*A***x** = λ**x**的左侧`lhs`和右侧`rhs`之间的“距离”。由于这个距离非常小（小数点后0到14位），我们可以相当确信它们实际上是相同的。这不为零的事实可能是由于浮点精度误差。
- en: The `eig` routine is a wrapper around the low-level LAPACK routines for computing
    eigenvalues and eigenvectors. The theoretical procedure for finding eigenvalues
    and eigenvectors is to first find the eigenvalues by solving the equation
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`eig`例程是围绕低级LAPACK例程的包装器，用于计算特征值和特征向量。找到特征值和特征向量的理论过程是首先通过解方程找到特征值'
- en: '![](assets/29520bb2-fc2e-42af-bbb9-e3236ea9936a.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/29520bb2-fc2e-42af-bbb9-e3236ea9936a.png)'
- en: where *I* is the appropriate identity matrix, to find the values λ. The equation
    determined by the left-hand side is a polynomial in λ and is called the *characteristic
    polynomial* of *A*. The corresponding eigenvectors can then be found by solving
    the matrix equation
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*I*是适当的单位矩阵，以找到值λ。左侧确定的方程是λ的多项式，称为*A*的*特征多项式*。然后可以通过解决矩阵方程找到相应的特征向量
- en: '![](assets/a8e09b6c-ef9b-406f-980b-cfacf87b2969.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8e09b6c-ef9b-406f-980b-cfacf87b2969.png)'
- en: where λ*[j]*is one of the eigenvalues already found. In practice, this process
    is somewhat inefficient, and there are alternative strategies for computing eigenvalues
    and eigenvectors numerically more efficiently.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 其中λ*[j]*是已经找到的特征值之一。实际上，这个过程有些低效，有替代策略可以更有效地计算特征值和特征向量。
- en: One key application of eigenvalues and eigenvectors is in *principal component
    analysis*, which is a key technique for reducing a large, complex dataset to better
    understand the internal structure.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值和特征向量的一个关键应用是*主成分分析*，这是一种将大型复杂数据集减少到更好地理解内部结构的关键技术。
- en: We can only compute eigenvalues and eigenvectors for square matrices; for non-square
    matrices, the definition does not make sense. There is a generalization of eigenvalues
    and eigenvalues to non-square matrices called *singular values*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能计算方阵的特征值和特征向量；对于非方阵，该定义没有意义。有一种将特征值和特征值推广到非方阵的称为*奇异值*的方法。
- en: Sparse matrices
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稀疏矩阵
- en: Systems of linear equations such as those discussed earlier are extremely common
    throughout mathematics and, in particular, in mathematical computing. In many
    applications, the coefficient matrix will be extremely large, with thousands of
    rows and columns, and will likely be obtained from an alternative source rather
    than simply entering by hand. In many cases, it will also be a *sparse* matrix,
    where most of the entries are 0.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如前面讨论的那样的线性方程组在数学中非常常见，特别是在数学计算中。在许多应用中，系数矩阵将非常庞大，有数千行和列，并且可能来自替代来源而不是简单地手动输入。在许多情况下，它还将是*稀疏*矩阵，其中大多数条目为0。
- en: A matrix is *sparse* if a large number of the elements are zero. The exact number
    of elements that need to be zero in order to call a matrix sparse is not well
    defined. Sparse matrices can be represented more efficiently, for example, by
    simply storing the indexes (*i*, *j*) and the values *a[i,j]* that are non-zero.
    There are entire collections of algorithms for sparse matrices that offer great
    improvements in performance, assuming the matrix is indeed sufficiently sparse.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵的大多数元素为零，则矩阵是*稀疏*的。要调用矩阵稀疏，需要为零的确切元素数量并不明确定义。稀疏矩阵可以更有效地表示，例如，只需存储非零的索引（*i*，*j*）和值*a[i,j]*。有整个集合的稀疏矩阵算法，可以在矩阵确实足够稀疏的情况下大大提高性能。
- en: Sparse matrices appear in many applications, and often follow some kind of pattern.
    In particular, several techniques for solving **partial differential equations**
    (**PDEs**) involve solving sparse matrix equations (see [Chapter 3](1a62e7c6-06f5-4ee3-8f63-5bb14f6db553.xhtml),
    *Calculus and Differential Equations)*, and matrices associated with networks
    are often sparse. There are additional routines for sparse matrices associated
    with networks (graphs) contained in the `sparse.csgraph` module. We will discuss
    these further in [Chapter 5](c1a2f2ae-682f-469a-a00e-32c848bd1f38.xhtml), *Working
    with Trees and Networks*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵出现在许多应用程序中，并且通常遵循某种模式。特别是，解决**偏微分方程**（**PDEs**）的几种技术涉及解决稀疏矩阵方程（请参阅[第3章](1a62e7c6-06f5-4ee3-8f63-5bb14f6db553.xhtml)，*微积分和微分方程*），与网络相关的矩阵通常是稀疏的。`sparse.csgraph`模块中包含与网络（图）相关的稀疏矩阵的其他例程。我们将在[第5章](c1a2f2ae-682f-469a-a00e-32c848bd1f38.xhtml)中进一步讨论这些内容，*处理树和网络*。
- en: The `sparse` module contains several different classes representing the different
    means of storing a sparse matrix. The most basic means of storing a sparse matrix
    is to store three arrays, two containing integers representing the indices of
    non zero elements, and the third the data of the corresponding element. This is
    the format of the `coo_matrix` class. Then there are the compressed column CSC
    (`csc_matrix`) and the compressed row CSR (`csr_matrix`) formats, which provide
    efficient column or row slicing, respectively.There are three additional sparse
    matrix classes in `sparse`, including `dia_matrix`, which efficiently stores matrices
    where the non-zero entries appear along a diagonal band.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse`模块包含几种表示稀疏矩阵存储方式的不同类。存储稀疏矩阵的最基本方式是存储三个数组，其中两个包含表示非零元素的索引的整数，第三个包含相应元素的数据。这是`coo_matrix`类的格式。然后有压缩列CSC（`csc_matrix`）和压缩行CSR（`csr_matrix`）格式，它们分别提供了有效的列或行切片。`sparse`中还有三个额外的稀疏矩阵类，包括`dia_matrix`，它有效地存储非零条目沿对角线带出现的矩阵。'
- en: 'The `sparse` module from SciPy contains routines for creating and working with
    sparse matrices. We import the `sparse` module from SciPy using the following
    `import` statement:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 来自SciPy的`sparse`模块包含用于创建和处理稀疏矩阵的例程。我们使用以下`import`语句从SciPy导入`sparse`模块：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A sparse matrix can be created from a full (dense) matrix, or some other kind
    of data structure. This is done using the constructor for the specific format
    in which you wish to store the sparse matrix.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵可以从完整（密集）矩阵或其他某种数据结构创建。这是使用特定格式的构造函数来完成的，您希望将稀疏矩阵存储在其中。
- en: 'For example, we can take a dense matrix and store it in CSR format by using
    the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过使用以下命令将密集矩阵存储为CSR格式：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you are generating a sparse matrix by hand, the matrix probably follows
    some kind of pattern, such as the following *tridiagonal* matrix:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手动生成稀疏矩阵，该矩阵可能遵循某种模式，例如以下*三对角*矩阵：
- en: '![](assets/0d9a6f28-5695-48e2-b5eb-606945aaddf9.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0d9a6f28-5695-48e2-b5eb-606945aaddf9.png)'
- en: 'Here, the non-zero entries appear on the diagonal and on either side of the
    diagonal, and the non-zero entries in each row follow the same pattern. To create
    such a matrix, we could use one of the array creation routines in `sparse` such
    as `diags`, which is a convenience routine for creating matrices with diagonal
    patterns:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，非零条目出现在对角线上以及对角线两侧，并且每行中的非零条目遵循相同的模式。要创建这样的矩阵，我们可以使用`sparse`中的数组创建例程之一，例如`diags`，这是一个用于创建具有对角线模式的矩阵的便利例程：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will create the matrix *T* as described previously and store it as a sparse
    matrix in compressed sparse row CSR format. The first argument specifies the values
    that should appear in the output matrix, and the second argument is the positions
    relative to the diagonal position in which the values should be placed. So the
    0 index in the tuple represents the diagonal entry, -1 is to the left of the diagonal
    in the row, and +1 is to the right of the diagonal in the row. The `shape` keyword
    argument gives the dimensions of the matrix produced, and the `format` specifies
    the storage format for the matrix. If no format is provided using the optional
    argument, then a reasonable default will be used. The array `T` can be expanded
    to a full (*dense*) matrix using the `toarray` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建矩阵*T*，并按压缩稀疏行CSR格式存储它。第一个参数指定应出现在输出矩阵中的值，第二个参数是相对于应放置值的对角线位置的位置。因此，元组中的0索引表示对角线条目，-1表示在行中对角线的左侧，+1表示在行中对角线的右侧。`shape`关键字参数给出了生成的矩阵的维度，`format`指定了矩阵的存储格式。如果没有使用可选参数提供格式，则将使用合理的默认值。数组`T`可以使用`toarray`方法扩展为完整（*密集*）矩阵：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When the matrix is small (as it is here), there is little difference in performance
    between the sparse solving routine and the usual solving routines.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩阵很小时（就像这里一样），稀疏求解例程和通常的求解例程之间的性能差异很小。
- en: 'Once a matrix is stored in a sparse format, we can use the sparse solving routines
    in the `linalg` submodule of `sparse`. For example, we can solve a matrix equation
    using the `spsolve` routine from this module. The `spsolve` routine will convert
    the matrix into CSR or CSC, which may add additional time to the computation if
    it is not provided in one of these formats:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦矩阵以稀疏格式存储，我们可以使用`sparse`的`linalg`子模块中的稀疏求解例程。例如，我们可以使用该模块的`spsolve`例程来解决矩阵方程。`spsolve`例程将把矩阵转换为CSR或CSC，如果矩阵不是以这些格式之一提供的话，可能会增加额外的计算时间：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `sparse.linalg` module also contains many of the routines that can be found
    in the `linalg` module of NumPy (or SciPy) that accept sparse matrices instead
    of full NumPy arrays, such as `eig` and `inv`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse.linalg`模块还包含许多可以在NumPy（或SciPy）的`linalg`模块中找到的接受稀疏矩阵而不是完整NumPy数组的例程，例如`eig`和`inv`。'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Python offers built-in support for mathematics with some basic numerical types,
    arithmetic, and basic mathematical functions. However, for more serious computations
    involving large arrays of numerical values, you should use the NumPy and SciPy
    packages. NumPy provides high-performance array types and basic routines, while
    SciPy provides more specific tools for solving equations and working with sparse
    matrices (among many other things).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了对数学的内置支持，包括一些基本的数值类型、算术和基本的数学函数。然而，对于涉及大量数值值数组的更严肃的计算，您应该使用NumPy和SciPy软件包。NumPy提供高性能的数组类型和基本例程，而SciPy提供了更多用于解方程和处理稀疏矩阵（以及许多其他内容）的特定工具。
- en: NumPy arrays can be multi-dimensional. In particular, two-dimensional arrays
    have matrix properties that can be accessed using the `linalg` module from either
    NumPy or SciPy (the former is a subset of the latter). Moreover, there is a special
    operator in Python for matrix multiplication, `@`, which is implemented for NumPy
    arrays.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组可以是多维的。特别是，二维数组具有矩阵属性，可以使用NumPy或SciPy的`linalg`模块（前者是后者的子集）来访问。此外，Python中有一个特殊的矩阵乘法运算符`@`，它是为NumPy数组实现的。
- en: In the next chapter, we'll get started looking at some recipes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始查看一些配方。
- en: Further reading
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are many mathematical textbooks describing the basic properties of matrices
    and linear algebra, which is the study of vectors and matrices. A good introductory
    text is *Blyth, T. and Robertson, E. (2013). Basic Linear Algebra**. London: Springer
    London, Limited*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '有许多数学教科书描述矩阵和线性代数的基本属性，线性代数是研究向量和矩阵的学科。一个很好的入门文本是*Blyth, T. and Robertson,
    E. (2013). Basic Linear Algebra**. London: Springer London, Limited*。'
- en: NumPy and SciPy are part of the Python mathematical and scientific computing
    ecosystem, and have extensive documentation that can be accessed from the official
    website, [https://scipy.org](https://scipy.org). We will see several other packages
    from this ecosystem throughout this book.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy和SciPy是Python数学和科学计算生态系统的一部分，并且有广泛的文档可以从官方网站[https://scipy.org](https://scipy.org)访问。我们将在本书中看到这个生态系统中的几个其他软件包。
- en: 'More information about the BLAS and LAPACK libraries that NumPy and SciPy use
    behind the scenes can be found at the following links: BLAS: [https://www.netlib.org/blas/](https://www.netlib.org/blas/)
    and LAPACK: [https://www.netlib.org/lapack/](https://www.netlib.org/lapack/).**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有关NumPy和SciPy在幕后使用的BLAS和LAPACK库的更多信息可以在以下链接找到：BLAS：[https://www.netlib.org/blas/](https://www.netlib.org/blas/)
    和 LAPACK：[https://www.netlib.org/lapack/](https://www.netlib.org/lapack/)。
