- en: Extracting Embedded Metadata Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取嵌入式元数据配方
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下配方：
- en: Extracting audio and video metadata
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取音频和视频元数据
- en: The big picture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大局观
- en: Mining for PDF metadata
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挖掘PDF元数据
- en: Reviewing executable metadata
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查可执行文件元数据
- en: Reading office document metadata
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读办公文档元数据
- en: Integrating our metadata extractor with EnCase
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的元数据提取器与EnCase集成
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When an investigation comes down to just a few files of interest, it is critical
    to extract every piece of available information about the file. Embedded metadata,
    often overlooked, can provide us with crucial information that solidifies the
    evidentiary value of a given file. Whether it is gathering authorship information
    from Microsoft Office files, mapping GPS coordinates from pictures, or extracting
    compilation information from executables, we can learn a lot more about files
    we are investigating. In this chapter, we will develop scripts to examine these
    file formats, and others, to extract key information for our review. We will illustrate
    how to integrate these recipes with EnCase, the popular forensic suite, and add
    them to your investigative workflow.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当调查仅涉及少数感兴趣的文件时，提取有关文件的每一条可用信息至关重要。经常被忽视的嵌入式元数据可以为我们提供巩固给定文件证据价值的关键信息。无论是从Microsoft
    Office文件中收集作者信息，从图片中映射GPS坐标，还是从可执行文件中提取编译信息，我们都可以更多地了解我们正在调查的文件。在本章中，我们将开发脚本来检查这些文件格式以及其他文件格式，以提取我们审查的关键信息。我们将说明如何将这些配方与流行的取证套件EnCase集成，并将它们添加到您的调查工作流程中。
- en: 'In particular, we will develop code that highlights the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将开发突出以下内容的代码：
- en: Parsing ID3 and QuickTime-formatted metadata from audio and video formats
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析音频和视频格式的ID3和QuickTime格式的元数据
- en: Revealing GPS coordinates embedded within images
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示嵌入在图像中的GPS坐标
- en: Identifying authorship and lineage information from PDF files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从PDF文件中识别作者和谱系信息
- en: Extracting embedded names, compilation dates, and other attributes of Windows
    executable files
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Windows可执行文件中提取嵌入的名称、编译日期和其他属性的信息
- en: Reporting on document creation and source of Microsoft Office files
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告Microsoft Office文件的创建和来源
- en: Launching Python scripts from EnCase
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从EnCase启动Python脚本
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)下载本章的代码包。
- en: Extracting audio and video metadata
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取音频和视频元数据
- en: 'Recipe Difficulty: Easy'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Audio and video files are common file formats that make use of embedded metadata.
    This information, for example, is used by your preferred media player to show
    the artist, album, and track name information of the content you import. Though
    the majority of this information is standard and focused on providing information
    to the listener, we sometimes find important details in this area of the file.
    We begin our exploration of embedded metadata with the extraction of the common
    attributes from audio and video files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 音频和视频文件是常见的文件格式，它们使用嵌入式元数据。例如，您喜欢的媒体播放器使用此信息来显示您导入的内容的艺术家、专辑和曲目名称信息。尽管大多数信息是标准的并专注于向听众提供信息，但我们有时会在文件的这个领域找到重要的细节。我们从提取音频和视频文件的常见属性开始探索嵌入式元数据。
- en: Getting started
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This recipe requires the installation of the third-party library `mutagen`.
    All other libraries used in this script are present in Python''s standard library.
    This library allows us to extract metadata from audio and video files. This library
    can be installed using `pip`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要安装第三方库`mutagen`。此脚本中使用的所有其他库都包含在Python的标准库中。此库允许我们从音频和视频文件中提取元数据。可以使用`pip`安装此库：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To learn more about the `mutagen` library, visit [https://mutagen.readthedocs.io/en/latest](https://mutagen.readthedocs.io/en/latest).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`mutagen`库的更多信息，请访问[https://mutagen.readthedocs.io/en/latest](https://mutagen.readthedocs.io/en/latest)。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this script, we perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们执行以下步骤：
- en: Identify the input file type.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别输入文件类型。
- en: Extract embedded metadata from the file type processor.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件类型处理器中提取嵌入式元数据。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To extract information from a sample MP3 or MP4 file, we first import the three
    libraries needed for this recipe: `argparse`, `json`, and `mutagen`. The `json`
    library allows us to load definitions for the QuickTime MP4 metadata format used
    later in this recipe.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要从示例MP3或MP4文件中提取信息，我们首先导入此配方所需的三个库：`argparse`、`json`和`mutagen`。`json`库允许我们加载稍后在此配方中使用的QuickTime
    MP4元数据格式的定义。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This recipe''s command-line handler takes one positional argument, `AV_FILE`,
    which represents the path to the MP3 or MP4 file to process. After parsing the
    user-supplied arguments, we use the `mutagen.File()` method to open a handle to
    the file. Depending on the extension of the input file, we send this handle to
    the appropriate function: `handle_id3()` or `handle_mp4()`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的命令行处理程序接受一个位置参数`AV_FILE`，表示要处理的MP3或MP4文件的路径。在解析用户提供的参数之后，我们使用`mutagen.File（）`方法打开文件的句柄。根据输入文件的扩展名，我们将此句柄发送到适当的函数：`handle_id3（）`或`handle_mp4（）`。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `handle_id3()` function is responsible for extracting metadata from MP3
    files. The MP3 format uses the ID3 standard for storing its metadata. In our ID3
    parsing function, we first create a dictionary, called `id3_frames`, mapping the
    ID3 fields, as they are represented in the raw file, to human-readable strings.
    We can add more fields to this definition to extend the information we extract.
    Before we extract the embedded metadata, we print appropriate column headers to
    the console.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_id3（）`函数负责从MP3文件中提取元数据。MP3格式使用ID3标准来存储其元数据。在我们的ID3解析函数中，我们首先创建一个名为`id3_frames`的字典，将ID3字段（在原始文件中表示）映射到人类可读的字符串。我们可以向此定义添加更多字段，以扩展我们提取的信息。在提取嵌入式元数据之前，我们将适当的列标题打印到控制台。'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we use a loop to extract the names and various values of each `id3` frame.
    We query the name of the frame against the `id3_frames` dictionary to extract
    the human-readable version of it. Additionally, from each of the frames, we extract
    the description, text, and value(s) (if they are present) using the `getattr()`
    method. Finally, we print the pipe-delimited text to the console for review. That
    takes care of MP3 files, now let's move onto MP4 files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用循环提取每个`id3`帧的名称和各种值。我们查询帧的名称以从`id3_frames`字典中提取其人类可读版本。此外，从每个帧中，我们使用`getattr()`方法提取描述、文本和值（如果存在）。最后，我们将管道分隔的文本打印到控制台进行审查。这样处理了MP3文件，现在让我们转到MP4文件。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `handle_mp4()` function is responsible for processing MP4 files and follows
    a similar workflow to the previous function. We begin by setting up the metadata
    mappings in a dictionary, called `qt_tag`, using the Unicode value for the copyright
    symbol (`u"\u00A9"`) as a prepended character to the field names. This mapping
    dictionary is designed so the tag name is the key and the human-readable string
    is the value. We then use the `json.load()` method to bring in a large list of
    definitions for types of media genres (Comedy, Podcasts, Country, and so on).
    By storing the JSON data to the `genre_ids` variable, in this case, we have a
    dictionary with genre look up values where keys are integers and their values
    are different genres. These definitions are from [http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/QuickTime.html#GenreID](http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/QuickTime.html#GenreID).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_mp4()`函数负责处理MP4文件，并且遵循与之前函数类似的工作流程。我们首先在一个名为`qt_tag`的字典中设置元数据映射，使用版权符号（`u"\u00A9"`）的Unicode值作为字段名称的前置字符。这个映射字典被设计成标签名称是键，人类可读的字符串是值。然后，我们使用`json.load()`方法导入了一个大型的媒体类型定义列表（喜剧、播客、乡村等）。通过将JSON数据存储到`genre_ids`变量中，这种情况下，我们有一个包含不同类型的键值对的字典，其中键是整数，值是不同的类型。这些定义来自[http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/QuickTime.html#GenreID](http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/QuickTime.html#GenreID)。'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we iterate through the MP4 file's embedded metadata key-value pairs. For
    each key, we use the `qt_tag` dictionary to look up the human-readable version
    of the key. If the value is a list, we join all of its elements into a semi-colon
    separated string. Alternatively, if the value is `"geID"`, we use the `genre_ids`
    dictionary to look up the integer and print the mapped genre for the user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历MP4文件的嵌入式元数据键值对。对于每个键，我们使用`qt_tag`字典查找键的人类可读版本。如果值是一个列表，我们将其所有元素连接成一个以分号分隔的字符串。或者，如果值是`"geID"`，我们使用`genre_ids`字典查找整数，并为用户打印映射的类型。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using a MP3 podcast as an example, the script shows additional details otherwise
    unavailable. We now know the release date, what appears to be the software used,
    and several identifiers that we can use for keywords to try and identify the file
    elsewhere.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MP3播客作为示例，脚本显示了其他不可用的详细信息。现在我们知道了发布日期，似乎是使用的软件，以及一些标识符，我们可以用作关键字来尝试在其他地方识别文件。
- en: '![](../images/00031.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: Let's look at another podcast, but this time, one that is an MP4\. After running
    the script, we are presenting with a great deal of information about the MP4 file's
    source and type of content. Again, we have several interesting identifiers, source
    URLs, and other attribution details available to us due to this exercise.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个播客，但这次是一个MP4文件。运行脚本后，我们将得到关于MP4文件来源和内容类型的大量信息。同样，由于这个练习，我们可以获得一些有趣的标识符、来源URL和其他归因细节。
- en: '![](../images/00032.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. here''s a recommendation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。这里有一个建议：
- en: Add additional support for other multimedia formats using the `mutagen` library.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`mutagen`库为其他多媒体格式添加额外支持。
- en: The big picture
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大局观
- en: 'Recipe Difficulty: Easy'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任意
- en: Images can contain many metadata attributes, depending on the file format and
    the device that was used to capture the image. Fortunately, most devices will
    embed GPS information within the photos they take. Using third-party libraries,
    we will extract GPS coordinates and plot them with Google Earth. This script focuses
    exclusively on this task, however, the recipe can be easily tweaked to extract
    all embedded **Exchangeable Image File Format** (**EXIF**) metadata in JPEG and
    TIFF images as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以包含许多元数据属性，取决于文件格式和用于拍摄图像的设备。幸运的是，大多数设备会在它们拍摄的照片中嵌入GPS信息。使用第三方库，我们将提取GPS坐标并在Google
    Earth中绘制它们。这个脚本专注于这个任务，但是这个食谱可以很容易地调整，以提取所有嵌入的**可交换图像文件格式**（**EXIF**）元数据在JPEG和TIFF图像中。
- en: Getting started
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This recipe requires the installation of two third-party libraries: `pillow`
    and `simplekml`. All other libraries used in this script are present in Python''s
    standard library. The `pillow` library provides a clean interface to the **Python
    Imaging Library** (**PIL**) and can be used to extract embedded metadata from
    images:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要安装两个第三方库：`pillow`和`simplekml`。此脚本中使用的所有其他库都包含在Python的标准库中。`pillow`库提供了一个清晰的接口，用于从图像中提取嵌入的元数据：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To learn more about the `pillow` library, visit [https://pillow.readthedocs.io/en/4.2.x/](https://pillow.readthedocs.io/en/4.2.x/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pillow`库的信息，请访问[https://pillow.readthedocs.io/en/4.2.x/](https://pillow.readthedocs.io/en/4.2.x/)。
- en: 'To add some extra flair to this recipe, we will be writing the GPS details
    to a KML file, for use in a program like Google Earth. To handle this, we will
    use the `simplekml` library, available for installation by executing the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给这个食谱增添一些额外的风采，我们将把GPS详细信息写入一个KML文件，以便在类似Google Earth的程序中使用。为了处理这个问题，我们将使用`simplekml`库，可以通过执行以下命令进行安装：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To learn more about the `simplekml` library, visit [http://www.simplekml.com/en/latest/](http://www.simplekml.com/en/latest/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`simplekml`库的信息，请访问[http://www.simplekml.com/en/latest/](http://www.simplekml.com/en/latest/)。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'We extract metadata from image files in the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按以下步骤从图像文件中提取元数据：
- en: Open the input photo with `PIL`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`PIL`打开输入照片。
- en: Use `PIL` to extract all `EXIF` tags.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PIL`提取所有`EXIF`标签。
- en: If GPS coordinates are found, create a Google Earth KML file.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到GPS坐标，创建一个Google Earth KML文件。
- en: Print the Google Maps URL to view the GPS data in the browser.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印Google Maps URL以在浏览器中查看GPS数据。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We begin by importing `argparse` along with the newly installed `simplekml`
    and `PIL` libraries. For this example, we will only need the `Image` and **`ExifTags.Tags`**
    classes from `PIL`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`argparse`以及新安装的`simplekml`和`PIL`库。在本例中，我们只需要从`PIL`中的`Image`和**`ExifTags.Tags`**类。
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This recipe's command-line handler accepts one positional argument, `PICTURE_FILE`,
    which represents the file path to the photo to process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受一个位置参数`PICTURE_FILE`，它代表要处理的照片的文件路径。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After configuring these arguments, we specify two URLs, `gmaps` and `open_maps`,
    that we will populate with coordinate information. Since the `PIL` library provides
    coordinates as a tuple of tuples in the **degrees minutes seconds** (**DMS**)
    format, we will need a function to convert them into decimal, which is another
    commonly used format for expressing coordinates. Each of the three elements in
    the provided tuple represents a different component of the coordinate. Additionally,
    within each tuple, there are two elements: the first element represents the value
    and the second is the scale that must be used to convert the value into an integer.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 配置这些参数后，我们指定两个URL，`gmaps`和`open_maps`，我们将用坐标信息填充它们。由于`PIL`库以**度分秒**（**DMS**）格式的元组元组提供坐标，我们需要一个函数将它们转换为另一种常用的坐标表示格式——十进制。提供的元组中的三个元素分别代表坐标的不同组成部分。此外，在每个元组中，有两个元素：第一个元素代表值，第二个元素是必须用来将值转换为整数的比例。
- en: For each component of the coordinate, we need to divide the first value in the
    nested tuple by the second value. This structure is used for the second and third
    tuple, which describe the minute and second values of the DMS coordinate. Additionally,
    we need to ensure that the minutes and seconds are added together properly by
    dividing each by the product of `60` to the power of the current iteration count
    (which will be `1` and `2`). While this won't change the first value (as enumeration
    begins at zero), it will ensure the second and third values are properly expressed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于坐标的每个组成部分，我们需要将嵌套元组中的第一个值除以第二个值。这种结构用于描述DMS坐标的第二个和第三个元组，此外，我们需要确保通过将每个值除以当前迭代计数的`60`的乘积来正确地将分钟和秒相加（这将是`1`和`2`）。虽然这不会改变第一个值（因为枚举从零开始），但它将确保第二和第三个值被正确表示。
- en: 'The following code block highlights an example of the coordinate format provided
    by the `PIL` library. Notice how the degree, minute, and second values are grouped
    into their own tuples. The first element represents the value of the coordinate
    and the second represents the scale. For example, for the seconds element (the
    third tuple), we need to divide the integer by `1000` before performing our other
    operations to ensure the value is represented correctly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块突出了`PIL`库提供的坐标格式的示例。请注意，度、分和秒值被分组到它们自己的元组中。第一个元素代表坐标的值，第二个代表比例。例如，对于秒元素（第三个元组），我们需要在执行其他操作之前将整数除以`1000`，以确保值被正确表示。
- en: '**Latitude**: `((41 , 1), (53 , 1), (23487 , 1000))`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纬度**：`((41 , 1), (53 , 1), (23487 , 1000))`'
- en: '**Longitude**: `((12 , 1), (29 , 1), (10362 , 1000))`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经度**：`((12 , 1), (29 , 1), (10362 , 1000))`'
- en: '**GPS coordinates**: `41.8898575 , 12.486211666666666`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPS坐标**：`41.8898575 , 12.486211666666666`'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the DMS to decimal coordinate conversion process configured, we open the
    image using the `Image.open()` method to open a file by path as a `PIL` object.
    We then use the `_getexif()` method to extract a dictionary containing EXIF data.
    If `PIL` is unable to extract metadata from the photo, this variable will be `None`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了DMS到十进制坐标转换过程后，我们使用`Image.open()`方法打开图像，以将文件路径作为`PIL`对象打开。然后，我们使用`_getexif()`方法提取包含EXIF数据的字典。如果`PIL`无法从照片中提取元数据，这个变量将是`None`。
- en: With the `EXIF` dictionary, we iterate through the keys and values to convert
    the numeric value to a human-readable name. This uses the `TAGS` dictionary from
    `PIL`, which maps the numeric value to a `string` representing the tag. The `TAGS`
    object acts in a similar manner to the manually specified mappings in the prior
    recipe.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EXIF`字典，我们遍历键和值，将数值转换为可读的名称。这使用了`PIL`中的`TAGS`字典，它将数值映射到表示标签的`string`。`TAGS`对象的作用方式类似于先前配方中手动指定的映射。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the `GPSInfo` tag is found, we extract four values of interest, found within
    the dictionary keys `1` through `4`. In pairs, we store the GPS reference and
    process the coordinates with the `process_coords()` method previously described.
    By storing the reference as a Boolean, we can easily use an `if` statement to
    determine whether the GPS decimal coordinates should be positive or negative.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到`GPSInfo`标签，我们提取字典键`1`到`4`中的四个感兴趣的值。成对地，我们存储GPS参考并使用先前描述的`process_coords()`方法处理坐标。通过将参考存储为布尔值，我们可以轻松地使用`if`语句来确定GPS十进制坐标是正数还是负数。
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To add our KML support, we initiate a `kml` object from the `simplekml` library.
    From there, we add a new point with a name and the coordinates. For the name,
    we simply use the file's name. The coordinates are provided as a tuple within
    a list where the first element is the longitude and the second is the latitude.
    We could also provide a third element in this tuple to specify the zoom level,
    though we omit it in this instance. To produce our `KML` file, we call the `save()`
    method and write it to a `.kml` file with the same name as the input file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加我们的KML支持，我们从`simplekml`库初始化一个`kml`对象。从那里，我们添加一个新的点，带有一个名称和坐标。对于名称，我们简单地使用文件的名称。坐标被提供为一个元组，其中第一个元素是经度，第二个元素是纬度。我们也可以在这个元组中提供第三个元素来指定缩放级别，尽管在这种情况下我们省略了它。为了生成我们的`KML`文件，我们调用`save()`方法并将其写入一个与输入文件同名的`.kml`文件。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the processed GPS information, we can print the coordinates, KML file,
    and URLs to the console. Notice how we nest the format strings, allowing us to
    print a basic message along with the URL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了处理过的GPS信息，我们可以在控制台上打印坐标、KML文件和URL。注意我们如何嵌套格式字符串，允许我们打印基本消息以及URL。
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we run this script at the command line, we quickly see the coordinates,
    two links to view the location on a map, and the path to the KML file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在命令行上运行这个脚本时，我们很快就能看到坐标、两个链接以查看地图上的位置，以及KML文件的路径。
- en: '![](../images/00033.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: Following the two links we generated, we can see the pins on the two maps and
    share these links with others if so desired.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们生成的两个链接，我们可以在两个地图上看到标记，并在需要时与其他人分享这些链接。
- en: '![](../images/00034.jpeg)![](../images/00035.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)![](../images/00035.jpeg)'
- en: Lastly, we can use the KML file to store and reference the location found within
    the image. Google Earth allows this file to be viewed through both the web and
    desktop clients.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用KML文件来存储和引用图像中找到的位置。Google Earth允许通过Web和桌面客户端查看这个文件。
- en: '![](../images/00036.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们提供了一个或多个建议如下：
- en: Integrate file recursion to process multiple photos to create larger KML files
    that map many GPS coordinates.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成文件递归以处理多张照片，创建包含许多GPS坐标的更大的KML文件。
- en: Experiment with the `simplekml` library to add additional detail to each point,
    such as a description, timestamp, coloring, and more.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用`simplekml`库为每个点添加额外的细节，比如描述、时间戳、着色等。
- en: Mining for PDF metadata
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挖掘PDF元数据
- en: 'Recipe Difficulty: Easy'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: While PDF documents can represent a wide variety of media, including images,
    text, and forms, they contain structured embedded metadata in the **Extensible
    Metadata Platform** (**XMP**) format that can provide us with some additional
    information. Through this recipe, we access a PDF using Python and extract metadata
    describing the creation and lineage of the document.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PDF文档可以表示各种各样的媒体，包括图像、文本和表单，但它们包含结构化的嵌入式元数据，以**可扩展元数据平台**（**XMP**）格式提供了一些额外的信息。通过这个配方，我们使用Python访问PDF并提取描述文档创建和传承的元数据。
- en: Getting started
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This recipe requires the installation of the third-party library `PyPDF2`.
    All other libraries used in this script are present in Python''s standard library.
    The `PyPDF2` module provides us with bindings to read and write PDF files. In
    our case, we will only use this library to read the metadata stored in the XMP
    format. To install this library, run the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要安装第三方库`PyPDF2`。这个脚本中使用的所有其他库都包含在Python的标准库中。`PyPDF2`模块为我们提供了读写PDF文件的绑定。在我们的情况下，我们只会使用这个库来读取以XMP格式存储的元数据。要安装这个库，请运行以下命令：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To learn more about the `PyPDF2` library, visit [http://mstamy2.github.io/PyPDF2/](http://mstamy2.github.io/PyPDF2/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`PyPDF2`库的信息，请访问[http://mstamy2.github.io/PyPDF2/](http://mstamy2.github.io/PyPDF2/)。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To handle PDFs for this recipe, we follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个配方的PDF，我们按照以下步骤进行：
- en: Open the PDF file with `PyPDF2` and extract embedded metadata.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`PyPDF2`打开PDF文件并提取嵌入式元数据。
- en: Define a custom print function for different Python object types.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为不同的Python对象类型定义自定义打印函数。
- en: Print various embedded metadata properties.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印各种嵌入式元数据属性。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we import the `argparse`, `datetime`, and `sys` libraries along with
    the newly installed `PyPDF2` module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`argparse`、`datetime`和`sys`库，以及新安装的`PyPDF2`模块。
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This recipe's command-line handler accepts one positional argument, `PDF_FILE`,
    which represents the file path to the PDF to process. For this script, we need
    to pass an open file object to the `PdfFileReader` class, so we use the `argparse.FileType`
    handler to open the file for us.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受一个位置参数`PDF_FILE`，表示要处理的PDF文件的文件路径。对于这个脚本，我们需要将一个打开的文件对象传递给`PdfFileReader`类，所以我们使用`argparse.FileType`处理程序来为我们打开文件。
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After providing the open file to the `PdfFileReader` class, we call the `getXmpMetadata()`
    method to provide an object containing the available XMP metadata. If this method
    returns `None`, we print a succinct message to the user before exiting.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开的文件提供给`PdfFileReader`类后，我们调用`getXmpMetadata()`方法来提供一个包含可用XMP元数据的对象。如果这个方法返回`None`，我们会在退出之前向用户打印一个简洁的消息。
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the `xmpm` object ready, we begin extracting and printing relevant values.
    We extract a number of different values including the title, creator, contributor,
    description, creation, and modification dates. These value definitions are from
    [http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMP%20SDK%20Release%20cc-2016-08/XMPSpecificationPart1.pdf](http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMP%20SDK%20Release%20cc-2016-08/XMPSpecificationPart1.pdf).
    Even though many of these elements are different data types, we pass them to the
    `custom_print()` method in the same manner. Let's take a look at how this function
    works.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`xmpm`对象准备就绪，我们开始提取和打印相关值。我们提取了许多不同的值，包括标题、创建者、贡献者、描述、创建和修改日期。这些值的定义来自[http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMP%20SDK%20Release%20cc-2016-08/XMPSpecificationPart1.pdf](http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMP%20SDK%20Release%20cc-2016-08/XMPSpecificationPart1.pdf)。尽管这些元素中的许多是不同的数据类型，我们以相同的方式将它们传递给`custom_print()`方法。让我们看看这个函数是如何工作的。
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since the XMP values stored may differ based on the software used to generate
    the PDF, we use a custom print handling function, creatively called `custom_print()`.
    This allows us, as presented here, to handle the conversion of lists, dictionaries,
    dates, and other values into a readable format. This function is portable and
    can be brought into other scripts as needed. The function, through a series of
    `if-elif-else` statements, checks if the input `value` is a supported object type
    using the built-in `isinstance()` method and handles them appropriately. If the
    input `value` is an unsupported type, this is printed to the console instead.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储的XMP值可能因用于生成PDF的软件而异，我们使用一个名为`custom_print()`的自定义打印处理函数。这使我们可以处理列表、字典、日期和其他值的转换为可读格式。这个函数是可移植的，可以根据需要引入其他脚本。该函数通过一系列`if-elif-else`语句检查输入的`value`是否是支持的对象类型，使用内置的`isinstance()`方法并适当处理它们。如果输入的`value`是不受支持的类型，则会将其打印到控制台。
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our next set of metadata includes more details about the document''s lineage
    and creation. The `xmp_creatorTool` attribute stores information about the software
    used to create the resource. Separately, we can also deduce additional lineage
    information based on the following two IDs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个元数据集包括有关文档渊源和创建的更多细节。`xmp_creatorTool`属性存储有关用于创建资源的软件的信息。另外，我们还可以根据以下两个ID推断出额外的渊源信息：
- en: The `Document ID` represents an identifier, usually stored as a GUID, that is
    generally assigned when the resource is saved to a new file. For example, if we
    create `DocA.pdf` and then save it as `DocB.pdf`, we would have two different
    `Document IDs`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文档ID`表示一个标识符，通常存储为GUID，通常在将资源保存到新文件时分配。例如，如果我们创建`DocA.pdf`，然后将其另存为`DocB.pdf`，我们将有两个不同的`文档ID`。'
- en: Following the `Document ID` is the second identifier, `Instance ID`. This `Instance
    ID` is usually generated once per save. An example of this identifier updating
    is when we update `DocA.pdf` with a new paragraph of text and save it with the
    same filename.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`文档ID`之后是第二个标识符`实例ID`。`实例ID`通常在每次保存时生成一次。当我们使用新的段落更新`DocA.pdf`并以相同的文件名保存时，此标识符更新的一个例子。
- en: When editing the same PDF, you would expect the `Document ID` to remain the
    same while the `Instance ID` would likely update, though this behavior can vary
    depending on the software used.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑相同的PDF时，您期望`文档ID`保持不变，而`实例ID`可能会更新，尽管这种行为可能会因所使用的软件而异。
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Following this, we continue extracting other common XMP metadata, including
    the language, publisher, resource type, and type. The resource type field should
    represent a **Multipurpose Internet Mail Extensions** (**MIME**) value and the
    type field should store a **Dublin Core Metadata Initiative** *(***DCMI**) value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们继续提取其他常见的XMP元数据，包括语言、发布者、资源类型和类型。资源类型字段应该表示**多用途互联网邮件扩展**（**MIME**）值，而类型字段应该存储**都柏林核心元数据倡议**（***DCMI**）值。
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lastly, we extract any custom properties saved by the software. Since this should
    be a dictionary, we can print it without our `custom_print()` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提取软件保存的任何自定义属性。由于这应该是一个字典，我们可以在不使用我们的`custom_print()`函数的情况下打印它。
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we execute the script, we can quickly see many of the attributes stored
    within the PDF. Notice how the `Document ID` does not match the `Instance ID`,
    this suggests this document may have been modified from the original PDF.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行脚本时，我们可以快速看到PDF中存储的许多属性。请注意`文档ID`与`实例ID`不匹配，这表明该文档可能已经从原始PDF进行了修改。
- en: '![](../images/00037.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: There's more...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们提供了以下一个或多个建议：
- en: 'Explore and integrate other PDF-related libraries, such as `slate` and `pyocr`:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和集成其他与PDF相关的库，如`slate`和`pyocr`：
- en: The `slate` module, [https://github.com/timClicks/slate](https://github.com/timClicks/slate),
    can extract text from a PDF file.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slate`模块，[https://github.com/timClicks/slate](https://github.com/timClicks/slate)，可以从PDF文件中提取文本。'
- en: The `pyocr` module, [https://github.com/openpaperwork/pyocr](https://github.com/openpaperwork/pyocr),
    can be used to OCR a PDF to capture handwritten text.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyocr`模块，[https://github.com/openpaperwork/pyocr](https://github.com/openpaperwork/pyocr)，可用于对PDF进行OCR以捕获手写文本。'
- en: Reviewing executable metadata
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查可执行元数据
- en: 'Recipe Difficulty: Easy'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: During the course of an investigation, we may identify a potentially suspicious
    or unauthorized portable executable file. This executable may be interesting because
    of the time it was used on the system, its location on the system, or other attributes
    specific to the investigation. Whether we are investigating it as malicious software
    or an unauthorized utility, we need to have the capability to learn more about
    it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查过程中，我们可能会识别出潜在可疑或未经授权的可移植可执行文件。这个可执行文件可能很有趣，因为它在系统上的使用时间，它在系统上的位置，或者调查特定的其他属性。无论我们是将其作为恶意软件还是未经授权的实用程序进行调查，我们都需要有能力了解更多关于它的信息。
- en: By extracting embedded metadata from Windows executable files, we can learn
    about the components that make up the file. In this recipe, we will expose the
    compilation date, useful **Indicator of Compromise** (**IOC**) data from the section
    headers, and the imported and exported symbols.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从Windows可执行文件中提取嵌入的元数据，我们可以了解构成文件的组件。在这个示例中，我们将公开编译日期，来自节头的有用的**威胁指标**（**IOC**）数据，以及导入和导出的符号。
- en: Getting started
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'This recipe requires the installation of the third-party library `pefile`.
    All other libraries used in this script are present in Python''s standard library.
    The `pefile` module saves us from needing to specify all of the structures of
    Windows executable files. The `pefile` library can be installed like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要安装第三方库`pefile`。此脚本中使用的所有其他库都包含在Python的标准库中。`pefile`模块使我们无需指定Windows可执行文件的所有结构。`pefile`库可以这样安装：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To learn more about the `pefile` library, visit [https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`pefile`库的信息，请访问[https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile)。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We extract metadata from executable files via the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤从可执行文件中提取元数据：
- en: Open the executable and dump the metadata with `pefile`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开可执行文件并使用`pefile`转储元数据。
- en: If present, dynamically print metadata to the console.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，动态打印元数据到控制台。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We begin by importing libraries to handle arguments, parsing dates, and interacting
    with executable files. Notice that we specifically import the `PE` class from
    `pefile`, allowing us to invoke the `PE` class attributes and methods directly
    later in the recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入处理参数、解析日期和与可执行文件交互的库。请注意，我们专门从`pefile`中导入`PE`类，这样我们可以在示例后面直接调用`PE`类的属性和方法。
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This recipe’s command-line handler takes one positional argument, `EXE_FILE`,
    the path to the executable file we will be extracting metadata from. We will also
    take one optional argument, `v`, to allow the user to decide if they would like
    verbose or simplified output.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的命令行处理程序接受一个位置参数`EXE_FILE`，即我们将从中提取元数据的可执行文件的路径。我们还将接受一个可选参数`v`，以允许用户决定他们是否希望获得详细或简化的输出。
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the `PE` class, we load the input executable file simply by providing
    it the file's path. Using the `dump_dict()` method, we dump the executable data
    to a dictionary object. This library allows us to explore the key-value pairs
    through this `ped` dictionary or as properties of the `pe` object. We will demonstrate
    how to extract embedded metadata using both techniques.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PE`类，我们通过提供文件路径来简单地加载输入可执行文件。使用`dump_dict()`方法，我们将可执行文件数据转储到字典对象中。这个库允许我们通过这个`ped`字典或作为`pe`对象的属性来探索键值对。我们将演示如何使用这两种技术提取嵌入的元数据。
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's start by extracting basic file metadata, such as the embedded authorship,
    version, and compilation time. This metadata is stored within the `StringTable`
    in the `FileInfo` object. Using `for` loops and `if` statements, we ensure the
    correct values are extracted and assign the string `"Unknown"` to values that
    are `None` or whose length is zero to better accommodate printing this data to
    the console. With all key-value pairs extracted and printed to the console, we
    move onto processing the executable's embedded compilation time, which is stored
    elsewhere.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从提取基本文件元数据开始，比如嵌入的作者、版本和编译时间。这些元数据存储在`FileInfo`对象的`StringTable`中。使用`for`循环和`if`语句，我们确保提取正确的值，并将字符串“Unknown”赋给值为`None`或长度为零的值，以更好地适应将这些数据打印到控制台。提取并打印所有键值对到控制台后，我们继续处理可执行文件的嵌入编译时间，该时间存储在其他地方。
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The compilation timestamp is stored within the file and shows the date the executable
    was compiled. The `pefile` library interprets the raw data for us, whereas the
    `Value` key stores both the original hex value and an interpreted date within
    square brackets. We can either interpret the hex value ourselves or, more simply,
    convert the timestamp from the parsed date string into a `datetime` object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时间戳存储在文件中，显示可执行文件的编译日期。`pefile`库为我们解释原始数据，而`Value`键存储原始十六进制值和方括号内解释的日期。我们可以自己解释十六进制值，或者更简单地将解析后的日期字符串转换为`datetime`对象。
- en: We extract the parsed date string in square brackets using the `split()` and
    `strip()` methods to extract only the string contained within the brackets. An
    abbreviated time zone (for example, UTC, EST, or PST) must also be separated from
    the parsed date string prior to its conversion. Once the date string is isolated,
    we use the `datetime.strptime()` method with `datetime` formatters to properly
    convert and print the executable's embedded compilation date.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`split()`和`strip()`方法从方括号中提取解析后的日期字符串。在转换之前，必须将缩写的时区（例如UTC、EST或PST）与解析后的日期字符串分开。一旦日期字符串被隔离，我们使用`datetime.strptime()`方法和`datetime`格式化程序来正确转换和打印可执行文件的嵌入编译日期。
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next element we extract is metadata about the executable's sections. This
    time, rather than using the `pe` object and its attributes, we use the dictionary
    object we created, `ped`, to iterate through the sections and display the section
    name, address, sizes, and `MD5` hash of its content. This data can be added to
    your IOCs to assist with the identification of other malicious files on this and
    other hosts in the environment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取的下一个元素是关于可执行文件部分的元数据。这一次，我们不是使用`pe`对象及其属性，而是使用我们创建的字典对象`ped`来遍历部分并显示部分名称、地址、大小和其内容的`MD5`哈希。这些数据可以添加到您的IOC中，以帮助识别环境中此主机和其他主机上的其他恶意文件。
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Another set of metadata within a portable executable file is a listing of its
    imports and exports. Let's start with the import entries. First, we ensure that
    the attribute exists before attempting to access this attribute of the `pe` variable.
    If it is present, we use two `for` loops to step through the imported DLLs and,
    if the user specified verbose output, each of the imports within the DLLs. If
    the user did not specify verbose output, the innermost loop is skipped and only
    the DLL names are presented to the console. From these loops, we extract the DLL
    names, addresses, and import names. We can use the `getattr()` built-in function
    to ensure we don't receive any errors in the instance where the attribute is not
    present.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件中的另一组元数据是其导入和导出的列表。让我们从导入条目开始。首先，我们确保在尝试访问`pe`变量的这个属性之前，该属性存在。如果存在，我们使用两个`for`循环来遍历导入的DLL，并且如果用户指定了详细输出，遍历DLL中的每个导入。如果用户没有指定详细输出，则跳过最内层循环，只向控制台呈现DLL名称。从这些循环中，我们提取DLL名称、地址和导入名称。我们可以使用`getattr()`内置函数来确保在属性不存在的情况下不会收到任何错误。
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Lastly, let's review the code block related to export metadata. Because some
    executable may not have exports, we use the `hasattr()` function to confirm the
    `DIRECTORY_ENTRY_EXPORT` attribute is present. If it is, we iterate through each
    symbol and print the names and addresses for each of the symbols in a bulleted
    list to better distinguish them in the console.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回顾与导出元数据相关的代码块。因为一些可执行文件可能没有导出，我们使用`hasattr()`函数来确认`DIRECTORY_ENTRY_EXPORT`属性是否存在。如果存在，我们遍历每个符号，并在控制台中以项目符号列表的形式打印每个符号的名称和地址，以更好地区分它们。
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using a Firefox installer as our example, we are able to extract a great deal
    of embedded metadata attributes from the executable. This information shows us
    a number of things, such as the compilation date; that this appears to be a packed
    executable, likely with 7-Zip; and the hash values for the different sections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以Firefox安装程序为例，我们能够从可执行文件中提取大量嵌入的元数据属性。这些信息向我们展示了许多东西，比如编译日期；这似乎是一个打包的可执行文件，可能是用7-Zip打包的；以及不同部分的哈希值。
- en: '![](../images/00038.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: 'When we run this same script against a DLL, we see many of the same fields
    from the executable run, in addition to the exports section. Due to the length
    of the output, we''ve omitted some of the text in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对DLL运行相同的脚本时，我们看到与可执行文件运行中的许多相同字段，另外还有导出部分。由于输出的长度，我们省略了以下截图中的一些文本：
- en: '![](../images/00039.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.jpeg)'
- en: There's more...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们提供了一个或多个建议如下：
- en: Using recipes that we develop in [Chapter 5](part0158.html#4MLOS0-260f9401d2714cb9ab693c4692308abe),
    *Networking and Indicator of Compromise Recipes*, query the discovered hash values
    against online resources, such as VirusTotal, and report on any matches from other
    submissions.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在[第5章](part0158.html#4MLOS0-260f9401d2714cb9ab693c4692308abe)中开发的配方，*网络和威胁指标配方*，查询发现的哈希值与VirusTotal等在线资源，并报告其他提交的任何匹配项。
- en: Integrate `pytz` to allow the user to interpret dates in a local or otherwise
    specified timezone
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成`pytz`以允许用户在本地或其他指定的时区解释日期
- en: Reading office document metadata
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取办公文件元数据
- en: 'Recipe Difficulty: Medium'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：中等
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Reading metadata from office documents can expose interesting information about
    the authorship and history of those files. Conveniently, the 2007 formatted `.docx`,
    .`xlsx`, and `.pptx` files store metadata in XML. The XML tags can be easily processed
    with Python.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从办公文件中读取元数据可以暴露有关这些文件的作者和历史的有趣信息。方便的是，2007格式的`.docx`、`.xlsx`和`.pptx`文件将元数据存储在XML中。XML标记可以很容易地用Python处理。
- en: Getting started
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python's standard library.
    We use the built-in `xml` library and the `zipfile` library to allow us access
    to the XML documents within the ZIP container.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。我们使用内置的`xml`库和`zipfile`库来允许我们访问ZIP容器中的XML文档。
- en: To learn more about the `xml` library, visit [https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`xml`库的更多信息，请访问[https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html)。
- en: To Learn more about the `zipfile` library, visit [https://docs.python.org/3/library/zipfile.html](https://docs.python.org/3/library/zipfile.html)[.](https://docs.python.org/3/library/xml.etree.elementtree.html)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`zipfile`库的更多信息，请访问[https://docs.python.org/3/library/zipfile.html](https://docs.python.org/3/library/zipfile.html)[.](https://docs.python.org/3/library/xml.etree.elementtree.html)
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We extract embedded Office metadata by performing the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过执行以下步骤提取嵌入的Office元数据：
- en: Confirm that the input file is a valid ZIP file.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认输入文件是有效的ZIP文件。
- en: Extract the `core.xml` and `app.xml` files from Office file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Office文件中提取`core.xml`和`app.xml`文件。
- en: Parse XML data and print embedded metadata.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析XML数据并打印嵌入的元数据。
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we import the `argparse` and `datetime` libraries, followed by `xml.etree`
    and `zipfile` libraries. The `ElementTree` class allows us to read an XML string
    into an object that we can iterate through and interpret.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`argparse`和`datetime`库，然后是`xml.etree`和`zipfile`库。`ElementTree`类允许我们将XML字符串读入一个对象，我们可以通过它进行迭代和解释。
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This recipe’s command-line handler takes one positional argument, `Office_File`,
    the path to the office file we will be extracting metadata from.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受一个位置参数`Office_File`，即我们将从中提取元数据的办公文件的路径。
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Following our argument handling, we check to make sure the input file is a `zipfile`
    and raise an error if it is not. If it is, we open the valid ZIP file using the
    `ZipFile` class before accessing the two XML documents containing the metadata
    we are interested in. Though there are other XML files containing data describing
    the document, the two with the most metadata are named `core.xml` and `app.xml`.
    We will open the two XML files from the ZIP container with the `read()` method
    and send the returned string directly to the `etree.fromstring()` XML parsing
    method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理参数后，我们检查输入文件是否是一个`zipfile`，如果不是，则引发错误。如果是，我们使用`ZipFile`类打开有效的ZIP文件，然后访问包含我们感兴趣的元数据的两个XML文档。虽然还有其他包含描述文档数据的XML文件，但包含最多元数据的是名为`core.xml`和`app.xml`的两个文件。我们将使用`read()`方法从ZIP容器中打开这两个XML文件，并将返回的字符串直接发送到`etree.fromstring()`
    XML解析方法。
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the prepared XML objects, we can start extracting data of interest. We
    set up a dictionary, called `core_mapping`, to specify the fields we want to extract,
    as key names, and the value we want to display them as. This method allows us
    to easily print only the values important to us, if present, with a friendly title.
    This XML file contains great information about the authorship of the file. For
    instance, the two authorship fields, `creator` and `lastModifiedBy`, can show
    scenarios where one account modified a document created by another user account.
    The date values show us information about creation and modification of the document.
    Additionally, metadata fields like `revision` can give some indication to the
    number of versions of this document.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了准备好的XML对象，我们可以开始提取感兴趣的数据。我们设置了一个名为`core_mapping`的字典，用于指定我们想要提取的字段作为键名，以及我们想要将它们显示为的值。这种方法使我们能够轻松地打印出对我们重要的值，如果存在的话，还可以使用友好的标题。这个XML文件包含了关于文件作者的重要信息。例如，两个作者字段`creator`和`lastModifiedBy`可以显示一个账户修改了另一个用户账户创建的文档的情况。日期值向我们展示了关于文档的创建和修改的信息。此外，像`revision`这样的元数据字段可以给出有关此文档版本数量的一些指示。
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In our `for` loop, we iterate over the XML using the `iterchildren()` method
    to access each of the tags within the XML root of the `core.xml` file. Using the
    `core_mapping` dictionary, we can selectively output specific fields if they are
    found. We have also added logic to interpret date values using the `strptime()`
    method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`for`循环中，我们使用`iterchildren()`方法迭代XML，以访问`core.xml`文件的XML根中的每个标签。使用`core_mapping`字典，我们可以有选择地输出特定字段（如果找到的话）。我们还添加了用`strptime()`方法解释日期值的逻辑。
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The next set of column mappings focuses on the `app.xml` file. This file contains
    statistical information about the contents of the document, including total edit
    time and counts of words, pages, and slides. It also contains information about
    the company name registered with the software and hidden elements. To print these
    values to the console, we use a similar set of `for` loops as we did with the
    `core.xml` file.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的列映射集中在`app.xml`文件上。这个文件包含有关文档内容的统计信息，包括总编辑时间和单词、页数和幻灯片的计数。它还包含有关注册在软件中的公司名称和隐藏元素的信息。为了将这些值打印到控制台上，我们使用了与`core.xml`文件相似的一组`for`循环。
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When we run the script with a sample word document, as the following shows,
    a number of details about the document are in question.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行脚本并使用示例Word文档时，如下所示，关于文档的许多细节都受到质疑。
- en: '![](../images/00040.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: 'Separately, we can use the script on a PPTX document and review format-specific
    metadata associated with PPTX files:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以在PPTX文档上使用脚本并审查与PPTX文件相关的特定格式的元数据：
- en: '![](../images/00041.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: Integrating our metadata extractor with EnCase
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的元数据提取器与EnCase集成
- en: 'Recipe Difficulty: Medium'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：中等
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Windows'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Windows
- en: The embedded metadata extracting recipes we have designed work against loose
    files, not with files found within a forensic image. Annoyingly, this adds an
    extra step in our process, requiring us to export the files of interest from the
    image for this type of review. We show in this recipe, how to connect our scripts
    to a forensic tool, EnCase, and execute them without needing to export the files
    from a forensic image.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的嵌入式元数据提取配方适用于松散文件，而不适用于取证图像中的文件。令人恼火的是，这在我们的流程中增加了一个额外的步骤，需要我们从图像中导出感兴趣的文件进行此类审查。在这个配方中，我们展示了如何将我们的脚本连接到取证工具EnCase，并在无需从取证图像中导出文件的情况下执行它们。
- en: Getting started
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: With EnCase installed, we need to create a case and add in the evidence file,
    as we would for any other case. This recipe demonstrates the steps required to
    perform this in EnCase V6, although the same techniques can be applied to later
    versions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了EnCase后，我们需要创建一个案件并添加证据文件，就像对待其他案件一样。这个配方演示了在EnCase V6中执行此操作所需的步骤，尽管相同的技术也可以应用于后续版本。
- en: Before starting, we will also need to ensure Python 2.7 or 3.5, the script we
    wish to use, and the required dependencies are installed on the machine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们还需要确保机器上安装了Python 2.7或3.5、我们希望使用的脚本以及所需的依赖项。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'We integrate the metadata recipes with EnCase via the following steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤将元数据配方与EnCase集成：
- en: Open EnCase V6 and add evidence to a case.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开EnCase V6并将证据添加到案件中。
- en: Use the View file viewer menu to configure a custom file viewer with the `EXIF`
    metadata extractor.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“查看文件查看器”菜单配置自定义文件查看器，其中包括`EXIF`元数据提取器。
- en: Extract embedded GPS coordinates from a photo within EnCase using the newly
    created file viewer.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新创建的文件查看器在EnCase中提取嵌入的照片GPS坐标。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With the open case, we can look at the hex of a photo of interest to confirm
    we can see the `EXIF` header within the file. Following this header are the raw
    values processed by the script. With a good candidate identified, let's look at
    how we can configure EnCase to run the script.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 打开案例后，我们可以查看感兴趣的照片的十六进制，以确认我们可以在文件中看到`EXIF`头。在这个头部之后是脚本处理的原始值。确定了一个好的候选者后，让我们看看如何配置EnCase来运行脚本。
- en: '![](../images/00042.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00042.jpeg)'
- en: Under the View menu, we select the File Viewers option. This opens a tab listing
    the available viewers. The instance of EnCase we used does not have any viewers
    and so we must add any we wish to use first.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`查看`菜单下，我们选择`文件查看器`选项。这将打开一个列出可用查看器的选项卡。我们使用的EnCase实例没有任何查看器，所以我们必须首先添加任何我们希望使用的查看器。
- en: '![](../images/00043.gif)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00043.gif)'
- en: In this tab, right-click on the top-level `File Viewers` element and select
    New... to create our custom viewer.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个选项卡上，右键单击顶层的`文件查看器`元素，然后选择`新建...`来创建我们的自定义查看器。
- en: '![](../images/00044.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00044.jpeg)'
- en: A new window, shown in the following screenshot, allows us to specify the parameters
    to execute the script. In this example, we are implementing the GPS extraction
    script, though we can add others in this same manner. The first line specifies
    the name of the viewer. We should name this something memorable as it will be
    the only description available to us when selecting the file viewer later. The
    second line is the path to the executable. In our instance, we will launch the
    Command Prompt, since our Python script is not a standalone executable. We need
    to provide the full path to `cmd.exe` for EnCase to accept this parameter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新窗口，如下面的屏幕截图所示，允许我们指定执行脚本的参数。在这个例子中，我们正在实现GPS提取脚本，尽管我们可以以同样的方式添加其他脚本。第一行指定了查看器的名称。我们应该给它取一个容易记住的名字，因为在以后选择文件查看器时，这将是我们唯一可用的描述。第二行是可执行文件的路径。在我们的实例中，我们将启动命令提示符，因为我们的Python脚本不是一个独立的可执行文件。我们需要为EnCase提供`cmd.exe`的完整路径，以便接受这个参数。
- en: The last line is where we add in the script. This line allows us to specify
    the arguments to pass to the Command Prompt. We start with `/k` to keep our Command
    Prompt open after our script completes. This isn't required; although if your
    code displays information to the console (as ours does), we should implement this
    feature. Otherwise, the Command Prompt will close as soon as the code completes.
    Following the `/k` argument, we provide the parameters to launch the code. As
    shown here, this includes the Python executable and full path to the script. The
    last element, `[file]`, is a placeholder for EnCase that is replaced by the file
    we want to view when the file viewer is executed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是我们添加脚本的地方。这一行允许我们指定要传递给命令提示符的参数。我们从`/k`开始，以便在脚本完成后保持我们的命令提示符打开。这不是必需的；尽管如果您的代码在控制台上显示信息（就像我们的代码一样），我们应该实现这个功能。否则，命令提示符将在代码完成后立即关闭。在`/k`参数之后，我们提供启动代码的参数。如图所示，这包括Python可执行文件和脚本的完整路径。最后一个元素`[file]`是EnCase的占位符，在文件查看器执行时被我们要查看的文件替换。
- en: '![](../images/00045.gif)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00045.gif)'
- en: The new file viewer entry is now displayed within the `File Viewer` tab and
    shows us the name, executable, and arguments we specified. If everything looks
    right, we can return to the photo of interest in the file entry tab.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 新的文件查看器条目现在显示在`文件查看器`选项卡中，并显示了我们指定的名称、可执行文件和参数。如果一切看起来正确，我们可以返回到文件条目选项卡中感兴趣的照片。
- en: '![](../images/00046.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00046.jpeg)'
- en: Back on the file entry view, we can right-click on the photo of interest and
    select the file viewer from the `Send To` submenu.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 回到文件条目视图，我们可以右键单击感兴趣的照片，然后从`发送到`子菜单中选择文件查看器。
- en: '![](../images/00047.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00047.jpeg)'
- en: When we select this option, the command window appears and shows the output
    from the script. Notice that the KML file is automatically placed in the `Temp`
    directory for the case. This is because the file we are inspecting is cached in
    this directory during the script's execution.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择这个选项时，命令窗口会出现，并显示脚本的输出。请注意，KML文件会自动放置在案例的`Temp`目录中。这是因为我们正在检查的文件在脚本执行期间被缓存在这个目录中。
- en: '![](../images/00048.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00048.jpeg)'
- en: There's more...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This process can be further improved. We have provided one or more recommendations
    as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以进一步改进。我们提供了一个或多个建议如下：
- en: While not Python-related, look into EnScripting as another option to automate
    and parse multiple files and display the output within the EnCase Console tab.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然与Python无关，但可以考虑EnScripting作为自动化和解析多个文件并在EnCase控制台选项卡中显示输出的另一个选项。
- en: Add the other recipes covered in this chapter to EnCase by following a similar
    method. Since the information for these scripts is printed to the console, we
    should use the `/k` argument or rework the logic to place the output in a directory
    for us.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类似的方法将本章中涵盖的其他脚本添加到EnCase中。由于这些脚本的信息被打印到控制台，我们应该使用`/k`参数，或者重新设计逻辑将输出放在一个目录中。
